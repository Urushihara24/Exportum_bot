import warnings

warnings.filterwarnings("ignore", message=".*LibreSSL.*")
warnings.filterwarnings("ignore", message=".*NotOpenSSLWarning.*")
warnings.filterwarnings("ignore", category=UserWarning, module="urllib3")

import os
import logging
import requests
import asyncio
import re
import time
import json
import pickle
import sqlite3
import traceback
from dotenv import load_dotenv

load_dotenv()

from datetime import datetime, timedelta
from bs4 import BeautifulSoup
from collections import defaultdict
from aiogram import Bot, Dispatcher, types
from aiogram.utils.exceptions import MessageNotModified
from aiogram.dispatcher.filters.state import StatesGroup, State
from aiogram.types import (
    InlineKeyboardMarkup,
    InlineKeyboardButton,
    ReplyKeyboardMarkup,
    ReplyKeyboardRemove,
    KeyboardButton,
    Message,
    CallbackQuery,
    ContentType,
    InputFile,
    ChatMember,
)
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.state import State, StatesGroup
from aiogram.dispatcher.filters import Text
from aiogram.contrib.fsm_storage.memory import MemoryStorage
from aiogram.utils import executor
from apscheduler.schedulers.asyncio import AsyncIOScheduler
import csv
from io import StringIO
import shutil

try:
    import gspread
    from google.oauth2.service_account import Credentials

    GOOGLE_SHEETS_AVAILABLE = True
except ImportError:
    GOOGLE_SHEETS_AVAILABLE = False
    logging.warning("âš ï¸ Google Sheets Ğ±Ğ¸Ğ±Ğ»Ğ¸Ğ¾Ñ‚ĞµĞºĞ¸ Ğ½Ğµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ñ‹")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ›ĞĞ“Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ•
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
LOGS_DIR = "logs"
os.makedirs(LOGS_DIR, exist_ok=True)

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(os.path.join(LOGS_DIR, "bot.log"), encoding="utf-8"),
        logging.StreamHandler(),
    ],
)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ĞšĞĞĞ¤Ğ˜Ğ“Ğ£Ğ ĞĞ¦Ğ˜Ğ¯
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
API_TOKEN = os.getenv("BOT_TOKEN", "")
ADMIN_ID = int(os.getenv("ADMIN_ID", ""))
DB_PATH = "bot_data.db"
CHANNEL_ID = "@your_channel"  # Ğ—Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚Ğµ Ğ½Ğ° ID ĞºĞ°Ğ½Ğ°Ğ»Ğ° (-1001234567890)

CONFIG = {
    "timeout": 15,
    "cache_ttl": 1800,
    "fallback_prices": {
        "ĞŸÑˆĞµĞ½Ğ¸Ñ†Ğ°": 15650,
        "Ğ¯Ñ‡Ğ¼ĞµĞ½ÑŒ": 13300,
        "ĞšÑƒĞºÑƒÑ€ÑƒĞ·Ğ°": 14000,
        "Ğ¡Ğ¾Ñ": 40900,
        "ĞŸĞ¾Ğ´ÑĞ¾Ğ»Ğ½ĞµÑ‡Ğ½Ğ¸Ğº": 38600,
    },
    "south_regions": ["ĞšÑ€Ğ°ÑĞ½Ğ¾Ğ´Ğ°Ñ€", "Ğ Ğ¾ÑÑ‚Ğ¾Ğ²", "ĞÑÑ‚Ñ€Ğ°Ñ…Ğ°Ğ½ÑŒ", "Ğ’Ğ¾Ğ»Ğ³Ğ¾Ğ³Ñ€Ğ°Ğ´", "Ğ¡Ñ‚Ğ°Ğ²Ñ€Ğ¾Ğ¿Ğ¾Ğ»ÑŒ"],
    "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ĞŸĞ£Ğ¢Ğ˜ Ğš Ğ¤ĞĞ™Ğ›ĞĞœ - ĞĞŸĞ Ğ•Ğ”Ğ•Ğ›Ğ•ĞĞ˜Ğ• ĞĞ”Ğ˜Ğ Ğ ĞĞ—!
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
DATA_DIR = "data"
PULLS_FILE = os.path.join(DATA_DIR, "pulls.pkl")
os.makedirs(DATA_DIR, exist_ok=True)

USERSFILE = os.path.join(DATA_DIR, "users.pkl")
BATCHESFILE = os.path.join(DATA_DIR, "batches.pkl")
EXPEDITORSFILE = os.path.join(DATA_DIR, "expeditors.pkl")
USERS_JSON = os.path.join(DATA_DIR, "users.json")
BATCHES_JSON = os.path.join(DATA_DIR, "batches.json")
PULLS_JSON = os.path.join(DATA_DIR, "pulls.json")
PRICES_FILE = os.path.join(DATA_DIR, "prices.json")
NEWS_FILE = os.path.join(DATA_DIR, "news.json")
GOOGLE_SHEETS_CREDENTIALS = "credentials.json"
SPREADSHEET_ID = ""
USERS_FILE = "users.json"
BATCHES_FILE = "batches.pkl"
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ˜ĞĞ˜Ğ¦Ğ˜ĞĞ›Ğ˜Ğ—ĞĞ¦Ğ˜Ğ¯ Ğ‘ĞĞ¢Ğ - Ğ¢ĞĞ›Ğ¬ĞšĞ ĞĞ”Ğ˜Ğ Ğ ĞĞ—!
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
bot = Bot(token=API_TOKEN)
storage = MemoryStorage()
dp = Dispatcher(bot, storage=storage)
scheduler = AsyncIOScheduler()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ¥Ğ ĞĞĞ˜Ğ›Ğ˜Ğ©Ğ Ğ”ĞĞĞĞ«Ğ¥ - Ğ‘Ğ•Ğ— Ğ”Ğ£Ğ‘Ğ›Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ¯!
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ Ñ…Ñ€Ğ°Ğ½Ğ¸Ğ»Ğ¸Ñ‰Ğ°
users = {}
user_requests = {}
batches = {}
pulls = {}
pullparticipants = {}
matches = {}
deals = {}
logger = logging.getLogger(__name__)

# Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ¸ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ°
shipping_requests = {}
logistics_requests = {}
farmer_logistics_requests = {}
farmer_shipping_requests = {}

# ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
logistics_cards = {}
expeditor_cards = {}
expeditor_offers = {}
logistic_offers = {}

# Ğ ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³Ğ¸
logistic_ratings = {}
last_start_times = {}
welcome_message_ids = {}
# Ğ¡Ñ‡Ñ‘Ñ‚Ñ‡Ğ¸ĞºĞ¸
batch_counter = 0
pull_counter = 0
deal_counter = 0
match_counter = 0
logistics_request_counter = 0
logistics_offer_counter = 0

# ĞšÑÑˆ Ñ†ĞµĞ½ Ğ¸ Ğ½Ğ¾Ğ²Ğ¾ÑÑ‚ĞµĞ¹
prices_cache = {"data": {}, "updated": None}
news_cache = {"data": [], "updated": None}
last_prices_update = None
last_news_update = None

shipping_requests = {}
logistics_requests = {}
logistic_offers = {}
deliveries = {}
logistics_offers = {}
# Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€
expeditor_offers = {}

# ============================================================================
# ĞšĞĞĞ¡Ğ¢ĞĞĞ¢Ğ«
# ============================================================================
TRANSPORT_TYPES = {
    "Ğ–Ğ”": "ğŸš‚",
    "Ğ—ĞµÑ€Ğ½Ğ¾Ğ²Ğ¾Ğ·": "ğŸšš",
    "Ğ¤ÑƒÑ€Ğ°": "ğŸš›",
}

TRANSPORT_EMOJIS = {
    "Ğ–Ğ”": "ğŸš‚",
    "Ğ—ĞµÑ€Ğ½Ğ¾Ğ²Ğ¾Ğ·": "ğŸšš",
    "Ğ¤ÑƒÑ€Ğ°": "ğŸš›",
}

status_map = {
    "active": "âœ… ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ°",
    "in_progress": "ğŸ”„ Ğ’ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğµ",
    "completed": "âœ… Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¾",
    "canceled": "âŒ ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾",
    "reserved": "ğŸ”’ Ğ—Ğ°Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ°",
    "sold": "ğŸ’° ĞŸÑ€Ğ¾Ğ´Ğ°Ğ½Ğ°",
    "filled": "ğŸ“¥ Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½",
    "closed": "ğŸ”’ Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚",
    "cancelled": "âŒ ĞÑ‚Ğ¼ĞµĞ½Ñ‘Ğ½",
    "open": "ğŸ“‚ ĞÑ‚ĞºÑ€Ñ‹Ñ‚",
    "pending": "â³ ĞĞ¶Ğ¸Ğ´Ğ°Ğ½Ğ¸Ğµ",
    "delivered": "ğŸšš Ğ”Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½",
}

ROLES = {
    "farmer": "ğŸŒ¾ Ğ¤ĞµÑ€Ğ¼ĞµÑ€",
    "exporter": "ğŸ“¦ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€",
    "logistic": "ğŸšš Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚",
    "expeditor": "ğŸš› Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€",
}

CULTURES = ["ĞŸÑˆĞµĞ½Ğ¸Ñ†Ğ°", "Ğ¯Ñ‡Ğ¼ĞµĞ½ÑŒ", "ĞšÑƒĞºÑƒÑ€ÑƒĞ·Ğ°", "ĞŸĞ¾Ğ´ÑĞ¾Ğ»Ğ½ĞµÑ‡Ğ½Ğ¸Ğº", "Ğ Ğ°Ğ¿Ñ", "Ğ¡Ğ¾Ñ"]

QUALITY_CLASSES = ["1 ĞºĞ»Ğ°ÑÑ", "2 ĞºĞ»Ğ°ÑÑ", "3 ĞºĞ»Ğ°ÑÑ", "4 ĞºĞ»Ğ°ÑÑ", "5 ĞºĞ»Ğ°ÑÑ"]

STORAGE_TYPES = ["Ğ­Ğ»ĞµĞ²Ğ°Ñ‚Ğ¾Ñ€", "Ğ¡ĞºĞ»Ğ°Ğ´", "ĞĞ°Ğ¿Ğ¾Ğ»ÑŒĞ½Ğ¾Ğµ Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ", "Ğ¡Ğ¸Ğ»Ğ¾Ñ"]

DEAL_STATUSES = {
    "pending": "ğŸ”„ Ğ’ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑĞµ",
    "matched": "ğŸ¯ ĞĞ°Ğ¹Ğ´ĞµĞ½ Ğ¿Ğ°Ñ€Ñ‚Ğ½Ñ‘Ñ€",
    "shipping": "ğŸš› ĞÑ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºĞ¸",
    "completed": "âœ… Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°",
    "cancelled": "âŒ ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½Ğ°",
}

PORTS = [
    "ĞÑ€Ğ¸Ğ±",
    "ĞŸĞšĞ¤ Â«Ğ’Ğ¾Ğ»Ğ³Ğ°-ĞŸĞ¾Ñ€Ñ‚Â»",
    "ĞŸĞšĞ¤ Â«Ğ®Ğ³-Ğ¢ĞµÑ€Â»",
    "ĞŸĞĞ Â«ĞÑÑ‚Ñ€.ĞŸĞ¾Ñ€Ñ‚Â»",
    "Ğ£Ğ½Ğ¸Ğ²ĞµÑ€.ĞŸĞ¾Ñ€Ñ‚",
    "Ğ®Ğ¶.ĞŸĞ¾Ñ€Ñ‚",
    "ĞĞ³Ñ€Ğ¾Ñ„ÑƒĞ´",
    "ĞœĞ¾ÑĞ¿Ğ¾Ñ€Ñ‚",
    "Ğ¦Ğ“ĞŸ",
    "Ğ¤Ğ—Ğ¢",
    "ĞĞœĞŸ",
    "ĞÑ€Ğ¼Ğ°Ğ´Ğ°",
    "Ğ¡Ñ‚Ñ€ĞµĞ»ĞµÑ†",
    "ĞĞ»ÑŒÑ„Ğ°",
]


def translate_pull_status(
    status: str = None, current_volume: float = None, target_volume: float = None
) -> str:
    """âœ… ĞŸĞµÑ€ĞµĞ²Ğ¾Ğ´Ğ¸Ñ‚ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ¿ÑƒĞ»Ğ° Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¸Ğ¹ Ñ ÑĞ¼Ğ¾Ğ´Ğ·Ğ¸"""

    # âœ… Ğ•ÑĞ»Ğ¸ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ½Ğµ Ğ·Ğ°Ğ´Ğ°Ğ½, Ğ½Ğ¾ Ğ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ñ‹ Ğ¾Ğ±ÑŠÑ‘Ğ¼Ñ‹ â€” Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸
    if not status and current_volume is not None and target_volume is not None:
        if target_volume > 0 and current_volume >= target_volume:
            status = "filled"
        elif current_volume > 0:
            status = "active"
        else:
            status = "active"

    # âœ… Ğ¡Ğ»Ğ¾Ğ²Ğ°Ñ€ÑŒ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ¾Ğ²
    status_map = {
        "active": "ğŸŸ¢ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¹",
        "Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¹": "ğŸŸ¢ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¹",
        "Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚": "ğŸŸ¢ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¹",
        "open": "ğŸŸ¢ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¹",
        "filling": "ğŸŸ¡ Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ÑĞµÑ‚ÑÑ",  # â† Ğ”ĞĞ‘ĞĞ’Ğ›Ğ•ĞĞ
        "filled": "ğŸ‰ Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½",  # â† Ğ£Ğ‘Ğ ĞĞĞ "(100%)"
        "Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½": "ğŸ‰ Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½",
        "closed": "ğŸ”´ Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚",
        "Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚": "ğŸ”´ Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚",  # â† Ğ”ĞĞ‘ĞĞ’Ğ›Ğ•ĞĞ
        "Ğ·Ğ°Ğ²ĞµÑ€ÑˆÑ‘Ğ½": "âœ”ï¸ Ğ—Ğ°Ğ²ĞµÑ€ÑˆÑ‘Ğ½",
        "completed": "âœ”ï¸ Ğ—Ğ°Ğ²ĞµÑ€ÑˆÑ‘Ğ½",
        "cancelled": "âŒ ĞÑ‚Ğ¼ĞµĞ½Ñ‘Ğ½",
        "Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‘Ğ½": "âŒ ĞÑ‚Ğ¼ĞµĞ½Ñ‘Ğ½",  # â† Ğ”ĞĞ‘ĞĞ’Ğ›Ğ•ĞĞ
    }

    # âœ… ĞŸÑ€Ğ¸Ğ²Ğ¾Ğ´Ğ¸Ğ¼ Ğº Ğ½Ğ¸Ğ¶Ğ½ĞµĞ¼Ñƒ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ñƒ Ğ¸ ÑƒĞ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ğ¿Ñ€Ğ¾Ğ±ĞµĞ»Ñ‹
    if status:
        normalized_status = str(status).lower().strip()
    else:
        return "â“ ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚ĞµĞ½"  # â† Ğ•ÑĞ»Ğ¸ ÑÑ‚Ğ°Ñ‚ÑƒÑ None

    return status_map.get(normalized_status, f"âšª {status}")


def migrate_all_existing_pulls():
    """âœ… ĞšĞ Ğ˜Ğ¢Ğ˜Ğ§Ğ•Ğ¡ĞšĞĞ¯ ĞœĞ˜Ğ“Ğ ĞĞ¦Ğ˜Ğ¯: Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ½Ğ¾Ğ²Ñ‹Ğµ Ğ¿Ğ¾Ğ»Ñ Ğ²Ğ¾ Ğ’Ğ¡Ğ• ÑÑ‚Ğ°Ñ€Ñ‹Ğµ Ğ¿ÑƒĞ»Ñ‹"""
    global pulls

    logging.info("ğŸ”„ Ğ—ĞĞŸĞ£Ğ¡Ğš ĞœĞ˜Ğ“Ğ ĞĞ¦Ğ˜Ğ˜ ĞŸĞ£Ğ›ĞĞ’...")
    migrated = 0

    # âœ… ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞ: Ğ˜Ñ‚ĞµÑ€Ğ¸Ñ€ÑƒĞµĞ¼ pulls['pulls'], Ğ° Ğ½Ğµ pulls
    for pull_id, pull in list(pulls.get("pulls", {}).items()):
        if not isinstance(pull, dict):
            logging.warning(
                f"âš ï¸ ĞŸÑƒĞ» {pull_id} Ğ¸Ğ¼ĞµĞµÑ‚ Ğ½ĞµĞ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ‚Ğ¸Ğ¿ {type(pull)}, Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ°Ñ"
            )
            continue

        changed = False

        # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ½Ğ¾Ğ²Ñ‹Ğµ Ğ¿Ğ¾Ğ»Ñ ĞµÑĞ»Ğ¸ Ğ¸Ñ… Ğ½ĞµÑ‚
        if "creator_id" not in pull and "exporter_id" in pull:
            pull["creator_id"] = pull["exporter_id"]
            changed = True

        if "price_per_ton" not in pull and "price" in pull:
            pull["price_per_ton"] = float(pull.get("price", 0))
            changed = True

        if "farmer_ids" not in pull:
            pull["farmer_ids"] = pull.get("participants", [])
            changed = True

        if "batches" not in pull:
            pull["batches"] = pull.get("batch_ids", [])
            changed = True

        if "batch_ids" not in pull:
            pull["batch_ids"] = []
            changed = True

        if "logist_ids" not in pull:
            pull["logist_ids"] = []
            changed = True

        if "expeditor_ids" not in pull:
            pull["expeditor_ids"] = []
            changed = True

        if changed:
            migrated += 1
            logging.info(
                f"   âœ… ĞŸÑƒĞ» #{pull_id} Ğ¼Ğ¸Ğ³Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½: farmer_ids={len(pull.get('farmer_ids', []))} Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ²"
            )

    if migrated > 0:
        save_pulls_to_pickle()
        logging.info(f"âœ… ĞœĞ˜Ğ“Ğ ĞĞ¦Ğ˜Ğ¯ Ğ—ĞĞ’Ğ•Ğ Ğ¨Ğ•ĞĞ: {migrated} Ğ¿ÑƒĞ»Ğ¾Ğ² Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾!")
    else:
        logging.info("â„¹ï¸ Ğ’ÑĞµ Ğ¿ÑƒĞ»Ñ‹ ÑƒĞ¶Ğµ Ğ¼Ğ¸Ğ³Ñ€Ğ°Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹")

    return migrated


def migrate_old_pulls():
    """Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµÑ‚ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ´Ğ»Ñ ÑÑ‚Ğ°Ñ€Ñ‹Ñ… Ğ¿ÑƒĞ»Ğ¾Ğ² Ğ±ĞµĞ· ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°"""
    migrated_count = 0
    valid_statuses = ["active", "filled", "closed", "completed", "cancelled"]

    all_pulls = pulls.get("pulls", {})  # âœ… Ğ”ĞĞ‘ĞĞ’Ğ›Ğ•ĞĞ

    for pull_id, pull in all_pulls.items():  # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ
        if not isinstance(pull, dict):  # âœ… Ğ”ĞĞ‘ĞĞ’Ğ›Ğ•ĞĞ
            continue

        current_status = pull.get("status", None)

        # Ğ›Ğ¾Ğ³Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‚ĞµĞºÑƒÑ‰ĞµĞµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ°
        logging.info(
            f"ğŸ” ĞŸÑƒĞ» #{pull_id}: ÑÑ‚Ğ°Ñ‚ÑƒÑ='{current_status}' (Ñ‚Ğ¸Ğ¿: {type(current_status).__name__}), "
            f"Ğ¾Ğ±ÑŠÑ‘Ğ¼={pull.get('current_volume', 0)}/{pull.get('target_volume', 0)}"
        )

        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼: ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚, Ğ¿ÑƒÑÑ‚Ğ¾Ğ¹, None Ğ¸Ğ»Ğ¸ Ğ½ĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¹
        needs_migration = (
            current_status is None
            or current_status == ""
            or current_status.lower() not in valid_statuses
        )

        if needs_migration:
            # ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ¿Ğ¾ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸
            current_vol = pull.get("current_volume", 0)
            target_vol = pull.get("target_volume", 1)

            if current_vol >= target_vol and target_vol > 0:
                pull["status"] = "filled"
                logging.info(
                    f"âœ… ĞŸÑƒĞ» #{pull_id} Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»Ñ‘Ğ½: 'filled' (Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½ {current_vol}/{target_vol} Ñ‚)"
                )
                migrated_count += 1
            else:
                pull["status"] = "active"
                logging.info(
                    f"âœ… ĞŸÑƒĞ» #{pull_id} Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»Ñ‘Ğ½: 'active' (Ğ°ĞºÑ‚Ğ¸Ğ²ĞµĞ½ {current_vol}/{target_vol} Ñ‚)"
                )
                migrated_count += 1
        else:
            logging.info(
                f"â„¹ï¸ ĞŸÑƒĞ» #{pull_id}: ÑÑ‚Ğ°Ñ‚ÑƒÑ '{current_status}' ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚ĞµĞ½, Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ°ĞµĞ¼"
            )

    if migrated_count > 0:
        save_pulls_to_pickle()
        logging.info(f"âœ… ĞœĞ¸Ğ³Ñ€Ğ°Ñ†Ğ¸Ñ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°: Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾ {migrated_count} Ğ¿ÑƒĞ»Ğ¾Ğ²")
    else:
        logging.info("â„¹ï¸ ĞœĞ¸Ğ³Ñ€Ğ°Ñ†Ğ¸Ñ Ğ½Ğµ Ñ‚Ñ€ĞµĞ±ÑƒĞµÑ‚ÑÑ: Ğ²ÑĞµ Ğ¿ÑƒĞ»Ñ‹ ÑƒĞ¶Ğµ Ğ¸Ğ¼ĞµÑÑ‚ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¹ ÑÑ‚Ğ°Ñ‚ÑƒÑ")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”„ ĞšĞĞĞ’Ğ•Ğ Ğ¢Ğ•Ğ Ğ« Ğ”ĞĞĞĞ«Ğ¥ - Ğ´Ğ»Ñ Ñ‡Ñ‚ĞµĞ½Ğ¸Ñ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ°
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


def get_pull_with_participants(pull_id):
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¿ÑƒĞ» Ñ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ°Ğ¼Ğ¸ Ğ² Ğ¾Ğ´Ğ½Ğ¾Ğ¼ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğµ (Ñ‚Ğ²Ğ¾Ğ¹ Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚)"""
    global pulls

    if not pulls or "pulls" not in pulls:
        return None

    all_pulls = pulls.get("pulls", {})

    if pull_id in all_pulls:
        return all_pulls[pull_id]  # âœ… Ğ’ĞµÑ€Ğ½Ñ‘Ñ‚ Ğ¿ÑƒĞ» ÑĞ¾ Ğ’Ğ¡Ğ•ĞœĞ˜ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸ Ğ²ĞºĞ»ÑÑ‡Ğ°Ñ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²

    return None


def get_farmers_from_pull(pull_id):
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ², Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½Ğ¸Ğ²ÑˆĞ¸Ñ…ÑÑ Ğº Ğ¿ÑƒĞ»Ñƒ"""
    global pulls

    pull_data = get_pull_with_participants(pull_id)
    if not pull_data:
        return []

    # âœ… Ğ§Ğ¸Ñ‚Ğ°ĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ² Ñ‚Ğ²Ğ¾Ñ‘Ğ¼ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ¼ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğµ
    farmer_ids = pull_data.get("farmer_ids", [])

    if isinstance(farmer_ids, list):
        return farmer_ids

    return []


def get_batches_from_pull(pull_id):
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸, Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½Ğ¸Ğ²ÑˆĞ¸ĞµÑÑ Ğº Ğ¿ÑƒĞ»Ñƒ"""
    global pulls

    pull_data = get_pull_with_participants(pull_id)
    if not pull_data:
        return []

    # âœ… Ğ§Ğ¸Ñ‚Ğ°ĞµĞ¼ Ğ±Ğ°Ñ‚Ñ‡Ğ¸ Ğ² Ñ‚Ğ²Ğ¾Ñ‘Ğ¼ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğµ
    batches = pull_data.get("batches", [])

    if isinstance(batches, list):
        return batches

    return []


def get_all_pulls_with_format():
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ’Ğ¡Ğ• Ğ¿ÑƒĞ»Ñ‹ Ğ² Ñ‚Ğ²Ğ¾Ñ‘Ğ¼ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ¼ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğµ"""
    global pulls

    if not pulls or "pulls" not in pulls:
        return {}

    return pulls.get("pulls", {})


# âœ… Ğ‘Ğ•Ğ— async - Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ!
def find_matching_batches(pull_data):
    """ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´ÑÑ‰Ğ¸Ñ… Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ´Ğ»Ñ Ğ¿ÑƒĞ»Ğ°"""
    global batches
    matching_batches = []

    if not batches or not isinstance(batches, dict):
        logging.warning(f"âš ï¸ Ğ‘Ğ°Ñ‚Ñ‡Ğ¸ Ğ¿ÑƒÑÑ‚Ñ‹ Ğ¸Ğ»Ğ¸ Ğ½ĞµĞ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ‚Ğ¸Ğ¿: {type(batches)}")
        return matching_batches

    try:
        for user_id, user_batches in batches.items():
            # Ğ•ÑĞ»Ğ¸ ÑÑ‚Ğ¾ ÑĞ»Ğ¾Ğ²Ğ°Ñ€ÑŒ Ğ±Ğ°Ñ‚Ñ‡ĞµĞ¹ (batch_id: {...})
            if isinstance(user_batches, dict):
                for batch_id, batch in user_batches.items():
                    if not isinstance(batch, dict):
                        continue

                    if _batch_matches_pull(batch, pull_data):
                        batch_copy = batch.copy()
                        batch_copy["farmer_id"] = user_id
                        batch_copy["batch_id"] = batch_id
                        matching_batches.append(batch_copy)

            # Ğ•ÑĞ»Ğ¸ ÑÑ‚Ğ¾ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ±Ğ°Ñ‚Ñ‡ĞµĞ¹
            elif isinstance(user_batches, list):
                for idx, batch in enumerate(user_batches):
                    if not isinstance(batch, dict):
                        continue

                    if _batch_matches_pull(batch, pull_data):
                        batch_copy = batch.copy()
                        batch_copy["farmer_id"] = user_id
                        batch_copy["batch_id"] = batch.get("id", idx)
                        matching_batches.append(batch_copy)

    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ¸ÑĞºĞ° Ğ±Ğ°Ñ‚Ñ‡ĞµĞ¹: {e}", exc_info=True)

    logging.info(f"ğŸ” ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ±Ğ°Ñ‚Ñ‡ĞµĞ¹: {len(matching_batches)}")
    return matching_batches


def _batch_matches_pull(batch, pull_data):
    """âœ… Ğ›Ğ¾Ğ³Ğ¸ĞºĞ° ÑÑ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ñ Ğ±Ğ°Ñ‚Ñ‡Ğ° Ğ¸ Ğ¿ÑƒĞ»Ğ°"""
    return (
        batch.get("culture", "").lower() == pull_data.get("culture", "").lower()
        and batch.get("status") == "ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ°"
        and batch.get("price", float("inf"))
        <= pull_data.get("price", float("inf")) * 0.75
        and batch.get("humidity", 999) <= pull_data.get("moisture", 0)
        and batch.get("impurity", 999) <= pull_data.get("impurity", 0)
    )


def parse_join_pull_callback(callback_data: str) -> dict:
    """Ğ£Ğ½Ğ¸Ğ²ĞµÑ€ÑĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿Ğ°Ñ€ÑĞµÑ€ callback Ğ´Ğ»Ñ join_pull"""
    try:
        parts = callback_data.split(":")
        pull_id = int(parts[1])
        timestamp = parts[2] if len(parts) >= 3 else None

        logging.info(f"ğŸ”— Parsed callback: pull_id={pull_id}, timestamp={timestamp}")
        return {"pull_id": pull_id, "timestamp": timestamp}
    except (ValueError, IndexError) as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ°Ñ€ÑĞ¸Ğ½Ğ³Ğ° '{callback_data}': {e}")
        raise


def validate_batch_volume(batch: dict, pull: dict) -> tuple:
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚, Ğ¿Ğ¾Ğ¼ĞµÑÑ‚Ğ¸Ñ‚ÑÑ Ğ»Ğ¸ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ² Ğ¿ÑƒĞ»"""
    batch_volume = batch.get("volume", 0)
    current_volume = pull.get("current_volume", 0)
    target_volume = pull.get("target_volume", 0)
    available = target_volume - current_volume

    if batch_volume > available:
        return (
            False,
            f"âŒ ĞĞ±ÑŠÑ‘Ğ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ ({batch_volume} Ñ‚) Ğ¿Ñ€ĞµĞ²Ñ‹ÑˆĞ°ĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğ¹ ({available} Ñ‚)",
        )

    return (True, "âœ… ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´Ğ¸Ñ‚")


async def check_and_close_pool_if_full(pull_id: int):
    """ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ·Ğ°ĞºÑ€Ñ‹Ğ²Ğ°ĞµÑ‚ Ğ¿ÑƒĞ» ĞµÑĞ»Ğ¸ current_volume >= target_volume"""
    if pull_id not in pulls.get("pulls", {}):
        logging.error(f"âŒ ĞŸÑƒĞ» #{pull_id} Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½")
        return

    pull = pulls["pulls"][pull_id]
    current = pull.get("current_volume", 0)
    target = pull.get("target_volume", 0)

    logging.info(f"ğŸ” ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ°Ğ²Ñ‚Ğ¾Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ñ Ğ¿ÑƒĞ»Ğ° #{pull_id}: {current}/{target} Ñ‚")

    if current >= target:
        pull["status"] = "closed"  # ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°
        pull["closed_at"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        save_pulls_to_pickle()

        logging.info(f"ğŸ”’ ĞŸÑƒĞ» #{pull_id} ĞĞ’Ğ¢ĞĞœĞĞ¢Ğ˜Ğ§Ğ•Ğ¡ĞšĞ˜ Ğ—ĞĞšĞ Ğ«Ğ¢ ({current}/{target} Ñ‚)")

        notification_text = (
            f"ğŸ‰ <b>ĞŸÑƒĞ» #{pull_id} Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚!</b>\n\n"
            f"ğŸ“¦ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {pull.get('culture', 'ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ°')}\n"
            f"ğŸ“Š ĞĞ±ÑŠÑ‘Ğ¼: {current}/{target} Ñ‚\n"
            f"âœ… ĞŸÑƒĞ» Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½ Ğ¸ Ğ³Ğ¾Ñ‚Ğ¾Ğ² Ğº Ğ¾Ñ‚Ğ³Ñ€ÑƒĞ·ĞºĞµ."
        )

        keyboard = InlineKeyboardMarkup()
        keyboard.add(
            InlineKeyboardButton(
                "ğŸ“‹ ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ğ¿ÑƒĞ»", callback_data=f"view_pull:{pull_id}"
            )
        )

        # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°
        exporter_id = pull.get("exporter_id")
        if exporter_id:
            try:
                await bot.send_message(
                    exporter_id,
                    notification_text,
                    parse_mode="HTML",
                    reply_markup=keyboard,
                )
            except Exception as e:
                logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°: {e}")

        # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ²
        farmer_ids = pull.get("farmer_ids", [])
        for farmer_id in farmer_ids:
            try:
                await bot.send_message(
                    farmer_id,
                    notification_text,
                    parse_mode="HTML",
                    reply_markup=keyboard,
                )
            except Exception as e:
                logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ° {farmer_id}: {e}")

        # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²
        logist_ids = pull.get("logist_ids", [])
        for logist_id in logist_ids:
            try:
                await bot.send_message(
                    logist_id,
                    notification_text,
                    parse_mode="HTML",
                    reply_markup=keyboard,
                )
            except Exception as e:
                logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° {logist_id}: {e}")


# ==================== ĞšĞĞĞ•Ğ¦ ĞĞĞ’Ğ«Ğ¥ Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ™ ====================


def save_deals_to_pickle():
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ ÑĞ´ĞµĞ»Ğ¾Ğº Ğ² pickle"""
    try:
        deals_file = os.path.join(DATA_DIR, "deals.pkl")
        with open(deals_file, "wb") as f:
            pickle.dump(deals, f)
        logging.info("âœ… Ğ¡Ğ´ĞµĞ»ĞºĞ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ñ‹")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ ÑĞ´ĞµĞ»Ğ¾Ğº: {e}")


def save_farmers_logistics():
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ·Ğ°ÑĞ²Ğ¾Ğº Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ² Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ"""
    try:
        path = os.path.join(DATA_DIR, "farmer_logistics_requests.pkl")
        with open(path, "wb") as f:
            pickle.dump(farmer_logistics_requests, f)
        logging.info(f"âœ… Ğ—Ğ°ÑĞ²ĞºĞ¸ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ²: {len(farmer_logistics_requests)}")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ farmer_logistics: {e}")


def save_logistics_requests_data():
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ·Ğ°ÑĞ²Ğ¾Ğº Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²"""
    try:
        path = os.path.join(DATA_DIR, "logistics_requests.pkl")
        with open(path, "wb") as f:
            pickle.dump(logistics_requests, f)
        logging.info(f"âœ… Ğ—Ğ°ÑĞ²ĞºĞ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²: {len(logistics_requests)}")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ logistics_requests: {e}")


def save_shipping_requests_data():
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ·Ğ°ÑĞ²Ğ¾Ğº Ğ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€Ğ¾Ğ²"""
    try:
        path = os.path.join(DATA_DIR, "shipping_requests.pkl")
        with open(path, "wb") as f:
            pickle.dump(shipping_requests, f)
        logging.info(f"âœ… Ğ—Ğ°ÑĞ²ĞºĞ¸ Ğ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ: {len(shipping_requests)}")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ shipping_requests: {e}")


def save_logistics_offers_data():
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²"""
    try:
        if logistics_offers:
            path = os.path.join(DATA_DIR, "logistics_offers.pkl")
            with open(path, "wb") as f:
                pickle.dump(logistics_offers, f)
            logging.info(f"âœ… ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²: {len(logistics_offers)}")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ logistics_offers: {e}")


def save_expeditor_data():
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²"""
    try:
        if expeditor_cards:
            path = os.path.join(DATA_DIR, "expeditor_cards.pkl")
            with open(path, "wb") as f:
                pickle.dump(expeditor_cards, f)
            logging.info(f"âœ… ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²: {len(expeditor_cards)}")

        if expeditor_offers:
            path = os.path.join(DATA_DIR, "expeditor_offers.pkl")
            with open(path, "wb") as f:
                pickle.dump(expeditor_offers, f)
            logging.info(f"âœ… ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²: {len(expeditor_offers)}")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ expeditor: {e}")


def save_logistics_cards_data():
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞµĞº Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²"""
    try:
        if logistics_cards:
            path = os.path.join(DATA_DIR, "logistics_cards.pkl")
            with open(path, "wb") as f:
                pickle.dump(logistics_cards, f)
            logging.info(f"âœ… ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²: {len(logistics_cards)}")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ logistics_cards: {e}")


def save_data():
    """âœ… ĞĞ¡ĞĞĞ’ĞĞĞ¯ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ğ’Ğ¡Ğ• Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…"""
    try:
        logging.info("ğŸ”„ ĞĞ°Ñ‡Ğ¸Ğ½Ğ°Ñ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…...")
        os.makedirs(DATA_DIR, exist_ok=True)

        # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ·Ğ°ÑĞ²ĞºĞ¸
        save_farmers_logistics()
        save_logistics_requests_data()
        save_shipping_requests_data()

        # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
        save_logistics_offers_data()
        save_expeditor_data()

        # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸
        save_logistics_cards_data()

        # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ±Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ñ‡ĞµÑ€ĞµĞ· ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
        save_users_to_pickle()
        save_batches_to_pickle()
        save_pulls_to_pickle()
        save_deals_to_pickle()

        logging.info("âœ… Ğ’Ğ¡Ğ• Ğ”ĞĞĞĞ«Ğ• Ğ¡ĞĞ¥Ğ ĞĞĞ•ĞĞ« Ğ£Ğ¡ĞŸĞ•Ğ¨ĞĞ")
        return True

    except Exception as e:
        logging.error(f"âŒ ĞĞ¨Ğ˜Ğ‘ĞšĞ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ: {e}", exc_info=True)
        return False


def load_data():
    """âœ… Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ğ’Ğ¡Ğ• Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¿Ñ€Ğ¸ ÑÑ‚Ğ°Ñ€Ñ‚Ğµ"""
    global farmer_logistics_requests, logistics_requests, shipping_requests
    global logistics_offers, expeditor_cards, expeditor_offers, logistics_cards
    global pulls, users, batches  # âœ… Ğ’ĞĞ–ĞĞ!

    try:
        logging.info("ğŸ”„ ĞĞ°Ñ‡Ğ¸Ğ½Ğ°Ñ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºÑƒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…...")
        os.makedirs(DATA_DIR, exist_ok=True)

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # âœ… Ğ—ĞĞ“Ğ Ğ£Ğ–ĞĞ•Ğœ USERS
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if os.path.exists(os.path.join(DATA_DIR, "users.json")):
            with open(os.path.join(DATA_DIR, "users.json"), "r", encoding="utf-8") as f:
                users = json.load(f)
                logging.info(f"âœ… ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸ Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ñ‹: {len(users)}")

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # âœ… Ğ—ĞĞ“Ğ Ğ£Ğ–ĞĞ•Ğœ BATCHES
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if os.path.exists(os.path.join(DATA_DIR, "batches.pkl")):
            with open(os.path.join(DATA_DIR, "batches.pkl"), "rb") as f:
                batches = pickle.load(f)
                logging.info(f"âœ… ĞŸĞ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ñ‹")

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # âœ… Ğ—ĞĞ“Ğ Ğ£Ğ–ĞĞ•Ğœ PULLS Ğ¡ PULLPARTICIPANTS (ĞšĞ Ğ˜Ğ¢Ğ˜Ğ§ĞĞĞ•!)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if os.path.exists(os.path.join(DATA_DIR, "pulls.pkl")):
            with open(os.path.join(DATA_DIR, "pulls.pkl"), "rb") as f:
                pulls_loaded = pickle.load(f)

                # Ğ•ÑĞ»Ğ¸ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ°Ñ - Ñ€Ğ°ÑĞ¿Ğ°ĞºĞ¾Ğ²Ñ‹Ğ²Ğ°ĞµĞ¼
                if isinstance(pulls_loaded, dict):
                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    # âœ… Ğ—ĞĞ“Ğ Ğ£Ğ–ĞĞ•Ğœ PULLS
                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    if "pulls" in pulls_loaded:
                        pulls_data = pulls_loaded.get("pulls", {})

                        # âœ… ĞŸĞ ĞĞ’Ğ•Ğ ĞšĞ: Ğ•ÑĞ»Ğ¸ ÑÑ‚Ğ¾ Ğ¾Ğ´Ğ¸Ğ½ Ğ¿ÑƒĞ» (ĞµÑÑ‚ÑŒ 'id'), Ğ¾Ğ±Ğ¾Ñ€Ğ°Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ² ÑĞ»Ğ¾Ğ²Ğ°Ñ€ÑŒ
                        if isinstance(pulls_data, dict):
                            if "id" in pulls_data:
                                # âŒ Ğ­Ğ¢Ğ ĞĞ”Ğ˜Ğ ĞŸĞ£Ğ›! Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ ĞµĞ³Ğ¾ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾
                                logging.warning(
                                    "âš ï¸ pulls['pulls'] - ÑÑ‚Ğ¾ Ğ¾Ğ´Ğ¸Ğ½ Ğ¿ÑƒĞ»! ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ¸Ñ€ÑƒÑ..."
                                )
                                pull_id = pulls_data.get("id", 1)
                                pulls["pulls"] = {pull_id: pulls_data}
                                logging.info(
                                    f"âœ… ĞŸÑƒĞ» #{pull_id} ÑĞ¾Ñ…Ñ€Ğ°Ğ½Ñ‘Ğ½ Ğ² Ğ½Ğ¾Ğ²Ğ¾Ğ¹ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğµ"
                                )
                            else:
                                # âœ… Ğ­Ñ‚Ğ¾ ÑĞ»Ğ¾Ğ²Ğ°Ñ€ÑŒ Ğ¿ÑƒĞ»Ğ¾Ğ²
                                pulls["pulls"] = pulls_data
                        else:
                            pulls["pulls"] = {}
                    else:
                        pulls["pulls"] = {}

                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    # âœ… Ğ—ĞĞ“Ğ Ğ£Ğ–ĞĞ•Ğœ PULLPARTICIPANTS
                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    if "pullparticipants" in pulls_loaded:
                        pullparticipants_data = pulls_loaded.get("pullparticipants", {})

                        # âœ… ĞŸĞ ĞĞ’Ğ•Ğ ĞšĞ: Ğ•ÑĞ»Ğ¸ ÑÑ‚Ğ¾ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿ÑƒĞ»Ğ°, Ğ° Ğ½Ğµ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¸
                        if isinstance(pullparticipants_data, dict):
                            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ĞºĞ»ÑÑ‡Ğ¸ - ĞµÑĞ»Ğ¸ ÑÑ‚Ğ¾ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿ÑƒĞ»Ğ°, Ğ¾Ñ‡Ğ¸Ñ‰Ğ°ĞµĞ¼
                            if (
                                "farmer_ids" in pullparticipants_data
                                or "status" in pullparticipants_data
                                or "batches" in pullparticipants_data
                                or "batch_ids" in pullparticipants_data
                            ):
                                # âŒ Ğ­Ğ¢Ğ Ğ”ĞĞĞĞ«Ğ• ĞŸĞ£Ğ›Ğ! Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ğ¿ÑƒÑÑ‚Ğ¾Ğ¹ ÑĞ»Ğ¾Ğ²Ğ°Ñ€ÑŒ
                                logging.warning(
                                    "âš ï¸ pullparticipants ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿ÑƒĞ»Ğ°, Ğ° Ğ½Ğµ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²!"
                                )
                                logging.warning("âš ï¸ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ Ğ¿ÑƒÑÑ‚Ğ¾Ğ¹ pullparticipants...")
                                pulls["pullparticipants"] = {}
                            else:
                                # âœ… Ğ­Ñ‚Ğ¾ ÑĞ»Ğ¾Ğ²Ğ°Ñ€ÑŒ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² (ĞºĞ»ÑÑ‡Ğ¸ = ID Ğ¿ÑƒĞ»Ğ¾Ğ²)
                                pulls["pullparticipants"] = pullparticipants_data
                        else:
                            pulls["pullparticipants"] = {}
                    else:
                        pulls["pullparticipants"] = {}

                    logging.info(f"âœ… ĞŸÑƒĞ»Ñ‹ Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ñ‹: {len(pulls.get('pulls', {}))}")
                    logging.info(
                        f"âœ… Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¸ Ğ¿ÑƒĞ»Ğ¾Ğ² Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ñ‹: {len(pulls.get('pullparticipants', {}))}"
                    )

                    if pulls.get("pullparticipants"):
                        logging.info(
                            f"   ğŸ“Š pullparticipants.keys() = {list(pulls.get('pullparticipants', {}).keys())}"
                        )
                else:
                    logging.warning("âš ï¸ pulls.pkl ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ Ğ½ĞµĞ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ‚Ğ¸Ğ¿ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…!")
                    pulls["pulls"] = {}
                    pulls["pullparticipants"] = {}
        else:
            logging.info("â„¹ï¸ pulls.pkl Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ - ÑĞ¾Ğ·Ğ´Ğ°Ñ Ğ¿ÑƒÑÑ‚ÑƒÑ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñƒ")
            pulls["pulls"] = {}
            pulls["pullparticipants"] = {}

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # âœ… Ğ—ĞĞ“Ğ Ğ£Ğ–ĞĞ•Ğœ ĞĞ¡Ğ¢ĞĞ›Ğ¬ĞĞ«Ğ• Ğ”ĞĞĞĞ«Ğ•
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        # Ğ—Ğ°Ğ³Ñ€ÑƒĞ¶Ğ°ĞµĞ¼ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ²
        if os.path.exists(os.path.join(DATA_DIR, "farmer_logistics_requests.pkl")):
            with open(
                os.path.join(DATA_DIR, "farmer_logistics_requests.pkl"), "rb"
            ) as f:
                farmer_logistics_requests = pickle.load(f)
                logging.info(
                    f"âœ… Ğ—Ğ°ÑĞ²ĞºĞ¸ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ² Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ñ‹: {len(farmer_logistics_requests)}"
                )

        if os.path.exists(os.path.join(DATA_DIR, "logistics_requests.pkl")):
            with open(os.path.join(DATA_DIR, "logistics_requests.pkl"), "rb") as f:
                logistics_requests = pickle.load(f)
                logging.info(f"âœ… Ğ—Ğ°ÑĞ²ĞºĞ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ² Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ñ‹: {len(logistics_requests)}")

        if os.path.exists(os.path.join(DATA_DIR, "shipping_requests.pkl")):
            with open(os.path.join(DATA_DIR, "shipping_requests.pkl"), "rb") as f:
                shipping_requests = pickle.load(f)
                logging.info(f"âœ… Ğ—Ğ°ÑĞ²ĞºĞ¸ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸ Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ñ‹: {len(shipping_requests)}")

        # Ğ—Ğ°Ğ³Ñ€ÑƒĞ¶Ğ°ĞµĞ¼ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
        if os.path.exists(os.path.join(DATA_DIR, "logistics_offers.pkl")):
            with open(os.path.join(DATA_DIR, "logistics_offers.pkl"), "rb") as f:
                logistics_offers = pickle.load(f)
                logging.info(
                    f"âœ… ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ² Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ñ‹: {len(logistics_offers)}"
                )

        if os.path.exists(os.path.join(DATA_DIR, "expeditor_cards.pkl")):
            with open(os.path.join(DATA_DIR, "expeditor_cards.pkl"), "rb") as f:
                expeditor_cards = pickle.load(f)
                logging.info(
                    f"âœ… ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ² Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ñ‹: {len(expeditor_cards)}"
                )

        if os.path.exists(os.path.join(DATA_DIR, "expeditor_offers.pkl")):
            with open(os.path.join(DATA_DIR, "expeditor_offers.pkl"), "rb") as f:
                expeditor_offers = pickle.load(f)
                logging.info(
                    f"âœ… ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ² Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ñ‹: {len(expeditor_offers)}"
                )

        if os.path.exists(os.path.join(DATA_DIR, "logistics_cards.pkl")):
            with open(os.path.join(DATA_DIR, "logistics_cards.pkl"), "rb") as f:
                logistics_cards = pickle.load(f)
                logging.info(f"âœ… ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ² Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ñ‹: {len(logistics_cards)}")

                # âœ… Ğ—ĞĞ“Ğ Ğ£Ğ–ĞĞ•Ğœ batch_counter
        global batch_counter
        if os.path.exists(os.path.join(DATA_DIR, "batch_counter.pkl")):
            with open(os.path.join(DATA_DIR, "batch_counter.pkl"), "rb") as f:
                batch_counter = pickle.load(f)
                logging.info(f"âœ… batch_counter Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½: {batch_counter}")
        else:
            # Ğ•ÑĞ»Ğ¸ Ñ„Ğ°Ğ¹Ğ»Ğ° Ğ½ĞµÑ‚, Ğ²Ñ‹Ñ‡Ğ¸ÑĞ»ÑĞµĞ¼ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ID Ğ¸Ğ· ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ñ… Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹
            max_id = 0
            for user_batches in batches.values():
                for batch in user_batches:
                    batch_id = batch.get("id", 0)
                    if batch_id > max_id:
                        max_id = batch_id
            batch_counter = max_id
            logging.info(f"âœ… batch_counter Ğ²Ñ‹Ñ‡Ğ¸ÑĞ»ĞµĞ½ Ğ¸Ğ· Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹: {batch_counter}")

        logging.info("âœ… Ğ’Ğ¡Ğ• Ğ”ĞĞĞĞ«Ğ• Ğ—ĞĞ“Ğ Ğ£Ğ–Ğ•ĞĞ« Ğ£Ğ¡ĞŸĞ•Ğ¨ĞĞ!")
        return True

    except Exception as e:
        logging.error(f"âŒ ĞĞ¨Ğ˜Ğ‘ĞšĞ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸: {e}", exc_info=True)
        return False


def get_logistics_by_port(port):
    """ĞŸĞ¾Ğ¸ÑĞº Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ² Ğ¿Ğ¾ Ğ¿Ğ¾Ñ€Ñ‚Ñƒ Ñ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğ¹ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸ĞµĞ¹"""
    result = []
    for uid, card in logistics_cards.items():
        ports = card.get("ports", [])
        if isinstance(ports, str):
            ports = [p.strip() for p in ports.split(",")]
        if port in ports or "Ğ’ÑĞµ Ğ¿Ğ¾Ñ€Ñ‚Ñ‹" in ports:
            user = users.get(uid, {})
            result.append(
                {
                    "user_id": uid,
                    "name": user.get("name", "Ğ/Ğ”"),
                    "company": card.get("company", user.get("name", "Ğ/Ğ”")),
                    "inn": user.get("inn", "Ğ/Ğ”"),  # âœ… Ğ”ĞĞ‘ĞĞ’Ğ˜Ğ›Ğ˜
                    "ogrn": user.get("ogrn", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"),  # âœ… Ğ”ĞĞ‘ĞĞ’Ğ˜Ğ›Ğ˜
                    "phone": user.get("phone", "Ğ/Ğ”"),
                    "email": user.get("email", "Ğ/Ğ”"),  # âœ… Ğ”ĞĞ‘ĞĞ’Ğ˜Ğ›Ğ˜
                    "price_per_ton": card.get("price_per_ton", 0),
                    "transport_type": card.get("transport_type", "Ğ/Ğ”"),
                }
            )
    return result


def get_expeditors_by_port(port):
    """ĞŸĞ¾Ğ¸ÑĞº ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ² Ğ¿Ğ¾ Ğ¿Ğ¾Ñ€Ñ‚Ñƒ Ñ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğ¹ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸ĞµĞ¹"""
    result = []
    for uid, card in expeditor_cards.items():
        ports = card.get("ports", [])
        if isinstance(ports, str):
            ports = [p.strip() for p in ports.split(",")]
        if port in ports or "Ğ’ÑĞµ Ğ¿Ğ¾Ñ€Ñ‚Ñ‹" in ports:
            user = users.get(uid, {})
            result.append(
                {
                    "user_id": uid,
                    "name": user.get("name", "Ğ/Ğ”"),
                    "company": card.get("company", user.get("name", "Ğ/Ğ”")),
                    "inn": user.get("inn", "Ğ/Ğ”"),  # âœ… Ğ”ĞĞ‘ĞĞ’Ğ˜Ğ›Ğ˜
                    "ogrn": user.get("ogrn", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"),  # âœ… Ğ”ĞĞ‘ĞĞ’Ğ˜Ğ›Ğ˜
                    "phone": user.get("phone", "Ğ/Ğ”"),
                    "email": user.get("email", "Ğ/Ğ”"),  # âœ… Ğ”ĞĞ‘ĞĞ’Ğ˜Ğ›Ğ˜
                    "services": card.get("services", "Ğ/Ğ”"),
                    "dt_price": card.get("dt_price", 0),
                }
            )
    return result


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”„ ĞšĞĞĞ’Ğ•Ğ Ğ¢Ğ•Ğ Ğ« Ğ”ĞĞĞĞ«Ğ¥ - Ğ´Ğ»Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ñ Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğ¼ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¾Ğ¼ Ğ¿ÑƒĞ»Ğ¾Ğ²
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


def get_pull_with_participants(pull_id):
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¿ÑƒĞ» Ñ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ°Ğ¼Ğ¸ Ğ² Ğ¾Ğ´Ğ½Ğ¾Ğ¼ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğµ (Ñ‚Ğ²Ğ¾Ğ¹ Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚)"""
    global pulls

    if not pulls or "pulls" not in pulls:
        return None

    all_pulls = pulls.get("pulls", {})

    if pull_id in all_pulls:
        return all_pulls[pull_id]  # âœ… Ğ’ĞµÑ€Ğ½Ñ‘Ñ‚ Ğ¿ÑƒĞ» ÑĞ¾ Ğ’Ğ¡Ğ•ĞœĞ˜ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸ Ğ²ĞºĞ»ÑÑ‡Ğ°Ñ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²

    return None


def get_farmers_from_pull(pull_id):
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ², Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½Ğ¸Ğ²ÑˆĞ¸Ñ…ÑÑ Ğº Ğ¿ÑƒĞ»Ñƒ"""
    global pulls

    pull_data = get_pull_with_participants(pull_id)
    if not pull_data:
        return []

    # âœ… Ğ§Ğ¸Ñ‚Ğ°ĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ² Ñ‚Ğ²Ğ¾Ñ‘Ğ¼ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ¼ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğµ
    farmer_ids = pull_data.get("farmer_ids", [])

    if isinstance(farmer_ids, list):
        return farmer_ids

    return []


def get_batches_from_pull(pull_id):
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸, Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½Ğ¸Ğ²ÑˆĞ¸ĞµÑÑ Ğº Ğ¿ÑƒĞ»Ñƒ"""
    global pulls

    pull_data = get_pull_with_participants(pull_id)
    if not pull_data:
        return []

    # âœ… Ğ§Ğ¸Ñ‚Ğ°ĞµĞ¼ Ğ±Ğ°Ñ‚Ñ‡Ğ¸ Ğ² Ñ‚Ğ²Ğ¾Ñ‘Ğ¼ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğµ
    batches = pull_data.get("batches", [])

    if isinstance(batches, list):
        return batches

    return []


def get_all_pulls_with_format():
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ’Ğ¡Ğ• Ğ¿ÑƒĞ»Ñ‹ Ğ² Ñ‚Ğ²Ğ¾Ñ‘Ğ¼ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ¼ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğµ"""
    global pulls

    if not pulls or "pulls" not in pulls:
        return {}

    return pulls.get("pulls", {})


def get_vehicle_emoji(transport_type):
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ÑĞ¼Ğ¾Ğ´Ğ·Ğ¸ Ğ´Ğ»Ñ Ñ‚Ğ¸Ğ¿Ğ° Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°"""
    transport_type_lower = transport_type.lower()

    if "Ñ„ÑƒÑ€Ğ°" in transport_type_lower:
        return "ğŸš›"
    elif "Ğ³Ñ€ÑƒĞ·Ğ¾Ğ²Ğ¸Ğº" in transport_type_lower:
        return "ğŸšš"
    elif "Ğ³Ğ°Ğ·ĞµĞ»ÑŒ" in transport_type_lower:
        return "ğŸš"
    elif "Ğ¶/Ğ´" in transport_type_lower or "Ğ²Ğ°Ğ³Ğ¾Ğ½" in transport_type_lower:
        return "ğŸš‚"
    elif "Ğ±Ğ°Ñ€Ğ¶Ğ°" in transport_type_lower or "ÑÑƒĞ´Ğ½Ğ¾" in transport_type_lower:
        return "ğŸš¢"
    elif "ĞºĞ¾Ğ½Ñ‚ĞµĞ¹Ğ½ĞµÑ€" in transport_type_lower:
        return "ğŸ“¦"
    elif "Ñ€ĞµÑ„Ñ€Ğ¸Ğ¶ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€" in transport_type_lower:
        return "ğŸ§Š"
    else:
        return "ğŸš›"  # ĞŸĞ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ


def generate_unique_id():
    """Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ ÑƒĞ½Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ ID"""
    import uuid
    import time

    timestamp = int(time.time() * 1000) % 1000000
    unique = str(uuid.uuid4())[:8].upper()
    return f"{timestamp}{unique}"


def generate_id():
    """Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ ÑƒĞ½Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ ID"""
    import uuid, time

    return f"{int(time.time())%1000000}{str(uuid.uuid4())[:6].upper()}"


def format_logistics_cards(logistics):
    """Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞµĞº Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ² Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ Ğ² ÑĞ¿Ğ¸ÑĞºĞµ"""
    if not logistics:
        return "âŒ Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚Ñ‹ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ñ‹ Ğ´Ğ»Ñ Ğ´Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ñ€Ñ‚Ğ¾Ğ²Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ¼Ğ¿Ğ»ĞµĞºÑĞ°"

    text = "<b>ğŸš› ĞĞĞ™Ğ”Ğ•ĞĞĞ«Ğ• Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢Ğ«:</b>\n\n"

    for i, log in enumerate(logistics[:5], 1):
        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ÑĞ¼Ğ¾Ğ´Ğ·Ğ¸ Ğ´Ğ»Ñ Ñ‚Ğ¸Ğ¿Ğ° Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°
        emoji = get_vehicle_emoji(log.get("transport_type", ""))

        # ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
        company = log.get("company", log.get("name", "Ğ/Ğ”"))
        phone = log.get("phone", "Ğ/Ğ”")
        price_per_ton = log.get("price_per_ton", 0)
        transport_type = log.get("transport_type", "Ğ/Ğ”")

        # Ğ ĞµĞºĞ²Ğ¸Ğ·Ğ¸Ñ‚Ñ‹
        inn = log.get("inn", "Ğ/Ğ”")
        ogrn = log.get("ogrn", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        email = log.get("email", "Ğ/Ğ”")

        # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ
        text += f"{i}. {emoji} <b>{company}</b>\n"
        text += f"   ğŸ¢ Ğ˜ĞĞ: {inn} | ĞĞ“Ğ Ğ: {ogrn}\n"
        text += f"   ğŸ“± <code>{phone}</code>\n"

        if email != "Ğ/Ğ”":
            text += f"   ğŸ“§ <code>{email}</code>\n"

        text += f"   ğŸš— {transport_type}\n"
        text += f"   ğŸ’° {price_per_ton:,.0f} â‚½/Ñ‚\n\n"

    # Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ± Ğ¾ÑÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ñ…
    if len(logistics) > 5:
        text += f"<i>â„¹ï¸ Ğ•Ñ‰Ñ‘ {len(logistics) - 5} Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ² Ğ² Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ°Ñ…</i>\n"
        text += "â“ Ğ—Ğ°Ğ¿Ñ€Ğ¾ÑĞ¸Ñ‚Ğµ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ Ğº Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğ¼Ñƒ ÑĞ¿Ğ¸ÑĞºÑƒ"

    return text


def format_expeditors_cards(expeditors):
    """Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞµĞº ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ² Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ Ğ² ÑĞ¿Ğ¸ÑĞºĞµ"""
    if not expeditors:
        return "âŒ Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ñ‹ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ñ‹ Ğ´Ğ»Ñ Ğ´Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ñ€Ñ‚Ğ¾Ğ²Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ¼Ğ¿Ğ»ĞµĞºÑĞ°"

    text = "<b>ğŸ“‹ ĞĞĞ™Ğ”Ğ•ĞĞĞ«Ğ• Ğ­ĞšĞ¡ĞŸĞ•Ğ”Ğ˜Ğ¢ĞĞ Ğ«:</b>\n\n"

    for i, exp in enumerate(expeditors[:5], 1):
        # ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
        company = exp.get("company", exp.get("name", "Ğ/Ğ”"))
        phone = exp.get("phone", "Ğ/Ğ”")
        services = exp.get("services", "Ğ/Ğ”")
        dt_price = exp.get("dt_price", 0)

        # Ğ ĞµĞºĞ²Ğ¸Ğ·Ğ¸Ñ‚Ñ‹
        inn = exp.get("inn", "Ğ/Ğ”")
        ogrn = exp.get("ogrn", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        email = exp.get("email", "Ğ/Ğ”")

        # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ
        text += f"{i}. ğŸ“‹ <b>{company}</b>\n"
        text += f"   ğŸ¢ Ğ˜ĞĞ: {inn} | ĞĞ“Ğ Ğ: {ogrn}\n"
        text += f"   ğŸ“± <code>{phone}</code>\n"

        if email != "Ğ/Ğ”":
            text += f"   ğŸ“§ <code>{email}</code>\n"

        text += f"   ğŸ› ï¸ {services}\n"
        text += f"   ğŸ’° {dt_price:,.0f} â‚½\n\n"

    # Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ± Ğ¾ÑÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ñ…
    if len(expeditors) > 5:
        text += f"<i>â„¹ï¸ Ğ•Ñ‰Ñ‘ {len(expeditors) - 5} ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ² Ğ² Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ°Ñ…</i>\n"
        text += "â“ Ğ—Ğ°Ğ¿Ñ€Ğ¾ÑĞ¸Ñ‚Ğµ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ Ğº Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğ¼Ñƒ ÑĞ¿Ğ¸ÑĞºÑƒ"

    return text


def save_logistics_requests_to_pickle():
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ·Ğ°ÑĞ²Ğ¾Ğº Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ"""
    try:
        with open(os.path.join(DATA_DIR, "logistics_requests.pkl"), "wb") as f:
            pickle.dump(logistics_requests, f)
        logging.info("âœ… Ğ—Ğ°ÑĞ²ĞºĞ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ñ‹")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {e}")


def save_logistics_offers_to_pickle():
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹"""
    try:
        with open(os.path.join(DATA_DIR, "logistics_offers.pkl"), "wb") as f:
            pickle.dump(logistics_offers, f)
        logging.info("âœ… ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ñ‹")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {e}")


def save_logistics_cards_to_pickle():
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞµĞº Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²"""
    try:
        with open(os.path.join(DATA_DIR, "logistics_cards.pkl"), "wb") as f:
            pickle.dump(logistics_cards, f)
        logging.info("âœ… ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ² ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ñ‹")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {e}")


def save_expeditor_cards_to_pickle():
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞµĞº ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²"""
    try:
        with open(os.path.join(DATA_DIR, "expeditor_cards.pkl"), "wb") as f:
            pickle.dump(expeditor_cards, f)
        logging.info("âœ… ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ² ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ñ‹")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {e}")


def save_logistic_offers():
    try:
        with open(os.path.join(DATA_DIR, "logistic_offers.pkl"), "wb") as f:
            pickle.dump(logistic_offers, f)
        logging.info("âœ… Logistic offers saved")
    except Exception as e:
        logging.error(f"âŒ Error saving logistic offers: {e}")


def load_logistic_offers():
    global logistic_offers
    try:
        filepath = os.path.join(DATA_DIR, "logistic_offers.pkl")
        if os.path.exists(filepath):
            with open(filepath, "rb") as f:
                logistic_offers = pickle.load(f)
            logging.info(f"âœ… Loaded {len(logistic_offers)} logistic offers")
        else:
            logistic_offers = {}
    except Exception as e:
        logging.error(f"âŒ Error loading logistic offers: {e}")
        logistic_offers = {}


def save_deliveries():
    try:
        with open(os.path.join(DATA_DIR, "deliveries.pkl"), "wb") as f:
            pickle.dump(deliveries, f)
        logging.info("âœ… Deliveries saved")
    except Exception as e:
        logging.error(f"âŒ Error saving deliveries: {e}")


def load_deliveries():
    global deliveries
    try:
        filepath = os.path.join(DATA_DIR, "deliveries.pkl")
        if os.path.exists(filepath):
            with open(filepath, "rb") as f:
                deliveries = pickle.load(f)
            logging.info(f"âœ… Loaded {len(deliveries)} deliveries")
        else:
            deliveries = {}
    except Exception as e:
        logging.error(f"âŒ Error loading deliveries: {e}")
        deliveries = {}


def save_expeditor_offers():
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²"""
    try:
        with open("data/expeditor_offers.pkl", "wb") as f:
            pickle.dump(expeditor_offers, f)
        logging.info(f"âœ… Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¾ {len(expeditor_offers)} Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ expeditor_offers: {e}")


def clean_text(text):
    """ĞÑ‡Ğ¸ÑÑ‚ĞºĞ° Ñ‚ĞµĞºÑÑ‚Ğ°"""
    if not text:
        return ""
    text = str(text).strip()
    text = re.sub(r"[^\w\s\-.,Ñ‘ĞĞ-Ğ¯Ğ°-Ñ0-9]", "", text)
    return text


def load_expeditor_offers():
    """Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ² Ğ¸Ğ· Ñ„Ğ°Ğ¹Ğ»Ğ°"""
    global expeditor_offers

    try:
        file_path = os.path.join(DATA_DIR, "expeditor_offers.pkl")
        if os.path.exists(file_path):
            with open(file_path, "rb") as f:
                expeditor_offers = pickle.load(f)
            logging.info(f"âœ… Loaded {len(expeditor_offers)} expeditor offers")
        else:
            expeditor_offers = {}
            logging.info("â„¹ï¸ No expeditor offers file found, starting fresh")
    except Exception as e:
        logging.error(f"âŒ Error loading expeditor offers: {e}")
        expeditor_offers = {}


def load_expeditor_cards():
    """Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞµĞº ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ² Ğ¸Ğ· Ñ„Ğ°Ğ¹Ğ»Ğ°"""
    global expeditor_cards

    try:
        file_path = os.path.join(DATA_DIR, "expeditor_cards.pkl")
        if os.path.exists(file_path):
            with open(file_path, "rb") as f:
                expeditor_cards = pickle.load(f)
            logging.info(f"âœ… Ğ—Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ğ¾ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞµĞº ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²: {len(expeditor_cards)}")
        else:
            expeditor_cards = {}
            logging.info("â„¹ï¸ Ğ¤Ğ°Ğ¹Ğ» expeditor_cards.pkl Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½, ÑĞ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ğ½Ğ¾Ğ²Ñ‹Ğ¹")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸ expeditor_cards: {e}")
        expeditor_cards = {}


# ============================================================================
# ĞšĞ Ğ˜Ğ¢Ğ˜Ğ§Ğ•Ğ¡ĞšĞĞ¯ Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ¯: ĞŸĞ°Ñ€ÑĞ¸Ğ½Ğ³ ID Ğ¸Ğ· callback_data
# ============================================================================


def parse_callback_id(callback_data: str) -> int:
    """âœ… ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞ«Ğ™ Ğ¿Ğ°Ñ€ÑĞ¸Ğ½Ğ³ ID Ğ¸Ğ· callback_data"""

    # âœ… Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ¿Ñ€ĞµÑ„Ğ¸ĞºÑĞ¾Ğ² ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ ĞĞ• ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ ID
    non_id_prefixes = ["culture:", "port:", "region:", "back_to_pulls"]

    # âœ… ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ñ€ĞµÑ„Ğ¸ĞºÑÑ‹ Ğ±ĞµĞ· ID
    for prefix in non_id_prefixes:
        if callback_data == prefix or callback_data.startswith(prefix):
            return None

    try:
        if ":" in callback_data:
            id_str = callback_data.split(":")[-1]
        elif "_" in callback_data:
            id_str = callback_data.split("_")[-1]
        else:
            id_str = callback_data

        # âœ… ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ñ‡Ñ‚Ğ¾ ÑÑ‚Ğ¾ Ñ‡Ğ¸ÑĞ»Ğ¾
        if not id_str.isdigit():
            logging.warning(f"âš ï¸ parse_callback_id: Ğ½Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾Ğ²Ğ¾Ğ¹ ID: {id_str}")
            return None

        return int(id_str)

    except (ValueError, IndexError) as e:
        logging.error(f"âŒ parse_callback_id Ğ¾ÑˆĞ¸Ğ±ĞºĞ°: {e} Ğ´Ğ»Ñ {callback_data}")
        raise ValueError(f"ĞĞµ Ğ¼Ğ¾Ğ³Ñƒ Ğ¿Ğ°Ñ€ÑĞ¸Ñ‚ÑŒ ID Ğ¸Ğ· '{callback_data}'")


class RegistrationStatesGroup(StatesGroup):
    name = State()
    phone = State()
    email = State()
    region = State()
    role = State()
    inn = State()
    ogrn = State()
    company_details = State()


class EditRequestStates(StatesGroup):
    waiting_for_choice = State()
    waiting_for_custom_value = State()
    waiting_for_number = State()


class FarmerShippingRequestStates(StatesGroup):
    """State Group Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ"""

    select_batch = State()
    select_destination = State()
    select_transport = State()
    confirm = State()


# FSM Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ¸ÑĞºĞ° Ğ¿Ğ¾ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğµ
class SearchByCulture(StatesGroup):
    waiting_culture = State()


# FSM Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°
class CreateLogisticCardStates(StatesGroup):
    routes = State()
    price_per_km = State()
    price_per_ton = State()
    min_volume = State()
    transport_type = State()
    ports = State()
    additional_info = State()


# FSM Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°
class CreateExpeditorCardStates(StatesGroup):
    services = State()
    dt_price = State()
    ports = State()
    experience = State()
    additional_info = State()


class ExpeditorCardStates(StatesGroup):
    """Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°"""

    vehicle_type = State()
    capacity = State()
    regions = State()
    price_per_km = State()
    description = State()


class AddBatch(StatesGroup):
    """Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ¼ Ñ Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ½Ñ‹Ğ¼Ğ¸ Ğ¿Ğ¾Ğ»ÑĞ¼Ğ¸"""

    culture = State()
    region = State()
    volume = State()
    price = State()
    humidity = State()
    impurity = State()
    quality_class = State()
    storage_type = State()
    readiness_date = State()


class EditBatch(StatesGroup):
    """Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""

    field = State()
    new_value = State()


class DeleteBatch(StatesGroup):
    """Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""

    confirmation = State()


class EditProfile(StatesGroup):
    """Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ"""

    field = State()
    new_value = State()


class CreatePullStatesGroup(StatesGroup):
    culture = State()  # Ğ’Ñ‹Ğ±Ğ¾Ñ€ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñ‹
    volume = State()  # ĞĞ±ÑŠĞµĞ¼
    price = State()  # Ğ¦ĞµĞ½Ğ°
    port = State()  # ĞŸĞ¾Ñ€Ñ‚
    moisture = State()  # Ğ’Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ
    nature = State()  # ĞĞ°Ñ‚ÑƒÑ€Ğ°
    impurity = State()  # Ğ¡Ğ¾Ñ€Ğ½Ğ°Ñ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑÑŒ
    weed = State()  # Ğ—ĞµÑ€Ğ½Ğ¾Ğ²Ğ°Ñ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑÑŒ
    documents = State()  # Ğ”Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ñ‹
    doctype = State()  # Ğ¢Ğ¸Ğ¿ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²


class JoinPullStatesGroup(StatesGroup):
    """ĞŸÑ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ° Ğº Ğ¿ÑƒĞ»Ñƒ"""

    select_pull = State()
    select_batch = State()
    enter_volume = State()
    confirm_join = State()
    volume = State()


class LogisticsOffer(StatesGroup):
    """ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°"""

    transport_type = State()
    route_from = State()
    route_to = State()
    price_per_ton = State()
    delivery_days = State()
    additional_info = State()


class LogisticOfferStates(StatesGroup):
    """Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°"""

    request_id = State()
    vehicle_type = State()
    price = State()
    delivery_date = State()
    confirm = State()


class ExpeditorOfferStates(StatesGroup):
    """Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°"""

    service_type = State()
    ports = State()
    price = State()
    terms = State()
    confirm = State()


class ExpeditorOffer(StatesGroup):
    """ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°"""

    services = State()
    price = State()
    terms_days = State()
    additional_info = State()


class Broadcast(StatesGroup):
    """Ğ Ğ°ÑÑÑ‹Ğ»ĞºĞ° Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ°"""

    message = State()
    confirm = State()


class AdminStates(StatesGroup):
    """Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½ Ğ¿Ğ°Ğ½ĞµĞ»Ğ¸"""

    waiting_broadcast_message = State()
    waiting_user_search = State()
    waiting_export_format = State()
    viewing_user_details = State()
    waiting_manual_match = State()


class AdminStats(StatesGroup):
    """Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ°"""

    period = State()


class ExportData(StatesGroup):
    """Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¾Ğ¼"""

    data_type = State()


class EditPullStatesGroup(StatesGroup):
    """Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ° ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ¼"""

    select_pull = State()
    select_field = State()
    edit_culture = State()
    edit_volume = State()
    edit_price = State()
    edit_port = State()
    edit_region = State()
    edit_moisture = State()
    edit_nature = State()
    edit_impurity = State()
    edit_weed = State()
    confirm_changes = State()


class QuickBatchStatesGroup(StatesGroup):
    """FSM Ğ´Ğ»Ñ Ğ±Ñ‹ÑÑ‚Ñ€Ğ¾Ğ³Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ¿Ñ€Ğ¸ Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğ¸ Ğº Ğ¿ÑƒĞ»Ğ»Ñƒ"""

    pull_id = State()  # ID Ğ¿ÑƒĞ»Ğ»Ğ°
    volume = State()
    price = State()
    quality = State()
    moisture = State()
    nature = State()
    impurity = State()
    documents = State()


class SearchBatchesStatesGroup(StatesGroup):
    """Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ğ´Ğ»Ñ Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ¸ÑĞºĞ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹"""

    culture = State()
    enter_culture = State()
    enter_max_price = State()
    enter_max_volume = State()
    enter_min_price = State()
    enter_min_volume = State()
    enter_quality_class = State()
    enter_region = State()
    enter_storage_type = State()
    region = State()


class ExpeditorEditStates(StatesGroup):
    """Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°"""

    price = State()
    capacity = State()
    regions = State()
    description = State()


class AttachFilesStatesGroup(StatesGroup):
    """ĞŸÑ€Ğ¸ĞºÑ€ĞµĞ¿Ğ»ĞµĞ½Ğ¸Ğµ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² Ğº Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""

    upload_files = State()
    confirm_upload = State()


class ShippingRequestStatesGroup(StatesGroup):
    """Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ"""

    pull_id = State()
    route_from = State()
    route_to = State()
    price_rub = State()
    volume = State()
    culture = State()
    desired_date = State()


# Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºĞ° - Ğ·Ğ°ÑĞ²ĞºĞ° ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°
class CreateLogisticRequestStatesGroup(StatesGroup):
    pull_choose = State()
    transport_type = State()
    culture = State()
    route_from = State()
    port = State()
    loading_date = State()
    desired_price = State()
    notes = State()


# Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºĞ° - Ğ¾Ñ‚ĞºĞ»Ğ¸Ğº Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°
class LogisticOfferStatesGroup(StatesGroup):
    """FSM Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°"""

    request_id = State()  # ID Ğ·Ğ°ÑĞ²ĞºĞ¸
    vehicle_type = State()  # Ğ¢Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°
    price = State()  # Ğ¦ĞµĞ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸
    delivery_date = State()  # Ğ”Ğ°Ñ‚Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸
    additional_info = State()  # Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ°Ñ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ
    confirm = State()  # ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ


class LogisticCardStates(StatesGroup):
    vehicle_type = State()
    capacity = State()
    regions = State()
    price_per_km = State()
    description = State()


# â† Ğ”ĞĞ‘ĞĞ’Ğ¬Ğ¢Ğ• Ğ­Ğ¢Ğ:
class EditCardStates(StatesGroup):
    vehicle_type = State()
    capacity = State()
    regions = State()
    price_per_km = State()
    description = State()


def validate_phone(phone):
    """Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ½Ğ¾Ğ¼ĞµÑ€Ğ° Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°"""
    cleaned = re.sub(r"[\s\-\(\)\+]", "", phone)
    return len(cleaned) >= 10 and cleaned.isdigit()


def validate_email(email):
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° email Ğ½Ğ° Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ½Ğ¾ÑÑ‚ÑŒ Ñ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¼ regex"""
    if not email or not isinstance(email, str):
        return False
    # ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½: Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ°Ñ Ñ‡Ğ°ÑÑ‚ÑŒ Ğ¿ĞµÑ€ĞµĞ´ @
    pattern = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}â‚½"
    return bool(re.match(pattern, email.strip()))


def validate_inn(inn):
    """Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ˜ĞĞ"""
    return inn.isdigit() and len(inn) in [10, 12]


def validate_volume(volume):
    """Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ±ÑŠĞµĞ¼Ğ°"""
    try:
        vol = float(volume)
        return vol > 0
    except ValueError:
        return False


def validate_price(price):
    """Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ñ†ĞµĞ½Ñ‹"""
    try:
        pr = float(price)
        return pr > 0
    except ValueError:
        return False


def validate_percentage(value):
    """Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ¿Ñ€Ğ¾Ñ†ĞµĞ½Ñ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ"""
    try:
        val = float(value)
        return 0 <= val <= 100
    except ValueError:
        return False


def farmer_keyboard():
    """ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ´Ğ»Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°"""
    keyboard = ReplyKeyboardMarkup(resize_keyboard=True)
    keyboard.add("â• Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ")
    keyboard.add("ğŸšš Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ·Ğ°ÑĞ²ĞºÑƒ Ğ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ")
    keyboard.add("ğŸ“¬ ĞœĞĞ˜ Ğ—ĞĞ¯Ğ’ĞšĞ˜")  # â† ĞŸĞ ĞĞ¡Ğ¢Ğ Ğ¢Ğ•ĞšĞ¡Ğ¢, ĞºĞ°Ğº Ğ¸ Ğ¾ÑÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ
    keyboard.row("ğŸ”§ ĞœĞ¾Ğ¸ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸", "ğŸ¯ ĞŸÑƒĞ»Ñ‹")
    keyboard.row("ğŸ” ĞŸĞ¾Ğ¸ÑĞº ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ²", "ğŸ“‹ ĞœĞ¾Ğ¸ ÑĞ´ĞµĞ»ĞºĞ¸")
    keyboard.row("ğŸšš ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²")
    keyboard.row("ğŸ‘¤ ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ")
    keyboard.add("ğŸ“ˆ Ğ¦ĞµĞ½Ñ‹ Ğ½Ğ° Ğ·ĞµÑ€Ğ½Ğ¾", "ğŸ“° ĞĞ¾Ğ²Ğ¾ÑÑ‚Ğ¸ Ñ€Ñ‹Ğ½ĞºĞ°")
    return keyboard


def exporter_keyboard():
    keyboard = ReplyKeyboardMarkup(resize_keyboard=True, row_width=2)
    keyboard.add(KeyboardButton("â• Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¿ÑƒĞ»"), KeyboardButton("ğŸ“‹ ĞœĞ¾Ğ¸ Ğ¿ÑƒĞ»Ñ‹"))
    keyboard.add(
        KeyboardButton("ğŸšš Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ"),  # â† ĞĞĞ’ĞĞ¯ ĞšĞĞĞŸĞšĞ
        KeyboardButton("ğŸ“‹ ĞœĞ¾Ğ¸ ÑĞ´ĞµĞ»ĞºĞ¸"),
    )
    keyboard.add(KeyboardButton("ğŸ” ĞĞ°Ğ¹Ñ‚Ğ¸ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"), KeyboardButton("ğŸ‘¤ ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ"))
    keyboard.add(KeyboardButton("ğŸ“ˆ Ğ¦ĞµĞ½Ñ‹ Ğ½Ğ° Ğ·ĞµÑ€Ğ½Ğ¾"), KeyboardButton("ğŸ“° ĞĞ¾Ğ²Ğ¾ÑÑ‚Ğ¸ Ñ€Ñ‹Ğ½ĞºĞ°"))
    return keyboard


def logistic_keyboard():
    """ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°"""
    keyboard = ReplyKeyboardMarkup(resize_keyboard=True, row_width=2)
    keyboard.add(
        KeyboardButton("ğŸšš ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸"), KeyboardButton("ğŸ’¼ ĞœĞ¾Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ")
    )
    keyboard.add(
        KeyboardButton("ğŸš› ĞœĞ¾Ğ¸ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸"), KeyboardButton("ğŸš› Ğ‘Ğ°Ğ·Ğ° ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²")
    )
    keyboard.add(KeyboardButton("ğŸ“ˆ Ğ¦ĞµĞ½Ñ‹ Ğ½Ğ° Ğ·ĞµÑ€Ğ½Ğ¾"), KeyboardButton("ğŸ“° ĞĞ¾Ğ²Ğ¾ÑÑ‚Ğ¸ Ñ€Ñ‹Ğ½ĞºĞ°"))
    keyboard.add(KeyboardButton("ğŸ‘¤ ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ"))
    return keyboard


def expeditor_keyboard():
    """ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°"""
    keyboard = ReplyKeyboardMarkup(resize_keyboard=True, row_width=2)
    keyboard.add(
        KeyboardButton("ğŸšš Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸"), KeyboardButton("ğŸš› ĞœĞ¾Ğ¸ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸")
    )
    keyboard.add(
        KeyboardButton("âœ”ï¸ Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº"), KeyboardButton("ğŸ’³ ĞœĞ¾Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ°")
    )
    keyboard.add(KeyboardButton("ğŸ“ˆ Ğ¦ĞµĞ½Ñ‹ Ğ½Ğ° Ğ·ĞµÑ€Ğ½Ğ¾"), KeyboardButton("ğŸ“° ĞĞ¾Ğ²Ğ¾ÑÑ‚Ğ¸ Ñ€Ñ‹Ğ½ĞºĞ°"))
    keyboard.add(KeyboardButton("ğŸ‘¤ ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ"))
    return keyboard


def vehicle_type_keyboard():
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("ğŸš› ĞĞ²Ñ‚Ğ¾Ğ¼Ğ¾Ğ±Ğ¸Ğ»ÑŒ", callback_data="vehicle:truck"),
        InlineKeyboardButton("ğŸš‚ Ğ–/Ğ´", callback_data="vehicle:train"),
    )
    keyboard.add(
        InlineKeyboardButton("ğŸš¢ Ğ¡ÑƒĞ´Ğ½Ğ¾", callback_data="vehicle:ship"),
        InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="cancel"),
    )
    return keyboard


def expeditor_service_keyboard():
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("ğŸ“„ Ğ”Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ñ‹", callback_data="service:docs"),
        InlineKeyboardButton("ğŸ¢ Ğ¢Ğ°Ğ¼Ğ¾Ğ¶Ğ½Ñ", callback_data="service:customs"),
    )
    keyboard.add(
        InlineKeyboardButton("ğŸš¢ Ğ¤Ñ€Ğ°Ñ…Ñ‚", callback_data="service:freight"),
        InlineKeyboardButton("ğŸ“¦ ĞŸĞ¾Ğ»Ğ½Ñ‹Ğ¹ ÑĞµÑ€Ğ²Ğ¸Ñ", callback_data="service:full"),
    )
    keyboard.add(InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="cancel"))
    return keyboard


@dp.callback_query_handler(
    lambda c: c.data.startswith("expeditor_view_deal:"), state="*"
)
async def expeditor_view_deal_details(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹ ÑĞ´ĞµĞ»ĞºĞ¸"""
    await state.finish()

    try:
        deal_id = parse_callback_id(callback.data)
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    # Ğ˜Ñ‰ĞµĞ¼ ÑĞ´ĞµĞ»ĞºÑƒ
    deal = None
    for exporter_deals in deals.values():
        for d in exporter_deals:
            if d["id"] == deal_id:
                deal = d
                break
        if deal:
            break

    if not deal:
        await callback.answer("âŒ Ğ¡Ğ´ĞµĞ»ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    msg = f"ğŸ“‹ <b>Ğ¡Ğ´ĞµĞ»ĞºĞ° #{deal_id}</b>\n\n"
    msg += f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {deal['culture']}\n"
    msg += f"ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: {deal['total_volume']} Ñ‚\n"
    msg += f"ğŸ’° Ğ¦ĞµĞ½Ğ°: {deal['price']:,.0f} â‚½/Ñ‚\n"
    msg += f"ğŸš¢ ĞŸĞ¾Ñ€Ñ‚: {deal['port']}\n"
    msg += f"ğŸ‘¥ Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²: {len(deal.get('participants', []))}\n\n"

    keyboard = InlineKeyboardMarkup(row_width=1)
    keyboard.add(
        InlineKeyboardButton(
            "âœ… Ğ’Ğ·ÑÑ‚ÑŒ Ğ² Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñƒ", callback_data=f"expeditor_take:{deal_id}"
        ),
        InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="expeditor_available_deals"),
    )

    await callback.message.edit_text(msg, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("expeditor_take:"), state="*")
async def expeditor_take_deal(callback: types.CallbackQuery, state: FSMContext):
    """Ğ’Ğ·ÑÑ‚ÑŒ ÑĞ´ĞµĞ»ĞºÑƒ Ğ² Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñƒ"""
    await state.finish()

    user_id = callback.from_user.id

    try:
        deal_id = parse_callback_id(callback.data)
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    # Ğ˜Ñ‰ĞµĞ¼ ÑĞ´ĞµĞ»ĞºÑƒ
    deal = None
    for exporter_deals in deals.values():
        for d in exporter_deals:
            if d["id"] == deal_id:
                deal = d
                break
        if deal:
            break

    if not deal:
        await callback.answer("âŒ Ğ¡Ğ´ĞµĞ»ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    if deal.get("expeditor_id"):
        await callback.answer(
            "âŒ Ğ¡Ğ´ĞµĞ»ĞºĞ° ÑƒĞ¶Ğµ Ğ²Ğ·ÑÑ‚Ğ° Ğ´Ñ€ÑƒĞ³Ğ¸Ğ¼ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ¼", show_alert=True
        )
        return

    # ĞĞ°Ğ·Ğ½Ğ°Ñ‡Ğ°ĞµĞ¼ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°
    deal["expeditor_id"] = user_id
    deal["expeditor_name"] = users[user_id].get("name", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")
    deal["status"] = "in_progress"

    save_deals_to_pickle()

    await callback.answer("âœ… Ğ¡Ğ´ĞµĞ»ĞºĞ° Ğ²Ğ·ÑÑ‚Ğ° Ğ² Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñƒ!", show_alert=True)

    await callback.message.edit_text(
        f"âœ… <b>Ğ¡Ğ´ĞµĞ»ĞºĞ° #{deal_id} Ğ²Ğ·ÑÑ‚Ğ° Ğ² Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñƒ!</b>\n\n"
        f"ğŸŒ¾ {deal['culture']} â€¢ {deal['total_volume']} Ñ‚\n"
        f"ğŸš¢ ĞŸĞ¾Ñ€Ñ‚: {deal['port']}\n\n"
        f"ĞŸĞµÑ€ĞµĞ¹Ğ´Ğ¸Ñ‚Ğµ Ğ² 'ğŸ“‹ ĞœĞ¾Ğ¸ ÑĞ´ĞµĞ»ĞºĞ¸' Ğ´Ğ»Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ñ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°Ğ¼Ğ¸.",
        parse_mode="HTML",
    )

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°
    try:
        await bot.send_message(
            deal["exporter_id"],
            f"âœ… <b>Ğ¡Ğ´ĞµĞ»ĞºĞ° #{deal_id} Ğ²Ğ·ÑÑ‚Ğ° Ğ² Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñƒ!</b>\n\n"
            f"ğŸ“‹ Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€: {users[user_id].get('name')}\n"
            f"ğŸ“± Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: {users[user_id].get('phone')}\n\n"
            f"Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€ Ğ½Ğ°Ñ‡Ğ½Ñ‘Ñ‚ Ğ¾Ñ„Ğ¾Ñ€Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ¾Ğ².",
            parse_mode="HTML",
        )
    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°: {e}")


def admin_keyboard():
    """ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ´Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ°"""
    keyboard = ReplyKeyboardMarkup(resize_keyboard=True, row_width=2)
    keyboard.add(KeyboardButton("ğŸ‘¥ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸"), KeyboardButton("ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°"))
    keyboard.add(KeyboardButton("ğŸ“¢ Ğ Ğ°ÑÑÑ‹Ğ»ĞºĞ°"), KeyboardButton("ğŸ“¥ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…"))
    keyboard.add(KeyboardButton("ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ñ†ĞµĞ½Ñ‹"), KeyboardButton("ğŸ“ˆ ĞĞ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ°"))
    keyboard.add(KeyboardButton("ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ"))
    return keyboard


def adminkeyboard():
    """ĞĞ»Ğ¸Ğ°Ñ Ğ´Ğ»Ñ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸"""
    return admin_keyboard()


def format_admin_statistics():
    """Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸ Ğ´Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ°"""
    total_users = len(users)
    farmers_count = len([u for u in users.values() if u.get("role") == "farmer"])
    exporters_count = len([u for u in users.values() if u.get("role") == "exporter"])
    logistics_count = len([u for u in users.values() if u.get("role") == "logistic"])
    expeditors_count = len([u for u in users.values() if u.get("role") == "expeditor"])

    total_pulls = len(pulls)
    active_pulls = len([p for p in pulls.values() if p.get("status") == "active"])

    total_batches = sum(len(batches) for user_batches in batches.values())

    total_requests = len(shipping_requests)
    active_requests = len(
        [r for r in shipping_requests.values() if r.get("status") == "active"]
    )

    msg = "ğŸ“Š <b>Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ±Ğ¾Ñ‚Ğ°</b>\n\n"
    msg += "ğŸ‘¥ <b>ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸:</b>\n"
    msg += f"  â€¢ Ğ’ÑĞµĞ³Ğ¾: {total_users}\n"
    msg += f"  â€¢ Ğ¤ĞµÑ€Ğ¼ĞµÑ€Ñ‹: {farmers_count}\n"
    msg += f"  â€¢ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ñ‹: {exporters_count}\n"
    msg += f"  â€¢ Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚Ñ‹: {logistics_count}\n"
    msg += f"  â€¢ Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ñ‹: {expeditors_count}\n\n"

    msg += "ğŸ¯ <b>ĞŸÑƒĞ»Ñ‹:</b>\n"
    msg += f"  â€¢ Ğ’ÑĞµĞ³Ğ¾: {total_pulls}\n"
    msg += f"  â€¢ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ: {active_pulls}\n\n"

    msg += "ğŸ“¦ <b>ĞŸĞ°Ñ€Ñ‚Ğ¸Ğ¸:</b>\n"
    msg += f"  â€¢ Ğ’ÑĞµĞ³Ğ¾: {total_batches}\n\n"

    msg += "ğŸšš <b>Ğ—Ğ°ÑĞ²ĞºĞ¸ Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ:</b>\n"
    msg += f"  â€¢ Ğ’ÑĞµĞ³Ğ¾: {total_requests}\n"
    msg += f"  â€¢ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ: {active_requests}\n"

    return msg


@dp.message_handler(commands=["reset"], state="*")
async def reset_account(message: types.Message, state: FSMContext):
    """Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ ÑĞ²Ğ¾Ğ¹ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€Ğ½Ğ¾Ğ¹ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸"""
    user_id = message.from_user.id

    # ĞÑ‡Ğ¸Ñ‰Ğ°ĞµĞ¼ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ FSM
    await state.finish()

    # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ ĞºĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ñƒ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton(
            "âœ… Ğ”Ğ°, ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ", callback_data=f"confirm_reset:{user_id}"
        ),
        InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="cancel_reset"),
    )

    await message.answer(
        "âš ï¸ *Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°*\n\n"
        "Ğ’Ñ‹ ÑƒĞ²ĞµÑ€ĞµĞ½Ñ‹ Ñ‡Ñ‚Ğ¾ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ ÑĞ²Ğ¾Ğ¹ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚?\n\n"
        "Ğ­Ñ‚Ğ¾ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚:\n"
        "â€¢ Ğ’Ğ°Ñˆ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ\n"
        "â€¢ Ğ’ÑĞµ Ğ²Ğ°ÑˆĞ¸ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ (Ğ´Ğ»Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°)\n"
        "â€¢ Ğ’ÑĞµ Ğ²Ğ°ÑˆĞ¸ Ğ¿ÑƒĞ»Ñ‹ (Ğ´Ğ»Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°)\n"
        "â€¢ Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¸Ğ· Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸ Ğ¸ Google Sheets\n\n"
        "âš ï¸ *Ğ­Ñ‚Ğ¾ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ½ĞµĞ¾Ğ±Ñ€Ğ°Ñ‚Ğ¸Ğ¼Ğ¾!*",
        reply_markup=keyboard,
        parse_mode="Markdown",
    )


@dp.callback_query_handler(lambda c: c.data.startswith("confirm_reset:"), state="*")
async def confirm_reset_account(callback: CallbackQuery, state: FSMContext):
    """ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ñ ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸ĞµĞ¹ ÑÑÑ‹Ğ»Ğ¾Ğº Ğ½Ğ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ² Ğ¿ÑƒĞ»Ğµ, Ğ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸ĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…."""

    user_id = parse_callback_id(callback.data)

    if callback.from_user.id != user_id:
        await callback.answer("âŒ Ğ­Ñ‚Ğ¾ Ğ½Ğµ Ğ²Ğ°Ñˆ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚", show_alert=True)
        return

    deleted_items = []

    # 1. Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¸Ğ· Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸
    if user_id in users:
        role = users[user_id].get("role", "user")
        del users[user_id]
        deleted_items.append(f"Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ ({role})")
        logging.info(f"âœ… Ğ£Ğ´Ğ°Ğ»Ñ‘Ğ½ user {user_id} Ğ¸Ğ· Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸")

    # 2. Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¸ ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿ÑƒĞ»Ñ‹
    user_batches = batches.pop(user_id, [])
    batch_ids_to_delete = [b["id"] for b in user_batches if "id" in b]
    batch_count = len(user_batches)
    if batch_count > 0:
        deleted_items.append(f"{batch_count} Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹")
        logging.info(f"âœ… Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¾ {batch_count} Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ° {user_id}")

        # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ ÑÑÑ‹Ğ»ĞºĞ¸ Ğ½Ğ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ ÑĞ·ĞµÑ€Ğ° Ğ¸Ğ· Ğ¿ÑƒĞ»Ğ¾Ğ²
        if "pulls" in pulls:
            for pull in pulls["pulls"].values():
                # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ¸Ğ· ÑĞ¿Ğ¸ÑĞºĞ¾Ğ² Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
                pull["batch_ids"] = [
                    bid
                    for bid in pull.get("batch_ids", [])
                    if bid not in batch_ids_to_delete
                ]
                pull["batches"] = [
                    bid
                    for bid in pull.get("batches", [])
                    if bid not in batch_ids_to_delete
                ]
                pull["farmer_ids"] = [
                    fid for fid in pull.get("farmer_ids", []) if fid != user_id
                ]
                # ĞŸĞµÑ€ĞµÑÑ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğ¹ Ğ¾Ğ±ÑŠĞµĞ¼ Ğ¿Ğ¾ÑĞ»Ğµ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹
                pull["current_volume"] = (
                    sum(
                        b["volume"]
                        for b in pull.get("batches_data", [])
                        if b.get("id") not in batch_ids_to_delete
                    )
                    if pull.get("batches_data")
                    else 0
                )
                # Ğ•ÑĞ»Ğ¸ Ğ¾Ğ±ÑŠĞµĞ¼ < Ñ†ĞµĞ»ĞµĞ²Ğ¾Ğ³Ğ¾, Ğ¿ÑƒĞ» ÑĞ½Ğ¾Ğ²Ğ° Ğ°ĞºÑ‚Ğ¸Ğ²ĞµĞ½
                if pull["current_volume"] < pull.get("target_volume", 0):
                    pull["status"] = "active"

            # ĞŸĞ¾ÑĞ»Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹ Ğ¡Ğ ĞĞ—Ğ£ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ°ĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ğ¾Ğµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ¾Ğ²
            save_pulls_to_pickle(pulls)
            logging.info(
                "âœ… Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ñ‹ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ Ğ¿ÑƒĞ»Ğ¾Ğ² Ğ¿Ğ¾ÑĞ»Ğµ ĞºĞ°ÑĞºĞ°Ğ´Ğ½Ğ¾Ğ³Ğ¾ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹"
            )

    # 3. Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¸ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ¸Ğ· Google Sheets
    try:
        worksheet = spreadsheet.worksheet("Users")
        cell = worksheet.find(str(user_id))
        if cell:
            worksheet.delete_rows(cell.row)
            deleted_items.append("Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ Ğ² Google Sheets (Users)")
            logging.info(f"âœ… Ğ£Ğ´Ğ°Ğ»Ñ‘Ğ½ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚ {user_id} Ğ¸Ğ· Google Sheets (Users)")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ Ğ¸Ğ· Google Sheets (Users): {e}")

    try:
        worksheet = spreadsheet.worksheet("Batches")
        all_values = worksheet.get_all_values()
        rows_to_delete = []
        for i, row in enumerate(all_values[1:], start=2):
            if row and len(row) > 1 and str(row[1]) == str(user_id):
                rows_to_delete.append(i)
        for row_num in reversed(rows_to_delete):
            worksheet.delete_rows(row_num)
        if rows_to_delete:
            deleted_items.append(f"{len(rows_to_delete)} Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ¸Ğ· Google Sheets")
            logging.info(f"âœ… Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¾ {len(rows_to_delete)} Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ¸Ğ· Google Sheets")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ¸Ğ· Google Sheets: {e}")

    try:
        worksheet = spreadsheet.worksheet("Pulls")
        all_values = worksheet.get_all_values()
        rows_to_delete = []
        for i, row in enumerate(all_values[1:], start=2):
            if row and len(row) > 1 and str(row[1]) == str(user_id):
                rows_to_delete.append(i)
        for row_num in reversed(rows_to_delete):
            worksheet.delete_rows(row_num)
        if rows_to_delete:
            deleted_items.append(f"{len(rows_to_delete)} Ğ¿ÑƒĞ»Ğ»Ğ¾Ğ² Ğ¸Ğ· Google Sheets")
            logging.info(f"âœ… Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¾ {len(rows_to_delete)} Ğ¿ÑƒĞ»Ğ»Ğ¾Ğ² Ğ¸Ğ· Google Sheets")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ Ğ¿ÑƒĞ»Ğ»Ğ¾Ğ² Ğ¸Ğ· Google Sheets: {e}")

    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¾ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ°Ñ…
    if deleted_items:
        items_text = "\n".join([f"â€¢ {item}" for item in deleted_items])
        result_msg = (
            f"âœ… *ĞĞºĞºĞ°ÑƒĞ½Ñ‚ ÑƒĞ´Ğ°Ğ»Ñ‘Ğ½!*\n\n"
            f"Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¾:\n{items_text}\n\n"
            f"Ğ’Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒÑÑ Ğ·Ğ°Ğ½Ğ¾Ğ²Ğ¾ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ¾Ğ¹ /start"
        )
    else:
        result_msg = "âš ï¸ ĞĞºĞºĞ°ÑƒĞ½Ñ‚ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ Ğ¸Ğ»Ğ¸ ÑƒĞ¶Ğµ ÑƒĞ´Ğ°Ğ»Ñ‘Ğ½"

    await callback.message.edit_text(result_msg, parse_mode="Markdown")
    await callback.answer("âœ… ĞĞºĞºĞ°ÑƒĞ½Ñ‚ ÑƒĞ´Ğ°Ğ»Ñ‘Ğ½")


@dp.callback_query_handler(lambda c: c.data == "cancel_reset", state="*")
async def cancel_reset_account(callback: CallbackQuery):
    """ĞÑ‚Ğ¼ĞµĞ½Ğ° ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°"""
    await callback.message.edit_text("âŒ Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾")
    await callback.answer("ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾")


def format_admin_analytics():
    """Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ°Ğ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ¸ Ğ´Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ°"""
    regions_count = {}
    for user in users.values():
        region = user.get("region", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        regions_count[region] = regions_count.get(region, 0) + 1

    top_regions = sorted(regions_count.items(), key=lambda x: x[1], reverse=True)[:5]

    cultures_count = {}
    for user_batches in batches.values():
        for batch in user_batches:
            culture = batch.get("culture", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°")
            cultures_count[culture] = cultures_count.get(culture, 0) + 1

    top_cultures = sorted(cultures_count.items(), key=lambda x: x[1], reverse=True)[:5]

    pool_stats = {"forming": 0, "active": 0, "completed": 0, "cancelled": 0}
    for pull in pulls.values():
        status = pull.get("status", "unknown")
        if status in pool_stats:
            pool_stats[status] += 1

    msg = "ğŸ“ˆ <b>ĞĞ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ° Ğ±Ğ¾Ñ‚Ğ°</b>\n\n"

    if top_regions:
        msg += "ğŸ—º <b>Ğ¢Ğ¾Ğ¿-5 Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ¾Ğ²:</b>\n"
        for idx, (region, count) in enumerate(top_regions, 1):
            msg += f"  {idx}. {region}: {count} Ğ¿Ğ¾Ğ»ÑŒĞ·.\n"

    if top_cultures:
        msg += "\nğŸŒ¾ <b>Ğ¢Ğ¾Ğ¿-5 ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€:</b>\n"
        for idx, (culture, count) in enumerate(top_cultures, 1):
            msg += f"  {idx}. {culture}: {count} Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹\n"

    msg += "\nğŸ¯ <b>Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑÑ‹ Ğ¿ÑƒĞ»Ğ¾Ğ²:</b>\n"
    msg += f"  â€¢ Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµÑ‚ÑÑ: {pool_stats['forming']}\n"
    msg += f"  â€¢ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ: {pool_stats['active']}\n"
    msg += f"  â€¢ Ğ—Ğ°Ğ²ĞµÑ€ÑˆÑ‘Ğ½Ğ½Ñ‹Ğµ: {pool_stats['completed']}\n"
    msg += f"  â€¢ ĞÑ‚Ğ¼ĞµĞ½Ñ‘Ğ½Ğ½Ñ‹Ğµ: {pool_stats['cancelled']}\n"

    return msg


def format_admin_users():
    """Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ÑĞ¿Ğ¸ÑĞºĞ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ´Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ°"""
    farmers = [u for u in users.values() if u.get("role") == "farmer"]
    exporters = [u for u in users.values() if u.get("role") == "exporter"]
    logistics = [u for u in users.values() if u.get("role") == "logistic"]
    expeditors = [u for u in users.values() if u.get("role") == "expeditor"]

    msg = "ğŸ‘¥ <b>ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹</b>\n\n"
    msg += f"Ğ’ÑĞµĞ³Ğ¾: {len(users)}\n\n"

    if farmers:
        msg += f"<b>ğŸŒ¾ Ğ¤ĞµÑ€Ğ¼ĞµÑ€Ñ‹ ({len(farmers)})</b>\n"
        for u in farmers[:5]:
            name = u.get("name", "Ğ‘ĞµĞ· Ğ¸Ğ¼ĞµĞ½Ğ¸")
            phone = u.get("phone", "ĞĞµÑ‚ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°")
            region = u.get("region", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
            msg += f"  â€¢ {name}\n    ğŸ“± {phone}\n    ğŸ“ {region}\n"
        if len(farmers) > 5:
            msg += f"  ... Ğ¸ ĞµÑ‰Ñ‘ {len(farmers) - 5}\n"
        msg += "\n"

    if exporters:
        msg += f"<b>ğŸš¢ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ñ‹ ({len(exporters)})</b>\n"
        for u in exporters[:5]:
            name = u.get("name", "Ğ‘ĞµĞ· Ğ¸Ğ¼ĞµĞ½Ğ¸")
            phone = u.get("phone", "ĞĞµÑ‚ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°")
            msg += f"  â€¢ {name}\n    ğŸ“± {phone}\n"
        if len(exporters) > 5:
            msg += f"  ... Ğ¸ ĞµÑ‰Ñ‘ {len(exporters) - 5}\n"
        msg += "\n"

    if logistics:
        msg += f"<b>ğŸšš Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚Ñ‹ ({len(logistics)})</b>\n"
        for u in logistics[:5]:
            name = u.get("name", "Ğ‘ĞµĞ· Ğ¸Ğ¼ĞµĞ½Ğ¸")
            phone = u.get("phone", "ĞĞµÑ‚ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°")
            msg += f"  â€¢ {name}\n    ğŸ“± {phone}\n"
        if len(logistics) > 5:
            msg += f"  ... Ğ¸ ĞµÑ‰Ñ‘ {len(logistics) - 5}\n"
        msg += "\n"

    if expeditors:
        msg += f"<b>ğŸ“‹ Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ñ‹ ({len(expeditors)})</b>\n"
        for u in expeditors[:3]:
            name = u.get("name", "Ğ‘ĞµĞ· Ğ¸Ğ¼ĞµĞ½Ğ¸")
            phone = u.get("phone", "ĞĞµÑ‚ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°")
            msg += f"  â€¢ {name}\n    ğŸ“± {phone}\n"
        if len(expeditors) > 3:
            msg += f"  ... Ğ¸ ĞµÑ‰Ñ‘ {len(expeditors) - 3}\n"

    return msg


def join_pull_keyboard(pull_id):
    """ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ Ğº Ğ¿ÑƒĞ»Ñƒ"""
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton(
            "âœ… ĞŸÑ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½Ğ¸Ñ‚ÑŒÑÑ", callback_data=f"confirm_join_pull:{pull_id}"
        ),
        InlineKeyboardButton(
            "ğŸ“‹ Ğ’Ñ‹Ğ±Ñ€Ğ°Ñ‚ÑŒ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ", callback_data=f"select_batch_for_pull:{pull_id}"
        ),
        InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_pools_list"),
    )
    return keyboard


def get_pull_details_keyboard(pull_id, user_id, pull):
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ĞºĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ñ‹ Ğ´Ğ»Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ğ¿ÑƒĞ»Ğ°"""
    keyboard = InlineKeyboardMarkup(row_width=2)

    if user_id == pull.get("exporter_id"):
        keyboard.add(
            InlineKeyboardButton(
                "ğŸ‘¥ Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¸", callback_data=f"viewparticipants:{pull_id}"
            ),
            InlineKeyboardButton(
                "âœï¸ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ", callback_data=f"editpull_{pull_id}"
            ),
        )
        keyboard.add(
            InlineKeyboardButton(
                "âœ… Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ¿ÑƒĞ»", callback_data=f"closepull_{pull_id}"
            ),
            InlineKeyboardButton("âŒ Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ", callback_data=f"deletepull_{pull_id}"),
        )

    elif user_id in users and users[user_id].get("role") == "farmer":
        keyboard.add(
            InlineKeyboardButton(
                "âœ… ĞŸÑ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½Ğ¸Ñ‚ÑŒÑÑ", callback_data=f"join_pull:{pull_id}"
            )
        )
        keyboard.add(
            InlineKeyboardButton(
                "ğŸ‘¥ Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¸", callback_data=f"viewparticipants:{pull_id}"
            )
        )

    else:
        keyboard.add(
            InlineKeyboardButton(
                "ğŸ‘¥ Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¸", callback_data=f"viewparticipants:{pull_id}"
            )
        )

    keyboard.add(InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_pools"))

    return keyboard


def logistics_offer_keyboard():
    """ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ´Ğ»Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… ÑƒÑĞ»ÑƒĞ³"""
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("ğŸš› Ğ¤ÑƒÑ€Ğ°", callback_data="transport_type:truck"),
        InlineKeyboardButton("ğŸš‚ Ğ–/Ğ”", callback_data="transport_type:train"),
        InlineKeyboardButton("ğŸš¢ Ğ¡ÑƒĞ´Ğ½Ğ¾", callback_data="transport_type:ship"),
    )
    return keyboard


def admin_broadcast_keyboard():
    """ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸"""
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("âœ… ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ", callback_data="broadcast_confirm"),
        InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ", callback_data="broadcast_cancel"),
    )
    return keyboard


def culture_keyboard():
    keyboard = InlineKeyboardMarkup(row_width=2)
    crops = ["ĞŸÑˆĞµĞ½Ğ¸Ñ†Ğ°", "Ğ¯Ñ‡Ğ¼ĞµĞ½ÑŒ", "ĞšÑƒĞºÑƒÑ€ÑƒĞ·Ğ°", "ĞŸĞ¾Ğ´ÑĞ¾Ğ»Ğ½ĞµÑ‡Ğ½Ğ¸Ğº", "Ğ Ğ°Ğ¿Ñ", "Ğ¡Ğ¾Ñ"]
    buttons = [
        InlineKeyboardButton(crop, callback_data=f"culture:{crop}") for crop in crops
    ]
    keyboard.add(*buttons)
    return keyboard


def region_keyboard():
    """ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ°"""
    keyboard = InlineKeyboardMarkup(row_width=2)
    regions = [
        "ĞÑÑ‚Ñ€Ğ°Ñ…Ğ°Ğ½ÑĞºĞ°Ñ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ",
        "ĞšÑ€Ğ°ÑĞ½Ğ¾Ğ´Ğ°Ñ€ÑĞºĞ¸Ğ¹ ĞºÑ€Ğ°Ğ¹",
        "Ğ¡Ñ‚Ğ°Ğ²Ñ€Ğ¾Ğ¿Ğ¾Ğ»ÑŒÑĞºĞ¸Ğ¹ ĞºÑ€Ğ°Ğ¹",
        "Ğ Ğ¾ÑÑ‚Ğ¾Ğ²ÑĞºĞ°Ñ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ",
        "Ğ’Ğ¾Ğ»Ğ³Ğ¾Ğ³Ñ€Ğ°Ğ´ÑĞºĞ°Ñ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ",
        "Ğ’Ğ¾Ñ€Ğ¾Ğ½ĞµĞ¶ÑĞºĞ°Ñ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ",
        "ĞšÑƒÑ€ÑĞºĞ°Ñ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ",
        "Ğ‘ĞµĞ»Ğ³Ğ¾Ñ€Ğ¾Ğ´ÑĞºĞ°Ñ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ",
        "Ğ¡Ğ°Ñ€Ğ°Ñ‚Ğ¾Ğ²ÑĞºĞ°Ñ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ",
        "ĞÑ€ĞµĞ½Ğ±ÑƒÑ€Ğ³ÑĞºĞ°Ñ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ",
        "ĞĞ»Ñ‚Ğ°Ğ¹ÑĞºĞ¸Ğ¹ ĞºÑ€Ğ°Ğ¹",
        "ĞĞ¼ÑĞºĞ°Ñ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ",
        "ĞĞ¾Ğ²Ğ¾ÑĞ¸Ğ±Ğ¸Ñ€ÑĞºĞ°Ñ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ",
    ]
    for region in regions:
        keyboard.add(InlineKeyboardButton(region, callback_data=f"region:{region}"))
    return keyboard


def port_keyboard():
    keyboard = InlineKeyboardMarkup(row_width=2)
    ports = [
        "ĞÑ€Ğ¸Ğ±",
        "ĞŸĞšĞ¤ Â«Ğ’Ğ¾Ğ»Ğ³Ğ°-ĞŸĞ¾Ñ€Ñ‚Â»",
        "ĞŸĞšĞ¤ Â«Ğ®Ğ³-Ğ¢ĞµÑ€Â»",
        "ĞŸĞĞ Â«ĞÑÑ‚Ñ€.ĞŸĞ¾Ñ€Ñ‚Â»",
        "Ğ£Ğ½Ğ¸Ğ²ĞµÑ€.ĞŸĞ¾Ñ€Ñ‚",
        "Ğ®Ğ¶.ĞŸĞ¾Ñ€Ñ‚",
        "ĞĞ³Ñ€Ğ¾Ñ„ÑƒĞ´",
        "ĞœĞ¾ÑĞ¿Ğ¾Ñ€Ñ‚",
        "Ğ¦Ğ“ĞŸ",
        "Ğ¤Ğ—Ğ¢",
        "ĞĞœĞŸ",
        "ĞÑ€Ğ¼Ğ°Ğ´Ğ°",
        "Ğ¡Ñ‚Ñ€ĞµĞ»ĞµÑ†",
        "ĞĞ»ÑŒÑ„Ğ°",
    ]

    buttons = [
        InlineKeyboardButton(port, callback_data=f"selectport_{port}") for port in ports
    ]
    keyboard.add(*buttons)
    return keyboard


def quality_class_keyboard():
    """ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° ĞºĞ»Ğ°ÑÑĞ° ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ°"""
    keyboard = InlineKeyboardMarkup(row_width=2)
    for quality_class in QUALITY_CLASSES:
        keyboard.add(
            InlineKeyboardButton(
                quality_class, callback_data=f"quality:{quality_class}"
            )
        )
    return keyboard


def storage_type_keyboard():
    """ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ñ‚Ğ¸Ğ¿Ğ° Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ"""
    keyboard = InlineKeyboardMarkup(row_width=2)
    for storage_type in STORAGE_TYPES:
        keyboard.add(
            InlineKeyboardButton(storage_type, callback_data=f"storage:{storage_type}")
        )
    return keyboard


def confirm_keyboard(action="confirm"):
    """ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ"""
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("âœ… Ğ”Ğ°", callback_data=f"confirm:{action}"),
        InlineKeyboardButton("âŒ ĞĞµÑ‚", callback_data=f"cancel:{action}"),
    )
    return keyboard


def batch_actions_keyboard(batch_id: int) -> InlineKeyboardMarkup:
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("âœï¸ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ", callback_data=f"edit_batch:{batch_id}"),
        InlineKeyboardButton("ğŸ—‘ Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ", callback_data=f"delete_batch:{batch_id}"),
    )
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ“ ĞŸÑ€Ğ¸ĞºÑ€ĞµĞ¿Ğ¸Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ»Ñ‹", callback_data=f"attach_files:{batch_id}"
        )
    )
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ“„ ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²", callback_data=f"view_files:{batch_id}"
        )
    )
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ” ĞĞ°Ğ¹Ñ‚Ğ¸ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ²", callback_data=f"find_exporters:{batch_id}"
        )
    )
    keyboard.add(InlineKeyboardButton("ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_my_batches"))
    return keyboard


def edit_batch_fields_keyboard(batch_id: int) -> InlineKeyboardMarkup:
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton(
            "ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°", callback_data=f"editfield_crop_{batch_id}"
        )  # â† Ğ”ĞĞ‘ĞĞ’Ğ¬ Ğ­Ğ¢Ğ
    )
    keyboard.add(
        InlineKeyboardButton("ğŸ’° Ğ¦ĞµĞ½Ğ°", callback_data="edit_field:price"),
        InlineKeyboardButton("ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼", callback_data="edit_field:volume"),
    )
    keyboard.add(
        InlineKeyboardButton("ğŸ’§ Ğ’Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ", callback_data="edit_field:humidity"),
        InlineKeyboardButton("ğŸŒ¾ Ğ¡Ğ¾Ñ€Ğ½Ğ¾ÑÑ‚ÑŒ", callback_data="edit_field:impurity"),
    )
    keyboard.add(
        InlineKeyboardButton(
            "â­ ĞšĞ»Ğ°ÑÑ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ°", callback_data="edit_field:quality_class"
        ),
        InlineKeyboardButton(
            "ğŸ­ Ğ¢Ğ¸Ğ¿ Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ", callback_data="edit_field:storage_type"
        ),
    )
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ“… Ğ”Ğ°Ñ‚Ğ° Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸", callback_data="edit_field:readiness_date"
        ),
        InlineKeyboardButton("ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ", callback_data="edit_field:status"),
    )
    keyboard.add(InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="edit_cancel"))
    return keyboard


def status_keyboard():
    """ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° ÑÑ‚Ğ°Ñ‚ÑƒÑĞ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""
    keyboard = InlineKeyboardMarkup(row_width=2)
    statuses = ["ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ°", "Ğ—Ğ°Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ°", "ĞŸÑ€Ğ¾Ğ´Ğ°Ğ½Ğ°", "Ğ¡Ğ½ÑÑ‚Ğ° Ñ Ğ¿Ñ€Ğ¾Ğ´Ğ°Ğ¶Ğ¸"]
    for status in statuses:
        keyboard.add(InlineKeyboardButton(status, callback_data=f"status:{status}"))
    return keyboard


def profile_edit_keyboard():
    """ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ"""
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("ğŸ“± Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½", callback_data="edit_profile:phone"),
        InlineKeyboardButton("ğŸ“§ Email", callback_data="edit_profile:email"),
    )
    keyboard.add(
        InlineKeyboardButton("ğŸ“ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½", callback_data="edit_profile:region"),
        InlineKeyboardButton(
            "ğŸ¢ Ğ ĞµĞºĞ²Ğ¸Ğ·Ğ¸Ñ‚Ñ‹", callback_data="edit_profile:company_details"
        ),
    )
    keyboard.add(InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="edit_cancel"))
    return keyboard


def search_criteria_keyboard():
    """ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° ĞºÑ€Ğ¸Ñ‚ĞµÑ€Ğ¸ĞµĞ² Ğ¿Ğ¾Ğ¸ÑĞºĞ°"""
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("ğŸŒ¾ ĞŸĞ¾ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğµ", callback_data="search_by:culture"),
        InlineKeyboardButton("ğŸ“ ĞŸĞ¾ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñƒ", callback_data="search_by:region"),
    )
    keyboard.add(
        InlineKeyboardButton(
            "ğŸŒ¾ Ğ’ÑĞµ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸", callback_data="search_by:available"
        )
    )
    keyboard.add(InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_main"))
    return keyboard


@dp.callback_query_handler(lambda c: c.data == "back_to_main", state="*")
async def back_to_main_handler(callback: types.CallbackQuery, state: FSMContext):
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğ² Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ Ğ¸Ğ· Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ¸ÑĞºĞ°"""
    await state.finish()

    user_id = callback.from_user.id

    if user_id not in users:
        await callback.message.answer(
            "âŒ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ /start Ğ´Ğ»Ñ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸"
        )
        await callback.answer()
        return

    user = users[user_id]
    role = user.get("role", "unknown")
    name = user.get("name", "ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ")

    # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ inline ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ
    try:
        await callback.message.delete()
    except Exception as e:
        print(f"ĞÑˆĞ¸Ğ±ĞºĞ°: {e}")
        pass

    # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ½Ğ¾Ğ²Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ñ ReplyKeyboard Ğ´Ğ»Ñ Ñ€Ğ¾Ğ»Ğ¸
    if role == "farmer":
        keyboard = farmer_keyboard()
        welcome_text = f"ğŸ‘‹ Ğ¡ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰ĞµĞ½Ğ¸ĞµĞ¼, {name}!\n\nğŸŒ¾ <b>ĞœĞµĞ½Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°</b>"
    elif role == "exporter":
        keyboard = exporter_keyboard()
        welcome_text = f"ğŸ‘‹ Ğ¡ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰ĞµĞ½Ğ¸ĞµĞ¼, {name}!\n\nğŸ“¦ <b>ĞœĞµĞ½Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°</b>"
    elif role == "logistic":
        keyboard = logistic_keyboard()
        welcome_text = f"ğŸ‘‹ Ğ¡ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰ĞµĞ½Ğ¸ĞµĞ¼, {name}!\n\nğŸšš <b>ĞœĞµĞ½Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°</b>"
    elif role == "expeditor":
        keyboard = expeditor_keyboard()
        welcome_text = f"ğŸ‘‹ Ğ¡ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰ĞµĞ½Ğ¸ĞµĞ¼, {name}!\n\nğŸ­ <b>ĞœĞµĞ½Ñ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°</b>"
    else:
        keyboard = ReplyKeyboardMarkup(resize_keyboard=True)
        keyboard.add(KeyboardButton("ğŸ“‹ ĞœĞµĞ½Ñ"))
        welcome_text = f"ğŸ‘‹ Ğ¡ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰ĞµĞ½Ğ¸ĞµĞ¼, {name}!"

    await callback.message.answer(
        welcome_text, reply_markup=keyboard, parse_mode="HTML"
    )

    await callback.answer()


def deal_actions_keyboard(deal_id):
    """ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğ¹ ÑĞ¾ ÑĞ´ĞµĞ»ĞºĞ¾Ğ¹"""
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ“ ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹ Ğ¿Ğ°Ñ€Ñ‚Ğ½Ñ‘Ñ€Ğ°", callback_data=f"contact_partner:{deal_id}"
        ),
        InlineKeyboardButton("ğŸšš Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºĞ°", callback_data=f"logistics:{deal_id}"),
    )
    keyboard.add(
        InlineKeyboardButton(
            "âœ… Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚ÑŒ ÑĞ´ĞµĞ»ĞºÑƒ", callback_data=f"complete_deal:{deal_id}"
        ),
        InlineKeyboardButton(
            "âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ÑĞ´ĞµĞ»ĞºÑƒ", callback_data=f"cancel_deal:{deal_id}"
        ),
    )
    keyboard.add(
        InlineKeyboardButton("ğŸ”™ Ğš ÑĞ¿Ğ¸ÑĞºÑƒ ÑĞ´ĞµĞ»Ğ¾Ğº", callback_data="back_to_deals")
    )
    return keyboard


def format_news_message():
    """Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ñ Ğ½Ğ¾Ğ²Ğ¾ÑÑ‚ÑĞ¼Ğ¸"""
    if not news_cache or not news_cache.get("data"):
        return (
            "ğŸ“° <b>ĞĞ¾Ğ²Ğ¾ÑÑ‚Ğ¸ Ñ€Ñ‹Ğ½ĞºĞ°</b>\n\n"
            "âš ï¸ ĞĞ¾Ğ²Ğ¾ÑÑ‚Ğ¸ ĞµÑ‰Ñ‘ Ğ½Ğµ Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ñ‹.\n"
            "ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ·Ğ¶Ğµ Ğ¸Ğ»Ğ¸ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ /start Ğ´Ğ»Ñ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ."
        )

    news_list = news_cache["data"]
    updated_time = (
        news_cache["updated"].strftime("%d.%m.%Y %H:%M")
        if news_cache.get("updated")
        else "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾"
    )

    if not news_list:
        return (
            "ğŸ“° <b>ĞĞ¾Ğ²Ğ¾ÑÑ‚Ğ¸ Ñ€Ñ‹Ğ½ĞºĞ°</b>\n\n"
            "ğŸ¤·â€â™‚ï¸ ĞĞ¾Ğ²Ğ¾ÑÑ‚ĞµĞ¹ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾.\n"
            "ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ·Ğ¶Ğµ."
        )

    message = "ğŸ“° <b>ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ Ğ½Ğ¾Ğ²Ğ¾ÑÑ‚Ğ¸ Ñ€Ñ‹Ğ½ĞºĞ°</b>\n\n"

    for i, news_item in enumerate(news_list[:5], 1):
        title = news_item.get("title", "Ğ‘ĞµĞ· Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ñ")
        link = news_item.get("link", "")
        date = news_item.get("date", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")

        if link:
            message += f"{i}. <a href='{link}'>{title}</a>\n"
        else:
            message += f"{i}. {title}\n"

        message += f"   ğŸ“… <i>{date}</i>\n\n"

    message += f"ğŸ• ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾: {updated_time}"

    return message


def format_prices_message():
    """âœ… Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ñ Ñ†ĞµĞ½Ğ°Ğ¼Ğ¸ - Ğ¢ĞĞ›Ğ¬ĞšĞ Ğ Ğ£Ğ‘Ğ›Ğ˜"""
    if not prices_cache or not prices_cache.get("data"):
        return (
            "ğŸ“Š <b>ĞĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ñ‹Ğµ Ñ†ĞµĞ½Ñ‹ Ğ½Ğ° Ğ·ĞµÑ€Ğ½Ğ¾</b>\n\n"
            "âš ï¸ Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ ĞµÑ‰Ñ‘ Ğ½Ğµ Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ñ‹.\n"
            "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ /start Ğ´Ğ»Ñ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ."
        )

    updated_time = (
        prices_cache["updated"].strftime("%d.%m.%Y %H:%M")
        if prices_cache.get("updated")
        else "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾"
    )

    data = prices_cache["data"]
    russia = data.get("russia_south", {})
    fob = data.get("fob", 0)
    cbot = data.get("cbot", {})

    message = "ğŸ“Š <b>ĞĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ñ‹Ğµ Ñ†ĞµĞ½Ñ‹ Ğ½Ğ° Ğ·ĞµÑ€Ğ½Ğ¾</b>\n\n"

    if russia:
        message += "ğŸ‡·ğŸ‡º <b>Ğ®Ğ³ Ğ Ğ¾ÑÑĞ¸Ğ¸</b>\n"
        for culture, price in russia.items():
            if isinstance(price, (int, float)):
                message += f"  â€¢ {culture}: <code>{price:,.0f} â‚½/Ñ‚</code>\n"
            else:
                message += f"  â€¢ {culture}: <code>{price}</code>\n"

    message += "\nğŸš¢ <b>FOB Ğ§ĞµÑ€Ğ½Ğ¾Ğµ Ğ¼Ğ¾Ñ€Ğµ</b>\n"
    if isinstance(fob, (int, float)):
        fob_rub = int(fob * 95)  # ĞšÑƒÑ€Ñ ~95â‚½/â‚½
        message += f"  â€¢ ĞŸÑˆĞµĞ½Ğ¸Ñ†Ğ°: <code>{fob_rub:,} â‚½/Ñ‚</code>\n"
    else:
        message += f"  â€¢ ĞŸÑˆĞµĞ½Ğ¸Ñ†Ğ°: <code>{fob}</code>\n"

    if cbot:
        message += "\nğŸŒ <b>CBOT (Ğ¡Ğ¨Ğ)</b>\n"
        for culture, price in cbot.items():
            if price:
                message += f"  â€¢ {culture}: <code>{price}</code>\n"

    message += f"\nğŸ• ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾: {updated_time}"

    return message


def format_farmer_card(farmer_id, batch_id=None):
    """Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğ¹ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ° Ñ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ğ°Ğ¼Ğ¸"""
    if farmer_id not in users:
        return "âŒ Ğ¤ĞµÑ€Ğ¼ĞµÑ€ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"

    farmer = users[farmer_id]

    msg = f"ğŸ‘¤ <b>Ğ¤ĞµÑ€Ğ¼ĞµÑ€: {farmer.get('name', 'ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾')}</b>\n\n"
    msg += "<b>ğŸ“ ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹:</b>\n"
    msg += f"ğŸ“± Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <code>{farmer.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>\n"
    msg += f"ğŸ“§ Email: <code>{farmer.get('email', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>\n"
    msg += f"ğŸ“ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½: {farmer.get('region', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n\n"

    if farmer.get("inn"):
        msg += "<b>ğŸ¢ Ğ ĞµĞºĞ²Ğ¸Ğ·Ğ¸Ñ‚Ñ‹:</b>\n"
        msg += f"Ğ˜ĞĞ: <code>{farmer.get('inn')}</code>\n"
        if farmer.get("company_details"):
            details = farmer["company_details"][:200]
            msg += (
                f"{details}...\n"
                if len(farmer["company_details"]) > 200
                else f"{details}\n"
            )
        msg += "\n"

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾Ğµ Ğ¾Ğ±Ñ€Ğ°Ñ‰ĞµĞ½Ğ¸Ğµ Ğº Ğ¿Ğ¾Ğ»ÑĞ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸
    if batch_id and farmer_id in batches:
        for batch in batches[farmer_id]:
            if batch["id"] == batch_id:
                msg += f"<b>ğŸ“¦ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ #{batch_id}:</b>\n"
                msg += f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {batch.get('culture', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n"
                msg += f"ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: {batch.get('volume', 0)} Ñ‚\n"
                msg += f"ğŸ’° Ğ¦ĞµĞ½Ğ°: {batch.get('price', 0):,.0f} â‚½/Ñ‚\n"

                # âœ… ĞšĞĞ§Ğ•Ğ¡Ğ¢Ğ’Ğ - Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞµÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ
                if "moisture" in batch or "nature" in batch:
                    msg += "\n<b>ğŸ”¬ ĞšĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ¾:</b>\n"
                    if "nature" in batch:
                        msg += (
                            f"   ğŸŒ¾ ĞĞ°Ñ‚ÑƒÑ€Ğ°: {batch.get('nature', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')} Ğ³/Ğ»\n"
                        )
                    if "moisture" in batch:
                        msg += f"   ğŸ’§ Ğ’Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ: {batch['moisture']}%\n"
                    if "impurity" in batch:
                        msg += (
                            f"   ğŸŒ¿ Ğ¡Ğ¾Ñ€Ğ½Ğ¾ÑÑ‚ÑŒ: {batch.get('impurity', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}%\n"
                        )

                # âœ… Ğ¡Ğ¢ĞĞ¢Ğ£Ğ¡
                msg += f"\nğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: {batch.get('status', 'ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ°')}\n"
                break

    # âœ… Ğ¡Ğ¢ĞĞ¢Ğ˜Ğ¡Ğ¢Ğ˜ĞšĞ
    if farmer_id in batches:
        total_batches = len(batches[farmer_id])
        active_batches = len(
            [b for b in batches[farmer_id] if b.get("status") == "ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ°"]
        )

        msg += "\n<b>ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°:</b>\n"
        msg += f"Ğ’ÑĞµĞ³Ğ¾ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹: {total_batches}\n"
        msg += f"ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ…: {active_batches}\n"

    return msg


def get_role_keyboard(role):
    role = str(role).lower()
    if role in ["farmer", "Ñ„ĞµÑ€Ğ¼ĞµÑ€"]:
        return farmer_keyboard()
    elif role in ["exporter", "ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€"]:
        return exporter_keyboard()
    elif role in ["logistic", "Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚"]:
        return logistic_keyboard()
    elif role in ["expeditor", "ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€", "broker", "Ğ±Ñ€Ğ¾ĞºĞµÑ€"]:
        return expeditor_keyboard()
    else:
        keyboard = ReplyKeyboardMarkup(resize_keyboard=True)
        keyboard.add("ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", "â„¹ï¸ ĞŸĞ¾Ğ¼Ğ¾Ñ‰ÑŒ")
        return keyboard


def determine_quality_class(humidity, impurity):
    """ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ ĞºĞ»Ğ°ÑÑĞ° ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ° Ğ·ĞµÑ€Ğ½Ğ°"""
    if humidity <= 14 and impurity <= 1:
        return "1 ĞºĞ»Ğ°ÑÑ"
    elif humidity <= 14.5 and impurity <= 2:
        return "2 ĞºĞ»Ğ°ÑÑ"
    elif humidity <= 15 and impurity <= 3:
        return "3 ĞºĞ»Ğ°ÑÑ"
    elif humidity <= 16 and impurity <= 5:
        return "4 ĞºĞ»Ğ°ÑÑ"
    else:
        return "5 ĞºĞ»Ğ°ÑÑ"


def validate_date(date_str):
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ° Ğ´Ğ°Ñ‚Ñ‹ Ğ”Ğ”.ĞœĞœ.Ğ“Ğ“Ğ“Ğ“"""
    try:
        datetime.strptime(date_str, "%d.%m.%Y")
        return True
    except Exception as e:
        return False


async def find_matching_exporters(batch):
    """ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´ÑÑ‰Ğ¸Ñ… Ğ¿ÑƒĞ»Ğ¾Ğ² ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ² Ğ´Ğ»Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°"""
    matching_pulls = []

    try:
        batch_culture = batch.get("culture", "").strip()
        batch_volume = batch.get("volume", 0)

        if not batch_culture or batch_volume <= 0:
            logging.warning(
                f"ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸: culture={batch_culture}, volume={batch_volume}"
            )
            return []

        all_pulls = pulls.get("pulls", {})  # âœ… Ğ”ĞĞ‘ĞĞ’Ğ›Ğ•ĞĞ

        for pull_id, pull in all_pulls.items():  # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ
            if not isinstance(pull, dict):  # âœ… Ğ”ĞĞ‘ĞĞ’Ğ›Ğ•ĞĞ
                continue

            pull_culture = pull.get("culture", "").strip()
            pull_status = pull.get("status", "")
            pull_current_volume = pull.get("current_volume", 0)
            pull_target_volume = pull.get("target_volume", 0)

            if (
                pull_culture.lower() == batch_culture.lower()
                and pull_status != "completed"
                and pull_current_volume < pull_target_volume
            ):

                free_space = pull_target_volume - pull_current_volume

                if free_space > 0:
                    exporter_id = pull.get("exporter_id")
                    exporter = users.get(exporter_id, {})

                    matching_pulls.append(
                        {
                            "pull_id": pull_id,
                            "pull": pull,
                            "exporter": exporter,
                            "exporter_id": exporter_id,
                            "exporter_name": exporter.get("name", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾"),
                            "exporter_company": exporter.get("company", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾"),
                            "exporter_phone": exporter.get("phone", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"),
                            "culture": pull_culture,
                            "price": pull.get("price", 0),
                            "port": pull.get("port", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"),
                            "free_space": free_space,
                            "current_volume": pull_current_volume,
                            "target_volume": pull_target_volume,
                        }
                    )

        if matching_pulls:
            logging.info(
                f"âœ… ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ {len(matching_pulls)} Ğ¿ÑƒĞ»Ğ¾Ğ² Ğ´Ğ»Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ {batch.get('id')}"
            )
        else:
            logging.info(f"âŒ ĞŸÑƒĞ»Ğ¾Ğ² Ğ´Ğ»Ñ {batch_culture} Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾")

        return matching_pulls

    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° find_matching_exporters: {e}")
        return []


async def create_match_notification(batch_id, pull_id):
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ¾ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğ¸"""
    global match_counter
    match_counter += 1

    match_data = {
        "id": match_counter,
        "batch_id": batch_id,
        "pull_id": pull_id,
        "created_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "status": "active",
    }

    matches[match_counter] = match_data
    return match_counter


async def notify_match(farmer_id, batch, matching_pulls, extra=None, *args, **kwargs):
    """Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ñƒ Ğ¾ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ½Ñ‹Ñ… ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸ÑÑ… Ñ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ğ°Ğ¼Ğ¸ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°"""
    try:
        if not matching_pulls:
            return

        batch_id = batch.get("id", "?")
        batch_culture = batch.get("culture", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")
        batch_volume = batch.get("volume", 0)

        text = "ğŸ¯ <b>ĞĞ°Ğ¹Ğ´ĞµĞ½Ñ‹ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´ÑÑ‰Ğ¸Ğµ Ğ¿ÑƒĞ»Ñ‹!</b>\n\n"
        text += f"ğŸ“¦ <b>Ğ’Ğ°ÑˆĞ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ:</b> {batch_culture} - {batch_volume} Ñ‚\n"
        text += f"ğŸ” <b>ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ¿ÑƒĞ»Ğ¾Ğ²:</b> {len(matching_pulls)}\n\n"

        kb = InlineKeyboardMarkup(row_width=1)

        for idx, pull_data in enumerate(matching_pulls[:5], 1):
            # âœ… ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ID Ğ¿ÑƒĞ»Ğ°
            pull_id = pull_data.get("id") or pull_data.get("pull_id", "?")

            # âœ… ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ID ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°
            exporter_id = pull_data.get("exporter_id")

            # âœ… ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ° Ğ¸Ğ· Ğ±Ğ°Ğ·Ñ‹ users
            exporter_info = users.get(exporter_id, {})
            exporter_name = pull_data.get("exporter_name", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾")
            company_name = exporter_info.get("company_name", exporter_name)
            phone = exporter_info.get("phone", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
            email = exporter_info.get("email", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")

            # âœ… Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿ÑƒĞ»Ğ°
            price = pull_data.get("price", 0)
            port = pull_data.get("port", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
            current_volume = pull_data.get("current_volume", 0)
            target_volume = pull_data.get("target_volume", 0)
            doc_type = pull_data.get("doc_type", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")

            # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ
            unique_id = int(time.time() * 1000) + idx
            kb.add(
                InlineKeyboardButton(
                    f"ğŸ”— ĞŸÑ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½Ğ¸Ñ‚ÑŒÑÑ Ğº ĞŸÑƒĞ»Ñƒ #{pull_id}",
                    callback_data=f"join_pull:{pull_id}:{unique_id}",
                )
            )

            # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‚ĞµĞºÑÑ‚
            text += f"<b>{idx}. ĞŸÑƒĞ» #{pull_id}</b>\n"
            text += f"ğŸ¢ <b>ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ:</b> {company_name}\n"
            text += f"ğŸ‘¤ <b>Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€:</b> {exporter_name}\n"
            text += f"ğŸ“ <b>Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½:</b> <code>{phone}</code>\n"
            text += f"ğŸ“§ <b>Email:</b> {email}\n"
            text += f"ğŸ’° <b>Ğ¦ĞµĞ½Ğ°:</b> {price:,.0f} â‚½/Ñ‚\n"
            text += f"ğŸš¢ <b>ĞŸĞ¾Ñ€Ñ‚:</b> {port}\n"
            text += f"ğŸ“‹ <b>Ğ£ÑĞ»Ğ¾Ğ²Ğ¸Ñ:</b> {doc_type}\n"
            text += f"ğŸ“Š <b>Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¾:</b> {current_volume}/{target_volume} Ñ‚\n"
            text += "\n"

        text += "ğŸ’¡ <i>Ğ¡Ğ²ÑĞ¶Ğ¸Ñ‚ĞµÑÑŒ Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ¼ Ğ´Ğ»Ñ Ğ¾Ğ±ÑÑƒĞ¶Ğ´ĞµĞ½Ğ¸Ñ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ğ¹!</i>"

        logging.info(f"ğŸ”„ ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑÑ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ñƒ {farmer_id}...")
        logging.info(f"ğŸ“ Ğ¢ĞµĞºÑÑ‚ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ ({len(text)} ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²): {text[:200]}...")
        logging.info(f"ğŸ”˜ ĞšĞ½Ğ¾Ğ¿Ğ¾Ğº: {len(kb.inline_keyboard)}")

        await bot.send_message(farmer_id, text, parse_mode="HTML", reply_markup=kb)
        logging.info(f"âœ… Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ñƒ {farmer_id} Ğ£Ğ¡ĞŸĞ•Ğ¨ĞĞ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾!")

    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ñƒ {farmer_id}: {e}", exc_info=True)


async def auto_match_batches_and_pulls():
    """
    Ğ˜Ñ‰ĞµÑ‚ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ¸ Ğ¿ÑƒĞ»Ğ¾Ğ², Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ÑĞµÑ‚ ÑÑ‚Ğ°Ñ‚ÑƒÑÑ‹ Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ.
    Ğ¢ĞĞ›Ğ¬ĞšĞ Ğ¤Ğ•Ğ ĞœĞ•Ğ Ğ« Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°ÑÑ‚ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ¾ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸ÑÑ…!
    """
    try:
        logging.info("ğŸ”„ Ğ—Ğ°Ğ¿ÑƒÑĞº Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ¸ÑĞºĞ° ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğ¹...")
        global batches, pulls

        if "pulls" not in pulls or not isinstance(pulls["pulls"], dict):
            logging.warning(
                "âš ï¸ Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° pulls Ğ½ĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ° Ğ¸Ğ»Ğ¸ ĞºĞ»ÑÑ‡ 'pulls' Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚"
            )
            return 0

        matching_count = 0

        for pull_id, pull_data in pulls["pulls"].items():
            if not isinstance(pull_id, int) or not isinstance(pull_data, dict):
                continue

            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ¿ÑƒĞ»Ğ° Ğ¸ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñƒ
            pull_status = pull_data.get("status", "").lower()
            pull_culture = pull_data.get("culture", "").lower().strip()

            if pull_status == "filled":
                continue  # ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ğ¿Ğ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ½Ñ‹Ğµ Ğ¿ÑƒĞ»Ñ‹

            # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: batches â€” ÑÑ‚Ğ¾ {batch_id: batch_data}, Ğ° Ğ½Ğµ {farmer_id: batches}
            for batch_id, batch in batches.items():
                if not isinstance(batch, dict):
                    continue

                # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ID Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ° Ğ¸Ğ· Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸
                farmer_id = batch.get("farmer_id")

                # âœ… ĞŸĞ ĞĞ’Ğ•Ğ ĞšĞ Ğ ĞĞ›Ğ˜: Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°ÑÑ‚ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ
                if farmer_id not in users:
                    logging.debug(f"âš ï¸ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ {farmer_id} Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ Ğ² Ğ±Ğ°Ğ·Ğµ")
                    continue

                user_role = users[farmer_id].get("role", "").lower()
                if user_role != "farmer":
                    logging.debug(
                        f"âš ï¸ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ {farmer_id} (Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ #{batch_id}) Ğ¸Ğ¼ĞµĞµÑ‚ Ñ€Ğ¾Ğ»ÑŒ '{user_role}', Ğ° Ğ½Ğµ 'farmer'. ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞºĞ°ĞµĞ¼."
                    )
                    continue

                batch_culture = batch.get("culture", "").lower().strip()
                batch_status = batch.get("status", "").lower()

                # Ğ›Ğ¾Ğ³Ğ¸ĞºĞ° ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğµ Ğ¸ ÑÑ‚Ğ°Ñ‚ÑƒÑÑƒ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸
                if batch_culture == pull_culture and batch_status in [
                    "Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ°",
                    "active",
                    "available",
                ]:
                    logging.info(
                        f"âœ… Ğ¡Ğ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğµ:\n"
                        f"  Ğ¤ĞµÑ€Ğ¼ĞµÑ€ {farmer_id} (Ñ€Ğ¾Ğ»ÑŒ: {user_role}): ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ #{batch_id} ({batch_culture})\n"
                        f"  ĞŸÑƒĞ» #{pull_id} ({pull_culture})"
                    )

                    try:
                        # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ñƒ
                        await notify_match(farmer_id, batch, [pull_data])
                        logging.info(f"âœ… Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ñƒ {farmer_id}")
                    except Exception as e:
                        logging.error(
                            f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ñƒ {farmer_id}: {e}"
                        )

                    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑÑ‹ Ğ² Ğ¿Ğ°Ñ€Ñ‚Ğ¸ÑÑ… Ğ¸ Ğ¿ÑƒĞ»Ğ°Ñ…
                    batch["status"] = "matched"
                    pull_data["status"] = "processing"
                    pulls["pulls"][pull_id] = pull_data

                    matching_count += 1

        if matching_count > 0:
            try:
                save_pulls_to_pickle()
                save_batches_to_pickle()
                logging.info(
                    f"âœ… ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ {matching_count} ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğ¹, Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ñ‹"
                )
            except Exception as e:
                logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…: {e}")
        else:
            logging.info("â„¹ï¸ Ğ¡Ğ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğ¹ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾")

        return matching_count

    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ² auto_match_batches_and_pulls: {e}", exc_info=True)
        return 0


# ============================================================================
# ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜Ğš ĞšĞĞœĞĞĞ”Ğ« /start
# ============================================================================
# Ğ“Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ÑĞ»Ğ¾Ğ²Ğ°Ñ€ÑŒ Ğ´Ğ»Ñ Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ñ‹ Ğ¾Ñ‚ Ğ´ÑƒĞ±Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
last_start_times = {}


@dp.message_handler(commands=["start"], state="*")
async def cmd_start(message: types.Message, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ /start"""
    user_id = message.from_user.id

    # âœ… Ğ¡Ğ ĞĞ—Ğ£ Ğ£Ğ”ĞĞ›Ğ¯Ğ•Ğœ ĞšĞĞœĞĞĞ”Ğ£ /start
    try:
        await message.delete()
    except:
        pass

    # âœ… ĞŸĞ ĞĞ’Ğ•Ğ ĞšĞ 1: Ğ•ÑĞ»Ğ¸ Ğ¸Ğ´Ñ‘Ñ‚ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ, Ğ¸Ğ³Ğ½Ğ¾Ñ€Ğ¸Ñ€ÑƒĞµĞ¼
    current_state = await state.get_state()
    if current_state and "Registration" in current_state:
        return

    await state.finish()

    # âœ… ĞŸĞ ĞĞ’Ğ•Ğ ĞšĞ 2: Ğ—Ğ°Ñ‰Ğ¸Ñ‚Ğ° Ğ¾Ñ‚ Ğ´ÑƒĞ±Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
    import time

    current_time = time.time()

    if user_id in last_start_times:
        time_diff = current_time - last_start_times[user_id]
        if time_diff < 3:
            return

    last_start_times[user_id] = current_time
    logging.info(f"ğŸš€ /start Ğ¾Ñ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ {user_id}")

    if user_id in users:
        # Ğ—Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ
        user = users[user_id]
        role = user.get("role", "unknown")
        name = user.get("name", "ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ")

        logging.info(f"âœ… ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ {user_id} ÑƒĞ¶Ğµ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½ ĞºĞ°Ğº {role}")

        welcome_text = f"ğŸ‘‹ Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ, {name}!\n\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ:"

        if role == "farmer":
            keyboard = farmer_keyboard()
        elif role == "exporter":
            keyboard = exporter_keyboard()
        elif role == "logistic":
            keyboard = logistic_keyboard()
        elif role == "expeditor":
            keyboard = expeditor_keyboard()
        elif role == "admin":
            keyboard = admin_keyboard()
        else:
            keyboard = ReplyKeyboardMarkup(resize_keyboard=True)
            keyboard.add(KeyboardButton("ğŸ“ Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ"))

        await message.answer(welcome_text, reply_markup=keyboard, parse_mode="HTML")

    else:
        # ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ
        logging.info(f"ğŸ‘¤ ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ {user_id} - Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¿Ñ€Ğ¸Ğ²ĞµÑ‚ÑÑ‚Ğ²Ğ¸Ğµ")

        keyboard = ReplyKeyboardMarkup(resize_keyboard=True)
        keyboard.add(KeyboardButton("ğŸ“ Ğ—Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒÑÑ"))

        # âœ… ĞŸĞ Ğ˜Ğ’Ğ•Ğ¢Ğ¡Ğ¢Ğ’Ğ˜Ğ• ĞĞ¡Ğ¢ĞĞĞ¢Ğ¡Ğ¯ Ğ’ Ğ§ĞĞ¢Ğ•
        await message.answer(
            "ğŸŒ¾ <b>EXPORTUM</b>\n\n"
            "ĞŸĞ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼Ğ° Ğ·ĞµÑ€Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ñ€Ñ‹Ğ½ĞºĞ° Ğ´Ğ»Ñ:\n\n"
            "â€¢ ğŸ‘¨â€ğŸŒ¾ Ğ¤ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ² â€” Ğ¿Ñ€Ğ¾Ğ´Ğ°Ğ¶Ğ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ·ĞµÑ€Ğ½Ğ°\n"
            "â€¢ ğŸ“¦ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ² â€” ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ»Ğ¾Ğ² Ğ¸ Ğ·Ğ°ĞºÑƒĞ¿ĞºĞ°\n"
            "â€¢ ğŸš› Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ² â€” Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ½Ñ‹Ñ… ÑƒÑĞ»ÑƒĞ³\n"
            "â€¢ ğŸ“‹ Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ² â€” Ñ‚Ğ°Ğ¼Ğ¾Ğ¶ĞµĞ½Ğ½Ğ¾Ğµ Ğ¾Ñ„Ğ¾Ñ€Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ\n\n"
            "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            "ğŸ“¢ ĞšĞ°Ğ½Ğ°Ğ»: @EXPORTUM\n"
            "ğŸ’¬ Ğ§Ğ°Ñ‚: @exportum_chat\n"
            "ğŸ¤– Ğ‘Ğ¾Ñ‚: @exportumbot\n\n"
            "ğŸ“Š ĞšĞ¾Ñ‚Ğ¸Ñ€Ğ¾Ğ²ĞºĞ¸ Ğ¸ Ğ½Ğ¾Ğ²Ğ¾ÑÑ‚Ğ¸ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ÑÑÑ‚ÑÑ ĞµĞ¶ĞµĞ´Ğ½ĞµĞ²Ğ½Ğ¾!\n\n"
            "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
            "ğŸ‘‡ ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ Ğ½Ğ¸Ğ¶Ğµ Ğ´Ğ»Ñ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸:",
            parse_mode="HTML",
            reply_markup=keyboard,
        )


# ============================================================================
# ADMIN CALLBACK HANDLERS - Ğ’Ğ«Ğ¡ĞĞšĞ˜Ğ™ ĞŸĞ Ğ˜ĞĞ Ğ˜Ğ¢Ğ•Ğ¢ (ĞŸĞ•Ğ Ğ•Ğ” Ğ’Ğ¡Ğ•ĞœĞ˜ ĞĞ¡Ğ¢ĞĞ›Ğ¬ĞĞ«ĞœĞ˜!)
# ============================================================================
def format_admin_statistics():
    """Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸"""
    total_users = len(users)
    farmers = sum(1 for u in users.values() if u.get("role") == "farmer")
    exporters = sum(1 for u in users.values() if u.get("role") == "exporter")
    logists = sum(1 for u in users.values() if u.get("role") == "logistic")
    expeditors = sum(1 for u in users.values() if u.get("role") == "expeditor")

    total_pulls = len(pulls)
    active_pulls = sum(1 for p in pulls.values() if p.get("status") == "active")

    total_batches = sum(len(b) for b in batches.values())

    total_requests = len(shipping_requests)
    active_requests = sum(
        1 for r in shipping_requests.values() if r.get("status") == "active"
    )

    msg = "ğŸ“Š <b>Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ±Ğ¾Ñ‚Ğ°</b>\n\n"
    msg += "ğŸ‘¥ <b>ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸:</b>\n"
    msg += f"â€¢ Ğ’ÑĞµĞ³Ğ¾: {total_users}\n"
    msg += f"â€¢ Ğ¤ĞµÑ€Ğ¼ĞµÑ€Ñ‹: {farmers}\n"
    msg += f"â€¢ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ñ‹: {exporters}\n"
    msg += f"â€¢ Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚Ñ‹: {logists}\n"
    msg += f"â€¢ Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ñ‹: {expeditors}\n\n"

    msg += "ğŸ’¼ <b>ĞŸÑƒĞ»Ñ‹:</b>\n"
    msg += f"â€¢ Ğ’ÑĞµĞ³Ğ¾: {total_pulls}\n"
    msg += f"â€¢ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ: {active_pulls}\n\n"

    msg += "ğŸŒ¾ <b>ĞŸĞ°Ñ€Ñ‚Ğ¸Ğ¸:</b>\n"
    msg += f"â€¢ Ğ’ÑĞµĞ³Ğ¾: {total_batches}\n\n"

    msg += "ğŸšš <b>Ğ—Ğ°ÑĞ²ĞºĞ¸ Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ:</b>\n"
    msg += f"â€¢ Ğ’ÑĞµĞ³Ğ¾: {total_requests}\n"
    msg += f"â€¢ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ: {active_requests}"

    return msg


def format_admin_analytics():
    """Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ°Ğ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ¸"""
    regions = {}
    for user in users.values():
        region = user.get("region", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        regions[region] = regions.get(region, 0) + 1

    top_regions = sorted(regions.items(), key=lambda x: x[1], reverse=True)[:5]

    cultures = {}
    for user_batches in batches.values():
        for batch in user_batches:
            culture = batch.get("culture", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")
            cultures[culture] = cultures.get(culture, 0) + 1

    top_cultures = sorted(cultures.items(), key=lambda x: x[1], reverse=True)[:5]

    pull_statuses = {}
    for pull in pulls.values():
        status = pull.get("status", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")
        pull_statuses[status] = pull_statuses.get(status, 0) + 1

    msg = "ğŸ“ˆ <b>ĞĞ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ° Ğ±Ğ¾Ñ‚Ğ°</b>\n\n"

    msg += "ğŸ—º <b>Ğ¢Ğ¾Ğ¿-5 Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ¾Ğ²:</b>\n"
    for i, (region, count) in enumerate(top_regions, 1):
        msg += f"{i}. {region}: {count} Ğ¿Ğ¾Ğ»ÑŒĞ·.\n"

    msg += "\nğŸŒ¾ <b>Ğ¢Ğ¾Ğ¿-5 ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€:</b>\n"
    for i, (culture, count) in enumerate(top_cultures, 1):
        msg += f"{i}. {culture}: {count} Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹\n"

    msg += "\nğŸ’¼ <b>Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑÑ‹ Ğ¿ÑƒĞ»Ğ¾Ğ²:</b>\n"
    for status, count in pull_statuses.items():
        status_emoji = "âœ…" if status == "active" else "â¸"
        msg += f"{status_emoji} {status.capitalize()}: {count}\n"

    return msg


def format_admin_users():
    """Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ÑĞ¿Ğ¸ÑĞºĞ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹"""
    if not users:
        return "âŒ ĞĞµÑ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹"

    msg = "ğŸ‘¥ <b>ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹</b>\n\n"

    roles = {
        "farmer": "ğŸŒ¾ Ğ¤ĞµÑ€Ğ¼ĞµÑ€Ñ‹",
        "exporter": "ğŸ’¼ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ñ‹",
        "logistic": "ğŸšš Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚Ñ‹",
        "expeditor": "âš“ Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ñ‹",
    }

    for role, title in roles.items():
        role_users = [u for u in users.values() if u.get("role") == role]
        if role_users:
            msg += f"{title}: {len(role_users)}\n"
            for user in role_users[:3]:
                name = user.get("name", "Ğ‘ĞµĞ· Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ñ")
                phone = user.get("phone", "ĞĞµÑ‚ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°")
                msg += f"â€¢ {name} ({phone})\n"
            if len(role_users) > 3:
                msg += f"... Ğ¸ ĞµÑ‰Ñ‘ {len(role_users) - 3}\n"
            msg += "\n"

    return msg


# Admin callback handlers - Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€ÑƒĞµĞ¼ ĞŸĞ•Ğ Ğ’Ğ«ĞœĞ˜!
@dp.callback_query_handler(lambda c: c.data and c.data.startswith("admin"), state="*")
async def admin_callbacks_router(callback: types.CallbackQuery, state: FSMContext):
    """Ğ Ğ¾ÑƒÑ‚ĞµÑ€ Ğ´Ğ»Ñ Ğ²ÑĞµÑ… admin callback handlers"""

    # ĞšĞ Ğ˜Ğ¢Ğ˜Ğ§ĞĞ: Ğ¡Ğ±Ñ€Ğ°ÑÑ‹Ğ²Ğ°ĞµĞ¼ state Ğ¡Ğ ĞĞ—Ğ£!
    current_state = await state.get_state()
    if current_state:
        logging.info(f"âš ï¸ Ğ¡Ğ±Ñ€Ğ°ÑÑ‹Ğ²Ğ°ĞµĞ¼ state: {current_state}")
        await state.finish()

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ñ€Ğ°Ğ²Ğ° Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ°
    if callback.from_user.id != ADMIN_ID:
        await callback.answer("âŒ ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°", show_alert=True)
        return

    data = callback.data
    logging.info(f"ğŸ”‘ Admin callback: {data} from {callback.from_user.id}")

    # ĞĞ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ callback
    if data == "adminstat":
        msg = format_admin_statistics()
        keyboard = InlineKeyboardMarkup(row_width=2)
        keyboard.add(
            InlineKeyboardButton("ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="adminstat"),
            InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="backtoadmin"),
        )
        await callback.message.edit_text(msg, reply_markup=keyboard, parse_mode="HTML")
        await callback.answer("âœ… Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°")

    elif data == "adminanalytics":
        msg = format_admin_analytics()
        keyboard = InlineKeyboardMarkup(row_width=2)
        keyboard.add(
            InlineKeyboardButton("ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="adminanalytics"),
            InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="backtoadmin"),
        )
        await callback.message.edit_text(msg, reply_markup=keyboard, parse_mode="HTML")
        await callback.answer("âœ… ĞĞ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°")

    elif data == "adminexport":
        keyboard = InlineKeyboardMarkup(row_width=2)
        keyboard.add(
            InlineKeyboardButton("ğŸ‘¥ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸", callback_data="exportusers"),
            InlineKeyboardButton("ğŸ“¦ ĞŸÑƒĞ»Ğ»Ñ‹", callback_data="exportpulls"),
        )
        keyboard.add(
            InlineKeyboardButton("ğŸŒ¾ ĞŸĞ°Ñ€Ñ‚Ğ¸Ğ¸", callback_data="exportbatches"),
            InlineKeyboardButton("ğŸ“‹ Ğ—Ğ°ÑĞ²ĞºĞ¸", callback_data="exportrequests"),
        )
        keyboard.add(
            InlineKeyboardButton("ğŸ’¼ ĞŸĞ¾Ğ»Ğ½Ñ‹Ğ¹ Ğ±ÑĞºĞ°Ğ¿", callback_data="exportfull")
        )
        keyboard.add(InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="backtoadmin"))

        await callback.message.edit_text(
            "ğŸ“¤ <b>Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…</b>\n\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ»Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ°:",
            reply_markup=keyboard,
            parse_mode="HTML",
        )
        await callback.answer()

    elif data == "adminusers":
        msg = format_admin_users()
        keyboard = InlineKeyboardMarkup(row_width=2)
        keyboard.add(
            InlineKeyboardButton("ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="adminusers"),
            InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="backtoadmin"),
        )
        await callback.message.edit_text(msg, reply_markup=keyboard, parse_mode="HTML")
        await callback.answer()

    elif data == "adminbroadcast":
        keyboard = InlineKeyboardMarkup(row_width=1)
        keyboard.add(InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="backtoadmin"))

        await callback.message.edit_text(
            "ğŸ“§ <b>Ğ Ğ°ÑÑÑ‹Ğ»ĞºĞ°</b>\n\nĞÑ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸ Ğ²ÑĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼.",
            reply_markup=keyboard,
            parse_mode="HTML",
        )
        await callback.answer()

    elif data == "adminprices":
        await callback.answer("â³ Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°Ñ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ñ†ĞµĞ½...")

        try:
            await update_prices_cache()

            keyboard = InlineKeyboardMarkup(row_width=1)
            keyboard.add(InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="backtoadmin"))

            await callback.message.edit_text(
                "âœ… <b>Ğ¦ĞµĞ½Ñ‹ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ñ‹ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾!</b>",
                reply_markup=keyboard,
                parse_mode="HTML",
            )
        except Exception as e:
            logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ñ†ĞµĞ½: {e}")
            await callback.message.edit_text(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ: {e}")


@dp.callback_query_handler(lambda c: c.data == "backtoadmin", state="*")
async def back_to_admin_callback(callback: types.CallbackQuery, state: FSMContext):
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğ² Ğ°Ğ´Ğ¼Ğ¸Ğ½ Ğ¼ĞµĞ½Ñ"""

    # Ğ¡Ğ±Ñ€Ğ°ÑÑ‹Ğ²Ğ°ĞµĞ¼ state
    current_state = await state.get_state()
    if current_state:
        logging.info(f"âš ï¸ Ğ¡Ğ±Ñ€Ğ°ÑÑ‹Ğ²Ğ°ĞµĞ¼ state: {current_state}")
        await state.finish()

    if callback.from_user.id != ADMIN_ID:
        await callback.answer("âŒ ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°", show_alert=True)
        return

    logging.info(f"â—€ï¸ Back to admin menu by {callback.from_user.id}")

    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°", callback_data="adminstat"),
        InlineKeyboardButton("ğŸ“ˆ ĞĞ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ°", callback_data="adminanalytics"),
    )
    keyboard.add(
        InlineKeyboardButton("ğŸ“¤ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", callback_data="adminexport"),
        InlineKeyboardButton("ğŸ‘¥ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸", callback_data="adminusers"),
    )
    keyboard.add(
        InlineKeyboardButton("ğŸ“§ Ğ Ğ°ÑÑÑ‹Ğ»ĞºĞ°", callback_data="adminbroadcast"),
        InlineKeyboardButton("ğŸ’° ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ñ†ĞµĞ½Ñ‹", callback_data="adminprices"),
    )

    await callback.message.edit_text(
        "ğŸ” <b>ĞĞ´Ğ¼Ğ¸Ğ½ Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ EXPORTUM</b>\n\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ:",
        reply_markup=keyboard,
        parse_mode="HTML",
    )
    await callback.answer()


# ============================================================================
# ĞĞ’Ğ¢ĞĞœĞĞ¢Ğ˜Ğ§Ğ•Ğ¡ĞšĞĞ• Ğ—ĞĞšĞ Ğ«Ğ¢Ğ˜Ğ• ĞŸĞ£Ğ›Ğ Ğ˜ Ğ¡ĞĞ—Ğ”ĞĞĞ˜Ğ• Ğ¡Ğ”Ğ•Ğ›ĞšĞ˜
# ============================================================================


def check_and_close_pull_if_full(pull_id):
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ½Ğ¾ÑÑ‚ÑŒ Ğ¿ÑƒĞ»Ğ° Ğ¸ Ğ·Ğ°ĞºÑ€Ñ‹Ğ²Ğ°ĞµÑ‚ ĞµĞ³Ğ¾ Ğ¿Ñ€Ğ¸ 100%"""
    if pull_id not in pulls.get("pulls", {}):
        return False

    pull = pulls["pulls"][pull_id]
    current = pull.get("current_volume", 0)
    target = pull.get("target_volume", 0)

    if current >= target and pull.get("status") == "ĞÑ‚ĞºÑ€Ñ‹Ñ‚":
        pull["status"] = "Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½"
        pull["closed_at"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        deal_id = create_deal_from_full_pull(pull)
        pull["deal_id"] = deal_id

        save_pulls_to_pickle()
        logging.info(f"âœ… Pull {pull_id} auto-closed â†’ Deal {deal_id}")

        # Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ Ğ¼Ğ°ÑÑĞ¾Ğ²Ğ¾Ğµ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ²ÑĞµÑ… Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ² Ğ¸ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²
        asyncio.create_task(notify_all_about_pull_closure(pull, deal_id))
        return True

    return False


def create_deal_from_full_pull(pull):
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ñ‚ ÑĞ´ĞµĞ»ĞºÑƒ Ğ¸Ğ· Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ğ¿ÑƒĞ»Ğ°"""
    global deal_counter

    deal_counter += 1

    farmer_ids = []
    batch_details = []

    for participant in pull.get("participants", []):
        f_id = participant.get("farmer_id")
        b_id = participant.get("batch_id")
        volume = participant.get("volume", 0)

        if f_id and f_id not in farmer_ids:
            farmer_ids.append(f_id)

        batch_details.append(
            {
                "farmer_id": f_id,
                "batch_id": b_id,
                "volume": volume,
                "farmer_name": users.get(f_id, {}).get("name", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾"),
            }
        )

    deal = {
        "id": deal_counter,
        "pull_id": pull["id"],
        "type": "pool_deal",
        "exporter_id": pull["exporter_id"],
        "exporter_name": pull["exporter_name"],
        "farmer_ids": farmer_ids,
        "batches": batch_details,
        "logistic_id": None,
        "expeditor_id": None,
        "culture": pull["culture"],
        "volume": pull["current_volume"],
        "price": pull["price"],
        "total_sum": pull["current_volume"] * pull["price"],
        "port": pull["port"],
        "quality": {
            "moisture": pull.get("moisture", 0),
            "nature": pull.get("nature", 0),
            "impurity": pull.get("impurity", 0),
            "weed": pull.get("weed", 0),
        },
        "documents": pull.get("documents", ""),
        "doc_type": pull.get("doc_type", "FOB"),
        "status": "new",
        "payment_status": "pending",
        "delivery_status": "pending",
        "created_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
    }

    deals[deal_counter] = deal
    save_deals_to_pickle()
    logging.info(f"âœ… Deal {deal_counter} created from pull {pull['id']}")
    return deal_counter


async def notify_all_about_pull_closure(pull, deal_id):
    """
    ĞœĞ°ÑÑĞ¾Ğ²Ğ¾Ğµ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ²ÑĞµĞ¼ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°Ğ¼ Ğ¸ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°Ğ¼-ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ°Ğ¼ Ğ¾ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ğ¸ Ğ¸Ğ»Ğ¸ ÑĞ±Ğ¾Ñ€Ğµ Ğ¿ÑƒĞ»Ğ°.
    Ğ’ÑÑ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ° Ğ»Ğ¾Ğ³Ğ¸Ñ€ÑƒĞµÑ‚ÑÑ!
    """
    pull_id = pull["id"]
    exporter_id = pull["exporter_id"]
    port = pull.get("port", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")

    # Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ• Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ñ€Ğ¾Ğ»ĞµĞ¹ Ğ½Ğ° Ñ‚Ğ¾Ñ‡Ğ½Ğ¾Ğµ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğµ 'logistic'
    logist_ids = [uid for uid, u in users.items() if u.get("role") == "logistic"]
    logging.info(f"[NOTIFY DEBUG] logist_ids for pull {pull_id}: {logist_ids}")

    participants = pullparticipants.get(pull_id, [])
    logging.info(f"[NOTIFY DEBUG] pullparticipants for pull {pull_id}: {participants}")

    farmer_ids = [p.get("farmer_id") for p in participants if p.get("farmer_id")]
    logging.info(f"[NOTIFY DEBUG] farmer_ids for pull {pull_id}: {farmer_ids}")

    all_notify_ids = set(farmer_ids) | set(logist_ids)
    logging.info(f"[NOTIFY DEBUG] all_notify_ids for pull {pull_id}: {all_notify_ids}")

    notify_text = (
        f"ğŸ”’ <b>ĞŸĞ£Ğ› #{pull_id} Ğ¡ĞĞ‘Ğ ĞĞ/Ğ—ĞĞšĞ Ğ«Ğ¢!</b>\n\n"
        f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {pull.get('culture')}\n"
        f"ğŸ¯ ĞĞ±ÑŠÑ‘Ğ¼: {pull.get('current_volume')} / {pull.get('target_volume')} Ñ‚\n"
        f"ğŸ¢ ĞŸĞ¾Ñ€Ñ‚: {port}\n"
        f"ğŸ’° Ğ¦ĞµĞ½Ğ°: {pull.get('price', 0):,.0f} â‚½/Ñ‚\n"
        f"âœ… Ğ¡Ğ´ĞµĞ»ĞºĞ° #{deal_id} ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ°\n"
    )

    sent_count = 0
    failed_ids = []
    for notify_id in all_notify_ids:
        try:
            await bot.send_message(notify_id, notify_text, parse_mode="HTML")
            logging.info(f"[NOTIFY DEBUG] ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ user_id={notify_id}")
            sent_count += 1
        except Exception as e:
            logging.error(
                f"[NOTIFY ERROR] ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¸ user_id={notify_id}: {e}"
            )
            failed_ids.append(notify_id)

    logging.info(
        f"[NOTIFY RESULT] Ğ˜Ñ‚Ğ¾Ğ³: {sent_count} ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾, "
        f"{len(failed_ids)} Ğ½Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾: {failed_ids}"
    )

    # -- ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²/ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ² Ğ´Ğ»Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ° --
    logistics = get_logistics_by_port(port)
    expeditors = get_expeditors_by_port(port)

    exporter_text = (
        f"ğŸ‰ <b>ĞŸĞ£Ğ› #{pull_id} Ğ¡ĞĞ‘Ğ ĞĞ!</b>\n"
        f"\n"
        f"ğŸ“¦ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {pull.get('culture')}\n"
        f"ğŸ¯ ĞĞ±ÑŠÑ‘Ğ¼: {pull.get('current_volume')} / {pull.get('target_volume')} Ñ‚\n"
        f"ğŸ¢ ĞŸĞ¾Ñ€Ñ‚: {port}\n"
        f"ğŸ’° Ğ¦ĞµĞ½Ğ°: {pull.get('price', 0):,.0f} â‚½/Ñ‚\n"
        f"\n"
        f"âœ… Ğ¡Ğ´ĞµĞ»ĞºĞ° #{deal_id} ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ°\n"
    )

    try:
        await bot.send_message(exporter_id, exporter_text, parse_mode="HTML")
        logging.info(f"[NOTIFY DEBUG] ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ñƒ user_id={exporter_id}")
        if logistics:
            logistics_text = f"\nğŸšš <b>Ğ”ĞĞ¡Ğ¢Ğ£ĞŸĞĞ«Ğ• Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢Ğ« ({len(logistics)}):</b>\n\n"
            logistics_text += format_logistics_cards(logistics)
            logistics_keyboard = InlineKeyboardMarkup(row_width=1)
            for log in logistics[:5]:
                company = log.get("company", "Ğ‘ĞµĞ· Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ñ")[:30]
                user_id = log.get("user_id")
                logistics_keyboard.add(
                    InlineKeyboardButton(
                        f"ğŸšš {company}",
                        callback_data=f"select_logistic_{user_id}_{deal_id}",
                    )
                )
            await bot.send_message(
                exporter_id,
                logistics_text,
                reply_markup=logistics_keyboard,
                parse_mode="HTML",
            )
            logging.info(f"[NOTIFY DEBUG] ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ñ‹ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ² ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ñƒ")

        if expeditors:
            expeditors_text = (
                f"\nğŸ“œ <b>Ğ”ĞĞ¡Ğ¢Ğ£ĞŸĞĞ«Ğ• Ğ­ĞšĞ¡ĞŸĞ•Ğ”Ğ˜Ğ¢ĞĞ Ğ« ({len(expeditors)}):</b>\n\n"
            )
            expeditors_text += format_expeditors_cards(expeditors)
            expeditors_keyboard = InlineKeyboardMarkup(row_width=1)
            for exp in expeditors[:5]:
                company = exp.get("company", "Ğ‘ĞµĞ· Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ñ")[:30]
                user_id = exp.get("user_id")
                expeditors_keyboard.add(
                    InlineKeyboardButton(
                        f"ğŸ“œ {company}",
                        callback_data=f"select_expeditor_{user_id}_{deal_id}",
                    )
                )
            await bot.send_message(
                exporter_id,
                expeditors_text,
                reply_markup=expeditors_keyboard,
                parse_mode="HTML",
            )
            logging.info(f"[NOTIFY DEBUG] ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ñ‹ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ² ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ñƒ")
    except Exception as e:
        logging.error(f"Error sending to exporter {exporter_id}: {e}")

    logging.info(f"âœ… Mass notifications sent for pull {pull_id}, deal {deal_id}")


@dp.callback_query_handler(lambda c: c.data.startswith("export"), state="*")
async def export_callbacks_router(callback: types.CallbackQuery, state: FSMContext):
    """Ğ Ğ¾ÑƒÑ‚ĞµÑ€ Ğ´Ğ»Ñ Ğ²ÑĞµÑ… export callback handlers"""

    # Ğ¡Ğ±Ñ€Ğ°ÑÑ‹Ğ²Ğ°ĞµĞ¼ state
    current_state = await state.get_state()
    if current_state:
        logging.info(f"âš ï¸ Ğ¡Ğ±Ñ€Ğ°ÑÑ‹Ğ²Ğ°ĞµĞ¼ state: {current_state}")
        await state.finish()

    if callback.from_user.id != ADMIN_ID:
        await callback.answer("âŒ ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°", show_alert=True)
        return

    data = callback.data
    logging.info(f"ğŸ“¤ Export callback: {data} from {callback.from_user.id}")

    await callback.answer("â³ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒÑ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ...")

    try:
        import pandas as pd
        from datetime import datetime
        import os

        if data == "exportusers":
            users_data = []
            for uid, user in users.items():
                users_data.append(
                    {
                        "ID": uid,
                        "Ğ˜Ğ¼Ñ": user.get("name", ""),
                        "Ğ Ğ¾Ğ»ÑŒ": user.get("role", ""),
                        "Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½": user.get("phone", ""),
                        "Ğ ĞµĞ³Ğ¸Ğ¾Ğ½": user.get("region", ""),
                        "Ğ˜ĞĞ": user.get("inn", ""),
                        "Ğ”Ğ°Ñ‚Ğ°": user.get("registered_at", ""),
                    }
                )

            df = pd.DataFrame(users_data)
            filename = f'users_export_{datetime.now().strftime("%Y%m%d_%H%M%S")}.xlsx'
            df.to_excel(filename, index=False, engine="openpyxl")

            with open(filename, "rb") as f:
                await callback.message.answer_document(
                    types.InputFile(f, filename=filename),
                    caption=f"ğŸ“¤ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹\n\nĞ’ÑĞµĞ³Ğ¾: {len(users_data)}",
                )

            os.remove(filename)

        elif data == "exportpulls":
            pulls_data = []
            all_pulls = pulls.get("pulls", {})  # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ

            for pull_id, pull in all_pulls.items():  # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ
                if not isinstance(pull, dict):  # âœ… Ğ”ĞĞ‘ĞĞ’Ğ›Ğ•ĞĞ
                    continue

                pulls_data.append(
                    {
                        "ID": pull_id,
                        "ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°": pull.get("culture", ""),
                        "ĞĞ±ÑŠÑ‘Ğ¼": pull.get("current_volume", 0),
                        "Ğ¦ĞµĞ½Ğ°": pull.get("price", 0),
                        "ĞŸĞ¾Ñ€Ñ‚": pull.get("port", ""),
                        "Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ": pull.get("status", ""),
                        "Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€": pull.get("exporter_name", ""),
                    }
                )

            df = pd.DataFrame(pulls_data)
            filename = f'pulls_export_{datetime.now().strftime("%Y%m%d_%H%M%S")}.xlsx'
            df.to_excel(filename, index=False, engine="openpyxl")

            with open(filename, "rb") as f:
                await callback.message.answer_document(
                    types.InputFile(f, filename=filename),
                    caption=f"ğŸ“¤ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ¿ÑƒĞ»Ğ»Ğ¾Ğ²\n\nĞ’ÑĞµĞ³Ğ¾: {len(pulls_data)}",
                )

            os.remove(filename)

        elif data == "exportbatches":
            batches_data = []
            for farmer_id, user_batches in batches.items():
                farmer_name = users.get(farmer_id, {}).get("name", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚ĞµĞ½")
                for batch in user_batches:
                    batches_data.append(
                        {
                            "ID": batch.get("id", ""),
                            "Ğ¤ĞµÑ€Ğ¼ĞµÑ€": farmer_name,
                            "ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°": batch.get("culture", ""),
                            "ĞĞ±ÑŠÑ‘Ğ¼": batch.get("volume", 0),
                            "Ğ¦ĞµĞ½Ğ°": batch.get("price", 0),
                            "Ğ ĞµĞ³Ğ¸Ğ¾Ğ½": batch.get("region", ""),
                            "Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ": batch.get("status", ""),
                        }
                    )

            df = pd.DataFrame(batches_data)
            filename = f'batches_export_{datetime.now().strftime("%Y%m%d_%H%M%S")}.xlsx'
            df.to_excel(filename, index=False, engine="openpyxl")

            with open(filename, "rb") as f:
                await callback.message.answer_document(
                    types.InputFile(f, filename=filename),
                    caption=f"ğŸ“¤ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹\n\nĞ’ÑĞµĞ³Ğ¾: {len(batches_data)}",
                )

            os.remove(filename)

        elif data == "exportrequests":
            requests_data = []
            for req_id, req in shipping_requests.items():
                requests_data.append(
                    {
                        "ID": req_id,
                        "ĞÑ‚": req.get("from_city", ""),
                        "Ğ”Ğ¾": req.get("to_city", ""),
                        "ĞĞ±ÑŠÑ‘Ğ¼": req.get("volume", 0),
                        "Ğ”Ğ°Ñ‚Ğ°": req.get("loading_date", ""),
                        "Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ": req.get("status", ""),
                    }
                )

            df = pd.DataFrame(requests_data)
            filename = (
                f'requests_export_{datetime.now().strftime("%Y%m%d_%H%M%S")}.xlsx'
            )
            df.to_excel(filename, index=False, engine="openpyxl")

            with open(filename, "rb") as f:
                await callback.message.answer_document(
                    types.InputFile(f, filename=filename),
                    caption=f"ğŸ“¤ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ·Ğ°ÑĞ²Ğ¾Ğº\n\nĞ’ÑĞµĞ³Ğ¾: {len(requests_data)}",
                )

            os.remove(filename)

        elif data == "exportfull":
            import zipfile
            import io
            import json

            zip_buffer = io.BytesIO()

            with zipfile.ZipFile(zip_buffer, "w", zipfile.ZIP_DEFLATED) as zip_file:
                zip_file.writestr(
                    "users.json", json.dumps(users, ensure_ascii=False, indent=2)
                )
                zip_file.writestr(
                    "pulls.json", json.dumps(pulls, ensure_ascii=False, indent=2)
                )
                zip_file.writestr(
                    "batches.json", json.dumps(batches, ensure_ascii=False, indent=2)
                )
                zip_file.writestr(
                    "deals.json", json.dumps(deals, ensure_ascii=False, indent=2)
                )
                zip_file.writestr(
                    "shipping_requests.json",
                    json.dumps(shipping_requests, ensure_ascii=False, indent=2),
                )

                backup_info = {
                    "created_at": datetime.now().isoformat(),
                    "total_users": len(users),
                    "total_pulls": len(pulls.get("pulls", {})),  # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ
                    "total_batches": sum(len(b) for b in batches.values()),
                }
                zip_file.writestr(
                    "backup_info.json",
                    json.dumps(backup_info, ensure_ascii=False, indent=2),
                )

            zip_buffer.seek(0)

            filename = f'exportum_backup_{datetime.now().strftime("%Y%m%d_%H%M%S")}.zip'
            await callback.message.answer_document(
                types.InputFile(zip_buffer, filename=filename),
                caption=f"ğŸ’¼ ĞŸĞ¾Ğ»Ğ½Ñ‹Ğ¹ Ğ±ÑĞºĞ°Ğ¿\n\n"
                f"ğŸ‘¥ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹: {len(users)}\n"
                f"ğŸ“¦ ĞŸÑƒĞ»Ğ»Ğ¾Ğ²: {len(pulls.get('pulls', {}))}\n"  # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ
                f"ğŸŒ¾ ĞŸĞ°Ñ€Ñ‚Ğ¸Ğ¹: {sum(len(b) for b in batches.values())}",
            )

        keyboard = InlineKeyboardMarkup(row_width=1)
        keyboard.add(InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="adminexport"))
        await callback.message.edit_reply_markup(reply_markup=keyboard)

    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ°: {e}")
        await callback.message.answer(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {e}")


@dp.message_handler(lambda m: m.text == "ğŸ“ Ğ—Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒÑÑ", state="*")
async def registration_entry(message: types.Message, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸"""
    await state.finish()
    user_id = message.from_user.id

    logging.info(f"ğŸ“ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ {user_id} Ğ½Ğ°Ñ‡Ğ¸Ğ½Ğ°ĞµÑ‚ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ")

    # âœ… Ğ£Ğ”ĞĞ›Ğ¯Ğ•Ğœ Ğ¢ĞĞ›Ğ¬ĞšĞ ĞĞĞ–ĞĞ¢Ğ˜Ğ• ĞšĞĞĞŸĞšĞ˜
    try:
        await message.delete()
    except:
        pass

    # âœ… ĞŸĞ Ğ˜Ğ’Ğ•Ğ¢Ğ¡Ğ¢Ğ’Ğ˜Ğ• ĞĞ¡Ğ¢ĞĞĞ¢Ğ¡Ğ¯ Ğ’ Ğ§ĞĞ¢Ğ•

    # ĞĞĞ§Ğ˜ĞĞĞ•Ğœ Ğ Ğ•Ğ“Ğ˜Ğ¡Ğ¢Ğ ĞĞ¦Ğ˜Ğ®
    msg = await message.answer(
        "ğŸ“ <b>Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ</b>\n\n" "â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘ 1/8\n\n" "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ²Ğ°ÑˆĞµ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğµ Ğ¸Ğ¼Ñ:",
        parse_mode="HTML",
        reply_markup=ReplyKeyboardRemove(),
    )

    await state.update_data(last_bot_msg_id=msg.message_id)
    await RegistrationStatesGroup.name.set()


@dp.callback_query_handler(lambda c: c.data == "start_registration", state="*")
async def start_registration(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ğ»Ğ¾ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ñ‡ĞµÑ€ĞµĞ· callback"""
    await callback.message.edit_text(
        "ğŸ“ <b>Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ</b>\n\n" "â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘ 1/8\n\n" "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ²Ğ°ÑˆĞµ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğµ Ğ¸Ğ¼Ñ:",
        parse_mode="HTML",
    )

    # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ ID ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ
    await state.update_data(last_bot_msg_id=callback.message.message_id)
    await RegistrationStatesGroup.name.set()
    await callback.answer()


# ========== Ğ’Ğ¡ĞŸĞĞœĞĞ“ĞĞ¢Ğ•Ğ›Ğ¬ĞĞĞ¯ Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ¯ Ğ£Ğ”ĞĞ›Ğ•ĞĞ˜Ğ¯ ==========
async def delete_previous_messages(message: types.Message, state: FSMContext):
    """Ğ£Ğ´Ğ°Ğ»ÑĞµÑ‚ Ğ¿Ñ€ĞµĞ´Ñ‹Ğ´ÑƒÑ‰ĞµĞµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ±Ğ¾Ñ‚Ğ° Ğ¸ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
    data = await state.get_data()
    last_msg_id = data.get("last_bot_msg_id")

    # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ±Ğ¾Ñ‚Ğ°
    if last_msg_id:
        try:
            await bot.delete_message(message.chat.id, last_msg_id)
        except Exception as e:
            logging.debug(f"ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ±Ğ¾Ñ‚Ğ°: {e}")

    # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    try:
        await message.delete()
    except Exception as e:
        logging.debug(f"ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ: {e}")


# ========== Ğ¨ĞĞ“ 1: Ğ˜ĞœĞ¯ ==========
@dp.message_handler(state=RegistrationStatesGroup.name)
async def registration_name(message: types.Message, state: FSMContext):
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¸Ğ¼ĞµĞ½Ğ¸ Ğ¿Ñ€Ğ¸ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸"""
    name = message.text.strip()

    if len(name) < 2:
        await message.answer("âŒ Ğ˜Ğ¼Ñ ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ ĞºĞ¾Ñ€Ğ¾Ñ‚ĞºĞ¾Ğµ. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğµ Ğ¸Ğ¼Ñ:")
        return

    await state.update_data(name=name)

    # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ¿Ñ€ĞµĞ´Ñ‹Ğ´ÑƒÑ‰Ğ¸Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ
    await delete_previous_messages(message, state)

    msg = await message.answer(
        "ğŸ“ <b>Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ</b>\n\n"
        "â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘ 2/8\n\n"
        "ğŸ“± Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ²Ğ°Ñˆ Ğ½Ğ¾Ğ¼ĞµÑ€ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°\n\n"
        "ĞĞ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: +79991234567",
        parse_mode="HTML",
    )

    await state.update_data(last_bot_msg_id=msg.message_id)
    await RegistrationStatesGroup.phone.set()


# ========== Ğ¨ĞĞ“ 2: Ğ¢Ğ•Ğ›Ğ•Ğ¤ĞĞ ==========
@dp.message_handler(state=RegistrationStatesGroup.phone)
async def registration_phone(message: types.Message, state: FSMContext):
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ° Ğ¿Ñ€Ğ¸ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸"""
    phone = message.text.strip()

    if len(phone) < 10 or not any(char.isdigit() for char in phone):
        await message.answer("âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¹ Ğ½Ğ¾Ğ¼ĞµÑ€ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·:")
        return

    await state.update_data(phone=phone)
    await delete_previous_messages(message, state)

    msg = await message.answer(
        "ğŸ“ <b>Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ</b>\n\n" "â–“â–“â–“â–‘â–‘â–‘â–‘â–‘ 3/8\n\n" "ğŸ“§ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ²Ğ°Ñˆ email:",
        parse_mode="HTML",
    )

    await state.update_data(last_bot_msg_id=msg.message_id)
    await RegistrationStatesGroup.email.set()


# ========== Ğ¨ĞĞ“ 3: EMAIL ==========
@dp.message_handler(state=RegistrationStatesGroup.email)
async def registration_email(message: types.Message, state: FSMContext):
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ email Ğ¿Ñ€Ğ¸ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸"""
    email = message.text.strip()

    if "@" not in email or "." not in email.split("@")[-1]:
        await message.answer("âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¹ email. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·:")
        return

    await state.update_data(email=email)
    await delete_previous_messages(message, state)

    msg = await message.answer(
        "ğŸ“ <b>Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ</b>\n\n"
        "â–“â–“â–“â–“â–‘â–‘â–‘â–‘ 4/8\n\n"
        "ğŸ¢ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ˜ĞĞ Ğ²Ğ°ÑˆĞµĞ¹ ĞºĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ğ¸\n\n"
        "Ğ˜ĞĞ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ ÑĞ¾ÑÑ‚Ğ¾ÑÑ‚ÑŒ Ğ¸Ğ· 10 Ğ¸Ğ»Ğ¸ 12 Ñ†Ğ¸Ñ„Ñ€",
        parse_mode="HTML",
    )

    await state.update_data(last_bot_msg_id=msg.message_id)
    await RegistrationStatesGroup.inn.set()


# ========== Ğ¨ĞĞ“ 4: Ğ˜ĞĞ ==========
@dp.message_handler(state=RegistrationStatesGroup.inn)
async def registration_inn(message: types.Message, state: FSMContext):
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ˜ĞĞ Ğ¿Ñ€Ğ¸ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸"""
    inn = message.text.strip()

    if not validate_inn(inn):
        await message.answer(
            "âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¹ Ğ˜ĞĞ. Ğ”Ğ¾Ğ»Ğ¶Ğ½Ğ¾ Ğ±Ñ‹Ñ‚ÑŒ 10 Ğ¸Ğ»Ğ¸ 12 Ñ†Ğ¸Ñ„Ñ€. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·:"
        )
        return

    await state.update_data(inn=inn)
    await delete_previous_messages(message, state)

    keyboard = InlineKeyboardMarkup()
    keyboard.add(InlineKeyboardButton("â¡ï¸ ĞŸÑ€Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ ĞĞ“Ğ Ğ", callback_data="skip_ogrn"))

    msg = await message.answer(
        "ğŸ“ <b>Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ</b>\n\n"
        "â–“â–“â–“â–“â–“â–‘â–‘â–‘ 5/8\n\n"
        "ğŸ“‹ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ĞĞ“Ğ Ğ Ğ²Ğ°ÑˆĞµĞ¹ ĞºĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ğ¸\n\n"
        "ĞĞ“Ğ Ğ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ ÑĞ¾ÑÑ‚Ğ¾ÑÑ‚ÑŒ Ğ¸Ğ· 15 Ñ†Ğ¸Ñ„Ñ€\n\n"
        "Ğ˜Ğ»Ğ¸ Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ Ğ½Ğ¸Ğ¶Ğµ:",
        reply_markup=keyboard,
        parse_mode="HTML",
    )

    await state.update_data(last_bot_msg_id=msg.message_id)
    await RegistrationStatesGroup.ogrn.set()


# ========== Ğ¨ĞĞ“ 5: ĞĞ“Ğ Ğ ==========
@dp.message_handler(state=RegistrationStatesGroup.ogrn)
async def registration_ogrn(message: types.Message, state: FSMContext):
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ĞĞ“Ğ Ğ Ğ¿Ñ€Ğ¸ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸"""
    ogrn = message.text.strip().replace(" ", "")

    if not ogrn.isdigit() or len(ogrn) != 15:
        await message.answer("âŒ ĞĞ“Ğ Ğ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ 15 Ñ†Ğ¸Ñ„Ñ€. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·:")
        return

    await state.update_data(ogrn=ogrn)
    await delete_previous_messages(message, state)

    msg = await message.answer(
        "ğŸ“ <b>Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ</b>\n\n"
        "â–“â–“â–“â–“â–“â–“â–‘â–‘ 6/8\n\n"
        "ğŸ“ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ÑÑ€Ğ¸Ğ´Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ°Ğ´Ñ€ĞµÑ ĞºĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ğ¸\n\n"
        "ĞĞ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: Ğ³. ĞšÑ€Ğ°ÑĞ½Ğ¾Ğ´Ğ°Ñ€, ÑƒĞ». ĞšÑ€Ğ°ÑĞ½Ğ°Ñ, Ğ´. 1, Ğ¾Ñ„. 10",
        parse_mode="HTML",
    )

    await state.update_data(last_bot_msg_id=msg.message_id)
    await RegistrationStatesGroup.company_details.set()


@dp.callback_query_handler(
    lambda c: c.data == "skip_ogrn", state=RegistrationStatesGroup.ogrn
)
async def skip_ogrn(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸÑ€Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ ĞĞ“Ğ Ğ"""
    await state.update_data(ogrn=None)

    # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ñ ĞºĞ½Ğ¾Ğ¿ĞºĞ¾Ğ¹
    try:
        await callback.message.delete()
    except:
        pass

    msg = await callback.message.answer(
        "ğŸ“ <b>Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ</b>\n\n"
        "â–“â–“â–“â–“â–“â–“â–‘â–‘ 6/8\n\n"
        "ğŸ“ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ÑÑ€Ğ¸Ğ´Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ°Ğ´Ñ€ĞµÑ ĞºĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ğ¸\n\n"
        "ĞĞ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: Ğ³. ĞšÑ€Ğ°ÑĞ½Ğ¾Ğ´Ğ°Ñ€, ÑƒĞ». ĞšÑ€Ğ°ÑĞ½Ğ°Ñ, Ğ´. 1, Ğ¾Ñ„. 10",
        parse_mode="HTML",
    )

    await state.update_data(last_bot_msg_id=msg.message_id)
    await RegistrationStatesGroup.company_details.set()
    await callback.answer()


# ========== Ğ¨ĞĞ“ 6: Ğ®Ğ Ğ˜Ğ”Ğ˜Ğ§Ğ•Ğ¡ĞšĞ˜Ğ™ ĞĞ”Ğ Ğ•Ğ¡ ==========
@dp.message_handler(state=RegistrationStatesGroup.company_details)
async def registration_company_details(message: types.Message, state: FSMContext):
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑÑ€Ğ¸Ğ´Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ³Ğ¾ Ğ°Ğ´Ñ€ĞµÑĞ° ĞºĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ğ¸"""
    company_details = message.text.strip()

    if len(company_details) < 10:
        await message.answer(
            "âŒ Ğ¡Ğ»Ğ¸ÑˆĞºĞ¾Ğ¼ ĞºĞ¾Ñ€Ğ¾Ñ‚ĞºĞ¸Ğ¹ Ğ°Ğ´Ñ€ĞµÑ. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğ¹ ÑÑ€Ğ¸Ğ´Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ°Ğ´Ñ€ĞµÑ:"
        )
        return

    await state.update_data(company_details=company_details)
    await delete_previous_messages(message, state)

    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("ğŸ‘¨â€ğŸŒ¾ Ğ¤ĞµÑ€Ğ¼ĞµÑ€", callback_data="role:farmer"),
        InlineKeyboardButton("ğŸ“¦ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€", callback_data="role:exporter"),
    )
    keyboard.add(
        InlineKeyboardButton("ğŸšš Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚", callback_data="role:logistic"),
        InlineKeyboardButton("ğŸš› Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€", callback_data="role:expeditor"),
    )

    msg = await message.answer(
        "ğŸ“ <b>Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ</b>\n\n" "â–“â–“â–“â–“â–“â–“â–“â–‘ 7/8\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ²Ğ°ÑˆÑƒ Ñ€Ğ¾Ğ»ÑŒ:",
        reply_markup=keyboard,
        parse_mode="HTML",
    )

    await state.update_data(last_bot_msg_id=msg.message_id)
    await RegistrationStatesGroup.role.set()


# ========== Ğ¨ĞĞ“ 7: Ğ ĞĞ›Ğ¬ ==========
@dp.callback_query_handler(
    lambda c: c.data.startswith("role:"), state=RegistrationStatesGroup.role
)
async def registration_role(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ñ€Ğ¾Ğ»Ğ¸"""
    role = callback.data.split(":", 1)[1]

    logging.info(f"ğŸ“ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ {callback.from_user.id} Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ» Ñ€Ğ¾Ğ»ÑŒ: {role}")

    await state.update_data(role=role)

    # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ñ ĞºĞ½Ğ¾Ğ¿ĞºĞ°Ğ¼Ğ¸
    try:
        await callback.message.delete()
    except:
        pass

    msg = await callback.message.answer(
        "ğŸ“ <b>Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ</b>\n\n" "â–“â–“â–“â–“â–“â–“â–“â–“ 8/8\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ²Ğ°Ñˆ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½:",
        reply_markup=region_keyboard(),
        parse_mode="HTML",
    )

    await state.update_data(last_bot_msg_id=msg.message_id)
    await RegistrationStatesGroup.region.set()
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("join_pull:"), state="*")
async def join_pull_start(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ğ»Ğ¾ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑĞ° Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ Ğº Ğ¿ÑƒĞ»Ñƒ"""

    try:
        parsed = parse_join_pull_callback(callback.data)
        pull_id = parsed["pull_id"]
        logging.info(
            f"ğŸ”— join_pull callback: {callback.data}, Ğ¸Ğ·Ğ²Ğ»ĞµÑ‡Ñ‘Ğ½ pull_id: {pull_id}"
        )
    except (IndexError, ValueError) as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ°Ñ€ÑĞ¸Ğ½Ğ³Ğ° callback: {callback.data}, Ğ¾ÑˆĞ¸Ğ±ĞºĞ°: {e}")
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
        return

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿ÑƒĞ»Ñ‹ Ğ¸Ğ· Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑÑ‚Ğ°
    all_pulls = pulls.get("pulls", {})

    if pull_id not in all_pulls:
        logging.warning(
            f"âŒ ĞŸÑƒĞ» {pull_id} Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½. Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ: {list(all_pulls.keys())}"
        )
        await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    pull = all_pulls.get(pull_id) or all_pulls.get(str(pull_id))

    if not pull:
        logging.warning(f"âŒ ĞŸÑƒĞ» {pull_id} Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ Ğ¿Ğ¾ÑĞ»Ğµ get()")
        await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    # âœ… ĞĞĞ’ĞĞ•: ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ½Ğ° Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹Ğ¹ Ğ¿ÑƒĞ»
    if pull.get("status") == "filled":
        await callback.answer(
            "âŒ Ğ­Ñ‚Ğ¾Ñ‚ Ğ¿ÑƒĞ» ÑƒĞ¶Ğµ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½ Ğ½Ğ° 100%!\n\nĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ¿ÑƒĞ»Ñ‹.",
            show_alert=True,
        )
        return

    user_id = callback.from_user.id

    if user_id not in users:
        await callback.answer("âŒ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½", show_alert=True)
        return

    if users[user_id].get("role") != "farmer":
        await callback.answer(
            "âŒ Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ñ‹ Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½ÑÑ‚ÑŒÑÑ Ğº Ğ¿ÑƒĞ»Ğ°Ğ¼", show_alert=True
        )
        return

    if user_id not in batches:
        keyboard = InlineKeyboardMarkup(row_width=1)
        keyboard.add(
            InlineKeyboardButton(
                text="âœ… Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ¿Ñ€ÑĞ¼Ğ¾ ÑĞµĞ¹Ñ‡Ğ°Ñ",
                callback_data=f"createbatchforpull:{pull_id}",
            ),
            InlineKeyboardButton(text="âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="cancel"),
        )
        await callback.message.answer(
            f"ğŸŒ¾ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñ‹ <b>{pull.get('culture', '?')}</b> Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ¿ÑƒĞ»Ğ°.\n\n"
            f"Ğ¥Ğ¾Ñ‚Ğ¸Ñ‚Ğµ ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²ÑƒÑ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ¿Ñ€ÑĞ¼Ğ¾ ÑĞµĞ¹Ñ‡Ğ°Ñ?",
            reply_markup=keyboard,
            parse_mode="HTML",
        )
        await callback.answer()
        return

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² Ğ¸Ğ· Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑÑ‚Ğ°
    all_pullparticipants = pulls.get("pullparticipants", {})

    already_joined_batch_ids = []
    pull_id_str = str(pull_id)

    if pull_id_str in all_pullparticipants:
        already_joined_batch_ids = [
            p["batch_id"]
            for p in all_pullparticipants[pull_id_str]
            if p.get("farmer_id") == user_id
        ]

    # ğŸ” Ğ”Ğ˜ĞĞ“ĞĞĞ¡Ğ¢Ğ˜ĞšĞ - ĞšĞ Ğ˜Ğ¢Ğ˜Ğ§ĞĞ Ğ”Ğ›Ğ¯ ĞĞ¢Ğ›ĞĞ”ĞšĞ˜
    logging.info(
        f"ğŸ” Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¸ Ğ¿ÑƒĞ»Ğ° {pull_id_str}: {all_pullparticipants.get(pull_id_str, [])}"
    )
    logging.info(
        f"ğŸ” ĞŸĞ°Ñ€Ñ‚Ğ¸Ğ¸ ÑƒĞ¶Ğµ Ğ² Ğ¿ÑƒĞ»Ğµ Ğ¾Ñ‚ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ° {user_id}: {already_joined_batch_ids}"
    )
    logging.info(
        f"ğŸ” ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ 3 Ğ² ÑĞ¿Ğ¸ÑĞºĞµ Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½Ñ‘Ğ½Ğ½Ñ‹Ñ…: {3 in already_joined_batch_ids}"
    )

    # âœ… Ğ”ĞĞ‘ĞĞ’Ğ›Ğ•ĞĞ: Ğ”Ğ¸Ğ°Ğ³Ğ½Ğ¾ÑÑ‚Ğ¸ĞºĞ°
    logging.info(f"ğŸ“‹ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ° Ğ¿ÑƒĞ»Ğ°: '{pull.get('culture')}'")
    logging.info(f"ğŸ“‹ ĞŸĞ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ {user_id}:")
    for b in batches.get(user_id, []):
        logging.info(
            f"   - ID: {b['id']}, ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: '{b.get('culture')}', Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: '{b.get('status')}', Ğ£Ğ¶Ğµ Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ°: {b['id'] in already_joined_batch_ids}"
        )

    active_batches = [
        b
        for b in batches.get(user_id, [])
        if b.get("culture") == pull.get("culture")
        and b.get("status", "").lower() in ["Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ°", "active", "Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ°"]
        and b["id"] not in already_joined_batch_ids
    ]

    logging.info(f"âœ… ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹: {len(active_batches)}")

    if not active_batches:
        keyboard = InlineKeyboardMarkup(row_width=1)
        keyboard.add(
            InlineKeyboardButton(
                text="âœ… Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ¿Ñ€ÑĞ¼Ğ¾ ÑĞµĞ¹Ñ‡Ğ°Ñ",
                callback_data=f"createbatchforpull:{pull_id}",
            ),
            InlineKeyboardButton(text="âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="cancel"),
        )
        await callback.message.answer(
            f"ğŸŒ¾ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñ‹ <b>{pull.get('culture', 'ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾')}</b> Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ¿ÑƒĞ»Ğ°.\n\n"
            f"Ğ¥Ğ¾Ñ‚Ğ¸Ñ‚Ğµ ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²ÑƒÑ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ¿Ñ€ÑĞ¼Ğ¾ ÑĞµĞ¹Ñ‡Ğ°Ñ?",
            reply_markup=keyboard,
            parse_mode="HTML",
        )
        await callback.answer()
        return

    await state.update_data(join_pull_id=pull_id)

    keyboard = InlineKeyboardMarkup(row_width=1)
    for batch in active_batches:
        button_text = (
            f"{batch['culture']} - {batch['volume']} Ñ‚ - {batch['price']:,.0f} â‚½/Ñ‚"
        )
        keyboard.add(
            InlineKeyboardButton(
                button_text, callback_data=f"selectbatchjoin:{batch['id']}"
            )
        )
        logging.info(f"   Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ: {button_text}")

    keyboard.add(InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data=f"view_pull:{pull_id}"))

    await JoinPullStatesGroup.select_batch.set()

    await callback.message.edit_text(
        f"ğŸ¯ <b>Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ Ğº Ğ¿ÑƒĞ»Ñƒ #{pull_id}</b>\n\n"
        f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {pull.get('culture', 'ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾')}\n"
        f"ğŸ“¦ Ğ¦ĞµĞ»ĞµĞ²Ğ¾Ğ¹ Ğ¾Ğ±ÑŠÑ‘Ğ¼: {pull.get('target_volume', 0)} Ñ‚\n"
        f"ğŸ“Š Ğ¢ĞµĞºÑƒÑ‰Ğ¸Ğ¹ Ğ¾Ğ±ÑŠÑ‘Ğ¼: {pull.get('current_volume', 0)} Ñ‚\n"
        f"ğŸ“‰ Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾: {pull.get('target_volume', 0) - pull.get('current_volume', 0)} Ñ‚\n\n"
        f"Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ¸Ğ· ÑĞ¿Ğ¸ÑĞºĞ° Ğ½Ğ¸Ğ¶Ğµ:",
        reply_markup=keyboard,
        parse_mode="HTML",
    )
    await callback.answer()


# Ğ‘Ñ‹ÑÑ‚Ñ€Ğ¾Ğµ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ´Ğ»Ñ Ğ¿ÑƒĞ»Ğ»Ğ°
@dp.callback_query_handler(lambda c: c.data.startswith("quickbatch:"), state="*")
async def quick_batch_start(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ñ‚ÑŒ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ Ğº Ğ¿ÑƒĞ»Ğ»Ñƒ"""
    await state.finish()

    pull_id = callback.data.split(":")[1]

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿ÑƒĞ»Ñ‹ Ğ¸Ğ· Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑÑ‚Ğ°
    all_pulls = pulls.get("pulls", {})
    pull = (
        all_pulls.get(pull_id)
        or all_pulls.get(str(pull_id))
        or all_pulls.get(int(pull_id) if str(pull_id).isdigit() else None)
    )

    if not pull:
        await callback.answer("âŒ ĞŸÑƒĞ»Ğ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    await state.update_data(pull_id=pull_id)
    await QuickBatchStatesGroup.volume.set()

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¿Ğ¾Ğ»Ñ
    target_volume = pull.get("target_volume", 0)
    current_volume = pull.get("current_volume", 0)
    available_volume = target_volume - current_volume

    msg = (
        f"ğŸ“¦ <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ´Ğ»Ñ Ğ¿ÑƒĞ»Ğ»Ğ°</b>\n\n"
        f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {pull.get('culture', '?')}\n"
        f"ğŸ“ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½: {pull.get('region', '?')}\n"
        f"ğŸ“Š Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾ Ğ² Ğ¿ÑƒĞ»Ğ»Ğµ: {available_volume:,.0f} Ñ‚\n\n"
        f"Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¾Ğ±ÑŠÑ‘Ğ¼ Ğ²Ğ°ÑˆĞµĞ¹ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ (Ñ‚Ğ¾Ğ½Ğ½):"
    )

    await callback.message.edit_text(msg, parse_mode="HTML")
    await callback.answer()


# ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¾Ğ±ÑŠÑ‘Ğ¼Ğ°
@dp.message_handler(state=QuickBatchStatesGroup.volume)
async def quick_batch_volume(message: types.Message, state: FSMContext):
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¾Ğ±ÑŠÑ‘Ğ¼Ğ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""
    try:
        volume = float(message.text.replace(",", ".").replace(" ", ""))
        if volume <= 0:
            await message.answer("âŒ ĞĞ±ÑŠÑ‘Ğ¼ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ±Ñ‹Ñ‚ÑŒ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ½ÑƒĞ»Ñ")
            return

        data = await state.get_data()
        pull_id = data.get("pull_id")

        # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿ÑƒĞ»Ñ‹ Ğ¸Ğ· Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑÑ‚Ğ°
        all_pulls = pulls.get("pulls", {})
        pull = all_pulls.get(pull_id) or all_pulls.get(str(pull_id))

        if not pull:
            await message.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½")
            await state.finish()
            return

        # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¿Ğ¾Ğ»Ñ
        target_volume = pull.get("target_volume", 0)
        current_volume = pull.get("current_volume", 0)
        available = target_volume - current_volume

        if volume > available:
            await message.answer(
                f"âš ï¸ Ğ’ Ğ¿ÑƒĞ»Ğ»Ğµ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ {available:,.0f} Ñ‚\n"
                f"Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¾Ğ±ÑŠÑ‘Ğ¼ Ğ½Ğµ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ {available:,.0f} Ñ‚:"
            )
            return

        await state.update_data(volume=volume)
        await QuickBatchStatesGroup.price.set()
        await message.answer(
            f"ğŸ’° <b>Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ†ĞµĞ½Ñƒ</b>\n\n"
            f"Ğ¦ĞµĞ½Ğ° Ğ¿ÑƒĞ»Ğ°: {pull.get('price', 0):,.0f} â‚½/Ñ‚\n\n"
            f"Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ²Ğ°ÑˆÑƒ Ñ†ĞµĞ½Ñƒ (â‚½/Ñ‚):",
            parse_mode="HTML",
        )

    except ValueError:
        await message.answer("âŒ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾")


# ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ñ†ĞµĞ½Ñ‹
@dp.message_handler(state=QuickBatchStatesGroup.price)
async def quick_batch_price(message: types.Message, state: FSMContext):
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ñ†ĞµĞ½Ñ‹"""
    try:
        price = float(message.text.replace(",", ".").replace(" ", ""))
        if price <= 0:
            await message.answer("âŒ Ğ¦ĞµĞ½Ğ° Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ½ÑƒĞ»Ñ")
            return

        await state.update_data(price=price)

        # Ğ¡Ğ¿Ñ€Ğ°ÑˆĞ¸Ğ²Ğ°ĞµĞ¼ Ğ¿Ñ€Ğ¾ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ¾
        keyboard = InlineKeyboardMarkup(row_width=2)
        keyboard.add(
            InlineKeyboardButton("Ğ”Ğ°", callback_data="quickquality:yes"),
            InlineKeyboardButton("ĞĞµÑ‚, Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ", callback_data="quickquality:no"),
        )

        await message.answer(
            "Ğ¥Ğ¾Ñ‚Ğ¸Ñ‚Ğµ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ° (Ğ²Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ, Ğ½Ğ°Ñ‚ÑƒÑ€Ğ°, Ğ¿Ñ€Ğ¸Ğ¼ĞµÑĞ¸)?",
            reply_markup=keyboard,
        )

    except ValueError:
        await message.answer("âŒ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾")


# Ğ’Ñ‹Ğ±Ğ¾Ñ€ - ÑƒĞºĞ°Ğ·Ñ‹Ğ²Ğ°Ñ‚ÑŒ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¸Ğ»Ğ¸ Ğ½ĞµÑ‚
@dp.callback_query_handler(
    lambda c: c.data.startswith("quickquality:"), state=QuickBatchStatesGroup.price
)
async def quick_batch_quality_choice(callback: types.CallbackQuery, state: FSMContext):
    """Ğ’Ñ‹Ğ±Ğ¾Ñ€ - ÑƒĞºĞ°Ğ·Ñ‹Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ°"""
    choice = callback.data.split(":")[1]

    if choice == "yes":
        await QuickBatchStatesGroup.quality.set()
        await callback.message.edit_text("Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ°Ñ‚ÑƒÑ€Ñƒ (Ğ³/Ğ»):")
    else:
        # ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ°, ÑÑ€Ğ°Ğ·Ñƒ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ°ĞµĞ¼
        await finish_quick_batch(callback.message, state, callback.from_user.id)
        await state.finish()

    await callback.answer()


# ĞšĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ¾: Ğ½Ğ°Ñ‚ÑƒÑ€Ğ°
@dp.message_handler(state=QuickBatchStatesGroup.quality)
async def quick_batch_quality(message: types.Message, state: FSMContext):
    """ĞĞ°Ñ‚ÑƒÑ€Ğ°"""
    try:
        nature = float(message.text.replace(",", "."))
        await state.update_data(nature=nature)
        await QuickBatchStatesGroup.moisture.set()
        await message.answer("Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ²Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ (%):")
    except ValueError:
        await message.answer("âŒ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾")


# Ğ’Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ
@dp.message_handler(state=QuickBatchStatesGroup.moisture)
async def quick_batch_moisture(message: types.Message, state: FSMContext):
    """Ğ’Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ"""
    try:
        moisture = float(message.text.replace(",", "."))
        await state.update_data(moisture=moisture)
        await QuickBatchStatesGroup.impurity.set()
        await message.answer("Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ÑĞ¾Ñ€Ğ½Ğ¾ÑÑ‚ÑŒ (%):")
    except ValueError:
        await message.answer("âŒ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾")


# Ğ¡Ğ¾Ñ€Ğ½Ğ¾ÑÑ‚ÑŒ
@dp.message_handler(state=QuickBatchStatesGroup.impurity)
async def quick_batch_impurity(message: types.Message, state: FSMContext):
    """Ğ¡Ğ¾Ñ€Ğ½Ğ¾ÑÑ‚ÑŒ"""
    try:
        impurity = float(message.text.replace(",", "."))
        await state.update_data(impurity=impurity)

        # Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞ°ĞµĞ¼ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸
        await finish_quick_batch(message, state, message.from_user.id)
        await state.finish()

    except ValueError:
        await message.answer("âŒ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾")


# Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ±Ñ‹ÑÑ‚Ñ€Ğ¾Ğ¹ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸
async def finish_quick_batch(message_or_callback, state: FSMContext, user_id: int):
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ¸ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ² Ğ¿ÑƒĞ»Ğ»"""
    data = await state.get_data()
    pull_id = data.get("pull_id")

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿ÑƒĞ»Ñ‹ Ğ¸Ğ· Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑÑ‚Ğ°
    all_pulls = pulls.get("pulls", {})
    pull = all_pulls.get(pull_id) or all_pulls.get(str(pull_id))

    if not pull:
        if hasattr(message_or_callback, "answer"):
            await message_or_callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½")
        else:
            await message_or_callback.message.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½")
        await state.finish()
        return

    # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ
    batch_id = generate_id()
    batch = {
        "id": batch_id,
        "farmer_id": user_id,
        "culture": pull.get("culture"),
        "volume": data.get("volume"),
        "price": data.get("price"),
        "region": pull.get("region", "?"),
        "status": "active",
        "created_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
    }

    # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ¾ ĞµÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ
    if "nature" in data:
        batch["nature"] = data.get("nature")
        batch["moisture"] = data.get("moisture")
        batch["impurity"] = data.get("impurity")

    # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ
    if user_id not in batches:
        batches[user_id] = []
    batches[user_id].append(batch)

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ² pullparticipants
    all_pullparticipants = pulls.get("pullparticipants", {})
    pull_id_str = str(pull_id)

    if pull_id_str not in all_pullparticipants:
        all_pullparticipants[pull_id_str] = []

    all_pullparticipants[pull_id_str].append(
        {
            "farmer_id": user_id,
            "farmer_name": users[user_id].get("name", "?"),
            "batch_id": batch_id,
            "volume": data.get("volume"),
            "joined_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        }
    )

    # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ² Ğ¿ÑƒĞ»Ğ»
    if "batches" not in pull:
        pull["batches"] = []

    pull["batches"].append(
        {
            "id": batch_id,
            "farmer_id": user_id,
            "culture": batch.get("culture"),
            "volume": batch.get("volume"),
            "price": batch.get("price"),
            "moisture": batch.get("moisture", 0),
            "impurities": batch.get("impurity", 0),
            "joined_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        }
    )

    if "batch_ids" not in pull:
        pull["batch_ids"] = []
    pull["batch_ids"].append(batch_id)

    if "farmer_ids" not in pull:
        pull["farmer_ids"] = []
    if user_id not in pull["farmer_ids"]:
        pull["farmer_ids"].append(user_id)

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ current_volume
    pull["current_volume"] = pull.get("current_volume", 0) + data.get("volume")

    # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ ÑĞ´ĞµĞ»ĞºÑƒ
    deal_id = generate_id()
    deal = {
        "id": deal_id,
        "pull_id": pull_id,
        "batch_id": batch_id,
        "farmer_id": user_id,
        "exporter_id": pull.get("exporter_id"),
        "status": "matched",
        "created_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
    }
    deals[deal_id] = deal

    # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼
    save_batches_to_pickle()
    save_pulls_to_pickle()
    save_deals_to_pickle()

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ
    farmer = users[user_id]
    exporter_id = pull.get("exporter_id")
    exporter = users.get(exporter_id, {})

    target_volume = pull.get("target_volume", 0)
    fill_percent = (
        (pull["current_volume"] / target_volume * 100) if target_volume > 0 else 0
    )

    await bot.send_message(
        user_id,
        f"âœ… <b>ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ° Ğ¸ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ° Ğ² Ğ¿ÑƒĞ»Ğ»!</b>\n\n"
        f"ğŸŒ¾ {batch['culture']} â€¢ {batch['volume']:,.0f} Ñ‚ â€¢ {batch['price']:,.0f} â‚½/Ñ‚\n"
        f"ğŸ“Š ĞŸÑƒĞ»Ğ» Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½: {pull['current_volume']:,.0f}/{target_volume:,.0f} Ñ‚ ({fill_percent:.0f}%)",
        parse_mode="HTML",
    )

    if exporter_id:
        await bot.send_message(
            exporter_id,
            f"ğŸ“¦ <b>ĞĞ¾Ğ²Ğ°Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ° Ğ² Ğ²Ğ°Ñˆ Ğ¿ÑƒĞ»Ğ» #{pull_id}!</b>\n\n"
            f"ğŸ‘¤ Ğ¤ĞµÑ€Ğ¼ĞµÑ€: {farmer.get('name')}\n"
            f"ğŸŒ¾ {batch['culture']} â€¢ {batch['volume']:,.0f} Ñ‚ â€¢ {batch['price']:,.0f} â‚½/Ñ‚\n"
            f"ğŸ“Š Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¾: {pull['current_volume']:,.0f}/{target_volume:,.0f} Ñ‚ ({fill_percent:.0f}%)",
            parse_mode="HTML",
        )

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ»Ğ°
    is_full = False
    if pull["current_volume"] >= target_volume:
        pull["status"] = "filled"
        is_full = True
        logging.info(f"ğŸ‰ ĞŸÑƒĞ» #{pull_id} Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½!")
        # await notify_pull_filled(pull_id)  # Ğ•ÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ Ñ‚Ğ°ĞºĞ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ

    # Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ÑÑ Ğº Ğ¿ÑƒĞ»Ğ»Ñƒ
    keyboard = InlineKeyboardMarkup()
    keyboard.add(
        InlineKeyboardButton("ğŸ“Š Ğš Ğ¿ÑƒĞ»Ğ»Ñƒ", callback_data=f"view_pull:{pull_id}")
    )

    if isinstance(message_or_callback, types.Message):
        await message_or_callback.answer(
            "âœ… Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾! ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ° Ğ² Ğ¿ÑƒĞ»Ğ»", reply_markup=keyboard
        )
    else:
        try:
            await message_or_callback.message.edit_text(
                "âœ… Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾! ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ° Ğ² Ğ¿ÑƒĞ»Ğ»", reply_markup=keyboard
            )
        except:
            await message_or_callback.message.answer(
                "âœ… Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾! ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ° Ğ² Ğ¿ÑƒĞ»Ğ»", reply_markup=keyboard
            )


@dp.callback_query_handler(
    lambda c: c.data.startswith("createbatchforpull:"), state="*"
)
async def create_batch_for_pull_callback(
    callback: types.CallbackQuery, state: FSMContext
):
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ Ğº Ğ¿ÑƒĞ»Ñƒ"""
    try:
        pull_id = parse_callback_id(callback.data)
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
        return

    if pull_id not in pulls.get("pulls", {}):
        await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    pull = pulls["pulls"][pull_id]

    # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ ID Ğ¿ÑƒĞ»Ğ° Ğ¸ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñƒ Ğ´Ğ»Ñ Ğ¿Ğ¾ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ³Ğ¾ Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ
    await state.update_data(create_batch_for_pull_id=pull_id, culture=pull["culture"])

    await callback.message.answer(
        f"**ğŸ“¦ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ´Ğ»Ñ Ğ¿ÑƒĞ»Ğ° #{pull_id}**\n\n"
        f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: **{pull['culture']}**\n\n"
        f"**Ğ¨Ğ°Ğ³ 1/8:** Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´ÑÑ‚Ğ²Ğ°:",
        reply_markup=region_keyboard(),
        parse_mode="Markdown",
    )

    await AddBatch.region.set()  # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: AddBatch Ğ²Ğ¼ĞµÑÑ‚Ğ¾ AddBatchStatesGroup
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("selectbatchjoin:"),
    state=JoinPullStatesGroup.select_batch,
)
async def select_batch_for_join(callback: types.CallbackQuery, state: FSMContext):
    """Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ Ğº Ğ¿ÑƒĞ»Ñƒ"""
    try:
        batch_id = parse_callback_id(callback.data)
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        await state.finish()
        return

    data = await state.get_data()
    pull_id = data.get("join_pull_id")

    if not pull_id:
        await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ÑĞ½Ğ¾Ğ²Ğ°.", show_alert=True)
        await state.finish()
        return

    all_pulls = pulls.get("pulls", {})
    pull = all_pulls.get(pull_id) or all_pulls.get(str(pull_id))
    if not pull:
        await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        await state.finish()
        return

    user_id = callback.from_user.id

    # ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ¿Ğ¾ Ğ²ÑĞµĞ¼ Ñ„ĞµÑ€Ğ¼ĞµÑ€ÑĞºĞ¸Ğ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹Ğ½Ñ‹Ğ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼
    batch = None
    farmer_id = None
    for uid, user_batches in batches.items():
        for b in user_batches:
            if b.get("id") == batch_id:
                batch = b
                farmer_id = uid
                break
        if batch:
            break

    if not batch:
        await callback.answer("âŒ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        await state.finish()
        return

    # Ğ¡Ñ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ğµ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€ Ñ ÑƒÑ‡ĞµÑ‚Ğ¾Ğ¼ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ° Ğ¸ Ğ¿Ñ€Ğ¾Ğ±ĞµĞ»Ğ¾Ğ²
    batch_culture = (batch.get("culture") or "").strip().lower()
    pull_culture = (pull.get("culture") or "").strip().lower()
    if batch_culture != pull_culture:
        await callback.answer(
            "âŒ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ½Ğµ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´Ğ°ĞµÑ‚ Ñ Ğ¿ÑƒĞ»Ğ¾Ğ¼!", show_alert=True
        )
        await state.finish()
        return

    target_volume = pull.get("target_volume", 0)
    current_volume = pull.get("current_volume", 0)
    available = target_volume - current_volume

    if batch.get("volume", 0) > available:
        await callback.answer(
            "âŒ ĞĞ±ÑŠĞµĞ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾Ğ³Ğ¾ Ğ² Ğ¿ÑƒĞ»Ğµ!", show_alert=True
        )
        await state.finish()
        return

    all_pullparticipants = pulls.setdefault("pullparticipants", {})
    pull_id_str = str(pull_id)
    if pull_id_str not in all_pullparticipants:
        all_pullparticipants[pull_id_str] = []

    participant = {
        "farmer_id": user_id,
        "farmer_name": users.get(user_id, {}).get("name", ""),
        "batch_id": batch_id,
        "volume": batch.get("volume", 0),
        "joined_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
    }
    all_pullparticipants[pull_id_str].append(participant)

    pull.setdefault("batch_ids", [])
    if batch_id not in pull["batch_ids"]:
        pull["batch_ids"].append(batch_id)

    pull.setdefault("farmer_ids", [])
    if user_id not in pull["farmer_ids"]:
        pull["farmer_ids"].append(user_id)

    pull.setdefault("batches", [])
    pull["batches"].append(
        {
            "id": batch_id,
            "farmer_id": user_id,
            "culture": batch.get("culture"),
            "volume": batch.get("volume"),
            "price": batch.get("price"),
            "moisture": batch.get("moisture", 0),
            "impurities": batch.get("impurities", 0),
            "quality_class": batch.get("quality_class", ""),
            "joined_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        }
    )

    pull["current_volume"] = current_volume + batch.get("volume", 0)

    # Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ° Ğ¿Ñ€Ğ¸ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğ¸
    if pull["current_volume"] >= target_volume:
        pull["status"] = "filled"
        logging.info(f"ğŸ‰ ĞŸÑƒĞ» #{pull_id} Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½ Ğ½Ğ° 100%!")

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€Ğ° Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°
    exporter_id = pull.get("exporter_id")
    if exporter_id:
        farmer = users.get(farmer_id, {})
        farmer_name = farmer.get("name", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")
        farmer_phone = farmer.get("phone", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        farmer_email = farmer.get("email", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        farmer_company = farmer.get("company_details", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾")

        message_exporter = (
            f"ğŸ‰ <b>ĞŸÑƒĞ» #{pull_id} Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½!</b>\n"
            f"ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {pull.get('culture')}\n"
            f"ĞĞ±ÑŠÑ‘Ğ¼: {pull['current_volume']:,.0f} Ñ‚\n"
            f"Ğ¦ĞµĞ½Ğ°: â‚½{pull.get('price', 0):,.0f}/Ñ‚\n"
            f"ĞŸĞ¾Ñ€Ñ‚: {pull.get('port')}\n"
            f"Ğ“Ğ¾Ñ‚Ğ¾Ğ² Ğº Ğ¾Ñ‚Ğ³Ñ€ÑƒĞ·ĞºĞµ!\n\n"
            f"ğŸ‘¤ <b>Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°:</b>\n"
            f"Ğ˜Ğ¼Ñ: {farmer_name}\n"
            f"ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ: {farmer_company}\n"
            f"Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: {farmer_phone}\n"
            f"Email: {farmer_email}"
        )
        try:
            await bot.send_message(exporter_id, message_exporter, parse_mode="HTML")
        except Exception as e:
            logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ñƒ: {e}")

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ° Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€Ğ°
    exporter = users.get(exporter_id, {})
    if exporter:
        exporter_name = exporter.get("name", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")
        exporter_phone = exporter.get("phone", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        exporter_email = exporter.get("email", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        exporter_company = exporter.get("company_details", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾")

        message_farmer = (
            f"âœ… <b>Ğ’Ñ‹ Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½Ğ¸Ğ»Ğ¸ÑÑŒ Ğº Ğ¿ÑƒĞ»Ñƒ #{pull_id}!</b>\n"
            f"ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {batch.get('culture')}\n"
            f"ĞĞ±ÑŠÑ‘Ğ¼: {batch.get('volume')} Ñ‚\n"
            f"Ğ¦ĞµĞ½Ğ°: {batch.get('price'):,.0f} â‚½/Ñ‚\n\n"
            f"ğŸ‘¤ <b>Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€Ğ°:</b>\n"
            f"Ğ˜Ğ¼Ñ: {exporter_name}\n"
            f"ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ: {exporter_company}\n"
            f"Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: {exporter_phone}\n"
            f"Email: {exporter_email}"
        )
        try:
            await bot.send_message(user_id, message_farmer, parse_mode="HTML")
        except Exception as e:
            logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ñƒ: {e}")

    batch["status"] = "Ğ—Ğ°Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ°"

    save_pulls_to_pickle()
    save_batches_to_pickle()

    try:
        await callback.message.delete()
    except Exception as e:
        logging.warning(f"ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ: {e}")

    fill_percent = (
        (pull["current_volume"] / target_volume) * 100 if target_volume else 0
    )
    remaining = target_volume - pull["current_volume"]

    if pull["status"] == "filled":
        await callback.answer(
            "âœ… ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ°! ĞŸÑƒĞ» Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½ Ğ½Ğ° 100%!", show_alert=True
        )
    else:
        await callback.answer("âœ… Ğ£ÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½Ğ¸Ğ»Ğ¸ÑÑŒ Ğº Ğ¿ÑƒĞ»Ñƒ!", show_alert=True)

    await state.finish()


@dp.callback_query_handler(lambda c: c.data.startswith("viewparticipants:"), state="*")
async def view_pullparticipants(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² Ğ¿ÑƒĞ»Ğ° Ñ Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğ¼Ğ¸ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ğ°Ğ¼Ğ¸"""
    await state.finish()

    try:
        pull_id = parse_callback_id(callback.data)
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿ÑƒĞ»Ñ‹ Ğ¸Ğ· Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑÑ‚Ğ°
    all_pulls = pulls.get("pulls", {})

    if pull_id not in all_pulls:
        await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    pull = all_pulls.get(pull_id) or all_pulls.get(str(pull_id))

    if not pull:
        await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² Ğ¸Ğ· Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑÑ‚Ğ°
    all_pullparticipants = pulls.get("pullparticipants", {})
    participants = all_pullparticipants.get(pull_id, [])

    if not participants:
        await callback.answer("Ğ’ Ğ¿ÑƒĞ»Ğµ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²", show_alert=True)
        return

    msg = f"ğŸ‘¥ <b>Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¸ Ğ¿ÑƒĞ»Ğ° #{pull_id}</b>\n\n"
    msg += f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {pull.get('culture', '?')}\n"
    msg += f"ğŸ“¦ Ğ¦ĞµĞ»ĞµĞ²Ğ¾Ğ¹ Ğ¾Ğ±ÑŠÑ‘Ğ¼: {pull.get('target_volume', 0)} Ñ‚\n"
    msg += f"ğŸ“Š Ğ¢ĞµĞºÑƒÑ‰Ğ¸Ğ¹ Ğ¾Ğ±ÑŠÑ‘Ğ¼: {pull.get('current_volume', 0)} Ñ‚\n"

    target_vol = pull.get("target_volume", 1)
    current_vol = pull.get("current_volume", 0)
    progress = (current_vol / target_vol * 100) if target_vol > 0 else 0

    msg += f"ğŸ“ˆ Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¾: {progress:.1f}%\n\n"
    msg += f"<b>Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¸ ({len(participants)}):</b>\n\n"

    for i, p in enumerate(participants, 1):
        farmer_id = p.get("farmer_id")
        farmer = users.get(farmer_id, {})

        msg += f"{i}. <b>{p.get('farmer_name', '?')}</b>\n"
        msg += f"   ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: {p.get('volume', 0)} Ñ‚\n"

        batch_id = p.get("batch_id")
        batch = None
        if farmer_id in batches:
            for b in batches[farmer_id]:
                if b.get("id") == batch_id:
                    batch = b
                    break

        if batch:
            msg += f"   ğŸ’° Ğ¦ĞµĞ½Ğ°: {batch.get('price', 0):,.0f} â‚½/Ñ‚\n"
            msg += f"   ğŸ“ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½: {batch.get('region', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n"

        msg += f"   ğŸ“… ĞŸÑ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½Ğ¸Ğ»ÑÑ: {p.get('joined_at', '?')}\n"

        phone = farmer.get("phone", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        email = farmer.get("email", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")

        msg += f"   ğŸ“± Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <code>{phone}</code>\n"
        msg += f"   ğŸ“§ Email: <code>{email}</code>\n"
        msg += "\n"

    keyboard = InlineKeyboardMarkup(row_width=1)
    keyboard.add(
        InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğº Ğ¿ÑƒĞ»Ñƒ", callback_data=f"view_pull:{pull_id}")
    )

    await callback.message.edit_text(msg, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("region:"), state=RegistrationStatesGroup.region
)
async def registration_region(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ°"""

    region = callback.data.split(":", 1)[1]

    if region == "other":
        await callback.message.answer("Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ²Ğ°ÑˆĞµĞ³Ğ¾ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ°:")
        return

    await state.update_data(region=region)

    data = await state.get_data()
    user_id = callback.from_user.id
    role = data.get("role")

    logging.info(
        f"ğŸ“ Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğµ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸ user_id={user_id}, role={role}, region={region}"
    )

    users[user_id] = {
        "name": data.get("name"),
        "phone": data.get("phone"),
        "email": data.get("email"),
        "inn": data.get("inn"),
        "ogrn": data.get("ogrn"),
        "company_details": data.get("company_details"),
        "role": role,
        "region": region,
        "registered_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
    }

    save_users_to_pickle()

    # Ğ¡Ğ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ñ Google Sheets
    if gs and gs.spreadsheet:
        try:
            gs.sync_user_to_sheets(users[user_id], user_id)
        except Exception as e:
            logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ñ Google Sheets: {e}")

    await state.finish()

    # âœ… Ğ£Ğ”ĞĞ›Ğ¯Ğ•Ğœ Ğ¡ĞĞĞ‘Ğ©Ğ•ĞĞ˜Ğ• Ğ¡ Ğ’Ğ«Ğ‘ĞĞ ĞĞœ Ğ Ğ•Ğ“Ğ˜ĞĞĞ
    try:
        await callback.message.delete()
    except Exception as e:
        logging.warning(f"âš ï¸ ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ°: {e}")

    keyboard = get_role_keyboard(role)

    role_names_display = {
        "farmer": "Ğ¤ĞµÑ€Ğ¼ĞµÑ€",
        "exporter": "Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€",
        "logistic": "Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚",
        "expeditor": "Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€",
    }

    # âœ… ĞĞ¢ĞŸĞ ĞĞ’Ğ›Ğ¯Ğ•Ğœ ĞĞĞ’ĞĞ• Ğ¡ĞĞĞ‘Ğ©Ğ•ĞĞ˜Ğ• (Ğ½Ğµ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€ÑƒĞµĞ¼)
    await callback.message.answer(
        f"âœ… <b>Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°!</b>\n\n"
        f"ğŸ‘¤ Ğ˜Ğ¼Ñ: {data.get('name')}\n"
        f"ğŸ“± Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: {data.get('phone')}\n"
        f"ğŸ“§ Email: {data.get('email')}\n"
        f"ğŸ­ Ğ Ğ¾Ğ»ÑŒ: {role_names_display.get(role, role)}\n"
        f"ğŸ“ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½: {region}\n\n"
        f"Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ² EXPORTUM!",
        reply_markup=keyboard,
        parse_mode="HTML",
    )

    await callback.answer("âœ… Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°!")


@dp.message_handler(commands=["admin"], state="*")
async def admin_menu(message: types.Message, state: FSMContext):
    """ĞĞ´Ğ¼Ğ¸Ğ½ Ğ¼ĞµĞ½Ñ"""
    await state.finish()

    user_id = message.from_user.id
    if user_id != ADMIN_ID:
        await message.answer("ğŸš« Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ° Ğº ÑÑ‚Ğ¾Ğ¹ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğµ.")
        return

    await message.answer(
        "ğŸ” <b>ĞĞ´Ğ¼Ğ¸Ğ½ Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ</b>\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ:",
        reply_markup=admin_keyboard(),
        parse_mode="HTML",
    )


# âœ… ĞĞ¡Ğ¢ĞĞ’Ğ›Ğ¯Ğ•Ğœ ĞĞĞ—Ğ’ĞĞĞ˜Ğ¯ ĞšĞĞš Ğ•Ğ¡Ğ¢Ğ¬!
# âœ… Ğ¢ĞĞ›Ğ¬ĞšĞ Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ¯Ğ•Ğœ Ğ›ĞĞ“Ğ˜ĞšĞ£ Ğ’ĞĞ£Ğ¢Ğ Ğ˜!


@dp.message_handler(lambda m: m.text == "ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ±Ğ¾Ñ‚Ğ°", state="*")
async def admin_stats_button(message: types.Message, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ±Ğ¾Ñ‚Ğ°"""
    await state.finish()
    user_id = message.from_user.id

    if user_id != ADMIN_ID:
        await message.answer("â›” Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰Ñ‘Ğ½")
        return

    try:
        # Ğ¡Ğ¾Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºÑƒ
        total_users = len(users)
        farmers = len([u for u in users.values() if u.get("role") == "farmer"])
        exporters = len([u for u in users.values() if u.get("role") == "exporter"])
        logists = len([u for u in users.values() if u.get("role") == "logist"])
        expeditors = len([u for u in users.values() if u.get("role") == "expeditor"])

        # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿ĞµÑ€ĞµĞ±Ğ¾Ñ€ batches
        total_batches = sum(len(farmer_batches) for farmer_batches in batches.values())
        active_batches = sum(
            len(
                [
                    b
                    for b in farmer_batches
                    if b.get("status") in ["active", "pending", None]
                ]
            )
            for farmer_batches in batches.values()
        )

        total_pulls = len(pulls)
        open_pulls = len(
            [p for p in pulls.values() if p.get("status") in ["open", "active"]]
        )

        total_deals = len(deals) if "deals" in dir() else 0
        active_deals = (
            len(
                [
                    d
                    for d in deals.values()
                    if d.get("status") not in ["completed", "cancelled"]
                ]
            )
            if "deals" in dir()
            else 0
        )

        total_matches = len(matches) if "matches" in dir() else 0
        active_matches = (
            len([m for m in matches.values() if m.get("status") == "active"])
            if "matches" in dir()
            else 0
        )

        stats_msg = f"""ğŸ“Š <b>Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ±Ğ¾Ñ‚Ğ°</b>

ğŸ‘¥ <b>ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸:</b>
â€¢ Ğ’ÑĞµĞ³Ğ¾: {total_users}
â€¢ ğŸŒ¾ Ğ¤ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ²: {farmers}
â€¢ ğŸ“¦ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ²: {exporters}
â€¢ ğŸšš Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²: {logists}
â€¢ ğŸš› Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²: {expeditors}

ğŸ“¦ <b>ĞŸĞ°Ñ€Ñ‚Ğ¸Ğ¸:</b>
â€¢ Ğ’ÑĞµĞ³Ğ¾: {total_batches}
â€¢ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ…: {active_batches}

ğŸ¯ <b>ĞŸÑƒĞ»Ñ‹:</b>
â€¢ Ğ’ÑĞµĞ³Ğ¾: {total_pulls}
â€¢ ĞÑ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ…: {open_pulls}

ğŸ¤ <b>Ğ¡Ğ´ĞµĞ»ĞºĞ¸:</b>
â€¢ Ğ’ÑĞµĞ³Ğ¾: {total_deals}
â€¢ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ…: {active_deals}

ğŸ”— <b>Ğ¡Ğ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ:</b>
â€¢ Ğ’ÑĞµĞ³Ğ¾: {total_matches}
â€¢ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ…: {active_matches}"""

        await message.answer(stats_msg, parse_mode="HTML")

    except Exception as e:
        logging.error(f"âŒ ĞĞ¨Ğ˜Ğ‘ĞšĞ Ğ² ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞµ: {e}", exc_info=True)
        await message.answer(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)}")


@dp.message_handler(lambda m: m.text == "ğŸ“Š ĞĞ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ°", state="*")
async def admin_analytics_button(message: types.Message, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ ĞĞ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ°"""
    await state.finish()
    user_id = message.from_user.id

    if user_id != ADMIN_ID:
        await message.answer("â›” Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰Ñ‘Ğ½")
        return

    try:
        # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿ĞµÑ€ĞµĞ±Ğ¾Ñ€ batches
        total_batch_volume = 0
        prices = []

        for farmer_id, farmer_batches in batches.items():
            for batch in farmer_batches:
                total_batch_volume += batch.get("volume", 0)
                if batch.get("price"):
                    prices.append(batch["price"])

        avg_price = sum(prices) / len(prices) if prices else 0
        min_price = min(prices) if prices else 0
        max_price = max(prices) if prices else 0

        # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿ĞµÑ€ĞµĞ±Ğ¾Ñ€ batches
        cultures_stats = {}
        for farmer_id, farmer_batches in batches.items():
            for batch in farmer_batches:
                culture = batch.get("culture", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")
                if culture not in cultures_stats:
                    cultures_stats[culture] = {"count": 0, "volume": 0}
                cultures_stats[culture]["count"] += 1
                cultures_stats[culture]["volume"] += batch.get("volume", 0)

        analytics_msg = f"""ğŸ“Š <b>Ğ Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ½Ğ°Ñ Ğ°Ğ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ°</b>

ğŸ“¦ <b>ĞĞ±ÑŠÑ‘Ğ¼Ñ‹:</b>
â€¢ ĞĞ±Ñ‰Ğ¸Ğ¹ Ğ¾Ğ±ÑŠÑ‘Ğ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹: {total_batch_volume:,.0f} Ñ‚

ğŸ’° <b>Ğ¦ĞµĞ½Ñ‹:</b>
â€¢ Ğ¡Ñ€ĞµĞ´Ğ½ÑÑ Ñ†ĞµĞ½Ğ°: {avg_price:,.0f} â‚½/Ñ‚
â€¢ ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ°Ñ: {min_price:,.0f} â‚½/Ñ‚
â€¢ ĞœĞ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ°Ñ: {max_price:,.0f} â‚½/Ñ‚

ğŸŒ¾ <b>ĞŸĞ¾ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°Ğ¼:</b>"""

        for culture, stats in cultures_stats.items():
            analytics_msg += (
                f"\nâ€¢ {culture}: {stats['count']} Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹, {stats['volume']:,.0f} Ñ‚"
            )

        analytics_msg += (
            f"\n\nğŸ“… ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾: {datetime.now().strftime('%d.%m.%Y %H:%M')}"
        )

        await message.answer(analytics_msg, parse_mode="HTML")

    except Exception as e:
        logging.error(f"âŒ ĞĞ¨Ğ˜Ğ‘ĞšĞ Ğ² Ğ°Ğ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞµ: {e}", exc_info=True)
        await message.answer(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)}")


@dp.message_handler(lambda m: m.text == "ğŸ“‚ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", state="*")
async def admin_export_button(message: types.Message, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…"""
    await state.finish()
    user_id = message.from_user.id

    if user_id != ADMIN_ID:
        await message.answer("â›” Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰Ñ‘Ğ½")
        return

    try:
        await message.answer("â³ Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒÑ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…...")

        # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ°Ñ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° batches
        export_data = {
            "users": users,
            "batches": batches,
            "pulls": pulls,
            "shipping_requests": shipping_requests,
            "expeditor_offers": expeditor_offers,
            "exported_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        }

        # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ² Ñ„Ğ°Ğ¹Ğ»
        filename = f"export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(filename, "w", encoding="utf-8") as f:
            json.dump(export_data, f, ensure_ascii=False, indent=2)

        # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ„Ğ°Ğ¹Ğ»
        with open(filename, "rb") as f:
            await message.answer_document(
                f,
                caption=f"ğŸ“‚ <b>Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…</b>\n\n"
                f"ğŸ“… {datetime.now().strftime('%d.%m.%Y %H:%M')}\n"
                f"ğŸ‘¥ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹: {len(users)}\n"
                f"ğŸ“¦ ĞŸĞ°Ñ€Ñ‚Ğ¸Ğ¹: {sum(len(b) for b in batches.values())}\n"
                f"ğŸ¯ ĞŸÑƒĞ»Ğ¾Ğ²: {len(pulls)}",
                parse_mode="HTML",
            )

        # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğ¹ Ñ„Ğ°Ğ¹Ğ»
        os.remove(filename)

    except Exception as e:
        logging.error(f"âŒ ĞĞ¨Ğ˜Ğ‘ĞšĞ Ğ¿Ñ€Ğ¸ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğµ: {e}", exc_info=True)
        await message.answer(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğµ: {str(e)}")


@dp.message_handler(lambda m: m.text == "ğŸ” ĞĞ°Ğ¹Ñ‚Ğ¸ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ", state="*")
async def admin_manual_match(message: types.Message, state: FSMContext):
    """Ğ ÑƒÑ‡Ğ½Ğ¾Ğ¹ Ğ¿Ğ¾Ğ¸ÑĞº ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğ¹"""
    await state.finish()

    user_id = message.from_user.id
    if user_id != ADMIN_ID:
        return

    await message.answer("ğŸ” Ğ—Ğ°Ğ¿ÑƒÑĞº Ğ¿Ğ¾Ğ¸ÑĞºĞ° ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğ¹...")

    matches_found = await auto_match_batches_and_pulls()

    await message.answer(
        f"âœ… <b>ĞŸĞ¾Ğ¸ÑĞº Ğ·Ğ°Ğ²ĞµÑ€ÑˆÑ‘Ğ½!</b>\n\n"
        f"ğŸ” ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğ¹: {matches_found}\n"
        f"ğŸ“Š Ğ’ÑĞµĞ³Ğ¾ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ…: {len([m for m in matches.values() if m.get('status') == 'active'])}",
        parse_mode="HTML",
    )


@dp.message_handler(lambda m: m.text == "â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", state="*")
async def admin_back(message: types.Message, state: FSMContext):
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğ¸Ğ· Ğ°Ğ´Ğ¼Ğ¸Ğ½ Ğ¿Ğ°Ğ½ĞµĞ»Ğ¸"""
    await state.finish()

    user_id = message.from_user.id
    if user_id != ADMIN_ID:
        return
    if user_id in users:
        role = users[user_id].get("role")
        keyboard = get_role_keyboard(role)
        await message.answer("â—€ï¸ Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğ² Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", reply_markup=keyboard)
    else:
        await message.answer("â—€ï¸ Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚")


@dp.message_handler(commands=["match"], state="*")
async def cmd_manual_match(message: types.Message, state: FSMContext):
    """Ğ ÑƒÑ‡Ğ½Ğ¾Ğ¹ Ğ·Ğ°Ğ¿ÑƒÑĞº Ğ¿Ğ¾Ğ¸ÑĞºĞ° ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğ¹"""
    await state.finish()

    user_id = message.from_user.id
    if user_id != ADMIN_ID:
        await message.answer("âŒ Ğ­Ñ‚Ğ° ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ñƒ")
        return

    await message.answer("ğŸ”„ Ğ—Ğ°Ğ¿ÑƒÑĞº Ñ€ÑƒÑ‡Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ¸ÑĞºĞ° ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğ¹...")

    matches_found = await auto_match_batches_and_pulls()

    await message.answer(
        f"âœ… ĞŸĞ¾Ğ¸ÑĞº Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½!\n\n"
        f"ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ½Ğ¾Ğ²Ñ‹Ñ… ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğ¹: {matches_found}\n"
        f"Ğ’ÑĞµĞ³Ğ¾ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğ¹: {len([m for m in matches.values() if m['status'] == 'active'])}"
    )


@dp.message_handler(lambda m: m.text == "ğŸ‘¤ ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ", state="*")
async def cmd_profile(message: types.Message, state: FSMContext):
    """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
    await state.finish()

    user_id = message.from_user.id
    if user_id not in users:
        await message.answer("âŒ Ğ’Ñ‹ Ğ½Ğµ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ /start")
        return

    user = users[user_id]

    profile_text = f"""
ğŸ‘¤ <b>Ğ’Ğ°Ñˆ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ</b>

ğŸ“ Ğ˜Ğ¼Ñ: {user.get('name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}
ğŸ­ Ğ Ğ¾Ğ»ÑŒ: {ROLES.get(user.get('role'), 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}
ğŸ“± Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: {user.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}
ğŸ“§ Email: {user.get('email', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}
ğŸ¢ Ğ˜ĞĞ: {user.get('inn', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}
ğŸ“‹ ĞĞ“Ğ Ğ: {user.get('ogrn', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}
ğŸ“ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½: {user.get('region', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}
ğŸ“… Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ: {user.get('registered_at', 'ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾')}
"""

    if user.get("company_details"):
        profile_text += f"\nğŸ¢ <b>Ğ ĞµĞºĞ²Ğ¸Ğ·Ğ¸Ñ‚Ñ‹ ĞºĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ğ¸:</b>\n{user['company_details']}"

    keyboard = profile_edit_keyboard()

    await message.answer(profile_text, parse_mode="HTML", reply_markup=keyboard)


@dp.callback_query_handler(lambda c: c.data.startswith("edit_profile:"), state="*")
async def start_edit_profile(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ñ‚ÑŒ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ"""
    field = callback.data.split(":", 1)[1]

    await state.update_data(edit_field=field)

    field_names = {
        "phone": "Ğ½Ğ¾Ğ¼ĞµÑ€ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°",
        "email": "email",
        "region": "Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½",
        "company_details": "Ñ€ĞµĞºĞ²Ğ¸Ğ·Ğ¸Ñ‚Ñ‹ ĞºĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ğ¸",
    }

    if field == "region":
        await callback.message.edit_text(
            "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½:", reply_markup=region_keyboard()
        )
    else:
        await callback.message.answer(
            f"Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ {field_names.get(field, 'Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ')}:"
        )

    await EditProfile.new_value.set()
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("region:"), state=EditProfile.new_value
)
async def edit_profile_region(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ° Ğ¿Ñ€Ğ¸ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¸ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ"""
    new_region = callback.data.split(":", 1)[1]

    data = await state.get_data()
    field = data.get("edit_field")
    user_id = callback.from_user.id

    if field != "region":
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°")
        return

    old_value = users[user_id].get("region", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
    users[user_id]["region"] = new_region

    save_users_to_json()

    if gs and gs.spreadsheet:
        gs.update_user_in_sheets(user_id, users[user_id])

    await state.finish()

    role = users[user_id].get("role")
    keyboard = get_role_keyboard(role)

    await callback.message.edit_text(
        f"âœ… Ğ ĞµĞ³Ğ¸Ğ¾Ğ½ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»Ñ‘Ğ½!\n\n"
        f"Ğ¡Ñ‚Ğ°Ñ€Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ: {old_value}\n"
        f"ĞĞ¾Ğ²Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ: {new_region}"
    )

    await callback.message.answer("ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»Ñ‘Ğ½!", reply_markup=keyboard)
    await callback.answer("âœ… Ğ ĞµĞ³Ğ¸Ğ¾Ğ½ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»Ñ‘Ğ½")


@dp.message_handler(state=EditProfile.new_value)
async def edit_profile_value(message: types.Message, state: FSMContext):
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ"""
    user_id = message.from_user.id
    data = await state.get_data()
    field = data.get("edit_field")
    new_value = message.text.strip()

    if field == "email":
        if not validate_email(new_value):
            await message.answer("âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¹ email. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·:")
            return
    elif field == "phone":
        if not validate_phone(new_value):
            await message.answer("âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¹ Ğ½Ğ¾Ğ¼ĞµÑ€ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·:")
            return

    old_value = users[user_id].get(field, "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾")
    users[user_id][field] = new_value

    save_users_to_json()

    if gs and gs.spreadsheet:
        gs.update_user_in_sheets(user_id, users[user_id])

    await state.finish()

    role = users[user_id].get("role")
    keyboard = get_role_keyboard(role)

    field_names = {
        "phone": "Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½",
        "email": "Email",
        "company_details": "Ğ ĞµĞºĞ²Ğ¸Ğ·Ğ¸Ñ‚Ñ‹ ĞºĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ğ¸",
    }

    await message.answer(
        f"âœ… {field_names.get(field, field.capitalize())} Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»Ñ‘Ğ½!",
        reply_markup=keyboard,
    )


@dp.message_handler(lambda m: m.text == "ğŸ“ˆ Ğ¦ĞµĞ½Ñ‹ Ğ½Ğ° Ğ·ĞµÑ€Ğ½Ğ¾", state="*")
async def show_prices_menu(message: types.Message, state: FSMContext):
    """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ñ†ĞµĞ½Ñ‹ ÑÑ€Ğ°Ğ·Ñƒ Ğ±ĞµĞ· Ğ¼ĞµĞ½Ñ"""
    await state.finish()

    prices_msg = format_prices_message()

    keyboard = InlineKeyboardMarkup(row_width=1)
    keyboard.add(
        InlineKeyboardButton("ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ñ†ĞµĞ½Ñ‹", callback_data="refresh_prices")
    )

    await message.answer(prices_msg, parse_mode="HTML", reply_markup=keyboard)


@dp.message_handler(lambda m: m.text == "ğŸ“° ĞĞ¾Ğ²Ğ¾ÑÑ‚Ğ¸ Ñ€Ñ‹Ğ½ĞºĞ°", state="*")
async def show_news_menu(message: types.Message, state: FSMContext):
    """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ğ¾ÑÑ‚Ğ¸ ÑÑ€Ğ°Ğ·Ñƒ Ğ±ĞµĞ· Ğ¼ĞµĞ½Ñ"""
    await state.finish()
    news_msg = format_news_message()
    keyboard = InlineKeyboardMarkup(row_width=1)
    keyboard.add(
        InlineKeyboardButton("ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ğ¾ÑÑ‚Ğ¸", callback_data="refresh_news")
    )

    await message.answer(
        news_msg,
        parse_mode="HTML",
        reply_markup=keyboard,
        disable_web_page_preview=True,
    )


@dp.callback_query_handler(lambda c: c.data == "view_news", state="*")
async def show_news(callback: types.CallbackQuery):
    """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ğ¾ÑÑ‚Ğ¸"""
    news_msg = format_news_message()
    await callback.message.edit_text(
        news_msg, parse_mode="HTML", disable_web_page_preview=True
    )
    await callback.answer()


def parse_soy_from_zol():
    """
    ĞŸĞ°Ñ€ÑĞ¸Ğ½Ğ³ Ñ†ĞµĞ½ Ğ½Ğ° ÑĞ¾Ñ Ñ ZOL.RU (Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ğ°Ğ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ°)

    ZOL.RU Ğ¿ÑƒĞ±Ğ»Ğ¸ĞºÑƒĞµÑ‚ ĞµĞ¶ĞµĞ½ĞµĞ´ĞµĞ»ÑŒĞ½ÑƒÑ Ğ°Ğ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºÑƒ Ñ†ĞµĞ½ Ğ¿Ğ¾ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ°Ğ¼ Ğ Ğ¾ÑÑĞ¸Ğ¸
    Ğ¦ĞµĞ½Ñ‹ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ñ‹ Ğ² Ñ€ÑƒĞ±/ĞºĞ³, ĞºĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ¸Ñ€ÑƒÑÑ‚ÑÑ Ğ² â‚½/Ñ‚

    Returns:
        int: Ğ¡Ñ€ĞµĞ´Ğ½ÑÑ Ñ†ĞµĞ½Ğ° Ğ² â‚½/Ñ‚ Ğ¸Ğ»Ğ¸ None Ğ¿Ñ€Ğ¸ Ğ¾ÑˆĞ¸Ğ±ĞºĞµ
    """
    try:
        logging.info("ğŸŒ± ĞŸĞ°Ñ€ÑĞ¸Ğ½Ğ³ ÑĞ¾Ğ¸ Ñ ZOL.RU...")

        # ZOL.RU Ğ¿ÑƒĞ±Ğ»Ğ¸ĞºÑƒĞµÑ‚ Ğ°Ğ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºÑƒ ĞµĞ¶ĞµĞ½ĞµĞ´ĞµĞ»ÑŒĞ½Ğ¾
        base_urls = [
            "https://www.zol.ru/n/3fa47",  # 01.10.2025
            "https://www.zol.ru/n/3faf3",  # Ñ€ĞµĞ·ĞµÑ€Ğ² 1
            "https://www.zol.ru/n/3f7b3",  # Ñ€ĞµĞ·ĞµÑ€Ğ² 2
            "https://www.zol.ru/soya.htm",  # Ğ¾Ğ±Ñ‰Ğ°Ñ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ğ°
        ]

        for url in base_urls:
            try:
                response = requests.get(
                    url,
                    timeout=10,
                    headers={
                        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
                    },
                )

                if response.status_code != 200:
                    continue

                text = response.text.lower()

                # ĞŸĞ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹ Ğ´Ğ»Ñ Ğ¿Ğ°Ñ€ÑĞ¸Ğ½Ğ³Ğ°
                patterns = [
                    r"ÑĞ¾Ñ\s*[=:]\s*(\d+\.?\d*)",
                    r"soy\s*[=:]\s*(\d+\.?\d*)",
                ]

                prices = []

                for pattern in patterns:
                    matches = re.findall(pattern, text)
                    if matches:
                        for match in matches:
                            try:
                                # Ğ¦ĞµĞ½Ğ° Ğ² Ñ€ÑƒĞ±/ĞºĞ³, Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ´Ğ¸Ğ¼ Ğ² â‚½/Ñ‚
                                price_kg = float(match)
                                price_ton = int(price_kg * 1000)

                                # Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ (18,000 - 60,000 â‚½/Ñ‚)
                                if 18000 <= price_ton <= 60000:
                                    prices.append(price_ton)
                            except Exception as e:
                                continue

                # Ğ£Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ğ´ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ‚Ñ‹
                prices = list(set(prices))

                if prices and len(prices) >= 1:
                    avg = int(sum(prices) / len(prices))
                    logging.info(f"âœ… Ğ¡Ğ¾Ñ (ZOL.RU): Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾ {len(prices)} Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ¾Ğ²")
                    for i, price in enumerate(sorted(prices), 1):
                        logging.info(f"   Ğ ĞµĞ³Ğ¸Ğ¾Ğ½ {i}: {price:,} â‚½/Ñ‚")
                    logging.info(
                        f"âœ… Ğ¡Ğ¾Ñ: ÑÑ€ĞµĞ´Ğ½ÑÑ {avg:,} â‚½/Ñ‚ ({len(prices)} Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ¾Ğ²) [Ğ¡ĞŸĞĞ Ğ¡Ğ•ĞĞ]"
                    )
                    return avg

            except Exception as e:
                logging.debug(f"ĞŸĞ¾Ğ¿Ñ‹Ñ‚ĞºĞ° {url}: {e}")
                continue

        logging.warning("âš ï¸ Ğ¡Ğ¾Ñ (ZOL.RU): Ğ½Ğµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑĞ¿Ğ°Ñ€ÑĞ¸Ñ‚ÑŒ")
        return None

    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ°Ñ€ÑĞ¸Ğ½Ğ³Ğ° ÑĞ¾Ğ¸ Ñ ZOL.RU: {e}")
        return None


def parse_russia_regional_prices():
    """ĞŸĞ°Ñ€ÑĞ¸Ğ½Ğ³ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… Ñ†ĞµĞ½ Ğ½Ğ° Ğ·ĞµÑ€Ğ½Ğ¾ Ğ² Ğ Ğ¾ÑÑĞ¸Ğ¸ Ñ zerno.ru"""

    logging.info("ğŸŒ¾ ĞŸĞ°Ñ€ÑĞ¸Ğ½Ğ³ Ğ Ğ¤: Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ¾...")
    result = {}

    # 1. ĞŸĞ¨Ğ•ĞĞ˜Ğ¦Ğ (Ğ¾ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ ĞºĞ°Ğº ĞµÑÑ‚ÑŒ - Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ğ¾Ñ‚Ğ»Ğ¸Ñ‡Ğ½Ğ¾)
    try:
        url_wheat = "https://www.zerno.ru/regional-prices-wheat-minimum-and-maximum"
        response = requests.get(url_wheat, timeout=10)
        response.raise_for_status()
        soup = BeautifulSoup(response.content, "html.parser")

        table = soup.find("table")
        if table:
            rows = table.find_all("tr")[1:]
            logging.info(f"ğŸ“‹ ĞŸÑˆĞµĞ½Ğ¸Ñ†Ğ°: Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾ ÑÑ‚Ñ€Ğ¾Ğº {len(rows)}")

            wheat_prices = []
            for row in rows:
                cells = row.find_all("td")
                if len(cells) < 2:
                    continue

                region = cells[0].get_text(strip=True)

                for i in range(1, min(4, len(cells))):
                    price_text = cells[i].get_text(strip=True)
                    if not price_text or price_text == "-":
                        continue

                    if "-" in price_text and not price_text.startswith("-"):
                        prices_range = price_text.split("-")
                        for p in prices_range:
                            try:
                                price_clean = re.sub(r"[^0-9]", "", p)
                                if price_clean:
                                    price_value = int(price_clean)
                                    if 8000 <= price_value <= 30000:
                                        wheat_prices.append(price_value)
                                        logging.info(
                                            f"âœ… ĞŸÑˆĞµĞ½Ğ¸Ñ†Ğ°: {price_value} â‚½/Ñ‚ Ğ¸Ğ· {region}"
                                        )
                            except Exception as e:
                                continue
                    else:
                        try:
                            price_clean = re.sub(r"[^0-9]", "", price_text)
                            if price_clean:
                                price_value = int(price_clean)
                                if 8000 <= price_value <= 30000:
                                    wheat_prices.append(price_value)
                                    logging.info(
                                        f"âœ… ĞŸÑˆĞµĞ½Ğ¸Ñ†Ğ°: {price_value} â‚½/Ñ‚ Ğ¸Ğ· {region}"
                                    )
                        except Exception as e:
                            continue

            if wheat_prices:
                result["ĞŸÑˆĞµĞ½Ğ¸Ñ†Ğ°"] = int(sum(wheat_prices) / len(wheat_prices))
                logging.info(
                    f"âœ… ĞŸÑˆĞµĞ½Ğ¸Ñ†Ğ°: ÑÑ€ĞµĞ´Ğ½ÑÑ {result['ĞŸÑˆĞµĞ½Ğ¸Ñ†Ğ°']} â‚½/Ñ‚ ({len(wheat_prices)} Ñ†ĞµĞ½)"
                )
            else:
                result["ĞŸÑˆĞµĞ½Ğ¸Ñ†Ğ°"] = 15000
                logging.warning("âš ï¸ ĞŸÑˆĞµĞ½Ğ¸Ñ†Ğ°: Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ½Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ")
        else:
            result["ĞŸÑˆĞµĞ½Ğ¸Ñ†Ğ°"] = 15000
            logging.warning("âš ï¸ ĞŸÑˆĞµĞ½Ğ¸Ñ†Ğ°: Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°")

    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ°Ñ€ÑĞ¸Ğ½Ğ³Ğ° Ğ¿ÑˆĞµĞ½Ğ¸Ñ†Ñ‹: {e}")
        result["ĞŸÑˆĞµĞ½Ğ¸Ñ†Ğ°"] = 15000

    # 2. Ğ£Ğ›Ğ£Ğ§Ğ¨Ğ•ĞĞĞ«Ğ™ ĞŸĞĞ Ğ¡Ğ˜ĞĞ“ Ğ”Ğ Ğ£Ğ“Ğ˜Ğ¥ ĞšĞ£Ğ›Ğ¬Ğ¢Ğ£Ğ 
    today = datetime.now().strftime("%Y-%m-%d")

    cereals_urls = {
        "Ğ¯Ñ‡Ğ¼ĞµĞ½ÑŒ": f"https://www.zerno.ru/cerealspricesdate/{today}/barley",
        "ĞšÑƒĞºÑƒÑ€ÑƒĞ·Ğ°": f"https://www.zerno.ru/cerealspricesdate/{today}/corn",
        "ĞŸĞ¾Ğ´ÑĞ¾Ğ»Ğ½ĞµÑ‡Ğ½Ğ¸Ğº": f"https://www.zerno.ru/cerealspricesdate/{today}/sunflower",
    }

    fallback_prices = {
        "Ğ¯Ñ‡Ğ¼ĞµĞ½ÑŒ": 14000,
        "ĞšÑƒĞºÑƒÑ€ÑƒĞ·Ğ°": 14000,
        "Ğ¡Ğ¾Ñ": 25000,
        "ĞŸĞ¾Ğ´ÑĞ¾Ğ»Ğ½ĞµÑ‡Ğ½Ğ¸Ğº": 30000,
    }

    price_ranges = {
        "Ğ¯Ñ‡Ğ¼ĞµĞ½ÑŒ": (7000, 25000),
        "ĞšÑƒĞºÑƒÑ€ÑƒĞ·Ğ°": (10000, 30000),  # Ğ ĞĞ¡Ğ¨Ğ˜Ğ Ğ•ĞĞ!
        "Ğ¡Ğ¾Ñ": (18000, 60000),  # Ğ ĞĞ¡Ğ¨Ğ˜Ğ Ğ•ĞĞ!
        "ĞŸĞ¾Ğ´ÑĞ¾Ğ»Ğ½ĞµÑ‡Ğ½Ğ¸Ğº": (15000, 50000),
    }

    for culture, url in cereals_urls.items():
        try:
            response = requests.get(url, timeout=10)

            if response.status_code != 200:
                logging.warning(
                    f"âš ï¸ {culture}: ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ğ° Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° (ĞºĞ¾Ğ´ {response.status_code})"
                )
                result[culture] = fallback_prices[culture]
                continue

            soup = BeautifulSoup(response.content, "html.parser")
            table = soup.find("table")

            if not table:
                logging.warning(f"âš ï¸ {culture}: Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°")
                result[culture] = fallback_prices[culture]
                continue

            prices = []
            rows = table.find_all("tr")
            logging.info(f"ğŸ“‹ {culture}: Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾ ÑÑ‚Ñ€Ğ¾Ğº {len(rows)}")

            for row in rows:
                cells = row.find_all("td")

                # ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ ĞºĞ¾Ñ€Ğ¾Ñ‚ĞºĞ¸Ğµ ÑÑ‚Ñ€Ğ¾ĞºĞ¸
                if len(cells) < 3:
                    continue

                # ĞšĞ›Ğ®Ğ§Ğ•Ğ’ĞĞ• Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ•: ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²ĞºĞ¸
                first_cell = cells[0].get_text(strip=True)
                if any(
                    keyword in first_cell
                    for keyword in ["ĞšĞ»Ğ°ÑÑ", "Ğ“Ğ¾Ñ€Ğ¾Ğ´", "Ñ†ĞµĞ½Ğ°", "Ğ¸Ğ·Ğ¼.", "Ñ‚Ñ€ĞµĞ½Ğ´", "Ğ’Ğ°Ğ»ÑÑ‚Ğ°"]
                ):
                    continue

                # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ³Ğ¾Ñ€Ğ¾Ğ´/Ğ¸ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸Ğº Ğ´Ğ»Ñ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
                city = first_cell if first_cell else "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾"

                # Ğ˜Ñ‰ĞµĞ¼ Ñ†ĞµĞ½Ñƒ Ğ² Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… ĞºĞ¾Ğ»Ğ¾Ğ½ĞºĞ°Ñ… (Ğ¿Ñ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚: 2, 1, 3, 4)
                for col_idx in [2, 1, 3, 4]:
                    if len(cells) <= col_idx:
                        continue

                    price_text = cells[col_idx].get_text(strip=True)

                    # ĞšĞ›Ğ®Ğ§Ğ•Ğ’ĞĞ• Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ•: ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ ÑĞ»ÑƒĞ¶ĞµĞ±Ğ½Ñ‹Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ
                    if not price_text or price_text in [
                        "default_value",
                        "-",
                        "0",
                        "",
                        "Ñ€ÑƒĞ±/Ñ‚",
                    ]:
                        continue

                    try:
                        # Ğ˜Ğ·Ğ²Ğ»ĞµĞºĞ°ĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ†Ğ¸Ñ„Ñ€Ñ‹
                        price_clean = re.sub(r"[^0-9]", "", price_text)
                        if not price_clean:
                            continue

                        price_value = int(price_clean)

                        # Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ñ Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ½Ñ‹Ğ¼Ğ¸ Ğ´Ğ¸Ğ°Ğ¿Ğ°Ğ·Ğ¾Ğ½Ğ°Ğ¼Ğ¸
                        min_p, max_p = price_ranges[culture]
                        if min_p <= price_value <= max_p:
                            prices.append(price_value)
                            logging.info(f"âœ… {culture}: {price_value} â‚½/Ñ‚ Ğ¸Ğ· {city}")
                            break  # ĞĞ°ÑˆĞ»Ğ¸ Ñ†ĞµĞ½Ñƒ, Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´Ğ¸Ğ¼ Ğº ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ¹ ÑÑ‚Ñ€Ğ¾ĞºĞµ
                    except Exception as e:
                        continue

            # Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚
            if prices:
                avg = int(sum(prices) / len(prices))
                result[culture] = avg
                logging.info(f"âœ… {culture}: ÑÑ€ĞµĞ´Ğ½ÑÑ {avg} â‚½/Ñ‚ ({len(prices)} Ñ†ĞµĞ½)")
            else:
                result[culture] = fallback_prices[culture]
                logging.warning(
                    f"âš ï¸ {culture}: Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ½Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ {fallback_prices[culture]} â‚½/Ñ‚"
                )

        except Exception as e:
            result[culture] = fallback_prices[culture]
            logging.error(f"âŒ {culture}: {e}")

    try:
        soy_price = parse_soy_from_zol()

        if soy_price:
            result["Ğ¡Ğ¾Ñ"] = soy_price
        else:
            # Ğ ĞµĞ·ĞµÑ€Ğ²Ğ½Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ½Ğ° Ğ¾ÑĞ½Ğ¾Ğ²Ğµ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ñ… Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
            result["Ğ¡Ğ¾Ñ"] = 28000
            logging.warning("âš ï¸ Ğ¡Ğ¾Ñ: Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ½Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ 28,000 â‚½/Ñ‚")

    except Exception as e:
        result["Ğ¡Ğ¾Ñ"] = 28000
        logging.error(f"âŒ Ğ¡Ğ¾Ñ: {e}, Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ½Ğ¾Ğµ")

    logging.info(f"ğŸ“Š ĞŸĞ°Ñ€ÑĞ¸Ğ½Ğ³ Ğ·Ğ°Ğ²ĞµÑ€ÑˆÑ‘Ğ½: {len(result)} ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€")
    return result


def parse_fob_black_sea():
    """âœ… ĞŸĞ°Ñ€ÑĞ¸Ğ½Ğ³ FOB (Ğ§ĞµÑ€Ğ½Ğ¾Ğµ Ğ¼Ğ¾Ñ€Ğµ)"""
    try:
        url = "https://query1.finance.yahoo.com/v8/finance/chart/ZW=F"
        response = requests.get(url, headers={"User-Agent": "Mozilla/5.0"}, timeout=10)
        data = response.json()

        if "chart" in data and "result" in data["chart"] and data["chart"]["result"]:
            result = data["chart"]["result"][0]
            if "meta" in result and "regularMarketPrice" in result["meta"]:
                price_cents = result["meta"]["regularMarketPrice"]
                price_dollars = price_cents / 100
                fob_price = round(price_dollars * 36.74, 2)
                logging.info(f"âœ… FOB: â‚½{fob_price}/Ñ‚")
                return fob_price

        logging.warning("âš ï¸ FOB: Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ fallback")
        return 210.0

    except Exception as e:
        logging.error(f"âŒ parse_fob_black_sea: {e}")
        return 210.0


def parse_cbot_futures():
    """âœ… ĞŸĞ°Ñ€ÑĞ¸Ğ½Ğ³ Ñ„ÑŒÑÑ‡ĞµÑ€ÑĞ¾Ğ² CBoT"""
    prices = {}

    try:
        symbols = {
            "ĞŸÑˆĞµĞ½Ğ¸Ñ†Ğ° (CBoT)": "ZW=F",
            "ĞšÑƒĞºÑƒÑ€ÑƒĞ·Ğ° (CBoT)": "ZC=F",
            "Ğ¡Ğ¾Ñ (CBoT)": "ZS=F",
        }

        for name, symbol in symbols.items():
            try:
                url = f"https://query1.finance.yahoo.com/v8/finance/chart/{symbol}"
                response = requests.get(
                    url, headers={"User-Agent": "Mozilla/5.0"}, timeout=10
                )
                data = response.json()

                if (
                    "chart" in data
                    and "result" in data["chart"]
                    and data["chart"]["result"]
                ):
                    result = data["chart"]["result"][0]
                    if "meta" in result and "regularMarketPrice" in result["meta"]:
                        price_cents = result["meta"]["regularMarketPrice"]
                        price_dollars = price_cents / 100
                        prices[name] = f"â‚½{price_dollars:.2f}/bu"
                        logging.info(f"âœ… {name}: â‚½{price_dollars:.2f}/bu")
            except Exception as e:
                logging.error(f"âŒ {name}: {e}")
                continue

        if not prices:
            prices = {
                "ĞŸÑˆĞµĞ½Ğ¸Ñ†Ğ° (CBoT)": "â‚½5.50/bu",
                "ĞšÑƒĞºÑƒÑ€ÑƒĞ·Ğ° (CBoT)": "â‚½4.20/bu",
                "Ğ¡Ğ¾Ñ (CBoT)": "â‚½10.80/bu",
            }
            logging.warning("âš ï¸ CBoT: Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ fallback")

        return prices

    except Exception as e:
        logging.error(f"âŒ parse_cbot_futures: {e}")
        return {
            "ĞŸÑˆĞµĞ½Ğ¸Ñ†Ğ° (CBoT)": "â‚½5.50/bu",
            "ĞšÑƒĞºÑƒÑ€ÑƒĞ·Ğ° (CBoT)": "â‚½4.20/bu",
            "Ğ¡Ğ¾Ñ (CBoT)": "â‚½10.80/bu",
        }


def parse_grain_news(limit=5):
    """âœ… ĞŸĞ°Ñ€ÑĞ¸Ğ½Ğ³ Ğ½Ğ¾Ğ²Ğ¾ÑÑ‚ĞµĞ¹ Ñ zerno.ru"""
    newslist = []

    try:
        url = "https://www.zerno.ru"
        headers = {
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            "Accept-Language": "ru-RU,ru;q=0.9",
        }

        response = requests.get(url, headers=headers, timeout=15)
        response.raise_for_status()
        soup = BeautifulSoup(response.text, "html.parser")

        links = soup.find_all("a", href=re.compile(r"/node/\d+"))
        seen_titles = set()

        keywords = [
            "ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚",
            "Ñ€Ğ¾ÑÑĞ¸Ñ",
            "Ğ°ÑÑ‚Ñ€Ğ°Ñ…Ğ°Ğ½ÑŒ",
            "Ğ·ĞµÑ€Ğ½Ğ¾",
            "Ğ¿ÑˆĞµĞ½Ğ¸Ñ†",
            "ÑƒÑ€Ğ¾Ğ¶Ğ°Ğ¹",
            "fob",
            "Ñ‡ĞµÑ€Ğ½Ğ¾Ğµ Ğ¼Ğ¾Ñ€Ğµ",
            "Ñ†ĞµĞ½",
            "Ñ€Ñ‹Ğ½Ğ¾Ğº",
        ]

        for link in links[:20]:
            title = link.text.strip()
            href = link.get("href", "")

            title_lower = title.lower()

            if title and len(title) > 30 and title not in seen_titles:
                if any(kw in title_lower for kw in keywords):
                    seen_titles.add(title)

                    date = datetime.now().strftime("%d.%m.%Y")
                    full_link = (
                        f"https://www.zerno.ru{href}" if href.startswith("/") else href
                    )

                    newslist.append({"title": title, "link": full_link, "date": date})

                    if len(newslist) >= limit:
                        break

        logging.info(f"âœ… Ğ¡Ğ¿Ğ°Ñ€ÑĞµĞ½Ğ¾ Ğ½Ğ¾Ğ²Ğ¾ÑÑ‚ĞµĞ¹: {len(newslist)}")
        return newslist

    except Exception as e:
        logging.error(f"âŒ parse_grain_news: {e}")
        return []


async def update_prices_cache():
    """ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ĞºÑÑˆĞ° Ñ†ĞµĞ½"""
    global prices_cache, last_prices_update

    try:
        logging.info("ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ñ†ĞµĞ½...")
        loop = asyncio.get_event_loop()

        russia_prices = await loop.run_in_executor(None, parse_russia_regional_prices)
        fob_price = await loop.run_in_executor(None, parse_fob_black_sea)
        cbot_prices = await loop.run_in_executor(None, parse_cbot_futures)

        prices_cache = {
            "data": {
                "russia_south": russia_prices,
                "fob": fob_price,
                "cbot": cbot_prices,
            },
            "updated": datetime.now(),
        }

        last_prices_update = datetime.now()
        logging.info("âœ… Ğ¦ĞµĞ½Ñ‹ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ñ‹")

    except Exception as e:
        logging.error(f"âŒ update_prices_cache: {e}")


async def update_news_cache():
    """ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ĞºÑÑˆĞ° Ğ½Ğ¾Ğ²Ğ¾ÑÑ‚ĞµĞ¹ - Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞĞĞ¯ Ğ’Ğ•Ğ Ğ¡Ğ˜Ğ¯"""
    global news_cache

    try:
        logging.info("ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ½Ğ¾Ğ²Ğ¾ÑÑ‚ĞµĞ¹...")
        loop = asyncio.get_event_loop()
        news = await loop.run_in_executor(None, parse_grain_news)

        news_cache = {"data": news, "updated": datetime.now()}

        logging.info(f"âœ… ĞĞ¾Ğ²Ğ¾ÑÑ‚Ğ¸ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ñ‹: {len(news)} Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹")

    except Exception as e:
        logging.error(f"âŒ update_news_cache: {e}")
        news_cache = {"data": [], "updated": datetime.now()}


def load_users_from_json():
    """Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ¸Ğ· JSON"""
    global users
    try:
        if os.path.exists(USERS_FILE):
            with open(USERS_FILE, "r", encoding="utf-8") as f:
                loaded = json.load(f)
                users = {int(k): v for k, v in loaded.items()}
            logging.info(f"âœ… ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸ Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ñ‹: {len(users)}")
        else:
            logging.info("â„¹ï¸ Ğ¤Ğ°Ğ¹Ğ» Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½, ÑĞ¾Ğ·Ğ´Ğ°Ğ½ Ğ½Ğ¾Ğ²Ñ‹Ğ¹")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹: {e}")


def save_users_to_json():
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ² JSON"""
    try:
        with open(USERS_FILE, "w", encoding="utf-8") as f:
            json.dump(users, f, ensure_ascii=False, indent=2)
        logging.info("âœ… ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ñ‹")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹: {e}")


def load_batches_from_pickle():
    """Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ¸Ğ· Ñ„Ğ°Ğ¹Ğ»Ğ°"""
    global batches
    try:
        file_path = os.path.join(DATA_DIR, "batches.pkl")
        if os.path.exists(file_path):
            with open(file_path, "rb") as f:
                loaded_data = pickle.load(f)

            if isinstance(loaded_data, dict):
                # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñƒ
                first_key = next(iter(loaded_data), None)

                if first_key and isinstance(loaded_data[first_key], list):
                    # ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞ«Ğ™ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚: {user_id: [batches]}
                    batches = loaded_data
                    total_batches = sum(
                        len(b) for b in batches.values() if isinstance(b, list)
                    )
                    unique_farmers = len(batches)
                    logging.info(
                        f"âœ… Ğ—Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ğ¾ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹: {total_batches} Ğ¾Ñ‚ {unique_farmers} Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ²"
                    )

                elif first_key and isinstance(loaded_data[first_key], dict):
                    # ĞĞ•ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞ«Ğ™ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚: {batch_id: batch}
                    # ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¾Ğ±Ñ€Ğ°Ñ‚Ğ½Ğ¾ Ğ² {user_id: [batches]}
                    logging.warning("âš ï¸ ĞĞ±Ğ½Ğ°Ñ€ÑƒĞ¶ĞµĞ½ Ğ½ĞµĞ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚, ĞºĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼...")
                    batches = {}
                    for batch_id, batch in loaded_data.items():
                        user_id = batch.get("user_id") or batch.get("farmer_id")
                        if user_id:
                            if user_id not in batches:
                                batches[user_id] = []
                            batches[user_id].append(batch)

                    total_batches = sum(len(b) for b in batches.values())
                    logging.info(
                        f"âœ… ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾ {total_batches} Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ² Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚"
                    )
                else:
                    batches = {}
                    logging.warning("âš ï¸ ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ batches.pkl")
            else:
                batches = {}
                logging.warning("âš ï¸ ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ñ‹Ğ¹ Ñ‚Ğ¸Ğ¿ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… batches.pkl")
        else:
            batches = {}
            logging.info("â„¹ï¸ Ğ¤Ğ°Ğ¹Ğ» batches.pkl Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹: {e}")
        batches = {}


async def load_requests_from_file():
    """Ğ—Ğ°Ğ³Ñ€ÑƒĞ¶Ğ°ĞµÑ‚ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ¸Ğ· Ñ„Ğ°Ğ¹Ğ»Ğ° Ğ¿Ñ€Ğ¸ ÑÑ‚Ğ°Ñ€Ñ‚Ğµ Ğ±Ğ¾Ñ‚Ğ°"""
    global user_requests
    try:
        with open("requests.json", "r", encoding="utf-8") as f:
            data = json.load(f)
            user_requests = {int(k): v for k, v in data.items()}
            logging.info(f"âœ… Ğ—Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ğ¾ {len(user_requests)} Ğ·Ğ°ÑĞ²Ğ¾Ğº Ğ¸Ğ· Ñ„Ğ°Ğ¹Ğ»Ğ°")
    except FileNotFoundError:
        logging.info("â„¹ï¸ Ğ¤Ğ°Ğ¹Ğ» requests.json Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ (Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¹ Ğ·Ğ°Ğ¿ÑƒÑĞº)")
        user_requests = {}
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸ Ğ·Ğ°ÑĞ²Ğ¾Ğº: {e}")
        user_requests = {}


def save_requests_to_file():
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµÑ‚ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ² JSON Ñ„Ğ°Ğ¹Ğ»"""
    global user_requests
    try:
        with open("requests.json", "w", encoding="utf-8") as f:
            data_to_save = {str(k): v for k, v in user_requests.items()}
            json.dump(data_to_save, f, ensure_ascii=False, indent=2)
        logging.info(f"âœ… Ğ—Ğ°ÑĞ²ĞºĞ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ñ‹: {len(user_requests)} Ğ·Ğ°ÑĞ²Ğ¾Ğº")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ğ·Ğ°ÑĞ²Ğ¾Ğº: {e}")


def save_batches_to_pickle():
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ² pickle"""
    global batch_counter
    try:
        os.makedirs("data", exist_ok=True)

        # âœ… ĞŸĞ ĞĞ’Ğ•Ğ Ğ¯Ğ•Ğœ Ğ§Ğ¢Ğ Ğ¡ĞĞ¥Ğ ĞĞĞ¯Ğ•Ğœ Ğ¡Ğ›ĞĞ’ĞĞ Ğ¬
        if not isinstance(batches, dict):
            logging.error(f"âŒ batches Ğ¸Ğ¼ĞµĞµÑ‚ Ğ½ĞµĞ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ‚Ğ¸Ğ¿: {type(batches)}")
            return

        with open("data/batches.pkl", "wb") as f:
            pickle.dump(batches, f)

        # âœ… Ğ¡ĞĞ¥Ğ ĞĞĞ¯Ğ•Ğœ batch_counter
        with open("data/batch_counter.pkl", "wb") as f:
            pickle.dump(batch_counter, f)

        total_batches = sum(len(batch_list) for batch_list in batches.values())
        logging.info(
            f"âœ… ĞŸĞ°Ñ€Ñ‚Ğ¸Ğ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ñ‹: {total_batches} Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹, batch_counter={batch_counter}"
        )
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹: {e}")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ˜ Ğ¡ĞĞ¥Ğ ĞĞĞ•ĞĞ˜Ğ¯/Ğ—ĞĞ“Ğ Ğ£Ğ—ĞšĞ˜ ĞŸĞ£Ğ›ĞĞ’ Ğ˜ ĞŸĞĞ›Ğ¬Ğ—ĞĞ’ĞĞ¢Ğ•Ğ›Ğ•Ğ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


def save_pulls_to_pickle():
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ¾Ğ² Ğ² pickle Ñ„Ğ°Ğ¹Ğ» Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¾Ğ¹ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹ Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸ĞµĞ¼ Ğ¿Ğ°Ğ¿ĞºĞ¸"""
    global pulls

    try:
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹
        if not isinstance(pulls, dict):
            logging.error(f"âŒ pulls Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ±Ñ‹Ñ‚ÑŒ dict, Ğ° Ğ½Ğµ {type(pulls)}")
            pulls = {"pulls": {}, "pullparticipants": {}}

        if "pulls" not in pulls:
            pulls["pulls"] = {}
        if "pullparticipants" not in pulls:
            pulls["pullparticipants"] = {}

        pulls_dict = pulls.get("pulls", {})
        if pulls_dict:
            first_key = next(iter(pulls_dict))
            first_value = pulls_dict[first_key]
            if not (
                isinstance(first_value, dict)
                and ("farmer_ids" in first_value or "created_at" in first_value)
            ):
                logging.error("âŒ ĞšĞ Ğ˜Ğ¢Ğ˜Ğ§Ğ•Ğ¡ĞšĞĞ¯ ĞĞ¨Ğ˜Ğ‘ĞšĞ: pulls['pulls'] - ÑÑ‚Ğ¾ ĞĞ”Ğ˜Ğ Ğ¿ÑƒĞ»!")
                logging.warning("ğŸ”§ Ğ˜ÑĞ¿Ñ€Ğ°Ğ²Ğ»ÑÑ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñƒ Ğ½Ğ° Ğ¿ÑƒÑÑ‚ÑƒÑ...")
                pulls = {"pulls": {}, "pullparticipants": {}}

        # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ¿Ğ°Ğ¿ĞºÑƒ, ĞµÑĞ»Ğ¸ Ğ½Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚
        dir_path = os.path.dirname(PULLS_FILE)
        if dir_path and not os.path.exists(dir_path):
            os.makedirs(dir_path, exist_ok=True)
            logging.info(f"âœ… Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ° Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ´Ğ»Ñ Ğ¿ÑƒĞ»Ğ¾Ğ²: {dir_path}")

        # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ñ„Ğ°Ğ¹Ğ»
        with open(PULLS_FILE, "wb") as f:
            pickle.dump(pulls, f, protocol=pickle.HIGHEST_PROTOCOL)

        pulls_count = len(pulls.get("pulls", {}))
        participants_count = len(pulls.get("pullparticipants", {}))

        logging.info(f"âœ… save_pulls_to_pickle() - ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¾ {pulls_count} Ğ¿ÑƒĞ»Ğ¾Ğ²")
        logging.info(
            f"âœ… save_pulls_to_pickle() - {participants_count} Ğ³Ñ€ÑƒĞ¿Ğ¿ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²"
        )

        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ„Ğ°Ğ¹Ğ»Ğ°
        if not os.path.isfile(PULLS_FILE):
            logging.error(f"âŒ Ğ¤Ğ°Ğ¹Ğ» Ğ¿ÑƒĞ»Ğ¾Ğ² Ğ½Ğµ ÑĞ¾Ğ·Ğ´Ğ°Ğ½: {PULLS_FILE}")
        else:
            logging.info(
                f"âœ… Ğ¤Ğ°Ğ¹Ğ» Ğ¿ÑƒĞ»Ğ¾Ğ² ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ ÑĞ¾Ñ…Ñ€Ğ°Ğ½Ñ‘Ğ½: {os.path.abspath(PULLS_FILE)}"
            )

        return True

    except Exception as e:
        logging.error(f"âŒ save_pulls_to_pickle() error: {e}", exc_info=True)
        return False


def load_pulls_from_pickle():
    """Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ğ¿ÑƒĞ»Ğ¾Ğ² Ğ¸Ğ· pickle Ñ„Ğ°Ğ¹Ğ»Ğ° Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¾Ğ¹ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹"""
    global pulls, pull_counter
    pull_counter = 0

    try:
        if os.path.exists(PULLS_FILE):
            with open(PULLS_FILE, "rb") as f:
                data = pickle.load(f)

            logging.info(f"ğŸ“‚ Ğ—Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½ Ñ„Ğ°Ğ¹Ğ» pulls.pkl, Ñ‚Ğ¸Ğ¿: {type(data)}")

            if isinstance(data, dict):
                if "pulls" in data and "pullparticipants" in data:
                    logging.info(
                        "âœ… ĞĞ±Ğ½Ğ°Ñ€ÑƒĞ¶ĞµĞ½Ğ° Ğ½Ğ¾Ğ²Ğ°Ñ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ñ 'pulls' Ğ¸ 'pullparticipants'"
                    )
                    if isinstance(data.get("pulls"), dict):
                        if (
                            "farmer_ids" in data["pulls"]
                            or "batch_ids" in data["pulls"]
                        ):
                            logging.error("âŒ ĞĞ¨Ğ˜Ğ‘ĞšĞ: pulls['pulls'] - ÑÑ‚Ğ¾ ĞĞ”Ğ˜Ğ Ğ¿ÑƒĞ»!")
                            logging.warning("ğŸ”§ Ğ˜ÑĞ¿Ñ€Ğ°Ğ²Ğ»ÑÑ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñƒ...")
                            pulls = {"pulls": {}, "pullparticipants": {}}
                            pull_counter = 0
                            logging.info("âœ… Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ° Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ°Ñ Ğ¿ÑƒÑÑ‚Ğ°Ñ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ°")
                        else:
                            pulls = data
                            if pulls.get("pulls"):
                                try:
                                    pull_counter = (
                                        max(int(k) for k in pulls["pulls"].keys()) + 1
                                    )
                                except (ValueError, TypeError):
                                    pull_counter = len(pulls.get("pulls", {})) + 1
                            else:
                                pull_counter = 0
                    else:
                        logging.warning("âš ï¸ pulls['pulls'] Ğ½Ğµ ÑĞ²Ğ»ÑĞµÑ‚ÑÑ dict")
                        pulls = {"pulls": {}, "pullparticipants": {}}
                        pull_counter = 0
                else:
                    logging.warning("âš ï¸ ĞĞ±Ğ½Ğ°Ñ€ÑƒĞ¶ĞµĞ½Ğ° ÑÑ‚Ğ°Ñ€Ğ°Ñ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ°")
                    pulls = {"pulls": data, "pullparticipants": {}}
                    try:
                        pull_counter = max(int(k) for k in data.keys()) + 1
                    except (ValueError, TypeError):
                        pull_counter = len(data) + 1
            else:
                logging.warning(f"âš ï¸ ĞĞµĞ¾Ğ¶Ğ¸Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ñ‚Ğ¸Ğ¿ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…: {type(data)}")
                pulls = {"pulls": {}, "pullparticipants": {}}
                pull_counter = 0

            pulls_count = len(pulls.get("pulls", {}))
            participants_count = len(pulls.get("pullparticipants", {}))
            logging.info(
                f"âœ… load_pulls_from_pickle() - Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ğ¾ {pulls_count} Ğ¿ÑƒĞ»Ğ¾Ğ², pull_counter={pull_counter}"
            )
            logging.info(
                f"âœ… load_pulls_from_pickle() - {participants_count} Ğ³Ñ€ÑƒĞ¿Ğ¿ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²"
            )

            if pulls.get("pullparticipants"):
                logging.info(
                    f"   ğŸ“Š pullparticipants.keys() = {list(pulls.get('pullparticipants', {}).keys())}"
                )

            return True

        else:
            logging.info("pulls.pkl Ğ½Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚, ÑĞ¾Ğ·Ğ´Ğ°Ñ Ğ½Ğ¾Ğ²ÑƒÑ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñƒ")
            pulls = {"pulls": {}, "pullparticipants": {}}
            pull_counter = 0
            return False

    except Exception as e:
        logging.error(f"âŒ load_pulls_from_pickle() error: {e}", exc_info=True)
        pulls = {"pulls": {}, "pullparticipants": {}}
        pull_counter = 0
        return False


def save_batches_to_pickle():
    """âœ… ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞĞ• ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹"""
    global batches
    try:
        with open(BATCHESFILE, "wb") as f:
            pickle.dump(batches, f, protocol=pickle.HIGHEST_PROTOCOL)
        logging.info(
            f"âœ… save_batches_to_pickle() - ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¾ {sum(len(b) for b in batches.values())} Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹"
        )
        return True
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹: {e}", exc_info=True)
        return False


def load_pulls_from_pickle():
    """Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ğ¿ÑƒĞ»Ğ¾Ğ² Ğ¸Ğ· pickle Ñ„Ğ°Ğ¹Ğ»Ğ°"""
    global pulls, pull_counter
    pull_counter = 0

    try:
        if not os.path.exists(PULLS_FILE):
            logging.info("â„¹ï¸ pulls.pkl Ğ½Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚, ÑĞ¾Ğ·Ğ´Ğ°Ñ Ğ½Ğ¾Ğ²ÑƒÑ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñƒ")
            pulls = {"pulls": {}, "pullparticipants": {}}
            pull_counter = 0
            return False

        with open(PULLS_FILE, "rb") as f:
            data = pickle.load(f)

        logging.info(f"ğŸ“‚ Ğ—Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½ Ñ„Ğ°Ğ¹Ğ» pulls.pkl, Ñ‚Ğ¸Ğ¿: {type(data)}")

        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñƒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
        if not isinstance(data, dict):
            logging.error(f"âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¹ Ñ‚Ğ¸Ğ¿ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…: {type(data)}")
            pulls = {"pulls": {}, "pullparticipants": {}}
            pull_counter = 0
            return False

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ĞĞŸĞ Ğ•Ğ”Ğ•Ğ›Ğ¯Ğ•Ğœ Ğ¡Ğ¢Ğ Ğ£ĞšĞ¢Ğ£Ğ Ğ£
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        if "pulls" in data and "pullparticipants" in data:
            # ĞĞĞ’ĞĞ¯ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ°: {'pulls': {...}, 'pullparticipants': {...}}
            logging.info("âœ… ĞĞ±Ğ½Ğ°Ñ€ÑƒĞ¶ĞµĞ½Ğ° ĞĞĞ’ĞĞ¯ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ñ 'pulls' Ğ¸ 'pullparticipants'")

            pulls_dict = data.get("pulls", {})
            participants_dict = data.get("pullparticipants", {})

            # âœ… ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞĞ¯ ĞŸĞ ĞĞ’Ğ•Ğ ĞšĞ: Ğ¡Ğ¼Ğ¾Ñ‚Ñ€Ğ¸Ğ¼ Ğ½Ğ° ĞŸĞ•Ğ Ğ’Ğ«Ğ™ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚
            if pulls_dict:
                first_key = next(iter(pulls_dict))
                first_value = pulls_dict[first_key]

                # Ğ•ÑĞ»Ğ¸ Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¹ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚ - ÑÑ‚Ğ¾ Ğ¡Ğ›ĞĞ’ĞĞ Ğ¬ Ñ Ğ¿Ğ¾Ğ»ÑĞ¼Ğ¸ Ğ¿ÑƒĞ»Ğ° (Ğ° Ğ½Ğµ Ğ¾Ğ´Ğ¸Ğ½ Ğ¿ÑƒĞ»)
                if isinstance(first_value, dict):
                    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ñ‡Ñ‚Ğ¾ ÑÑ‚Ğ¾ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ Ğ¡Ğ›ĞĞ’ĞĞ Ğ¬ Ğ¿ÑƒĞ»Ğ¾Ğ²
                    has_pull_fields = any(
                        field in first_value
                        for field in [
                            "id",
                            "farmer_ids",
                            "batches",
                            "status",
                            "created_at",
                            "culture",
                        ]
                    )

                    if has_pull_fields:
                        # âœ… ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞ: Ğ­Ñ‚Ğ¾ ÑĞ»Ğ¾Ğ²Ğ°Ñ€ÑŒ Ğ¿ÑƒĞ»Ğ¾Ğ² {'PULL_1': {pull}, 'PULL_2': {pull}}
                        logging.info(
                            "âœ… pulls['pulls'] - ÑÑ‚Ğ¾ Ğ¡Ğ›ĞĞ’ĞĞ Ğ¬ Ğ¿ÑƒĞ»Ğ¾Ğ² (Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾)"
                        )
                        pulls = data
                        pull_counter = len(pulls_dict)
                    else:
                        # âŒ ĞĞ¨Ğ˜Ğ‘ĞšĞ: ĞĞ´Ğ¸Ğ½ Ğ¿ÑƒĞ» Ğ¿Ğ¾Ğ¿Ğ°Ğ» Ğ² ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñƒ
                        logging.error(
                            "âŒ ĞĞ¨Ğ˜Ğ‘ĞšĞ: pulls['pulls'] ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ ĞĞ”Ğ ĞŸĞ£Ğ› Ğ²Ğ¼ĞµÑÑ‚Ğ¾ ÑĞ»Ğ¾Ğ²Ğ°Ñ€Ñ!"
                        )
                        logging.warning("ğŸ”§ Ğ˜ÑĞ¿Ñ€Ğ°Ğ²Ğ»ÑÑ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñƒ...")
                        pulls = {"pulls": {}, "pullparticipants": {}}
                        pull_counter = 0
                else:
                    logging.error(
                        f"âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¹ Ñ‚Ğ¸Ğ¿ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ Ğ² pulls['pulls']: {type(first_value)}"
                    )
                    pulls = {"pulls": {}, "pullparticipants": {}}
                    pull_counter = 0
            else:
                # pulls['pulls'] Ğ¿ÑƒÑÑ‚ - ÑÑ‚Ğ¾ Ğ½Ğ¾Ñ€Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾
                logging.info("â„¹ï¸ pulls['pulls'] Ğ¿ÑƒÑÑ‚")
                pulls = data
                pull_counter = 0

        else:
            # Ğ¡Ğ¢ĞĞ ĞĞ¯ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ°: Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ ÑĞ»Ğ¾Ğ²Ğ°Ñ€ÑŒ Ğ¿ÑƒĞ»Ğ¾Ğ² Ğ¸Ğ»Ğ¸ Ğ½ĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚
            logging.warning(
                "âš ï¸ ĞĞ±Ğ½Ğ°Ñ€ÑƒĞ¶ĞµĞ½Ğ° Ğ¡Ğ¢ĞĞ ĞĞ¯ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° (Ğ±ĞµĞ· 'pulls' Ğ¸ 'pullparticipants')"
            )

            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ñ‡Ñ‚Ğ¾ ÑÑ‚Ğ¾ ÑĞ»Ğ¾Ğ²Ğ°Ñ€ÑŒ Ğ¿ÑƒĞ»Ğ¾Ğ², Ğ° Ğ½Ğµ Ğ¾Ğ´Ğ¸Ğ½ Ğ¿ÑƒĞ»
            if data:
                first_key = next(iter(data))
                first_value = data[first_key]

                if isinstance(first_value, dict) and any(
                    field in first_value
                    for field in ["id", "farmer_ids", "batches", "status"]
                ):
                    # Ğ­Ñ‚Ğ¾ ÑĞ»Ğ¾Ğ²Ğ°Ñ€ÑŒ Ğ¿ÑƒĞ»Ğ¾Ğ² - ĞºĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ² Ğ½Ğ¾Ğ²ÑƒÑ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñƒ
                    logging.info("ğŸ”„ ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ¸Ñ€ÑƒÑ ÑÑ‚Ğ°Ñ€ÑƒÑ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñƒ Ğ² Ğ½Ğ¾Ğ²ÑƒÑ...")
                    pulls = {"pulls": data, "pullparticipants": {}}
                    pull_counter = len(data)
                else:
                    # ĞĞ´Ğ¸Ğ½ Ğ¿ÑƒĞ» - Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿ÑƒÑÑ‚Ğ¾
                    logging.error("âŒ ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ°Ñ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ°, Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€ÑƒÑ Ğ¿ÑƒÑÑ‚Ğ¾")
                    pulls = {"pulls": {}, "pullparticipants": {}}
                    pull_counter = 0
            else:
                pulls = {"pulls": {}, "pullparticipants": {}}
                pull_counter = 0

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Ğ›ĞĞ“Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ• Ğ Ğ•Ğ—Ğ£Ğ›Ğ¬Ğ¢ĞĞ¢Ğ
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        pulls_count = len(pulls.get("pulls", {}))
        participants_count = len(pulls.get("pullparticipants", {}))

        logging.info(
            f"âœ… load_pulls_from_pickle() - Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ğ¾ {pulls_count} Ğ¿ÑƒĞ»Ğ¾Ğ² (pull_counter={pull_counter})"
        )
        logging.info(
            f"âœ… load_pulls_from_pickle() - {participants_count} Ğ³Ñ€ÑƒĞ¿Ğ¿ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²"
        )

        if pulls_count > 0:
            pull_ids = list(pulls.get("pulls", {}).keys())[:3]  # ĞŸĞµÑ€Ğ²Ñ‹Ğµ 3 ID
            logging.info(f"   ğŸ“Š ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹ pull_id: {pull_ids}")

        if participants_count > 0:
            participant_ids = list(pulls.get("pullparticipants", {}).keys())[:3]
            logging.info(f"   ğŸ“Š ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹ pullparticipants: {participant_ids}")

        return True

    except Exception as e:
        logging.error(f"âŒ load_pulls_from_pickle() error: {e}", exc_info=True)
        pulls = {"pulls": {}, "pullparticipants": {}}
        pull_counter = 0
        return False


def save_users_to_pickle():
    """âœ… ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞĞ• ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹"""
    global users
    try:
        with open(USERSFILE, "wb") as f:
            pickle.dump(users, f, protocol=pickle.HIGHEST_PROTOCOL)
        logging.info(
            f"âœ… save_users_to_pickle() - ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¾ {len(users)} Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹"
        )
        return True
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹: {e}", exc_info=True)
        return False


def load_users_from_pickle():
    """âœ… ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞĞ¯ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹"""
    global users
    try:
        if os.path.exists(USERSFILE):
            with open(USERSFILE, "rb") as f:
                loaded = pickle.load(f)
                if isinstance(loaded, dict):
                    users = loaded
                    logging.info(
                        f"âœ… load_users_from_pickle() - Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ğ¾ {len(users)} Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹"
                    )
                    return True
                else:
                    logging.warning("âš ï¸ users.pkl Ğ¸Ğ¼ĞµĞµÑ‚ Ğ½ĞµĞ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚")
                    users = {}
                    return False
        else:
            logging.info("ğŸ“‚ Ğ¤Ğ°Ğ¹Ğ» users.pkl Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½")
            users = {}
            return False
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹: {e}", exc_info=True)
        users = {}
        return False


class GoogleSheetsManager:
    """ĞœĞµĞ½ĞµĞ´Ğ¶ĞµÑ€ Ğ´Ğ»Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ñ Google Sheets"""

    def __init__(self, credentials_file, spreadsheet_id):
        self.spreadsheet_id = spreadsheet_id
        self.client = None
        self.spreadsheet = None

        try:
            if not os.path.exists(credentials_file):
                logging.warning(
                    f"âš ï¸ Ğ¤Ğ°Ğ¹Ğ» {credentials_file} Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½. Google Sheets Ğ±ÑƒĞ´ĞµÑ‚ Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½."
                )
                return

            scope = [
                "https://spreadsheets.google.com/feeds",
                "https://www.googleapis.com/auth/drive",
            ]

            creds = Credentials.from_service_account_file(
                credentials_file, scopes=scope
            )
            self.client = gspread.authorize(creds)
            self.spreadsheet = self.client.open_by_key(spreadsheet_id)
            logging.info("âœ… Google Sheets Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾")

        except Exception as e:
            logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ Ğº Google Sheets: {e}")

    def get_or_create_worksheet(self, title, headers):
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¸Ğ»Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ worksheet"""
        if not self.spreadsheet:
            return None

        try:
            worksheet = self.spreadsheet.worksheet(title)
        except Exception as e:
            worksheet = self.spreadsheet.add_worksheet(
                title=title, rows=1000, cols=len(headers)
            )
            worksheet.append_row(headers)
            logging.info(f"âœ… Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½ worksheet: {title}")

        return worksheet

    def update_user_in_sheets(self, user_id, user_data):
        """ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¸Ğ»Ğ¸ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ² Google Sheets"""
        try:
            if not self.spreadsheet:
                logging.error("âŒ ĞĞµÑ‚ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ Ğº Google Sheets")
                return

            headers = [
                "User ID",
                "Ğ˜Ğ¼Ñ",
                "Ğ Ğ¾Ğ»ÑŒ",
                "Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½",
                "Email",
                "Ğ˜ĞĞ",
                "Ğ ĞµĞ³Ğ¸Ğ¾Ğ½",
                "Ğ ĞµĞºĞ²Ğ¸Ğ·Ğ¸Ñ‚Ñ‹",
                "Ğ”Ğ°Ñ‚Ğ° Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸",
                "ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾",
            ]
            worksheet = self.get_or_create_worksheet("Users", headers)

            if not worksheet:
                return

            row_data = [
                str(user_id),
                str(user_data.get("name", "")),
                str(user_data.get("role", "")),
                str(user_data.get("phone", "")),
                str(user_data.get("email", "")),
                str(user_data.get("inn", "")),
                str(user_data.get("region", "")),
                str(user_data.get("company_requisites", "")),
                str(
                    user_data.get(
                        "registration_date",
                        datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    )
                ),
                datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            ]

            try:
                cell = worksheet.find(str(user_id))
                if cell:
                    worksheet.update(f"A{cell.row}:J{cell.row}", [row_data])
                    logging.info(f"âœ… ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ {user_id} Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½ Ğ² Google Sheets")
                else:
                    worksheet.append_row(row_data)
                    logging.info(f"âœ… ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ {user_id} Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½ Ğ² Google Sheets")
            except Exception as e:
                worksheet.append_row(row_data)
                logging.info(f"âœ… ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ {user_id} Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½ Ğ² Google Sheets")

        except Exception as e:
            logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ² Google Sheets: {e}")

    def sync_batch_to_sheets(self, batch):
        """Ğ¡Ğ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ° Ğ² Google Sheets"""
        try:
            if not self.spreadsheet:
                logging.error("âŒ ĞĞµÑ‚ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ Ğº Google Sheets")
                return

            headers = [
                "ID",
                "Ğ¤ĞµÑ€Ğ¼ĞµÑ€ ID",
                "ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°",
                "ĞĞ±ÑŠÑ‘Ğ¼ (Ñ‚)",
                "Ğ¦ĞµĞ½Ğ° (â‚½/Ñ‚)",
                "Ğ ĞµĞ³Ğ¸Ğ¾Ğ½",
                "Ğ’Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ (%)",
                "ĞŸÑ€Ğ¾Ñ‚ĞµĞ¸Ğ½ (%)",
                "ĞšĞ»ĞµĞ¹ĞºĞ¾Ğ²Ğ¸Ğ½Ğ° (%)",
                "Ğ¡Ğ¾Ñ€Ğ½Ğ¾ÑÑ‚ÑŒ (%)",
                "Ğ”Ğ°Ñ‚Ğ° Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸",
                "Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ",
                "Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¾",
                "ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾",
            ]
            worksheet = self.get_or_create_worksheet("Batches", headers)

            if not worksheet:
                return

            row_data = [
                str(batch.get("id", "")),
                str(batch.get("farmer_id", "")),
                str(batch.get("culture", "")),
                str(batch.get("volume", 0)),
                str(batch.get("price", 0)),
                str(batch.get("region", "")),
                str(batch.get("moisture", "")),
                str(batch.get("protein", "")),
                str(batch.get("gluten", "")),
                str(batch.get("weediness", "")),
                str(batch.get("readiness_date", "")),
                str(batch.get("status", "active")),
                datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            ]

            batch_id = str(batch.get("id", ""))
            try:
                cell = worksheet.find(batch_id)
                if cell:
                    worksheet.update(f"A{cell.row}:N{cell.row}", [row_data])
                    logging.info(f"âœ… ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ {batch_id} Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ° Ğ² Google Sheets")
                else:
                    worksheet.append_row(row_data)
                    logging.info(f"âœ… ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ {batch_id} Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ° Ğ² Google Sheets")
            except Exception as e:
                worksheet.append_row(row_data)
                logging.info(f"âœ… ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ {batch_id} Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ° Ğ² Google Sheets")

        except Exception as e:
            logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ² Google Sheets: {e}")

    def update_batch_in_sheets(self, batch):
        """ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ² Google Sheets"""
        self.sync_batch_to_sheets(batch)

    def delete_batch_from_sheets(self, batch_id):
        """Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ¸Ğ· Google Sheets"""
        try:
            if not self.spreadsheet:
                logging.error("âŒ ĞĞµÑ‚ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ Ğº Google Sheets")
                return

            worksheet = self.spreadsheet.worksheet("Batches")
            cell = worksheet.find(str(batch_id))
            if cell:
                worksheet.delete_rows(cell.row)
                logging.info(f"âœ… ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ {batch_id} ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ° Ğ¸Ğ· Google Sheets")

        except Exception as e:
            logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ¸Ğ· Google Sheets: {e}")

    def sync_pull_to_sheets(self, pull):
        """Ğ¡Ğ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¿ÑƒĞ»Ğ° Ğ² Google Sheets"""
        try:
            if not self.spreadsheet:
                logging.error("âŒ ĞĞµÑ‚ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ Ğº Google Sheets")
                return

            headers = [
                "ID",
                "Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€ ID",
                "ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°",
                "Ğ¦ĞµĞ»ĞµĞ²Ğ¾Ğ¹ Ğ¾Ğ±ÑŠÑ‘Ğ¼ (Ñ‚)",
                "Ğ¢ĞµĞºÑƒÑ‰Ğ¸Ğ¹ Ğ¾Ğ±ÑŠÑ‘Ğ¼ (Ñ‚)",
                "Ğ¦ĞµĞ½Ğ° (â‚½/Ñ‚)",
                "Ğ’Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ (%)",
                "Ğ¡Ğ¾Ñ€Ğ½Ğ¾ÑÑ‚ÑŒ (%)",
                "Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ",
                "Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¾",
                "ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾",
            ]
            worksheet = self.get_or_create_worksheet("Pulls", headers)

            if not worksheet:
                return

            row_data = [
                str(pull.get("id", "")),
                str(pull.get("exporter_id", "")),
                str(pull.get("culture", "")),
                str(pull.get("target_volume", 0)),
                str(pull.get("current_volume", 0)),
                str(pull.get("price", 0)),
                str(pull.get("moisture", "")),
                str(pull.get("impurity", "")),
                str(pull.get("status", "active")),
                datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            ]

            pull_id = str(pull.get("id", ""))
            try:
                cell = worksheet.find(pull_id)
                if cell:
                    worksheet.update(f"A{cell.row}:K{cell.row}", [row_data])
                    logging.info(f"âœ… ĞŸÑƒĞ» {pull_id} Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½ Ğ² Google Sheets")
                else:
                    worksheet.append_row(row_data)
                    logging.info(f"âœ… ĞŸÑƒĞ» {pull_id} Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½ Ğ² Google Sheets")
            except Exception as e:
                worksheet.append_row(row_data)
                logging.info(f"âœ… ĞŸÑƒĞ» {pull_id} Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½ Ğ² Google Sheets")

        except Exception as e:
            logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ğ¿ÑƒĞ»Ğ° Ğ² Google Sheets: {e}")

    def update_pull_in_sheets(self, pull):
        """ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ° Ğ² Google Sheets"""
        self.sync_pull_to_sheets(pull)

    def sync_deal_to_sheets(self, deal):
        """Ğ¡Ğ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ ÑĞ´ĞµĞ»ĞºĞ¸ Ğ² Google Sheets"""
        try:
            if not self.spreadsheet:
                logging.error("âŒ ĞĞµÑ‚ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ Ğº Google Sheets")
                return

            headers = [
                "ID",
                "ĞŸÑƒĞ» ID",
                "ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ ID",
                "Ğ¤ĞµÑ€Ğ¼ĞµÑ€ ID",
                "Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€ ID",
                "ĞĞ±ÑŠÑ‘Ğ¼ (Ñ‚)",
                "Ğ¦ĞµĞ½Ğ° (â‚½/Ñ‚)",
                "Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ",
                "Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¾",
            ]
            worksheet = self.get_or_create_worksheet("Deals", headers)

            if not worksheet:
                return

            row_data = [
                str(deal.get("id", "")),
                str(deal.get("pull_id", "")),
                str(deal.get("batch_id", "")),
                str(deal.get("farmer_id", "")),
                str(deal.get("exporter_id", "")),
                str(deal.get("volume", 0)),
                str(deal.get("price", 0)),
                str(deal.get("status", "pending")),
                datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            ]

            worksheet.append_row(row_data)
            logging.info("âœ… Ğ¡Ğ´ĞµĞ»ĞºĞ° Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ° Ğ² Google Sheets")

        except Exception as e:
            logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ ÑĞ´ĞµĞ»ĞºĞ¸ Ğ² Google Sheets: {e}")


def sync_user_to_sheets(self, user_id, user_data):
    """Ğ¡Ğ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ² Google Sheets"""
    if not self.spreadsheet:
        return

    try:
        headers = [
            "user_id",
            "username",
            "name",
            "phone",
            "email",
            "inn",
            "company_details",
            "region",
            "role",
            "registered_at",
        ]

        worksheet = self.get_or_create_worksheet("Users", headers)
        if not worksheet:
            return

        try:
            cell = worksheet.find(str(user_id))
            row_num = cell.row

            row_data = [
                str(user_id),
                clean_text(user_data.get("username", "")),
                clean_text(user_data.get("name", "")),
                clean_text(user_data.get("phone", "")),
                clean_text(user_data.get("email", "")),
                clean_text(user_data.get("inn", "")),
                clean_text(user_data.get("company_details", "")),
                clean_text(user_data.get("region", "")),
                user_data.get("role", ""),
                user_data.get("registered_at", ""),
            ]

            worksheet.update(values=[row_data], range_name=f"A{row_num}:J{row_num}")
            logging.info(f"âœ… ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ {user_id}")

        except Exception as e:
            # ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ - Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ½Ğ¾Ğ²ÑƒÑ ÑÑ‚Ñ€Ğ¾ĞºÑƒ
            row_data = [
                str(user_id),
                clean_text(user_data.get("username", "")),
                clean_text(user_data.get("name", "")),
                clean_text(user_data.get("phone", "")),
                clean_text(user_data.get("email", "")),
                clean_text(user_data.get("inn", "")),
                clean_text(user_data.get("company_details", "")),
                clean_text(user_data.get("region", "")),
                clean_text(user_data.get("role", "")),
                clean_text(user_data.get("registered_at", "")),
            ]

            worksheet.append_row(row_data)
            logging.info(f"âœ… Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ {user_id}")

    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ: {e}")


def sync_batch_to_sheets(self, batch_data):
    """Ğ¡Ğ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ² Google Sheets"""
    if not self.spreadsheet:
        logging.warning("âš ï¸ Google Sheets Ğ½Ğµ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½")
        return

    try:
        headers = [
            "batch_id",
            "farmer_id",
            "farmer_name",
            "culture",
            "region",
            "volume",
            "price",
            "humidity",
            "impurity",
            "quality_class",
            "storage_type",
            "readiness_date",
            "status",
            "created_at",
        ]

        worksheet = self.get_or_create_worksheet("Batches", headers)
        if not worksheet:
            return

        try:
            cell = worksheet.find(str(batch_data["id"]))
            row_num = cell.row

            row_data = [
                str(batch_data["id"]),
                str(batch_data["farmer_id"]),
                clean_text(batch_data.get("farmer_name", "")),
                clean_text(batch_data.get("culture", "")),
                clean_text(batch_data.get("region", "")),
                str(batch_data.get("volume", "")),
                str(batch_data.get("price", "")),
                str(batch_data.get("humidity", "")),
                str(batch_data.get("impurity", "")),
                clean_text(batch_data.get("quality_class", "")),
                clean_text(batch_data.get("storage_type", "")),
                clean_text(batch_data.get("readiness_date", "")),
                batch_data.get("status", ""),
                batch_data.get("created_at", ""),
            ]

            worksheet.update(values=[row_data], range_name=f"A{row_num}:N{row_num}")
            logging.info(f"âœ… ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ {batch_data['id']}")

        except Exception as e:
            # ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ° - Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ½Ğ¾Ğ²ÑƒÑ
            row_data = [
                str(batch_data["id"]),
                str(batch_data["farmer_id"]),
                clean_text(batch_data.get("farmer_name", "")),
                clean_text(batch_data.get("culture", "")),
                clean_text(batch_data.get("region", "")),
                str(batch_data.get("volume", "")),
                str(batch_data.get("price", "")),
                str(batch_data.get("humidity", "")),
                str(batch_data.get("impurity", "")),
                clean_text(batch_data.get("quality_class", "")),
                clean_text(batch_data.get("storage_type", "")),
                clean_text(batch_data.get("readiness_date", "")),
                batch_data.get("status", ""),
                batch_data.get("created_at", ""),
            ]

            worksheet.append_row(row_data)
            logging.info(f"âœ… Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ {batch_data['id']}")

    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸: {e}")

    def sync_pull_to_sheets(self, pull_data):
        """Ğ¡Ğ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¿ÑƒĞ»Ğ° Ğ² Google Sheets"""
        if not self.spreadsheet:
            return

        try:
            headers = [
                "pull_id",
                "exporter_id",
                "exporter_name",
                "culture",
                "target_volume",
                "current_volume",
                "price",
                "port",
                "moisture",
                "nature",
                "impurity",
                "weed",
                "documents",
                "doc_type",
                "status",
                "created_at",
            ]

            worksheet = self.get_or_create_worksheet("Pulls", headers)
            if not worksheet:
                return

            try:
                cell = worksheet.find(str(pull_data["id"]))
                row_num = cell.row

                row_data = [
                    str(pull_data["id"]),
                    str(pull_data["exporter_id"]),
                    pull_data.get("exporter_name", ""),
                    pull_data.get("culture", ""),
                    str(pull_data.get("target_volume", "")),
                    str(pull_data.get("current_volume", "")),
                    str(pull_data.get("price", "")),
                    pull_data.get("port", ""),
                    str(pull_data.get("moisture", "")),
                    str(pull_data.get("nature", "")),
                    str(pull_data.get("impurity", "")),
                    str(pull_data.get("weed", "")),
                    pull_data.get("documents", ""),
                    pull_data.get("doc_type", ""),
                    pull_data.get("status", ""),
                    pull_data.get("created_at", ""),
                ]

                worksheet.update(values=[row_data], range_name=f"A{row_num}:P{row_num}")
                logging.info(f"âœ… ĞĞ±Ğ½Ğ¾Ğ²Ğ»Ñ‘Ğ½ Ğ¿ÑƒĞ» {pull_data['id']}")

            except Exception as e:
                row_data = [
                    str(pull_data["id"]),
                    str(pull_data["exporter_id"]),
                    pull_data.get("exporter_name", ""),
                    pull_data.get("culture", ""),
                    str(pull_data.get("target_volume", "")),
                    str(pull_data.get("current_volume", "")),
                    str(pull_data.get("price", "")),
                    pull_data.get("port", ""),
                    str(pull_data.get("moisture", "")),
                    str(pull_data.get("nature", "")),
                    str(pull_data.get("impurity", "")),
                    str(pull_data.get("weed", "")),
                    pull_data.get("documents", ""),
                    pull_data.get("doc_type", ""),
                    pull_data.get("status", ""),
                    pull_data.get("created_at", ""),
                ]
                worksheet.append_row(row_data)
                logging.info(f"âœ… Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½ Ğ¿ÑƒĞ» {pull_data['id']}")

        except Exception as e:
            logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ğ¿ÑƒĞ»Ğ°: {e}")

    def delete_batch_from_sheets(self, batch_id):
        """Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ¸Ğ· Google Sheets"""
        if not self.spreadsheet:
            return

        try:
            worksheet = self.get_or_create_worksheet("Batches", [])
            if not worksheet:
                return

            cell = worksheet.find(str(batch_id))
            if cell:
                worksheet.delete_rows(cell.row)
                logging.info(f"âœ… Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ {batch_id} Ğ¸Ğ· Google Sheets")

        except Exception as e:
            logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ {batch_id}: {e}")

    def update_batch_in_sheets(self, batch_data):
        """ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ² Google Sheets"""
        self.sync_batch_to_sheets(batch_data)

    def update_user_in_sheets(self, user_id, user_data):
        """ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ² Google Sheets"""
        self.sync_user_to_sheets(user_id, user_data)

    def update_pull_in_sheets(self, pull_data):
        """ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ° Ğ² Google Sheets"""
        self.sync_pull_to_sheets(pull_data)

    def sync_deal_to_sheets(self, deal_data):
        """Ğ¡Ğ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ ÑĞ´ĞµĞ»ĞºĞ¸ Ğ² Google Sheets"""
        if not self.spreadsheet:
            return

        try:
            headers = [
                "deal_id",
                "pull_id",
                "exporter_id",
                "farmer_ids",
                "logistic_id",
                "expeditor_id",
                "total_volume",
                "status",
                "created_at",
                "completed_at",
            ]

            worksheet = self.get_or_create_worksheet("Deals", headers)
            if not worksheet:
                return

            farmer_ids_str = ",".join(map(str, deal_data.get("farmer_ids", [])))

            try:
                cell = worksheet.find(str(deal_data["id"]))
                row_num = cell.row

                row_data = [
                    str(deal_data["id"]),
                    str(deal_data.get("pull_id", "")),
                    str(deal_data.get("exporter_id", "")),
                    farmer_ids_str,
                    str(deal_data.get("logistic_id", "")),
                    str(deal_data.get("expeditor_id", "")),
                    str(deal_data.get("total_volume", "")),
                    deal_data.get("status", ""),
                    deal_data.get("created_at", ""),
                    deal_data.get("completed_at", ""),
                ]

                worksheet.update(values=[row_data], range_name=f"A{row_num}:J{row_num}")
                logging.info(f"âœ… ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ° ÑĞ´ĞµĞ»ĞºĞ° {deal_data['id']}")

            except Exception as e:
                row_data = [
                    str(deal_data["id"]),
                    str(deal_data.get("pull_id", "")),
                    str(deal_data.get("exporter_id", "")),
                    farmer_ids_str,
                    str(deal_data.get("logistic_id", "")),
                    str(deal_data.get("expeditor_id", "")),
                    str(deal_data.get("total_volume", "")),
                    deal_data.get("status", ""),
                    deal_data.get("created_at", ""),
                    deal_data.get("completed_at", ""),
                ]
                worksheet.append_row(row_data)
                logging.info(f"âœ… Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ° ÑĞ´ĞµĞ»ĞºĞ° {deal_data['id']}")

        except Exception as e:
            logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ ÑĞ´ĞµĞ»ĞºĞ¸: {e}")

    def sync_match_to_sheets(self, match_data):
        """Ğ¡Ğ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ Ğ² Google Sheets"""
        if not self.spreadsheet:
            return

        try:
            headers = ["match_id", "batch_id", "pull_id", "status", "created_at"]

            worksheet = self.get_or_create_worksheet("Matches", headers)
            if not worksheet:
                return

            try:
                cell = worksheet.find(str(match_data["id"]))
                row_num = cell.row

                row_data = [
                    str(match_data["id"]),
                    str(match_data.get("batch_id", "")),
                    str(match_data.get("pull_id", "")),
                    match_data.get("status", ""),
                    match_data.get("created_at", ""),
                ]

                worksheet.update(values=[row_data], range_name=f"A{row_num}:E{row_num}")

            except Exception as e:
                row_data = [
                    str(match_data["id"]),
                    str(match_data.get("batch_id", "")),
                    str(match_data.get("pull_id", "")),
                    match_data.get("status", ""),
                    match_data.get("created_at", ""),
                ]
                worksheet.append_row(row_data)
                logging.info(f"âœ… Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğµ {match_data['id']}")

        except Exception as e:
            logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ: {e}")

    def export_all_data(self):
        """Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ²ÑĞµÑ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ² Google Sheets"""
        if not self.spreadsheet:
            logging.warning("âš ï¸ Google Sheets Ğ½Ğµ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½")
            return False

        try:
            for user_id, user_data in users.items():
                self.sync_user_to_sheets(user_id, user_data)
            for user_batches in batches.values():
                for batch in user_batches:
                    self.sync_batch_to_sheets(batch)
            for pull_data in pulls.values():
                self.sync_pull_to_sheets(pull_data)
            for deal_data in deals.values():
                self.sync_deal_to_sheets(deal_data)
            for match_data in matches.values():
                self.sync_match_to_sheets(match_data)

            logging.info("âœ… Ğ’ÑĞµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹ Ğ² Google Sheets")
            return True

        except Exception as e:
            logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…: {e}")
            return False


# ====================================================================
# Ğ˜ĞĞ˜Ğ¦Ğ˜ĞĞ›Ğ˜Ğ—ĞĞ¦Ğ˜Ğ¯ GOOGLE SHEETS (Ğ°ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ğ°Ñ)
# ====================================================================
gs = None


async def init_google_sheets():
    """ĞÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ğ°Ñ Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Google Sheets"""
    global gs
    try:
        if not GOOGLE_SHEETS_AVAILABLE:
            logging.warning("âš ï¸ Google Sheets Ğ¾Ñ‚ĞºĞ»ÑÑ‡Ñ‘Ğ½ (GOOGLE_SHEETS_AVAILABLE=False)")
            return

        if not os.path.exists(GOOGLE_SHEETS_CREDENTIALS):
            logging.warning(
                f"âš ï¸ Ğ¤Ğ°Ğ¹Ğ» credentials Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½: {GOOGLE_SHEETS_CREDENTIALS}"
            )
            return

        logging.info("ğŸ”„ Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Google Sheets Manager...")

        # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ğ¼ĞµĞ½ĞµĞ´Ğ¶ĞµÑ€ Ğ² Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ğ¾Ğ¼ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞµ Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ½Ğµ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ
        loop = asyncio.get_event_loop()
        gs = await loop.run_in_executor(
            None, GoogleSheetsManager, GOOGLE_SHEETS_CREDENTIALS, SPREADSHEET_ID
        )

        if gs and gs.spreadsheet:
            logging.info("âœ… Google Sheets Manager Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½")
        else:
            logging.warning("âš ï¸ Google Sheets Manager ÑĞ¾Ğ·Ğ´Ğ°Ğ½ Ğ½Ğ¾ spreadsheet Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿ĞµĞ½")
            gs = None

    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Google Sheets: {e}")
        gs = None


# ============================================================================
# ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜ĞšĞ˜ Ğ”Ğ›Ğ¯ ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ™ Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢ĞĞ’ (Ğ¤Ğ•Ğ ĞœĞ•Ğ )
# ============================================================================


@dp.message_handler(
    lambda message: message.text == "ğŸšš ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²", state="*"
)
async def farmer_view_logistics_offers(message: types.Message, state: FSMContext):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ² Ğ´Ğ»Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°"""
    global logistics_offers
    global users

    await state.finish()

    user_id = message.from_user.id

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ñ€Ğ¾Ğ»ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    if user_id not in users or users[user_id].get("role") != "farmer":
        await message.answer("âŒ Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°Ğ¼")
        return

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹
    if not logistics_offers:
        await message.answer(
            "ğŸ“­ <b>ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ² Ğ¿Ğ¾ĞºĞ° Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒÑÑ‚</b>\n\n"
            "ĞšĞ¾Ğ³Ğ´Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ñ‹ Ğ½Ğ°Ñ‡Ğ½ÑƒÑ‚ Ğ¿Ğ¾Ğ´Ğ°Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ, Ğ²Ñ‹ ÑĞ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¸Ñ… Ğ·Ğ´ĞµÑÑŒ ÑƒĞ²Ğ¸Ğ´ĞµÑ‚ÑŒ.",
            parse_mode="HTML",
        )
        return

    # Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ÑƒĞµĞ¼ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
    active_offers = [
        offer
        for offer in logistics_offers.values()
        if offer.get("status") in ["active", "pending"]
    ]

    if not active_offers:
        await message.answer(
            "ğŸ“­ <b>ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹ Ğ½ĞµÑ‚</b>\n\n"
            "Ğ’ÑĞµ Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ ÑƒĞ¶Ğµ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ñ‹ Ğ¸Ğ»Ğ¸ Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ñ‹.",
            parse_mode="HTML",
        )
        return

    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‚ĞµĞºÑÑ‚ ÑĞ¾ ÑĞ¿Ğ¸ÑĞºĞ¾Ğ¼
    text = "<b>ğŸšš Ğ”ĞĞ¡Ğ¢Ğ£ĞŸĞĞ«Ğ• ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯ Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢ĞĞ’</b>\n\n"
    text += f"ğŸ“Š ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹: <b>{len(active_offers)}</b>\n\n"

    keyboard = InlineKeyboardMarkup(row_width=1)

    # Ğ’Ñ‹Ğ²Ğ¾Ğ´Ğ¸Ğ¼ Ğ¿ĞµÑ€Ğ²Ñ‹Ğµ 10 Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹
    for offer in active_offers[:10]:
        offer_id = offer.get("offer_id")
        logist_id = offer.get("logist_id")
        logist_user = users.get(logist_id, {})
        logist_name = logist_user.get("name", "Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚")

        transport_type = offer.get("transport_type", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        route = offer.get("route", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        price_per_ton = offer.get("price_per_ton", 0)

        emoji = get_vehicle_emoji(transport_type)

        # Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‚ĞµĞºÑÑ‚ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸
        button_text = (
            f"{emoji} {logist_name[:15]} | "
            f"{route[:20]} | "
            f"{price_per_ton:,.0f}â‚½/Ñ‚"
        )

        keyboard.add(
            InlineKeyboardButton(
                button_text, callback_data=f"farmer_view_offer:{offer_id}"
            )
        )

    # Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ± Ğ¾ÑÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ñ…
    if len(active_offers) > 10:
        text += f"\n<i>â„¹ï¸ Ğ•Ñ‰Ñ‘ {len(active_offers) - 10} Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾</i>"

    keyboard.add(InlineKeyboardButton("â¬…ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_menu"))

    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")


@dp.callback_query_handler(lambda c: c.data.startswith("farmer_view_offer:"), state="*")
async def farmer_view_offer_details(callback: types.CallbackQuery, state: FSMContext):
    """Ğ”ĞµÑ‚Ğ°Ğ»Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° Ğ´Ğ»Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°"""

    await state.finish()

    try:
        offer_id = parse_callback_id(callback.data)
    except ValueError:
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ", show_alert=True)
        return

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
    if offer_id not in logistics_offers:
        await callback.answer("âŒ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾", show_alert=True)
        return

    offer = logistics_offers[offer_id]
    logist_id = offer.get("logist_id")

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°
    if logist_id not in users:
        await callback.answer("âŒ Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    logist = users[logist_id]

    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾Ğ»Ğ½ÑƒÑ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¸
    text = f"""
ğŸšš <b>ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ• Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢Ğ</b>

<b>ğŸ“‹ ID Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ:</b> #{offer_id}
<b>ğŸ“… Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¾:</b> {offer.get('created_at', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}
<b>ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ:</b> {'âœ… ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾' if offer.get('status') == 'active' else 'â³ ĞĞ° Ñ€Ğ°ÑÑĞ¼Ğ¾Ñ‚Ñ€ĞµĞ½Ğ¸Ğ¸'}

<b>ğŸ‘¤ Ğ˜ĞĞ¤ĞĞ ĞœĞĞ¦Ğ˜Ğ¯ Ğ Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢Ğ•:</b>
Ğ˜Ğ¼Ñ: {logist.get('name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}
ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ: {logist.get('company_details', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}
Ğ˜ĞĞ: <code>{logist.get('inn', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>
ĞĞ“Ğ Ğ: <code>{logist.get('ogrn', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>
ğŸ“± Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <code>{logist.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>
ğŸ“§ Email: <code>{logist.get('email', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>

<b>ğŸš› Ğ¥ĞĞ ĞĞšĞ¢Ğ•Ğ Ğ˜Ğ¡Ğ¢Ğ˜ĞšĞ˜ Ğ¢Ğ ĞĞĞ¡ĞŸĞĞ Ğ¢Ğ:</b>
Ğ¢Ğ¸Ğ¿: {offer.get('transport_type', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}
Ğ“Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ: {offer.get('capacity', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')} Ñ‚
ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚: {offer.get('route', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}
Ğ”Ğ½ĞµĞ¹ Ğ² Ğ¿ÑƒÑ‚Ğ¸: {offer.get('delivery_days', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}

<b>ğŸ’° Ğ¡Ğ¢ĞĞ˜ĞœĞĞ¡Ğ¢Ğ¬:</b>
Ğ¦ĞµĞ½Ğ°: {offer.get('price_per_ton', 0):,.0f} â‚½/Ñ‚
Ğ’ÑĞµĞ³Ğ¾: {(offer.get('price_per_ton', 0) * offer.get('capacity', 0)):,.0f} â‚½

<b>â„¹ï¸ Ğ”ĞĞŸĞĞ›ĞĞ˜Ğ¢Ğ•Ğ›Ğ¬ĞĞ:</b>
{offer.get('additional_info', 'ĞĞµÑ‚ Ğ´Ğ¾Ğ¿. Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸')}
"""

    keyboard = InlineKeyboardMarkup(row_width=2)

    # ĞšĞ½Ğ¾Ğ¿ĞºĞ¸ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°
    phone = logist.get("phone", "")
    if phone:
        keyboard.add(
            InlineKeyboardButton("ğŸ“ ĞŸĞ¾Ğ·Ğ²Ğ¾Ğ½Ğ¸Ñ‚ÑŒ", url=f"tel:{phone}"),
            InlineKeyboardButton("ğŸ’¬ ĞĞ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒ", url=f"tg://user?id={logist_id}"),
        )

    # ĞšĞ½Ğ¾Ğ¿ĞºĞ° Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¸Ñ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
    keyboard.add(
        InlineKeyboardButton(
            "âœ… ĞŸÑ€Ğ¸Ğ½ÑÑ‚ÑŒ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ", callback_data=f"farmer_accept_offer:{offer_id}"
        ),
        InlineKeyboardButton(
            "âŒ ĞÑ‚ĞºĞ»Ğ¾Ğ½Ğ¸Ñ‚ÑŒ", callback_data=f"farmer_reject_offer:{offer_id}"
        ),
    )

    keyboard.add(
        InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğº ÑĞ¿Ğ¸ÑĞºÑƒ", callback_data="farmer_back_to_offers")
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("farmer_accept_offer:"), state="*"
)
async def farmer_accept_logistics_offer(
    callback: types.CallbackQuery, state: FSMContext
):
    """Ğ¤ĞµÑ€Ğ¼ĞµÑ€ Ğ¿Ñ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°ĞµÑ‚ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°"""

    await state.finish()

    user_id = callback.from_user.id

    # ĞŸĞ°Ñ€ÑĞ¸Ğ¼ ID Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
    try:
        offer_id = parse_callback_id(callback.data)
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞµ", show_alert=True)
        return

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
    if offer_id not in logistics_offers:
        await callback.answer("âŒ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾", show_alert=True)
        return

    offer = logistics_offers[offer_id]

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
    if offer.get("status") != "active":
        await callback.answer("âŒ Ğ­Ñ‚Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ ÑƒĞ¶Ğµ Ğ½ĞµĞ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾", show_alert=True)
        return

    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
    offer["status"] = "accepted_by_farmer"
    offer["farmer_id"] = user_id
    offer["accepted_at"] = datetime.now().strftime("%d.%m.%Y %H:%M:%S")

    # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
    save_logistics_to_pickle()
    save_logistics_to_json()

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğµ
    logist_id = offer.get("logist_id")
    logist_user = users.get(logist_id, {})
    farmer_user = users.get(user_id, {})

    # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ñƒ
    farmer_msg = f"""
âœ… <b>ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ• ĞŸĞ Ğ˜ĞĞ¯Ğ¢Ğ!</b>

ğŸ“‹ ID Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ: #{offer_id}
ğŸ“… Ğ’Ñ€ĞµĞ¼Ñ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¸Ñ: {offer['accepted_at']}

<b>ğŸ‘¤ Ğ”ĞĞĞĞ«Ğ• Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢Ğ:</b>
Ğ˜Ğ¼Ñ: {logist_user.get('name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}
ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ: {logist_user.get('company_details', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}
ğŸ“± Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <code>{logist_user.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>
ğŸ“§ Email: <code>{logist_user.get('email', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>

<b>ğŸš› Ğ¥ĞĞ ĞĞšĞ¢Ğ•Ğ Ğ˜Ğ¡Ğ¢Ğ˜ĞšĞ˜:</b>
Ğ¢Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°: {offer.get('transport_type', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}
ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚: {offer.get('route', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}
Ğ¦ĞµĞ½Ğ°: {offer.get('price_per_ton', 0):,.0f} â‚½/Ñ‚
Ğ”Ğ½ĞµĞ¹ Ğ² Ğ¿ÑƒÑ‚Ğ¸: {offer.get('delivery_days', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}

â³ Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ ÑĞ²ÑĞ¶ĞµÑ‚ÑÑ Ñ Ğ²Ğ°Ğ¼Ğ¸ Ğ² Ğ±Ğ»Ğ¸Ğ¶Ğ°Ğ¹ÑˆĞµĞµ Ğ²Ñ€ĞµĞ¼Ñ Ğ´Ğ»Ñ ÑĞ¾Ğ³Ğ»Ğ°ÑĞ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸.
"""

    keyboard = InlineKeyboardMarkup()
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ“ ĞŸĞ¾Ğ·Ğ²Ğ¾Ğ½Ğ¸Ñ‚ÑŒ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ñƒ", url=f"tel:{logist_user.get('phone', '')}"
        ),
        InlineKeyboardButton("ğŸ’¬ ĞĞ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒ Ğ² Telegram", url=f"tg://user?id={logist_id}"),
    )
    keyboard.add(InlineKeyboardButton("â¬…ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğ² Ğ¼ĞµĞ½Ñ", callback_data="back_to_menu"))

    await callback.message.edit_text(
        farmer_msg, reply_markup=keyboard, parse_mode="HTML"
    )

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° Ğ¾ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¸Ğ¸
    logist_msg = f"""
ğŸ‰ <b>Ğ’ĞĞ¨Ğ• ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ• ĞŸĞ Ğ˜ĞĞ¯Ğ¢Ğ!</b>

ğŸ“‹ ID Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ: #{offer_id}
âœ… Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: ĞŸĞ Ğ˜ĞĞ¯Ğ¢Ğ
ğŸ“… Ğ’Ñ€ĞµĞ¼Ñ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¸Ñ: {offer['accepted_at']}

<b>ğŸ‘¨â€ğŸŒ¾ Ğ”ĞĞĞĞ«Ğ• Ğ¤Ğ•Ğ ĞœĞ•Ğ Ğ:</b>
Ğ˜Ğ¼Ñ: {farmer_user.get('name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}
Ğ ĞµĞ³Ğ¸Ğ¾Ğ½: {farmer_user.get('region', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}
ğŸ“± Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <code>{farmer_user.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>
ğŸ“§ Email: <code>{farmer_user.get('email', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>

<b>ğŸš› Ğ”Ğ•Ğ¢ĞĞ›Ğ˜ ĞŸĞ•Ğ Ğ•Ğ’ĞĞ—ĞšĞ˜:</b>
ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚: {offer.get('route', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}
Ğ’Ğ°ÑˆĞ° Ñ†ĞµĞ½Ğ°: {offer.get('price_per_ton', 0):,.0f} â‚½/Ñ‚

ğŸ“ Ğ¡Ğ²ÑĞ¶Ğ¸Ñ‚ĞµÑÑŒ Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ¼ Ğ² Ñ‚ĞµÑ‡ĞµĞ½Ğ¸Ğµ Ğ±Ğ»Ğ¸Ğ¶Ğ°Ğ¹ÑˆĞ¸Ñ… 24 Ñ‡Ğ°ÑĞ¾Ğ² Ğ´Ğ»Ñ ÑĞ¾Ğ³Ğ»Ğ°ÑĞ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ²ÑĞµÑ… Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸!

<b>Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾ Ğ·Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ½Ğ°ÑˆĞµĞ¹ Ğ¿Ğ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼Ñ‹! ğŸ™</b>
"""

    try:
        await bot.send_message(logist_id, logist_msg, parse_mode="HTML")
        logging.info(f"Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ñƒ #{logist_id} Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾")
    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞµ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ñƒ: {e}")

    # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¾Ğ± ÑƒÑĞ¿ĞµÑ…Ğµ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ñƒ
    await callback.answer(
        "âœ… ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¾! Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ.", show_alert=True
    )


@dp.callback_query_handler(
    lambda c: c.data.startswith("farmer_reject_offer:"), state="*"
)
async def farmer_reject_logistics_offer(
    callback: types.CallbackQuery, state: FSMContext
):
    """Ğ¤ĞµÑ€Ğ¼ĞµÑ€ Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ÑĞµÑ‚ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°"""

    await state.finish()

    user_id = callback.from_user.id

    # ĞŸĞ°Ñ€ÑĞ¸Ğ¼ ID Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
    try:
        offer_id = parse_callback_id(callback.data)
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞµ", show_alert=True)
        return

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
    if offer_id not in logistics_offers:
        await callback.answer("âŒ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾", show_alert=True)
        return

    offer = logistics_offers[offer_id]

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
    if offer.get("status") != "active":
        await callback.answer("âŒ Ğ­Ñ‚Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ ÑƒĞ¶Ğµ Ğ½ĞµĞ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾", show_alert=True)
        return

    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
    offer["status"] = "rejected_by_farmer"
    offer["farmer_id"] = user_id
    offer["rejected_at"] = datetime.now().strftime("%d.%m.%Y %H:%M:%S")

    # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
    save_logistics_to_pickle()
    save_logistics_to_json()

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğµ
    logist_id = offer.get("logist_id")

    # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ñƒ
    farmer_msg = f"""
âŒ <b>ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ• ĞĞ¢ĞšĞ›ĞĞĞ•ĞĞ</b>

ğŸ“‹ ID Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ: #{offer_id}
ğŸ“… Ğ’Ñ€ĞµĞ¼Ñ Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ñ: {offer['rejected_at']}

Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ğ± Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ğ¸.

ğŸ“² Ğ’Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ² Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ğµ "ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²"
"""

    keyboard = InlineKeyboardMarkup()
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ”„ Ğ”Ñ€ÑƒĞ³Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ", callback_data="view_logistics_offers_btn"
        )
    )
    keyboard.add(InlineKeyboardButton("â¬…ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğ² Ğ¼ĞµĞ½Ñ", callback_data="back_to_menu"))

    await callback.message.edit_text(
        farmer_msg, reply_markup=keyboard, parse_mode="HTML"
    )

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° Ğ¾Ğ± Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ğ¸
    logist_msg = f"""
âŒ <b>Ğ’ĞĞ¨Ğ• ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ• ĞĞ¢ĞšĞ›ĞĞĞ•ĞĞ</b>

ğŸ“‹ ID Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ: #{offer_id}
âŒ Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: ĞĞ¢ĞšĞ›ĞĞĞ•ĞĞ
ğŸ“… Ğ’Ñ€ĞµĞ¼Ñ Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ñ: {offer['rejected_at']}

Ğ¤ĞµÑ€Ğ¼ĞµÑ€ Ğ¿Ñ€Ğ¸Ğ½ÑĞ» Ñ€ĞµÑˆĞµĞ½Ğ¸Ğµ Ğ½Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²Ğ°ÑˆĞ¸ ÑƒÑĞ»ÑƒĞ³Ğ¸ Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ¹ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºĞ¸.

Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾ Ğ·Ğ° ÑƒÑ‡Ğ°ÑÑ‚Ğ¸Ğµ! ĞœÑ‹ Ğ¶Ğ´ĞµĞ¼ Ğ²Ğ°ÑˆĞ¸Ñ… Ğ½Ğ¾Ğ²Ñ‹Ñ… Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹. ğŸ™

Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´ÑƒĞµĞ¼:
â€¢ ĞŸÑ€Ğ¾Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ½Ñ‹Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
â€¢ ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑƒĞ»ÑƒÑ‡ÑˆĞ¸Ñ‚ÑŒ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ñ
â€¢ ĞŸĞ¾Ğ´Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ğ¾Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ñ Ğ»ÑƒÑ‡ÑˆĞ¸Ğ¼Ğ¸ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ°Ğ¼Ğ¸
"""

    try:
        await bot.send_message(logist_id, logist_msg, parse_mode="HTML")
        logging.info(
            f"Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ğ± Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ğ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ñƒ #{logist_id} Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾"
        )
    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞµ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ¾Ğ± Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ğ¸: {e}")

    # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¾Ğ± ÑƒÑĞ¿ĞµÑ…Ğµ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ñƒ
    await callback.answer("âœ… ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¾", show_alert=True)


# âœ… Ğ˜Ğ¡Ğ¢ĞĞ Ğ˜Ğ¯ ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ™ Ğ¤Ğ•Ğ ĞœĞ•Ğ Ğ
@dp.message_handler(lambda message: message.text == "ğŸ“‹ Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹", state="*")
async def view_farmer_offers_history(message: types.Message, state: FSMContext):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ğ¸ Ğ²ÑĞµÑ… Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²"""

    await state.finish()

    user_id = message.from_user.id

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ñ€Ğ¾Ğ»ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    if user_id not in users or users[user_id].get("role") != "farmer":
        await message.answer("âŒ Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°Ğ¼")
        return

    if not logistics_offers:
        await message.answer("ğŸ“­ Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹ Ğ¿ÑƒÑÑ‚Ğ°")
        return

    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ
    text = "<b>ğŸ“‹ Ğ˜Ğ¡Ğ¢ĞĞ Ğ˜Ğ¯ ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ™</b>\n\n"

    # ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ
    active = [o for o in logistics_offers.values() if o.get("status") == "active"]
    if active:
        text += f"<b>âœ… ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ ({len(active)}):</b>\n"
        for offer in active[:5]:
            text += f"â€¢ #{offer.get('offer_id')}: {offer.get('transport_type')} | {offer.get('price_per_ton', 0):,.0f}â‚½\n"
        text += "\n"

    # ĞŸÑ€Ğ¸Ğ½ÑÑ‚Ñ‹Ğµ
    accepted = [
        o for o in logistics_offers.values() if o.get("status") == "accepted_by_farmer"
    ]
    if accepted:
        text += f"<b>âœ”ï¸ ĞŸÑ€Ğ¸Ğ½ÑÑ‚Ñ‹Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ ({len(accepted)}):</b>\n"
        for offer in accepted[:5]:
            text += f"â€¢ #{offer.get('offer_id')}: {offer.get('transport_type')} | âœ… {offer.get('accepted_at')}\n"
        text += "\n"

    # ĞÑ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ½Ñ‹Ğµ
    rejected = [
        o for o in logistics_offers.values() if o.get("status") == "rejected_by_farmer"
    ]
    if rejected:
        text += f"<b>âŒ ĞÑ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ½Ñ‹Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ ({len(rejected)}):</b>\n"
        for offer in rejected[:5]:
            text += f"â€¢ #{offer.get('offer_id')}: {offer.get('transport_type')} | âŒ {offer.get('rejected_at')}\n"

    keyboard = InlineKeyboardMarkup()
    keyboard.add(
        InlineKeyboardButton(
            "ğŸšš ĞĞ¾Ğ²Ñ‹Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ", callback_data="view_logistics_offers_btn"
        )
    )
    keyboard.add(InlineKeyboardButton("â¬…ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğ² Ğ¼ĞµĞ½Ñ", callback_data="back_to_menu"))

    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")


@dp.callback_query_handler(lambda c: c.data == "farmer_back_to_offers", state="*")
async def farmer_back_to_offers_list(callback: types.CallbackQuery):
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğº ÑĞ¿Ğ¸ÑĞºÑƒ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹"""
    await farmer_view_logistics_offers(
        callback.message,
        FSMContext(dp.storage, callback.from_user.id, callback.from_user.id),
    )
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("view_deal:"), state="*")
async def view_deal_details(callback: types.CallbackQuery):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹ ÑĞ´ĞµĞ»ĞºĞ¸"""
    deal_id = parse_callback_id(callback.data)

    if deal_id not in deals:
        await callback.answer("âŒ Ğ¡Ğ´ĞµĞ»ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    deal = deals[deal_id]
    text = f"ğŸ“‹ <b>Ğ¡Ğ´ĞµĞ»ĞºĞ° #{deal_id}</b>\n\n"

    text += f"ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: {DEAL_STATUSES.get(deal.get('status', 'pending'), deal.get('status'))}\n"

    if deal.get("total_volume"):
        text += f"ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: {deal['total_volume']} Ñ‚\n"

    if deal.get("exporter_id"):
        exporter_name = users.get(deal["exporter_id"], {}).get("name", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")
        text += f"ğŸ“¦ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€: {exporter_name}\n"

    if deal.get("farmer_ids"):
        farmers_count = len(deal["farmer_ids"])
        text += f"ğŸŒ¾ Ğ¤ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ²: {farmers_count}\n"

    if deal.get("logistic_id"):
        logistic_name = users.get(deal["logistic_id"], {}).get("name", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")
        text += f"ğŸšš Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚: {logistic_name}\n"

    if deal.get("expeditor_id"):
        expeditor_name = users.get(deal["expeditor_id"], {}).get("name", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")
        text += f"ğŸš› Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€: {expeditor_name}\n"

    if deal.get("created_at"):
        text += f"ğŸ“… Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ°: {deal['created_at']}\n"

    if deal.get("completed_at"):
        text += f"âœ… Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°: {deal['completed_at']}\n"

    keyboard = deal_actions_keyboard(deal_id)

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.message_handler(lambda m: m.text == "ğŸ” ĞŸĞ¾Ğ¸ÑĞº ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ²", state="*")
async def search_exporters(message: types.Message, state: FSMContext):
    """ĞŸĞ¾Ğ¸ÑĞº ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ² Ğ´Ğ»Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ° â€” ÑƒĞ½Ğ¸Ğ²ĞµÑ€ÑĞ°Ğ»ÑŒĞ½Ğ°Ñ Ğ²ĞµÑ€ÑĞ¸Ñ"""
    await state.finish()

    user_id = message.from_user.id
    if user_id not in users or users[user_id].get("role") != "farmer":
        await message.answer("âŒ Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°Ğ¼")
        return

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ğ£ĞĞ˜Ğ’Ğ•Ğ Ğ¡ĞĞ›Ğ¬ĞĞĞ¯ ĞĞ‘Ğ ĞĞ‘ĞĞ¢ĞšĞ Ğ¡Ğ¢Ğ Ğ£ĞšĞ¢Ğ£Ğ Ğ« BATCHES
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    farmer_batches = {}

    for key, value in batches.items():
        # Ğ¡Ğ»ÑƒÑ‡Ğ°Ğ¹ 1: ĞĞ¾Ğ²Ğ°Ñ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° {batch_id: {farmer_id: ..., ...}}
        if isinstance(value, dict):
            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ farmer_id Ğ² ÑĞ»Ğ¾Ğ²Ğ°Ñ€Ğµ
            if "farmer_id" in value and value.get("farmer_id") == user_id:
                if value.get("status") in ["active", "ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ°", "Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ°", "", None]:
                    farmer_batches[key] = value

        # Ğ¡Ğ»ÑƒÑ‡Ğ°Ğ¹ 2: Ğ¡Ñ‚Ğ°Ñ€Ğ°Ñ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° {user_id: [batch1, batch2, ...]}
        elif isinstance(value, list):
            # Ğ•ÑĞ»Ğ¸ ĞºĞ»ÑÑ‡ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´Ğ°ĞµÑ‚ Ñ user_id, ÑÑ‚Ğ¾ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ ÑÑ‚Ğ¾Ğ³Ğ¾ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°
            if key == user_id:
                for batch in value:
                    if isinstance(batch, dict):
                        batch_id = batch.get("id")
                        if batch.get("status") in [
                            "active",
                            "ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ°",
                            "Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ°",
                            "",
                            None,
                        ]:
                            farmer_batches[batch_id] = batch

    if not farmer_batches:
        await message.answer(
            "ğŸ“¦ Ğ£ Ğ²Ğ°Ñ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ¸ÑĞºĞ° ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ².\n\n"
            "Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ğ´Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ñ‡ĞµÑ€ĞµĞ· Ğ¼ĞµĞ½Ñ 'â• Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ'",
            reply_markup=farmer_keyboard(),
        )
        return

    keyboard = InlineKeyboardMarkup(row_width=1)
    for batch_id, batch in list(farmer_batches.items())[:10]:
        culture = batch.get("culture", "â€”")
        volume = batch.get("volume", 0)
        price = batch.get("price", 0)
        button_text = f"ğŸŒ¾ {culture} - {volume:.0f} Ñ‚ â€¢ {price:,.0f} â‚½/Ñ‚"
        keyboard.add(
            InlineKeyboardButton(button_text, callback_data=f"findexporters:{batch_id}")
        )

    await message.answer(
        "ğŸ” <b>ĞŸĞ¾Ğ¸ÑĞº ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ²</b>\n\n"
        "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ¸ÑĞºĞ° Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´ÑÑ‰Ğ¸Ñ… ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ²:",
        reply_markup=keyboard,
        parse_mode="HTML",
    )


@dp.callback_query_handler(lambda c: c.data.startswith("findexporters:"), state="*")
async def process_find_exporters(callback: types.CallbackQuery):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ¸ÑĞºĞ° ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ² â€” Ñ„Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ğ²ĞµÑ€ÑĞ¸Ñ"""
    try:
        batch_id = int(callback.data.split(":")[1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    user_id = callback.from_user.id
    await callback.answer("ğŸ” Ğ˜Ñ‰ĞµĞ¼ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´ÑÑ‰Ğ¸Ñ… ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ²...")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ğ£ĞĞ˜Ğ’Ğ•Ğ Ğ¡ĞĞ›Ğ¬ĞĞ«Ğ™ ĞŸĞĞ˜Ğ¡Ğš ĞŸĞĞ Ğ¢Ğ˜Ğ˜ Ğ’ ĞĞ‘Ğ•Ğ˜Ğ¥ Ğ¡Ğ¢Ğ Ğ£ĞšĞ¢Ğ£Ğ ĞĞ¥
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    batch = None

    # Ğ¡Ğ»ÑƒÑ‡Ğ°Ğ¹ 1: ĞĞ¾Ğ²Ğ°Ñ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° {batch_id: {farmer_id: ..., ...}}
    if batch_id in batches and isinstance(batches[batch_id], dict):
        batch = batches[batch_id]

    # Ğ¡Ğ»ÑƒÑ‡Ğ°Ğ¹ 2: Ğ¡Ñ‚Ğ°Ñ€Ğ°Ñ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° {user_id: [batch1, batch2, ...]}
    else:
        for key, value in batches.items():
            if isinstance(value, list):
                for b in value:
                    if isinstance(b, dict) and b.get("id") == batch_id:
                        batch = b
                        break
            if batch:
                break

    if not batch:
        keyboard = InlineKeyboardMarkup()
        keyboard.add(
            InlineKeyboardButton("ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_my_batches")
        )
        await callback.message.edit_text("âŒ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", reply_markup=keyboard)
        return

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¿ÑƒĞ»Ñ‹ (ÑƒĞ½Ğ¸Ğ²ĞµÑ€ÑĞ°Ğ»ÑŒĞ½Ğ°Ñ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ°)
    true_pulls = None
    if (
        isinstance(pulls, dict)
        and "pulls" in pulls
        and isinstance(pulls["pulls"], dict)
    ):
        true_pulls = pulls["pulls"]
    elif isinstance(pulls, dict):
        true_pulls = pulls
    else:
        true_pulls = {}

    # Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğ¹
    matching_pulls = []
    for pull_id, pull in true_pulls.items():
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ‡Ñ‚Ğ¾ pull - ÑĞ»Ğ¾Ğ²Ğ°Ñ€ÑŒ
        if not isinstance(pull, dict):
            logging.warning(f"âš ï¸ ĞŸÑƒĞ» {pull_id} Ğ½Ğµ ÑĞ²Ğ»ÑĞµÑ‚ÑÑ ÑĞ»Ğ¾Ğ²Ğ°Ñ€Ñ‘Ğ¼: {type(pull)}")
            continue

        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°
        pull_status = str(pull.get("status", "")).lower().strip()
        if pull_status not in ["Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚", "open", "active", ""]:
            continue

        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñ‹
        if pull.get("culture") != batch.get("culture"):
            continue

        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¾Ğ±ÑŠÑ‘Ğ¼Ğ°
        target_volume = pull.get("target_volume", 0)
        current_volume = pull.get("current_volume", 0)
        remaining = target_volume - current_volume

        if remaining < batch.get("volume", 0):
            continue

        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°
        exporter_id = pull.get("exporter_id")
        exporter = users.get(exporter_id, {})

        # Ğ¤Ğ»Ğ°Ğ³ Ğ¿Ñ€ĞµĞ´ÑƒĞ¿Ñ€ĞµĞ¶Ğ´ĞµĞ½Ğ¸Ñ Ğ¾ Ñ†ĞµĞ½Ğµ
        pull_price = pull.get("price", 0)
        batch_price = batch.get("price", 0)
        price_warning = pull_price < batch_price

        matching_pulls.append(
            {
                "pull_id": pull_id,
                "pull": pull,
                "exporter": exporter,
                "exporter_id": exporter_id,
                "remaining_volume": remaining,
                "price_warning": price_warning,
            }
        )

    # Ğ•ÑĞ»Ğ¸ Ğ½Ğ¸Ñ‡ĞµĞ³Ğ¾ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾
    if not matching_pulls:
        keyboard = InlineKeyboardMarkup()
        keyboard.add(
            InlineKeyboardButton("ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_my_batches")
        )

        await callback.message.edit_text(
            f"ğŸ” <b>Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹ Ğ¿Ğ¾Ğ¸ÑĞºĞ° Ğ´Ğ»Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ #{batch_id}</b>\n\n"
            f"ğŸŒ¾ {batch.get('culture', 'â€”')} - {batch.get('volume', 0):.0f} Ñ‚\n"
            f"ğŸ’° {batch.get('price', 0):,.0f} â‚½/Ñ‚\n\n"
            f"âŒ Ğš ÑĞ¾Ğ¶Ğ°Ğ»ĞµĞ½Ğ¸Ñ, Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´ÑÑ‰Ğ¸Ñ… ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ² Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾.\n\n"
            f"ğŸ’¡ ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ:\n"
            f"â€¢ Ğ¡Ğ½Ğ¸Ğ·Ğ¸Ñ‚ÑŒ Ñ†ĞµĞ½Ñƒ\n"
            f"â€¢ Ğ Ğ°Ğ·Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğ° Ğ¼ĞµĞ½ÑŒÑˆĞ¸Ğµ Ğ¾Ğ±ÑŠÑ‘Ğ¼Ñ‹\n"
            f"â€¢ ĞŸĞ¾Ğ´Ğ¾Ğ¶Ğ´Ğ°Ñ‚ÑŒ Ğ¿Ğ¾ÑĞ²Ğ»ĞµĞ½Ğ¸Ñ Ğ½Ğ¾Ğ²Ñ‹Ñ… Ğ¿ÑƒĞ»Ğ¾Ğ²",
            reply_markup=keyboard,
            parse_mode="HTML",
        )
        return

    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ñ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ°Ğ¼Ğ¸
    text = (
        f"ğŸ¯ <b>ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ {len(matching_pulls)} Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´ÑÑ‰Ğ¸Ñ… ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ²</b>\n\n"
        f"Ğ”Ğ»Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸:\n"
        f"ğŸŒ¾ {batch.get('culture', 'â€”')} - {batch.get('volume', 0):.0f} Ñ‚\n"
        f"ğŸ’° {batch.get('price', 0):,.0f} â‚½/Ñ‚\n"
        f"ğŸ“ {batch.get('region', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n\n"
        f"<b>ĞŸĞ¾Ğ´Ñ…Ğ¾Ğ´ÑÑ‰Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ:</b>\n\n"
    )

    for idx, match in enumerate(matching_pulls[:10], 1):
        pull = match["pull"]
        exporter = match["exporter"]
        company = exporter.get("company_name") or exporter.get("name", "â€”")
        phone = exporter.get("phone", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        email = exporter.get("email", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        pull_price = pull.get("price", 0)

        text += (
            f"{idx}. <b>Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€:</b> {company}\n" f"   ğŸ’° Ğ¦ĞµĞ½Ğ°: {pull_price:,.0f} â‚½/Ñ‚"
        )

        # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¿Ñ€ĞµĞ´ÑƒĞ¿Ñ€ĞµĞ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¾ Ğ½Ğ¸Ğ·ĞºĞ¾Ğ¹ Ñ†ĞµĞ½Ğµ
        if match.get("price_warning"):
            text += f" âš ï¸ <i>(Ğ½Ğ¸Ğ¶Ğµ Ğ²Ğ°ÑˆĞµĞ¹ {batch.get('price', 0):,.0f} â‚½/Ñ‚)</i>"

        text += (
            f"\n"
            f"   ğŸ“¦ ĞÑƒĞ¶Ğ½Ğ¾: {pull.get('target_volume', 0):.0f} Ñ‚ (ÑĞ²Ğ¾Ğ±Ğ¾Ğ´Ğ½Ğ¾: {match['remaining_volume']:.0f} Ñ‚)\n"
            f"   ğŸš¢ ĞŸĞ¾Ñ€Ñ‚: {pull.get('port', 'â€”')}\n"
            f"   ğŸ“ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <code>{phone}</code>\n"
            f"   ğŸ“§ Email: <code>{email}</code>\n\n"
        )

    if len(matching_pulls) > 10:
        text += f"... Ğ¸ ĞµÑ‰Ñ‘ {len(matching_pulls) - 10} Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹\n\n"

    text += "ğŸ’¡ Ğ¡Ğ²ÑĞ¶Ğ¸Ñ‚ĞµÑÑŒ Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ¼ Ğ´Ğ»Ñ Ğ¾Ğ±ÑÑƒĞ¶Ğ´ĞµĞ½Ğ¸Ñ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ğ¹!"

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ĞšĞ›ĞĞ’Ğ˜ĞĞ¢Ğ£Ğ Ğ: Ğ¢ĞĞ›Ğ¬ĞšĞ ĞšĞĞĞŸĞšĞ "ĞĞĞ—ĞĞ”"
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    keyboard = InlineKeyboardMarkup()
    keyboard.add(InlineKeyboardButton("ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_my_batches"))

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")


@dp.message_handler(lambda m: m.text == "â• Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ", state="*")
async def add_batch_start(message: types.Message, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ğ»Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ¼ â€” Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ğ°Ñ Ğ²ĞµÑ€ÑĞ¸Ñ"""
    await state.finish()

    user_id = message.from_user.id
    if user_id not in users or users[user_id].get("role") != "farmer":
        await message.answer("âŒ Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°Ğ¼")
        return

    await message.answer(
        "ğŸ“¦ <b>Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸</b>\n\n" "Ğ¨Ğ°Ğ³ 1 Ğ¸Ğ· 9\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñƒ:",
        reply_markup=culture_keyboard(),
        parse_mode="HTML",
    )

    await AddBatch.culture.set()  # ĞŸĞµÑ€ĞµÑ…Ğ¾Ğ´ FSM ĞŸĞĞ¡Ğ›Ğ• Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ


@dp.callback_query_handler(
    lambda c: c.data.startswith("culture:"), state=SearchByCulture.waiting_culture
)
async def search_by_culture_selected(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñ‹ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ¸ÑĞºĞ° â€” Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ğ°Ñ Ğ²ĞµÑ€ÑĞ¸Ñ Ñ Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğ¼ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¾Ğ½Ğ°Ğ»Ğ¾Ğ¼"""
    try:
        # Ğ˜Ğ·Ğ²Ğ»ĞµĞºĞ°ĞµĞ¼ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñ‹
        culture = callback.data.split(":", 1)[1]

        # Ğ›Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ»Ğ°Ğ´ĞºĞ¸
        logging.info(f"ğŸ” Ğ˜Ñ‰ĞµĞ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ¿Ğ¾ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğµ: {culture}")
        logging.info(f"ğŸ“Š Ğ’ÑĞµĞ³Ğ¾ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ² Ğ±Ğ°Ğ·Ğµ: {len(batches)}")

    except (IndexError, ValueError) as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¸Ğ·Ğ²Ğ»ĞµÑ‡ĞµĞ½Ğ¸Ñ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñ‹: {e}")
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñ‹", show_alert=True)
        return

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ĞŸĞĞ˜Ğ¡Ğš ĞŸĞĞ Ğ¢Ğ˜Ğ™ ĞŸĞ ĞšĞ£Ğ›Ğ¬Ğ¢Ğ£Ğ Ğ•
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    found_batches = []

    # ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ°Ñ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ°: batches = {batch_id: {farmer_id: ..., culture: ..., status: ..., ...}}
    for batch_id, batch in batches.items():
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Ğ—ĞĞ©Ğ˜Ğ¢Ğ: ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ batch â€” ÑĞ»Ğ¾Ğ²Ğ°Ñ€ÑŒ
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if not isinstance(batch, dict):
            logging.error(
                f"âŒ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ #{batch_id} ĞĞ• ÑĞ»Ğ¾Ğ²Ğ°Ñ€ÑŒ: type={type(batch)}, value={batch}"
            )
            continue

        # Ğ˜Ğ·Ğ²Ğ»ĞµĞºĞ°ĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸
        batch_culture = batch.get("culture", "")
        batch_status = batch.get("status", "")

        logging.info(
            f"  ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ #{batch_id}: culture='{batch_culture}', status='{batch_status}'"
        )

        # Ğ¡Ñ€Ğ°Ğ²Ğ½Ğ¸Ğ²Ğ°ĞµĞ¼ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñ‹ (Ğ¸Ğ³Ğ½Ğ¾Ñ€Ğ¸Ñ€ÑƒĞµĞ¼ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€ Ğ¸ Ğ¿Ñ€Ğ¾Ğ±ĞµĞ»Ñ‹)
        if batch_culture.strip().lower() == culture.strip().lower():
            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ
            if batch_status.lower() in [
                "active",
                "Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ°",
                "available",
                "Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ°",
                "",  # Ğ¿ÑƒÑÑ‚Ğ¾Ğ¹ ÑÑ‚Ğ°Ñ‚ÑƒÑ = Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ°
            ]:
                # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ batch_id Ğ² ÑĞ°Ğ¼Ñƒ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ´Ğ»Ñ ÑƒĞ´Ğ¾Ğ±ÑÑ‚Ğ²Ğ°
                batch["batch_id"] = batch_id
                found_batches.append(batch)
                logging.info(f"    âœ… ĞĞĞ™Ğ”Ğ•ĞĞ!")

    logging.info(f"ğŸ¯ Ğ˜Ñ‚Ğ¾Ğ³Ğ¾ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹: {len(found_batches)}")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ĞĞ‘Ğ ĞĞ‘ĞĞ¢ĞšĞ Ğ Ğ•Ğ—Ğ£Ğ›Ğ¬Ğ¢ĞĞ¢ĞĞ’ ĞŸĞĞ˜Ğ¡ĞšĞ
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if not found_batches:
        # ĞŸĞ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ñ‹
        keyboard = InlineKeyboardMarkup()
        keyboard.add(
            InlineKeyboardButton("ğŸ” ĞĞ°Ğ·Ğ°Ğ´ Ğº Ğ¿Ğ¾Ğ¸ÑĞºÑƒ", callback_data="back_to_search")
        )

        await callback.message.edit_text(
            f"âŒ <b>ĞŸĞ¾ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğµ '{culture}' Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾.</b>\n\n"
            f"ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ²Ñ‹Ğ±Ñ€Ğ°Ñ‚ÑŒ Ğ´Ñ€ÑƒĞ³ÑƒÑ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñƒ.",
            reply_markup=keyboard,
            parse_mode="HTML",
        )
        await state.finish()
        await callback.answer()
        return

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ğ¤ĞĞ ĞœĞ˜Ğ ĞĞ’ĞĞĞ˜Ğ• Ğ Ğ•Ğ—Ğ£Ğ›Ğ¬Ğ¢ĞĞ¢Ğ
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    # Ğ¡Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾ Ñ†ĞµĞ½Ğµ
    found_batches_sorted = sorted(found_batches, key=lambda x: x.get("price", 0))

    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ
    text = f"ğŸŒ¾ <b>ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹:</b> {len(found_batches)}\n\n"
    text += f"<b>ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°:</b> {culture}\n"
    text += f"<b>ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹:</b> {len(found_batches)}\n\n"

    # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ´ĞµÑ‚Ğ°Ğ»Ğ¸ Ğ¿ĞµÑ€Ğ²Ñ‹Ñ… 10 Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹
    for idx, batch in enumerate(found_batches_sorted[:10], 1):
        batch_id = batch.get("batch_id") or batch.get("id", 0)
        batch_culture = batch.get("culture", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°")
        volume = batch.get("volume", 0)
        price = batch.get("price", 0)
        region = batch.get("region", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        farmer_id = batch.get("farmer_id")

        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğµ
        farmer = users.get(farmer_id, {})
        farmer_name = farmer.get("name", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾")
        farmer_phone = farmer.get("phone", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")

        text += f"{idx}. <b>{batch_culture}</b> - {volume:.0f} Ñ‚\n"
        text += f"   ğŸ’° {price:,.0f} â‚½/Ñ‚ | ğŸ“ {region}\n"
        text += f"   ğŸ‘¤ Ğ¤ĞµÑ€Ğ¼ĞµÑ€: {farmer_name}\n"
        text += f"   ğŸ“ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: {farmer_phone}\n\n"

    if len(found_batches_sorted) > 10:
        text += f"...Ğ¸ ĞµÑ‰Ñ‘ {len(found_batches_sorted) - 10} Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹\n"

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ğ¡ĞĞ—Ğ”ĞĞĞ˜Ğ• ĞšĞ›ĞĞ’Ğ˜ĞĞ¢Ğ£Ğ Ğ«
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    keyboard = InlineKeyboardMarkup(row_width=1)

    # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ Ğ´Ğ»Ñ Ğ¿ĞµÑ€Ğ²Ñ‹Ñ… 10 Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹
    for batch in found_batches_sorted[:10]:
        batch_id = batch.get("batch_id") or batch.get("id", 0)
        batch_culture = batch.get("culture", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°")
        volume = batch.get("volume", 0)
        price = batch.get("price", 0)

        keyboard.add(
            InlineKeyboardButton(
                f"{batch_culture} - {volume:.0f} Ñ‚ | {price:,.0f} â‚½/Ñ‚",
                callback_data=f"view_batch:{batch_id}",
            )
        )

    keyboard.add(
        InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğº Ğ¿Ğ¾Ğ¸ÑĞºÑƒ", callback_data="back_to_search")
    )

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ĞĞ¢ĞŸĞ ĞĞ’ĞšĞ Ğ Ğ•Ğ—Ğ£Ğ›Ğ¬Ğ¢ĞĞ¢Ğ
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    try:
        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° edit_text: {e}")
        await callback.message.answer(text, reply_markup=keyboard, parse_mode="HTML")

    await state.finish()

    logging.info(f"âœ… ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¾ {len(found_batches)} Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ¿Ğ¾ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğµ '{culture}'")
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("contact_farmer:"))
async def contact_farmer_callback(callback: types.CallbackQuery):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ Ğ¡Ğ²ÑĞ·Ğ°Ñ‚ÑŒÑÑ Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ¼ - Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğµ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹"""
    global batches, users

    try:
        # Ğ˜Ğ·Ğ²Ğ»ĞµĞºĞ°ĞµĞ¼ batch_id Ğ¸Ğ· callback_data
        batch_id = int(callback.data.split(":")[1])
        logging.info(f"ğŸ“ Ğ—Ğ°Ğ¿Ñ€Ğ¾Ñ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ğ¾Ğ² Ğ´Ğ»Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ {batch_id}")

        # ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ² Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ¹ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğµ: batches = {batch_id: {farmer_id: ..., ...}}
        if batch_id not in batches:
            await callback.answer("âŒ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
            logging.warning(f"âŒ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ {batch_id} Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ° Ğ² batches")
            return

        found_batch = batches[batch_id]

        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ ÑÑ‚Ğ¾ ÑĞ»Ğ¾Ğ²Ğ°Ñ€ÑŒ
        if not isinstance(found_batch, dict):
            await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸", show_alert=True)
            logging.error(
                f"âŒ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ {batch_id} Ğ½Ğµ ÑĞ²Ğ»ÑĞµÑ‚ÑÑ ÑĞ»Ğ¾Ğ²Ğ°Ñ€Ñ‘Ğ¼: {type(found_batch)}"
            )
            return

        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ farmer_id Ğ¸Ğ· Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸
        farmer_id = found_batch.get("farmer_id")
        if not farmer_id:
            await callback.answer("âŒ Ğ¤ĞµÑ€Ğ¼ĞµÑ€ Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½", show_alert=True)
            logging.warning(f"âŒ Ğ£ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ {batch_id} Ğ½ĞµÑ‚ farmer_id")
            return

        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğµ
        farmer = users.get(farmer_id, {})
        farmer_name = farmer.get("name", "Ğ¤ĞµÑ€Ğ¼ĞµÑ€")
        farmer_phone = farmer.get("phone", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        farmer_email = farmer.get("email", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        farmer_company = farmer.get("company_name", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°")
        farmer_inn = farmer.get("inn", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        farmer_region = farmer.get("region", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")

        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸
        culture = found_batch.get("culture", "N/A")
        volume = found_batch.get("volume", 0)
        price = found_batch.get("price", 0)
        region = found_batch.get("region", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        quality = found_batch.get("quality_class", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        moisture = found_batch.get("moisture", "â€”")
        impurity = found_batch.get("impurity", "â€”")
        storage = found_batch.get("storage_type", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        readiness = found_batch.get("readiness_date", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°")

        # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ ĞºÑ€Ğ°ÑĞ¸Ğ²Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ñ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ğ°Ğ¼Ğ¸
        text = f"ğŸ“ <b>ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°</b>\n\n"
        text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        text += f"<b>ğŸ“¦ ĞŸĞĞ Ğ¢Ğ˜Ğ¯ #{batch_id}</b>\n"
        text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        text += f"<b>ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°:</b> {culture}\n"
        text += f"<b>ĞĞ±ÑŠÑ‘Ğ¼:</b> {volume:,.1f} Ñ‚\n"
        text += f"<b>Ğ¦ĞµĞ½Ğ°:</b> {price:,.0f} â‚½/Ñ‚\n"
        text += f"<b>Ğ ĞµĞ³Ğ¸Ğ¾Ğ½:</b> {region}\n"
        text += f"<b>ĞšĞ»Ğ°ÑÑ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ°:</b> {quality}\n"
        text += f"<b>Ğ’Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ:</b> {moisture}%\n"
        text += f"<b>Ğ¡Ğ¾Ñ€Ğ½Ğ¾ÑÑ‚ÑŒ:</b> {impurity}%\n"
        text += f"<b>Ğ¥Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ:</b> {storage}\n"
        text += f"<b>Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ½Ğ¾ÑÑ‚ÑŒ:</b> {readiness}\n\n"
        text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        text += f"<b>ğŸ‘¤ ĞšĞĞĞ¢ĞĞšĞ¢Ğ« Ğ¤Ğ•Ğ ĞœĞ•Ğ Ğ</b>\n"
        text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        text += f"<b>Ğ˜Ğ¼Ñ:</b> {farmer_name}\n"
        text += f"<b>ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ:</b> {farmer_company}\n"
        text += f"<b>Ğ˜ĞĞ:</b> {farmer_inn}\n"
        text += f"<b>Ğ ĞµĞ³Ğ¸Ğ¾Ğ½:</b> {farmer_region}\n"
        text += f"<b>Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½:</b> <code>{farmer_phone}</code>\n"
        text += f"<b>Email:</b> <code>{farmer_email}</code>\n\n"
        text += f"ğŸ’¬ Ğ’Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¿Ğ¾Ğ·Ğ²Ğ¾Ğ½Ğ¸Ñ‚ÑŒ Ğ¸Ğ»Ğ¸ Ğ½Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ñƒ Ğ´Ğ»Ñ Ğ¾Ğ±ÑÑƒĞ¶Ğ´ĞµĞ½Ğ¸Ñ ÑĞ´ĞµĞ»ĞºĞ¸."

        keyboard = InlineKeyboardMarkup(row_width=1)
        # ĞšĞ½Ğ¾Ğ¿ĞºĞ¸ Ğ´Ğ»Ñ Ğ¿Ñ€ÑĞ¼Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ğ°
        if farmer_phone and farmer_phone != "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½":
            keyboard.add(
                InlineKeyboardButton(
                    f"ğŸ“ ĞŸĞ¾Ğ·Ğ²Ğ¾Ğ½Ğ¸Ñ‚ÑŒ {farmer_phone}", url=f"tel:{farmer_phone}"
                )
            )
        keyboard.add(
            InlineKeyboardButton(
                "ğŸ’¬ ĞĞ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒ Ğ² Telegram", url=f"tg://user?id={farmer_id}"
            )
        )
        keyboard.add(
            InlineKeyboardButton("ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´ Ğº Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ°Ğ¼", callback_data="startsearch")
        )

        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
        logging.info(
            f"âœ… ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ñ‹ Ğ´Ğ»Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ {batch_id}, Ñ„ĞµÑ€Ğ¼ĞµÑ€ {farmer_id}"
        )

    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğ¸ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ğ¾Ğ²: {e}")
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ğ¾Ğ²", show_alert=True)

    await callback.answer()


# Ğ“Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ (ĞµÑĞ»Ğ¸ ĞµÑ‰Ñ‘ Ğ½Ğµ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ñ‹)
@dp.callback_query_handler(
    lambda c: c.data.startswith("culture:"), state=AddBatch.culture
)
async def add_batch_culture(callback: types.CallbackQuery, state: FSMContext):
    """Ğ’Ñ‹Ğ±Ğ¾Ñ€ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñ‹ Ğ´Ğ»Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""
    try:
        culture = callback.data.split(":", 1)[1]
    except (IndexError, ValueError) as e:
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ°Ñ€ÑĞ¸Ğ½Ğ³Ğ°: {e}, data: {callback.data}")
        return

    await state.update_data(culture=culture)

    await callback.message.edit_text(
        "ğŸ“¦ <b>Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸</b>\n\n" "Ğ¨Ğ°Ğ³ 2 Ğ¸Ğ· 9\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½:",
        reply_markup=region_keyboard(),
        parse_mode="HTML",
    )
    await AddBatch.region.set()
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("region:"), state=AddBatch.region
)
async def add_batch_region(callback: types.CallbackQuery, state: FSMContext):
    """Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ° Ğ´Ğ»Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""
    region = callback.data.split(":", 1)[1]
    await state.update_data(region=region)

    await callback.message.edit_text(
        "ğŸ“¦ <b>Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸</b>\n\n"
        "Ğ¨Ğ°Ğ³ 3 Ğ¸Ğ· 9\n\n"
        "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¾Ğ±ÑŠÑ‘Ğ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ (Ğ² Ñ‚Ğ¾Ğ½Ğ½Ğ°Ñ…):",
        parse_mode="HTML",
    )
    await AddBatch.volume.set()
    await callback.answer()


@dp.message_handler(state=AddBatch.volume)
async def add_batch_volume(message: types.Message, state: FSMContext):
    """Ğ’Ğ²Ğ¾Ğ´ Ğ¾Ğ±ÑŠÑ‘Ğ¼Ğ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""
    try:
        volume = float(message.text.strip().replace(",", "."))
        if volume <= 0:
            raise ValueError

        await state.update_data(volume=volume)

        await message.answer(
            "ğŸ“¦ <b>Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸</b>\n\n"
            "Ğ¨Ğ°Ğ³ 4 Ğ¸Ğ· 9\n\n"
            "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ†ĞµĞ½Ñƒ (â‚½/Ñ‚Ğ¾Ğ½Ğ½Ğ°):",
            parse_mode="HTML",
        )
        await AddBatch.price.set()

    except ValueError:
        await message.answer("âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ 0:")


@dp.message_handler(state=AddBatch.price)
async def add_batch_price(message: types.Message, state: FSMContext):
    """Ğ’Ğ²Ğ¾Ğ´ Ñ†ĞµĞ½Ñ‹ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""
    try:
        price = float(message.text.strip().replace(",", "."))
        if price <= 0:
            raise ValueError

        await state.update_data(price=price)

        await message.answer(
            "ğŸ“¦ <b>Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸</b>\n\n" "Ğ¨Ğ°Ğ³ 5 Ğ¸Ğ· 9\n\n" "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ²Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ (%):",
            parse_mode="HTML",
        )
        await AddBatch.humidity.set()

    except ValueError:
        await message.answer("âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ 0:")


@dp.message_handler(state=AddBatch.humidity)
async def add_batch_humidity(message: types.Message, state: FSMContext):
    """Ğ’Ğ²Ğ¾Ğ´ Ğ²Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""
    try:
        humidity = float(message.text.strip().replace(",", "."))
        if not 0 <= humidity <= 100:
            raise ValueError

        await state.update_data(humidity=humidity)

        await message.answer(
            "ğŸ“¦ <b>Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸</b>\n\n" "Ğ¨Ğ°Ğ³ 6 Ğ¸Ğ· 9\n\n" "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ÑĞ¾Ñ€Ğ½Ğ¾ÑÑ‚ÑŒ (%):",
            parse_mode="HTML",
        )
        await AddBatch.impurity.set()

    except ValueError:
        await message.answer("âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ Ğ¾Ñ‚ 0 Ğ´Ğ¾ 100:")


@dp.message_handler(state=AddBatch.impurity)
async def add_batch_impurity(message: types.Message, state: FSMContext):
    """Ğ’Ğ²Ğ¾Ğ´ ÑĞ¾Ñ€Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""
    try:
        impurity = float(message.text.strip().replace(",", "."))
        if not 0 <= impurity <= 100:
            raise ValueError

        await state.update_data(impurity=impurity)
        data = await state.get_data()
        quality_class = determine_quality_class(data["humidity"], impurity)
        await state.update_data(quality_class=quality_class)

        await message.answer(
            "ğŸ“¦ <b>Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸</b>\n\n"
            "Ğ¨Ğ°Ğ³ 7 Ğ¸Ğ· 9\n\n"
            f"ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½ ĞºĞ»Ğ°ÑÑ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ°: <b>{quality_class}</b>\n\n"
            "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ‚Ğ¸Ğ¿ Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ:",
            reply_markup=storage_type_keyboard(),
            parse_mode="HTML",
        )
        await AddBatch.storage_type.set()

    except ValueError:
        await message.answer("âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ Ğ¾Ñ‚ 0 Ğ´Ğ¾ 100:")


@dp.callback_query_handler(
    lambda c: c.data.startswith("storage:"), state=AddBatch.storage_type
)
async def add_batch_storage_type(callback: types.CallbackQuery, state: FSMContext):
    """Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ñ‚Ğ¸Ğ¿Ğ° Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ"""
    storage_type = callback.data.split(":", 1)[1]
    await state.update_data(storage_type=storage_type)

    await callback.message.edit_text(
        "ğŸ“¦ <b>Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸</b>\n\n"
        "Ğ¨Ğ°Ğ³ 8 Ğ¸Ğ· 9\n\n"
        "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ´Ğ°Ñ‚Ñƒ Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸ (Ğ² Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğµ Ğ”Ğ”.ĞœĞœ.Ğ“Ğ“Ğ“Ğ“) Ğ¸Ğ»Ğ¸ 'ÑĞµĞ¹Ñ‡Ğ°Ñ' ĞµÑĞ»Ğ¸ Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ°:",
        parse_mode="HTML",
    )
    await AddBatch.readiness_date.set()
    await callback.answer()


@dp.message_handler(state=AddBatch.readiness_date)
async def add_batch_readiness_date(message: types.Message, state: FSMContext):
    """Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğµ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ½Ğ¾Ğ¹ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""
    global batch_counter

    readiness_date = message.text.strip()

    if readiness_date.lower() == "ÑĞµĞ¹Ñ‡Ğ°Ñ":
        readiness_date = datetime.now().strftime("%d.%m.%Y")
    elif not validate_date(readiness_date):
        await message.answer(
            "âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ°Ñ Ğ´Ğ°Ñ‚Ğ°. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ğ”Ğ”.ĞœĞœ.Ğ“Ğ“Ğ“Ğ“ Ğ¸Ğ»Ğ¸ 'ÑĞµĞ¹Ñ‡Ğ°Ñ':"
        )
        return

    user_id = message.from_user.id
    data = await state.get_data()

    # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ
    batch_counter += 1
    batch = {
        "id": batch_counter,
        "farmer_id": user_id,
        "farmer_name": users[user_id].get("name", ""),
        "culture": data["culture"],
        "region": data["region"],
        "volume": data["volume"],
        "price": data["price"],
        "humidity": data["humidity"],
        "impurity": data["impurity"],
        "quality_class": data["quality_class"],
        "storage_type": data["storage_type"],
        "readiness_date": readiness_date,
        "status": "ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ°",
        "created_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "files": [],
        "matches": [],
    }

    # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ² Ğ±Ğ°Ğ·Ñƒ
    if user_id not in batches:
        batches[user_id] = []
    batches[user_id].append(batch)

    save_batches_to_pickle()

    # âœ… ĞĞ’Ğ¢ĞĞŸĞ Ğ˜Ğ¡ĞĞ•Ğ”Ğ˜ĞĞ•ĞĞ˜Ğ• Ğš ĞŸĞ£Ğ›Ğ£ (ĞµÑĞ»Ğ¸ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ²Ğ°Ğ»Ğ°ÑÑŒ Ğ´Ğ»Ñ Ğ¿ÑƒĞ»Ğ°)
    if "create_batch_for_pull_id" in data:
        pull_id = data["create_batch_for_pull_id"]

        if pull_id in pulls:
            pull = pulls["pulls"][pull_id]
            available = pull["target_volume"] - pull["current_volume"]

            if batch["volume"] <= available and batch["culture"] == pull["culture"]:
                if pull_id not in pullparticipants:
                    pullparticipants[pull_id] = []

                # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ñ‡Ñ‚Ğ¾ ĞµÑ‰Ñ‘ Ğ½Ğµ Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½Ğ¸Ğ»Ğ¸ÑÑŒ
                already_joined = any(
                    p["batch_id"] == batch["id"] for p in pullparticipants[pull_id]
                )

                if not already_joined:
                    participant = {
                        "farmer_id": user_id,
                        "farmer_name": users[user_id].get("name", ""),
                        "batch_id": batch["id"],
                        "volume": batch["volume"],
                        "joined_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    }
                    pullparticipants[pull_id].append(participant)
                    pull["current_volume"] += batch["volume"]

                    batch["status"] = "Ğ—Ğ°Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ°"

                    save_pulls_to_pickle()
                    save_batches_to_pickle()

                    logging.info(
                        f"âœ… ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ #{batch['id']} Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ° Ğº Ğ¿ÑƒĞ»Ñƒ #{pull_id}"
                    )

                    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ñƒ Ğ¾ Ğ½Ğ¾Ğ²Ğ¾Ğ¹ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸
                    try:
                        # âœ… ĞŸĞ ĞĞ’Ğ•Ğ ĞšĞ ĞĞĞ›Ğ˜Ğ§Ğ˜Ğ¯ Ğ­ĞšĞ¡ĞŸĞĞ Ğ¢ĞĞ Ğ
                        if "exporter_id" in pull and pull["exporter_id"]:
                            farmer_card = format_farmer_card(user_id, batch["id"])

                            await bot.send_message(
                                pull["exporter_id"],
                                f"ğŸ‰ <b>ĞĞ¾Ğ²Ğ°Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ° Ğº Ğ¿ÑƒĞ»Ñƒ #{pull_id}!</b>\n\n{farmer_card}",
                                parse_mode="HTML",
                            )
                            logging.info(
                                f"âœ… Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ñƒ {pull['exporter_id']} Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾"
                            )
                        else:
                            logging.warning(f"âš ï¸ Ğ’ Ğ¿ÑƒĞ»Ğµ {pull_id} Ğ½ĞµÑ‚ exporter_id")
                    except Exception as e:
                        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ñƒ: {e}")

                    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ñƒ Ğ¾Ğ± ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾Ğ¼ Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğ¸
                    await message.answer(
                        f"âœ… <b>ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ #{batch['id']} ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ° Ğ¸ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ° Ğº Ğ¿ÑƒĞ»Ñƒ #{pull_id}!</b>\n\n"
                        f"ğŸŒ¾ {batch['culture']}\n"
                        f"ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: {batch['volume']} Ñ‚\n"
                        f"ğŸ’° Ğ¦ĞµĞ½Ğ°: {batch['price']:,.0f} â‚½/Ñ‚\n\n"
                        f"Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ğ» ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¸ ÑĞ²ÑĞ¶ĞµÑ‚ÑÑ Ñ Ğ²Ğ°Ğ¼Ğ¸.",
                        parse_mode="HTML",
                        reply_markup=get_role_keyboard("farmer"),
                    )

                    await state.finish()
                    return

    # âœ… ĞĞ‘Ğ«Ğ§ĞĞ«Ğ™ Ğ¤Ğ›ĞĞ£ (Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ ĞĞ• Ğ´Ğ»Ñ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ¿ÑƒĞ»Ğ°)

    # Ğ¡Ğ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ñ Google Sheets
    if gs and gs.spreadsheet:
        try:
            gs.sync_batch_to_sheets(batch)
            farmer_name = users[user_id].get("name", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")
            await publish_batch_to_channel(batch, farmer_name)
        except Exception as e:
            logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ñ Google Sheets: {e}")

    # Ğ˜Ñ‰ĞµĞ¼ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´ÑÑ‰Ğ¸Ğµ Ğ¿ÑƒĞ»Ñ‹
    matching_pulls = await find_matching_exporters(batch)

    keyboard = get_role_keyboard("farmer")

    message_text = (
        f"âœ… <b>ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ #{batch['id']} Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ°!</b>\n\n"
        f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {batch['culture']}\n"
        f"ğŸ“ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½: {batch.get('region', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
        f"ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: {batch['volume']} Ñ‚\n"
        f"ğŸ’° Ğ¦ĞµĞ½Ğ°: {batch['price']:,.0f} â‚½/Ñ‚\n"
        f"ğŸ’§ Ğ’Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ: {batch.get('humidity', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}%\n"
        f"ğŸŒ¾ Ğ¡Ğ¾Ñ€Ğ½Ğ¾ÑÑ‚ÑŒ: {batch.get('impurity', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}%\n"
        f"â­ ĞšĞ»Ğ°ÑÑ: {batch.get('quality_class', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n"
        f"ğŸ­ Ğ¥Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ: {batch.get('storage_type', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n"
        f"ğŸ“… Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ½Ğ¾ÑÑ‚ÑŒ: {batch.get('readiness_date', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}"
    )

    if matching_pulls:
        message_text += f"\n\nğŸ¯ ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´ÑÑ‰Ğ¸Ñ… Ğ¿ÑƒĞ»Ğ¾Ğ²: {len(matching_pulls)}"

        # âœ… Ğ¡ĞĞ—Ğ”ĞĞ•Ğœ match-Ğ¾Ğ±ÑŠĞµĞºÑ‚Ñ‹ Ğ˜ Ğ¡ĞĞ¥Ğ ĞĞĞ¯Ğ•Ğœ Ğ’ matches
        match_objs = []
        for pull_dict in matching_pulls:
            pull_id = pull_dict["pull_id"]

            # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ match-Ğ¾Ğ±ÑŠĞµĞºÑ‚ Ğ´Ğ»Ñ notify_match()
            match_obj = {
                "pull_id": pull_id,
                "exporter_company": pull_dict.get("exporter_company", ""),
                "exporter_name": pull_dict.get("exporter_name", ""),
                "price": pull_dict.get("price", 0),
                "port": pull_dict.get("port", ""),
                "current_volume": pull_dict.get("current_volume", 0),
                "target_volume": pull_dict.get("target_volume", 0),
            }
            match_objs.append(match_obj)

            # âœ… Ğ¡ĞĞ¥Ğ ĞĞĞ¯Ğ•Ğœ Ğ’ matches
            match_id = len(matches) + 1
            matches[match_id] = {
                "id": match_id,
                "batch_id": batch["id"],
                "pull_id": pull_id,
                "status": "active",
                "created_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            }

        await asyncio.sleep(0.5)
        await notify_match(user_id, batch, match_objs)

    await message.answer(message_text, reply_markup=keyboard, parse_mode="HTML")
    await state.finish()


@dp.callback_query_handler(lambda c: c.data.startswith("view_matches:"), state="*")
async def view_batch_matches(callback: types.CallbackQuery):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğ¹ Ğ´Ğ»Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""
    try:
        batch_id = int(callback.data.split(":")[1])
    except (IndexError, ValueError) as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ°Ñ€ÑĞ¸Ğ½Ğ³Ğ° batch_id: {e}")
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    user_id = callback.from_user.id

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ² ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğµ {farmer_id: [batch_list]}
    batch = None
    farmer_id = None

    for fid, batch_list in batches.items():
        if isinstance(batch_list, list):
            for b in batch_list:
                if isinstance(b, dict) and b.get("id") == batch_id:
                    batch = b
                    farmer_id = fid
                    break
        if batch:
            break

    if not batch:
        await callback.answer("âŒ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    # Ğ˜Ñ‰ĞµĞ¼ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ
    batch_matches = []
    for match in matches.values():
        if match.get("batch_id") == batch_id and match.get("status") == "active":
            batch_matches.append(match)

    if not batch_matches:
        await callback.answer("ğŸ¤·â€â™‚ï¸ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğ¹ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾", show_alert=True)
        return

    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‚ĞµĞºÑÑ‚ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ
    text = f"ğŸ¯ <b>Ğ¡Ğ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ Ğ´Ğ»Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ #{batch_id}</b>\n\n"
    text += f"ğŸŒ¾ <b>{batch.get('culture', '?')}</b> â€¢ {batch.get('volume', 0)} Ñ‚ â€¢ {batch.get('price', 0):,.0f} â‚½/Ñ‚\n\n"

    # âœ… ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿ÑƒĞ»Ñ‹
    all_pulls = pulls.get("pulls", {})

    for i, match in enumerate(batch_matches[:5], 1):
        pull_id = match.get("pull_id")
        pull = all_pulls.get(pull_id) or all_pulls.get(str(pull_id))

        if pull and isinstance(pull, dict):
            target_volume = pull.get("target_volume", 0)
            current_volume = pull.get("current_volume", 0)
            progress = (
                (current_volume / target_volume * 100) if target_volume > 0 else 0
            )

            text += f"<b>{i}. ĞŸÑƒĞ» #{pull_id}</b>\n"
            text += (
                f"   ğŸ“¦ <b>ĞÑƒĞ¶Ğ½Ğ¾:</b> {target_volume} Ñ‚ ({progress:.0f}% Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¾)\n"
            )
            text += f"   ğŸ’° <b>Ğ¦ĞµĞ½Ğ°:</b> â‚½{pull.get('price', 0):,.0f}/Ñ‚\n"
            text += f"   ğŸš¢ <b>ĞŸĞ¾Ñ€Ñ‚:</b> {pull.get('port', '?')}\n"
            text += f"   ğŸ‘¤ <b>Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€:</b> {pull.get('exporter_name', '?')}\n"
            text += f"   ğŸ“‹ <b>Ğ£ÑĞ»Ğ¾Ğ²Ğ¸Ñ:</b> {pull.get('doc_type', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ñ‹')}\n\n"

    if len(batch_matches) > 5:
        text += f"<i>... Ğ¸ ĞµÑ‰Ñ‘ {len(batch_matches) - 5} ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğ¹</i>\n\n"

    text += "ğŸ’¡ <b>Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ğ¸Ñ:</b> Ğ¡Ğ²ÑĞ¶Ğ¸Ñ‚ĞµÑÑŒ Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°Ğ¼Ğ¸ Ğ´Ğ»Ñ Ğ¾Ğ±ÑÑƒĞ¶Ğ´ĞµĞ½Ğ¸Ñ Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹."

    keyboard = InlineKeyboardMarkup(row_width=1)
    keyboard.add(
        InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data=f"view_batch:{batch_id}")
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.message_handler(lambda m: m.text == "ğŸ”§ ĞœĞ¾Ğ¸ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸", state="*")
async def view_my_batches(message: types.Message, state: FSMContext):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ²ÑĞµÑ… Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ° Ñ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¼Ğ¸ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°Ğ¼Ğ¸ Ñ‡ĞµÑ€ĞµĞ· ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ¼Ğ°Ğ¿"""

    global batches
    await state.finish()

    user_id = message.from_user.id
    if user_id not in users or users[user_id].get("role") != "farmer":
        await message.answer("âŒ Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°Ğ¼")
        return

    if user_id not in batches or not batches[user_id]:
        await message.answer(
            "ğŸ“¦ Ğ£ Ğ²Ğ°Ñ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ñ… Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹.\n\n"
            "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ 'â• Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ' Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ½Ğ¾Ğ²Ğ¾Ğ¹."
        )
        return

    user_batches = batches[user_id]

    # Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ Ğ¼Ğ°Ğ¿ Ğ´Ğ»Ñ ÑĞ¾Ğ¿Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ñ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ¾Ğ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸
    status_map = {
        "active": ["Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ°", "matched"],
        "reserved": ["Ğ·Ğ°Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ°"],
        "sold": ["Ğ¿Ñ€Ğ¾Ğ´Ğ°Ğ½Ğ°"],
        "withdrawn": ["ÑĞ½ÑÑ‚Ğ° Ñ Ğ¿Ñ€Ğ¾Ğ´Ğ°Ğ¶Ğ¸"],
    }

    def in_status_group(batch_status, group):
        return batch_status.lower() in status_map.get(group, [])

    active_batches = [
        b for b in user_batches if in_status_group(b.get("status", ""), "active")
    ]
    reserved_batches = [
        b for b in user_batches if in_status_group(b.get("status", ""), "reserved")
    ]
    sold_batches = [
        b for b in user_batches if in_status_group(b.get("status", ""), "sold")
    ]
    withdrawn_batches = [
        b for b in user_batches if in_status_group(b.get("status", ""), "withdrawn")
    ]

    keyboard = InlineKeyboardMarkup(row_width=1)

    for batch in active_batches:
        has_matches = any(
            m["batch_id"] == batch["id"] and m["status"] == "active"
            for m in matches.values()
        )
        match_emoji = "ğŸ¯ " if has_matches else ""
        button_text = (
            f"{match_emoji}âœ… {batch['culture']} - {batch['volume']} Ñ‚ "
            f"({batch['price']:,.0f} â‚½/Ñ‚)"
        )
        keyboard.add(
            InlineKeyboardButton(button_text, callback_data=f"view_batch:{batch['id']}")
        )

    for batch in reserved_batches:
        button_text = (
            f"ğŸ”’ {batch['culture']} - {batch['volume']} Ñ‚ "
            f"({batch['price']:,.0f} â‚½/Ñ‚)"
        )
        keyboard.add(
            InlineKeyboardButton(button_text, callback_data=f"view_batch:{batch['id']}")
        )

    for batch in sold_batches:
        button_text = (
            f"ğŸ’° {batch['culture']} - {batch['volume']} Ñ‚ "
            f"({batch['price']:,.0f} â‚½/Ñ‚)"
        )
        keyboard.add(
            InlineKeyboardButton(button_text, callback_data=f"view_batch:{batch['id']}")
        )

    for batch in withdrawn_batches:
        button_text = (
            f"âŒ {batch['culture']} - {batch['volume']} Ñ‚ "
            f"({batch['price']:,.0f} â‚½/Ñ‚)"
        )
        keyboard.add(
            InlineKeyboardButton(button_text, callback_data=f"view_batch:{batch['id']}")
        )

    keyboard.add(
        InlineKeyboardButton("ğŸ”„ ĞĞ²Ñ‚Ğ¾Ğ¿Ğ¾Ğ¸ÑĞº ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ²", callback_data="auto_match_all")
    )

    await message.answer(
        f"ğŸ“¦ <b>Ğ’Ğ°ÑˆĞ¸ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸</b> ({len(user_batches)} ÑˆÑ‚.)\n\n"
        f"âœ… ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ: {len(active_batches)}\n"
        f"ğŸ”’ Ğ—Ğ°Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ: {len(reserved_batches)}\n"
        f"ğŸ’° ĞŸÑ€Ğ¾Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ: {len(sold_batches)}\n"
        f"âŒ Ğ¡Ğ½ÑÑ‚Ñ‹Ğµ Ñ Ğ¿Ñ€Ğ¾Ğ´Ğ°Ğ¶Ğ¸: {len(withdrawn_batches)}\n"
        f"ğŸ¯ Ğ¡ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸ÑĞ¼Ğ¸: {len([b for b in active_batches if any(m['batch_id'] == b['id'] and m['status'] == 'active' for m in matches.values())])}\n\n"
        "ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ Ğ½Ğ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ° Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹:",
        reply_markup=keyboard,
        parse_mode="HTML",
    )


@dp.message_handler(lambda m: m.text == "ğŸ¯ ĞŸÑƒĞ»Ñ‹", state="*")
async def view_pools_menu(message: types.Message, state: FSMContext):
    """âœ… ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ¿ÑƒĞ»Ğ¾Ğ² Ğ´Ğ»Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°"""
    await state.finish()

    user_id = message.from_user.id
    if user_id not in users or users[user_id].get("role") != "farmer":
        await message.answer("âŒ Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°Ğ¼")
        return

    # âœ… Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ: Ğ˜Ğ·Ğ²Ğ»ĞµĞºĞ°ĞµĞ¼ Ğ¿ÑƒĞ»Ñ‹ Ğ¸Ğ· Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑÑ‚Ğ°
    all_pulls = pulls.get("pulls", {})

    if not all_pulls:
        logging.info(f"ğŸ“Š ĞŸÑƒĞ»Ğ¾Ğ² Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾. pulls.keys() = {list(pulls.keys())}")
        await message.answer(
            "ğŸ¯ <b>ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ¿ÑƒĞ»Ñ‹</b>\n\n"
            "Ğ¡ĞµĞ¹Ñ‡Ğ°Ñ Ğ½ĞµÑ‚ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… Ğ¿ÑƒĞ»Ğ¾Ğ² Ğ´Ğ»Ñ ÑƒÑ‡Ğ°ÑÑ‚Ğ¸Ñ.\n"
            "ĞŸÑƒĞ»Ñ‹ ÑĞ¾Ğ·Ğ´Ğ°ÑÑ‚ÑÑ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°Ğ¼Ğ¸ Ğ´Ğ»Ñ ÑĞ±Ğ¾Ñ€Ğ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ·ĞµÑ€Ğ½Ğ°.",
            parse_mode="HTML",
        )
        return

    # âœ… Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ: Ğ˜Ñ‚ĞµÑ€Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾ all_pulls
    open_pulls = []
    for pull_id, pull in all_pulls.items():
        if not isinstance(pull, dict):
            logging.warning(f"âš ï¸ ĞŸÑƒĞ» {pull_id} Ğ½Ğµ dict: {type(pull)}")
            continue

        if pull.get("status") in ["active", "ĞÑ‚ĞºÑ€Ñ‹Ñ‚", "open"]:
            pull_data = pull.copy()
            pull_data["pull_id"] = pull_id
            open_pulls.append(pull_data)

    logging.info(f"ğŸ“Š ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… Ğ¿ÑƒĞ»Ğ¾Ğ²: {len(open_pulls)} Ğ¸Ğ· {len(all_pulls)}")

    if not open_pulls:
        await message.answer(
            "ğŸ¯ <b>ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ¿ÑƒĞ»Ñ‹</b>\n\n"
            "Ğ¡ĞµĞ¹Ñ‡Ğ°Ñ Ğ½ĞµÑ‚ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… Ğ¿ÑƒĞ»Ğ¾Ğ² Ğ´Ğ»Ñ ÑƒÑ‡Ğ°ÑÑ‚Ğ¸Ñ.\n"
            "ĞŸÑƒĞ»Ñ‹ ÑĞ¾Ğ·Ğ´Ğ°ÑÑ‚ÑÑ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°Ğ¼Ğ¸ Ğ´Ğ»Ñ ÑĞ±Ğ¾Ñ€Ğ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ·ĞµÑ€Ğ½Ğ°.",
            parse_mode="HTML",
        )
        return

    keyboard = InlineKeyboardMarkup(row_width=1)

    for pull in open_pulls[:10]:
        pull_id = pull.get("pull_id")

        if pull_id is None:
            logging.warning(f"âš ï¸ pull_id is None Ğ´Ğ»Ñ Ğ¿ÑƒĞ»Ğ°: {pull}")
            continue

        progress = (
            pull.get("current_volume", 0) / pull.get("target_volume", 1) * 100
            if pull.get("target_volume", 1) > 0
            else 0
        )

        button_text = (
            f"ğŸŒ¾ {pull.get('culture', '?')} - "
            f"{pull.get('target_volume', 0)}Ñ‚ ({progress:.0f}%)"
        )

        # âœ… Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ: Ñ Ğ¿Ğ¾Ğ´Ñ‡Ñ‘Ñ€ĞºĞ¸Ğ²Ğ°Ğ½Ğ¸ĞµĞ¼
        callback_data = f"view_pull:{pull_id}"

        keyboard.add(InlineKeyboardButton(button_text, callback_data=callback_data))

    await message.answer(
        f"ğŸ¯ <b>ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ¿ÑƒĞ»Ñ‹</b> ({len(open_pulls)} ÑˆÑ‚.)\n\n"
        "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿ÑƒĞ» Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ° Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹ Ğ¸ Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ:",
        reply_markup=keyboard,
        parse_mode="HTML",
    )


@dp.message_handler(state=JoinPullStatesGroup.volume)
async def join_pull_volume(message: types.Message, state: FSMContext):
    """Ğ’Ğ²Ğ¾Ğ´ Ğ¾Ğ±ÑŠÑ‘Ğ¼Ğ° Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ Ğº Ğ¿ÑƒĞ»Ñƒ"""
    try:
        volume = float(message.text.strip().replace(",", ".").replace(" ", ""))
        if volume <= 0:
            raise ValueError

        data = await state.get_data()
        pull_id = data.get("pull_id")
        batch_id = data.get("batch_id")
        user_id = message.from_user.id

        # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿ÑƒĞ»Ñ‹ Ğ¸Ğ· Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑÑ‚Ğ°
        all_pulls = pulls.get("pulls", {})
        pull = all_pulls.get(pull_id) or all_pulls.get(str(pull_id))

        if not pull:
            await message.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½")
            await state.finish()
            return

        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑÑ‚Ğ°
        target_volume = pull.get("target_volume", 0)
        current_volume = pull.get("current_volume", 0)
        available = target_volume - current_volume

        if volume > available:
            await message.answer(
                f"âŒ ĞŸÑ€ĞµĞ²Ñ‹ÑˆĞµĞ½ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğ¹ Ğ¾Ğ±ÑŠÑ‘Ğ¼!\n"
                f"Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾: {available:,.0f} Ñ‚\n"
                f"Ğ’Ñ‹ ÑƒĞºĞ°Ğ·Ğ°Ğ»Ğ¸: {volume:,.0f} Ñ‚"
            )
            return

        # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ° Ğ² pullparticipants
        all_pullparticipants = pulls.get("pullparticipants", {})
        pull_id_str = str(pull_id)

        if pull_id_str not in all_pullparticipants:
            all_pullparticipants[pull_id_str] = []

        all_pullparticipants[pull_id_str].append(
            {
                "farmer_id": user_id,
                "farmer_name": users[user_id].get("name", "?"),
                "batch_id": batch_id,
                "volume": volume,
                "joined_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            }
        )

        # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğ¹ Ğ¾Ğ±ÑŠÑ‘Ğ¼ Ğ¿ÑƒĞ»Ğ°
        pull["current_volume"] = current_volume + volume

        save_pulls_to_pickle()

        # âœ… ĞšĞ›Ğ®Ğ§Ğ•Ğ’ĞĞ¯ ĞŸĞ ĞĞ’Ğ•Ğ ĞšĞ - Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ½Ğ¾ÑÑ‚ÑŒ
        is_full = False
        if pull["current_volume"] >= pull.get("target_volume", 0):
            pull["status"] = "filled"
            is_full = True
            logging.info(f"ğŸ‰ ĞŸÑƒĞ» #{pull_id} Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½ Ğ½Ğ° 100%!")

        await state.finish()

        if is_full:
            # ĞŸÑƒĞ» Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½ Ğ½Ğ° 100%
            await message.answer(
                f"ğŸ‰ <b>ĞŸĞ¾Ğ·Ğ´Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼!</b>\n\n"
                f"Ğ’Ğ°ÑˆĞ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ°: {volume:,.0f} Ñ‚\n\n"
                f"âœ… <b>ĞŸÑƒĞ» #{pull_id} Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½ Ğ½Ğ° 100%!</b>\n\n"
                f"ĞŸÑƒĞ» Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚ Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ° ÑĞ´ĞµĞ»ĞºĞ°.\n"
                f"Ğ”ĞµÑ‚Ğ°Ğ»Ğ¸ ÑĞ´ĞµĞ»ĞºĞ¸ Ğ¿Ñ€Ğ¸Ğ´ÑƒÑ‚ Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ğ¾.",
                parse_mode="HTML",
                reply_markup=farmer_keyboard(),
            )
        else:
            # ĞĞ±Ñ‹Ñ‡Ğ½Ğ¾Ğµ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ
            fill_percent = (pull["current_volume"] / pull.get("target_volume", 1)) * 100
            remaining = pull.get("target_volume", 0) - pull["current_volume"]

            await message.answer(
                f"âœ… <b>ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ° Ğ² Ğ¿ÑƒĞ»!</b>\n\n"
                f"ğŸ“¦ Ğ’Ğ°Ñˆ Ğ¾Ğ±ÑŠĞµĞ¼: {volume:,.0f} Ñ‚\n"
                f"ğŸ’µ Ğ¦ĞµĞ½Ğ°: â‚½{pull.get('price', 0):,.0f}/Ñ‚\n"
                f"ğŸ’° Ğ’Ğ°ÑˆĞ° ÑÑƒĞ¼Ğ¼Ğ°: â‚½{volume * pull.get('price', 0):,.0f}\n\n"
                f"ğŸ“Š <b>Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ½Ğ¾ÑÑ‚ÑŒ Ğ¿ÑƒĞ»Ğ°:</b>\n"
                f"{pull['current_volume']:,.0f} / {pull.get('target_volume', 0):,.0f} Ñ‚ ({fill_percent:.1f}%)\n"
                f"ĞÑÑ‚Ğ°Ğ»Ğ¾ÑÑŒ: {remaining:,.0f} Ñ‚\n\n"
                f"Ğ’Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚Ğµ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ, ĞºĞ¾Ğ³Ğ´Ğ° Ğ¿ÑƒĞ» Ğ±ÑƒĞ´ĞµÑ‚ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½.",
                parse_mode="HTML",
                reply_markup=farmer_keyboard(),
            )

        logging.info(
            f"Batch {batch_id} â†’ Pull {pull_id}, volume: {volume}, full: {is_full}"
        )

    except ValueError:
        await message.answer("âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¹ Ğ¾Ğ±ÑŠÑ‘Ğ¼. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾.")


@dp.callback_query_handler(lambda c: c.data == "refresh_prices", state="*")
async def refresh_prices(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ Ñ†ĞµĞ½ (Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğµ)"""
    await state.finish()

    prices_msg = format_prices_message()

    try:
        await callback.message.edit_text(prices_msg, parse_mode="HTML")
        await callback.answer("âœ… Ğ¦ĞµĞ½Ñ‹ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ñ‹!")
    except MessageNotModified:
        await callback.answer("â„¹ï¸ Ğ¦ĞµĞ½Ñ‹ Ğ°ĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ñ‹", show_alert=False)


@dp.callback_query_handler(lambda c: c.data == "refresh_news", state="*")
async def refresh_news(callback: types.CallbackQuery):
    """ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ½Ğ¾Ğ²Ğ¾ÑÑ‚ĞµĞ¹"""
    await callback.answer("ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ½Ğ¾Ğ²Ğ¾ÑÑ‚Ğ¸...")
    await update_news_cache()

    news_msg = format_news_message()
    await callback.message.edit_text(
        news_msg, parse_mode="HTML", disable_web_page_preview=True
    )


@dp.callback_query_handler(
    lambda c: c.data in ["view_analytics", "view_grain_news", "view_export_news"],
    state="*",
)
@dp.callback_query_handler(lambda c: c.data == "auto_match_all", state="*")
async def auto_match_all_batches(callback: types.CallbackQuery):
    """ĞĞ²Ñ‚Ğ¾Ğ¿Ğ¾Ğ¸ÑĞº ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ² Ğ´Ğ»Ñ Ğ²ÑĞµÑ… Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹"""
    user_id = callback.from_user.id

    if user_id not in batches:
        await callback.answer("âŒ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹", show_alert=True)
        return

    active_batches = [b for b in batches[user_id] if b.get("status") == "ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ°"]

    if not active_batches:
        await callback.answer("âŒ ĞĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹", show_alert=True)
        return

    await callback.answer("ğŸ” Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ğ¿Ğ¾Ğ¸ÑĞº ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ²...")

    total_matches = 0
    for batch in active_batches:
        matching_pulls = await find_matching_exporters(batch)
        if matching_pulls:
            total_matches += len(matching_pulls)
            for pull in matching_pulls:
                await notify_match(user_id, batch, [pull])
        await asyncio.sleep(0.5)  # Ğ—Ğ°Ğ´ĞµÑ€Ğ¶ĞºĞ° Ğ¼ĞµĞ¶Ğ´Ñƒ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ°Ğ¼Ğ¸

    if total_matches > 0:
        await callback.message.answer(
            f"âœ… ĞĞ²Ñ‚Ğ¾Ğ¿Ğ¾Ğ¸ÑĞº Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½!\n\n"
            f"ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğ¹: {total_matches}\n"
            f"Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ğ»Ğ¸ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ¾ Ğ²Ğ°ÑˆĞ¸Ñ… Ğ¿Ğ°Ñ€Ñ‚Ğ¸ÑÑ…."
        )
    else:
        await callback.message.answer(
            "ğŸ¤·â€â™‚ï¸ Ğš ÑĞ¾Ğ¶Ğ°Ğ»ĞµĞ½Ğ¸Ñ, Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´ÑÑ‰Ğ¸Ñ… ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ² Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾.\n\n"
            "Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´ÑƒĞµĞ¼:\n"
            "â€¢ ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ°ĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ Ñ†ĞµĞ½\n"
            "â€¢ Ğ£Ñ‚Ğ¾Ñ‡Ğ½Ğ¸Ñ‚ÑŒ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ°\n"
            "â€¢ ĞŸĞ¾Ğ´Ğ¾Ğ¶Ğ´Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ñ… Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹"
        )
    await callback.answer()


@dp.message_handler(lambda m: m.text == "â• Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¿ÑƒĞ»", state="*")
async def create_pull_start(message: types.Message, state: FSMContext):
    await state.finish()
    userid = message.from_user.id

    if userid not in users or users[userid].get("role") != "exporter":
        await message.answer("âŒ Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€Ğ¾Ğ².")
        return

    await CreatePullStatesGroup.culture.set()
    await message.answer(
        "ğŸŒ¾ <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ°</b>\n\n" "<b>Ğ¨Ğ°Ğ³ 1 Ğ¸Ğ· 10</b>\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñƒ:",
        reply_markup=culture_keyboard(),
        parse_mode="HTML",
    )
    logging.info(
        f"User {userid} started pull creation, state set to CreatePullStatesGroup.culture"
    )


# âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñ‹
@dp.callback_query_handler(
    lambda c: c.data.startswith("culture:"), state=CreatePullStatesGroup.culture
)
async def create_pull_culture_callback(
    callback: types.CallbackQuery, state: FSMContext
):
    logging.info(
        f"Received callback: {callback.data}, state: {await state.get_state()}"
    )

    try:
        culture = callback.data.split(":", 1)[1]
        logging.info(f"Parsed culture: {culture}")
    except (IndexError, ValueError) as e:
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñ‹", show_alert=True)
        logging.error(f"Culture selection error: {e}, data: {callback.data}")
        return

    await state.update_data(culture=culture)

    try:
        await callback.message.edit_text(
            f"ğŸŒ¾ <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ°</b>\n\n"
            f"<b>Ğ¨Ğ°Ğ³ 2 Ğ¸Ğ· 10</b>\n\n"
            f"Ğ’Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ° ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: <b>{culture}</b>\n\n"
            f"Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ†ĞµĞ»ĞµĞ²Ğ¾Ğ¹ Ğ¾Ğ±ÑŠĞµĞ¼ Ğ¿ÑƒĞ»Ğ° (Ğ² Ñ‚Ğ¾Ğ½Ğ½Ğ°Ñ…):",
            parse_mode="HTML",
        )
    except Exception as e:
        logging.error(f"Error editing message: {e}")
        await callback.message.answer(
            f"ğŸŒ¾ <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ°</b>\n\n"
            f"<b>Ğ¨Ğ°Ğ³ 2 Ğ¸Ğ· 10</b>\n\n"
            f"Ğ’Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ° ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: <b>{culture}</b>\n\n"
            f"Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ†ĞµĞ»ĞµĞ²Ğ¾Ğ¹ Ğ¾Ğ±ÑŠĞµĞ¼ Ğ¿ÑƒĞ»Ğ° (Ğ² Ñ‚Ğ¾Ğ½Ğ½Ğ°Ñ…):",
            parse_mode="HTML",
        )

    await CreatePullStatesGroup.volume.set()
    await callback.answer()
    logging.info("State changed to CreatePullStatesGroup.volume")


# ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¾Ğ±ÑŠĞµĞ¼Ğ°
@dp.message_handler(state=CreatePullStatesGroup.volume)
async def create_pull_volume(message: types.Message, state: FSMContext):
    try:
        volume = float(message.text.strip().replace(",", "."))
        if volume <= 0:
            raise ValueError
        await state.update_data(volume=volume)
        await message.answer(
            f"ğŸŒ¾ <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ°</b>\n\n"
            f"<b>Ğ¨Ğ°Ğ³ 3 Ğ¸Ğ· 10</b>\n\n"
            f"ĞĞ±ÑŠĞµĞ¼: <b>{volume:,.0f} Ñ‚Ğ¾Ğ½Ğ½</b>\n\n"
            f"Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ†ĞµĞ½Ñƒ FOB (â‚½/Ñ‚Ğ¾Ğ½Ğ½Ğ°):",
            parse_mode="HTML",
        )
        await CreatePullStatesGroup.price.set()
    except ValueError:
        await message.answer("âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¹ Ğ¾Ğ±ÑŠĞµĞ¼. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾.")


# ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ñ†ĞµĞ½Ñ‹
@dp.message_handler(state=CreatePullStatesGroup.price)
async def create_pull_price(message: types.Message, state: FSMContext):
    try:
        price = float(message.text.strip().replace(",", "."))
        if price <= 0:
            raise ValueError
        await state.update_data(price=price)
        await message.answer(
            f"ğŸŒ¾ <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ°</b>\n\n"
            f"<b>Ğ¨Ğ°Ğ³ 4 Ğ¸Ğ· 10</b>\n\n"
            f"Ğ¦ĞµĞ½Ğ°: <b>â‚½{price:,.0f}/Ñ‚Ğ¾Ğ½Ğ½Ğ°</b>\n\n"
            f"Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ñ€Ñ‚ Ğ¾Ñ‚Ğ³Ñ€ÑƒĞ·ĞºĞ¸:",
            reply_markup=port_keyboard(),
            parse_mode="HTML",
        )
        await CreatePullStatesGroup.port.set()
    except ValueError:
        await message.answer("âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ°Ñ Ñ†ĞµĞ½Ğ°. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾.")


# ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¿Ğ¾Ñ€Ñ‚Ğ°
# ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¿Ğ¾Ñ€Ñ‚Ğ°
@dp.callback_query_handler(
    lambda c: c.data.startswith("selectport_"), state=CreatePullStatesGroup.port
)
async def create_pull_port_callback(callback: types.CallbackQuery, state: FSMContext):
    logging.info(
        f"Received port callback: {callback.data}, state: {await state.get_state()}"
    )

    try:
        port = callback.data.split("_", 1)[1]
        logging.info(f"Parsed port: {port}")
    except (IndexError, ValueError) as e:
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ğ¿Ğ¾Ñ€Ñ‚Ğ°", show_alert=True)
        logging.error(f"Port selection error: {e}, data: {callback.data}")
        return

    await state.update_data(port=port)

    try:
        await callback.message.edit_text(
            f"ğŸŒ¾ <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ°</b>\n\n"
            f"<b>Ğ¨Ğ°Ğ³ 5 Ğ¸Ğ· 10</b>\n\n"
            f"ĞŸĞ¾Ñ€Ñ‚: <b>{port}</b>\n\n"
            f"Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½ÑƒÑ Ğ²Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ (%):",
            parse_mode="HTML",
        )
    except Exception as e:
        logging.error(f"Error editing message: {e}")
        await callback.message.answer(
            f"ğŸŒ¾ <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ°</b>\n\n"
            f"<b>Ğ¨Ğ°Ğ³ 5 Ğ¸Ğ· 10</b>\n\n"
            f"ĞŸĞ¾Ñ€Ñ‚: <b>{port}</b>\n\n"
            f"Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½ÑƒÑ Ğ²Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ (%):",
            parse_mode="HTML",
        )

    await CreatePullStatesGroup.moisture.set()
    await callback.answer()
    logging.info(f"Port set: {port}, state changed to CreatePullStatesGroup.moisture")


# ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚Ğ¸
@dp.message_handler(state=CreatePullStatesGroup.moisture)
async def create_pull_moisture(message: types.Message, state: FSMContext):
    try:
        moisture = float(message.text.strip().replace(",", "."))
        if not (0 <= moisture <= 100):
            raise ValueError
        await state.update_data(moisture=moisture)
        await message.answer(
            f"ğŸŒ¾ <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ°</b>\n\n"
            f"<b>Ğ¨Ğ°Ğ³ 6 Ğ¸Ğ· 10</b>\n\n"
            f"Ğ’Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ: <b>{moisture}%</b>\n\n"
            f"Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½ÑƒÑ Ğ½Ğ°Ñ‚ÑƒÑ€Ñƒ (Ğ³/Ğ»):",
            parse_mode="HTML",
        )
        await CreatePullStatesGroup.nature.set()
    except ValueError:
        await message.answer("âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ°Ñ Ğ²Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ Ğ¾Ñ‚ 0 Ğ´Ğ¾ 100.")


# ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ½Ğ°Ñ‚ÑƒÑ€Ñ‹
@dp.message_handler(state=CreatePullStatesGroup.nature)
async def create_pull_nature(message: types.Message, state: FSMContext):
    try:
        nature = float(message.text.strip().replace(",", "."))
        if nature <= 0:
            raise ValueError
        await state.update_data(nature=nature)
        await message.answer(
            f"ğŸŒ¾ <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ°</b>\n\n"
            f"<b>Ğ¨Ğ°Ğ³ 7 Ğ¸Ğ· 10</b>\n\n"
            f"ĞĞ°Ñ‚ÑƒÑ€Ğ°: <b>{nature} Ğ³/Ğ»</b>\n\n"
            f"Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½ÑƒÑ ÑĞ¾Ñ€Ğ½ÑƒÑ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑÑŒ (%):",
            parse_mode="HTML",
        )
        await CreatePullStatesGroup.impurity.set()
    except ValueError:
        await message.answer("âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ°Ñ Ğ½Ğ°Ñ‚ÑƒÑ€Ğ°. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾.")


# ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ÑĞ¾Ñ€Ğ½Ğ¾Ğ¹ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑĞ¸
@dp.message_handler(state=CreatePullStatesGroup.impurity)
async def create_pull_impurity(message: types.Message, state: FSMContext):
    try:
        impurity = float(message.text.strip().replace(",", "."))
        if not (0 <= impurity <= 100):
            raise ValueError
        await state.update_data(impurity=impurity)
        await message.answer(
            f"ğŸŒ¾ <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ°</b>\n\n"
            f"<b>Ğ¨Ğ°Ğ³ 8 Ğ¸Ğ· 10</b>\n\n"
            f"Ğ¡Ğ¾Ñ€Ğ½Ğ°Ñ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑÑŒ: <b>{impurity}%</b>\n\n"
            f"Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½ÑƒÑ Ğ·ĞµÑ€Ğ½Ğ¾Ğ²ÑƒÑ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑÑŒ (%):",
            parse_mode="HTML",
        )
        await CreatePullStatesGroup.weed.set()
    except ValueError:
        await message.answer("âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ°Ñ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑÑŒ. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ Ğ¾Ñ‚ 0 Ğ´Ğ¾ 100.")


# ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ·ĞµÑ€Ğ½Ğ¾Ğ²Ğ¾Ğ¹ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑĞ¸
@dp.message_handler(state=CreatePullStatesGroup.weed)
async def create_pull_weed(message: types.Message, state: FSMContext):
    try:
        weed = float(message.text.strip().replace(",", "."))
        if not (0 <= weed <= 100):
            raise ValueError
        await state.update_data(weed=weed)
        await message.answer(
            f"ğŸŒ¾ <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ°</b>\n\n"
            f"<b>Ğ¨Ğ°Ğ³ 9 Ğ¸Ğ· 10</b>\n\n"
            f"Ğ—ĞµÑ€Ğ½Ğ¾Ğ²Ğ°Ñ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑÑŒ: <b>{weed}%</b>\n\n"
            f"ĞšĞ°ĞºĞ¸Ğµ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ñ‹ Ñ‚Ñ€ĞµĞ±ÑƒÑÑ‚ÑÑ? (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: Ğ¤Ğ¸Ñ‚Ğ¾ÑĞµÑ€Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ‚, ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ¾, Ğ²ĞµÑ‚ÑĞµÑ€Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ‚)",
            parse_mode="HTML",
        )
        await CreatePullStatesGroup.documents.set()
    except ValueError:
        await message.answer("âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ°Ñ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑÑŒ. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ Ğ¾Ñ‚ 0 Ğ´Ğ¾ 100.")


@dp.message_handler(state=CreatePullStatesGroup.documents)
async def create_pull_documents(message: types.Message, state: FSMContext):
    documents = message.text.strip()
    await state.update_data(documents=documents)

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ°Ñ ĞºĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ°
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("CPT", callback_data="doctype_CPT"),
        InlineKeyboardButton("FOB", callback_data="doctype_FOB"),
    )
    keyboard.add(
        InlineKeyboardButton("CIF", callback_data="doctype_CIF"),
        InlineKeyboardButton("EXW", callback_data="doctype_EXW"),
    )

    await message.answer(
        f"ğŸŒ¾ <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ°</b>\n\n"
        f"<b>Ğ¨Ğ°Ğ³ 10 Ğ¸Ğ· 10</b>\n\n"
        f"Ğ”Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ñ‹: <b>{documents}</b>\n\n"
        f"Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ‚Ğ¸Ğ¿ Ğ¿Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸:",
        reply_markup=keyboard,
        parse_mode="HTML",
    )
    await CreatePullStatesGroup.doctype.set()
    logging.info(
        f"Documents set: {documents}, state changed to CreatePullStatesGroup.doctype"
    )


@dp.callback_query_handler(
    lambda c: c.data.startswith("doctype_"), state=CreatePullStatesGroup.doctype
)
async def create_pull_finish(callback: types.CallbackQuery, state: FSMContext):
    global pull_counter

    logging.info(
        f"Received doctype callback: {callback.data}, state: {await state.get_state()}"
    )

    try:
        doctype = callback.data.split("_", 1)[1]
        logging.info(f"Parsed doctype: {doctype}")
    except (IndexError, ValueError) as e:
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ñ‚Ğ¸Ğ¿Ğ° Ğ¿Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸", show_alert=True)
        logging.error(f"Doctype selection error: {e}, data: {callback.data}")
        return

    await state.update_data(doctype=doctype)
    data = await state.get_data()
    userid = callback.from_user.id

    # âœ… Ğ¡ĞĞ—Ğ”ĞĞĞ˜Ğ• ĞŸĞ£Ğ›Ğ Ğ¡ Ğ”Ğ’ĞĞ™ĞĞĞ™ ĞŸĞĞ”Ğ”Ğ•Ğ Ğ–ĞšĞĞ™ ĞŸĞĞ›Ğ•Ğ™
    pull_counter += 1
    pull = {
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Ğ¡Ğ¢ĞĞ Ğ«Ğ• ĞŸĞĞ›Ğ¯ (Ğ´Ğ»Ñ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ñ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğ¼ ĞºĞ¾Ğ´Ğ¾Ğ¼)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        "id": pull_counter,
        "exporter_id": userid,
        "exporter_name": users.get(userid, {}).get("name", ""),
        "culture": data["culture"],
        "target_volume": data["volume"],
        "current_volume": 0,
        "price": data["price"],  # â­ Ğ¡Ğ¢ĞĞ ĞĞ• Ğ˜ĞœĞ¯
        "port": data["port"],
        "moisture": data.get("moisture", 0),
        "nature": data.get("nature", 0),
        "impurity": data.get("impurity", 0),
        "weed": data.get("weed", 0),
        "documents": data.get("documents", ""),
        "doc_type": doctype,
        "status": "active",  # â­ Ğ¡Ğ¢ĞĞ Ğ«Ğ™ Ğ¡Ğ¢ĞĞ¢Ğ£Ğ¡
        "created_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "participants": [],
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ĞĞĞ’Ğ«Ğ• ĞŸĞĞ›Ğ¯ (Ğ´Ğ»Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ show_deal_detail)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        "price_per_ton": float(data.get("price", 0)),  # â­ ĞĞĞ’ĞĞ• Ğ˜ĞœĞ¯ (Ğ—Ğ•Ğ ĞšĞĞ›Ğ price)
        "creator_id": userid,  # â­ ĞĞĞ’ĞĞ• ĞĞĞ—Ğ’ĞĞĞ˜Ğ•
        "farmer_ids": [],  # â­ Ğ”Ğ›Ğ¯ Ğ”Ğ•Ğ¢ĞĞ›Ğ•Ğ™
        "batches": [],  # â­ Ğ”Ğ›Ğ¯ Ğ”Ğ•Ğ¢ĞĞ›Ğ•Ğ™
        "batch_ids": [],  # â­ Ğ—Ğ•Ğ ĞšĞĞ›Ğ batches
        "logist_ids": [],
        "expeditor_ids": [],
    }

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ•: Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ¿ÑƒĞ» Ğ’ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½ÑƒÑ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñƒ
    pulls["pulls"][pull_counter] = pull
    pulls["pullparticipants"][pull_counter] = []

    save_pulls_to_pickle()

    # Ğ¡Ğ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ñ Google Sheets
    try:
        if gs and gs.spreadsheet:
            gs.sync_pull_to_sheets(pull)
    except Exception as e:
        logging.error(f"Error syncing to Google Sheets: {e}")

    logging.info(f"âœ… Pull {pull_counter} created by user {userid}")

    await state.finish()

    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ñ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ¾Ğ¼
    summary = (
        f"âœ… <b>ĞŸÑƒĞ» #{pull_counter} ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ½!</b>\n\n"
        f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: <b>{pull['culture']}</b>\n"
        f"ğŸ“¦ ĞĞ±ÑŠĞµĞ¼: <b>{pull['target_volume']:,.0f} Ñ‚Ğ¾Ğ½Ğ½</b>\n"
        f"ğŸ’µ Ğ¦ĞµĞ½Ğ° FOB: <b>â‚½{pull['price']:,.0f}/Ñ‚Ğ¾Ğ½Ğ½Ğ°</b>\n"
        f"ğŸš¢ ĞŸĞ¾Ñ€Ñ‚: <b>{pull['port']}</b>\n"
        f"ğŸ’§ Ğ’Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ: <b>â‰¤{pull['moisture']}%</b>\n"
        f"âš–ï¸ ĞĞ°Ñ‚ÑƒÑ€Ğ°: <b>â‰¥{pull['nature']} Ğ³/Ğ»</b>\n"
        f"ğŸŒ¿ Ğ¡Ğ¾Ñ€Ğ½Ğ°Ñ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑÑŒ: <b>â‰¤{pull['impurity']}%</b>\n"
        f"ğŸŒ¾ Ğ—ĞµÑ€Ğ½Ğ¾Ğ²Ğ°Ñ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑÑŒ: <b>â‰¤{pull['weed']}%</b>\n"
        f"ğŸ“‹ Ğ”Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ñ‹: <b>{pull['documents']}</b>\n"
        f"ğŸ“¦ Ğ¢Ğ¸Ğ¿ Ğ¿Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸: <b>{doctype}</b>\n\n"
        f"Ğ¤ĞµÑ€Ğ¼ĞµÑ€Ñ‹ ÑĞ¼Ğ¾Ğ³ÑƒÑ‚ Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½ÑÑ‚ÑŒÑÑ Ğº Ğ¿ÑƒĞ»Ñƒ ÑĞ¾ ÑĞ²Ğ¾Ğ¸Ğ¼Ğ¸ Ğ¿Ğ°Ñ€Ñ‚Ğ¸ÑĞ¼Ğ¸."
    )

    keyboard = InlineKeyboardMarkup()
    keyboard.add(InlineKeyboardButton("ğŸ“‹ ĞœĞ¾Ğ¸ Ğ¿ÑƒĞ»Ñ‹", callback_data="back_to_pulls"))

    await callback.message.edit_text(summary, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data == "back_to_pools_list", state="*")
async def back_to_pools_list(callback: types.CallbackQuery, state: FSMContext):
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğº ÑĞ¿Ğ¸ÑĞºÑƒ Ğ¿ÑƒĞ»Ğ¾Ğ²"""
    await state.finish()

    user_id = callback.from_user.id

    # Ğ›ĞĞ“Ğ˜ĞšĞ: ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµĞ¼ ĞĞ‘Ğ• Ğ²ĞµÑ€ÑĞ¸Ğ¸ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ¾Ğ²
    open_pulls = [
        pull
        for pull in pulls.values()
        if pull.get("status") in ["ĞÑ‚ĞºÑ€Ñ‹Ñ‚", "open", "active", "Active"]
    ]

    if not open_pulls:
        await callback.message.edit_text(
            "ğŸ“¦ Ğ¡ĞµĞ¹Ñ‡Ğ°Ñ Ğ½ĞµÑ‚ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… Ğ¿ÑƒĞ»Ğ¾Ğ².\n\n"
            "ĞĞ¶Ğ¸Ğ´Ğ°Ğ¹Ñ‚Ğµ Ğ½Ğ¾Ğ²Ñ‹Ñ… Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹ Ğ¾Ñ‚ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ²."
        )
        await callback.answer()
        return

    if user_id in batches and batches[user_id]:
        farmer_cultures = set(batch["culture"] for batch in batches[user_id])
        relevant_pulls = [p for p in open_pulls if p["culture"] in farmer_cultures]

        if relevant_pulls:
            open_pulls = relevant_pulls

    keyboard = InlineKeyboardMarkup(row_width=1)
    for pull in open_pulls[:10]:
        available = pull["target_volume"] - pull["current_volume"]
        progress = (
            (pull["current_volume"] / pull["target_volume"] * 100)
            if pull["target_volume"] > 0
            else 0
        )

        button_text = f"ğŸŒ¾ {pull['culture']} | {available} Ñ‚ | â‚½{pull['price']}/Ñ‚ ({progress:.0f}%)"
        keyboard.add(
            InlineKeyboardButton(button_text, callback_data=f"view_pull:{pull['id']}")
        )

    await callback.message.edit_text(
        f"ğŸ“¦ <b>ĞÑ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ Ğ¿ÑƒĞ»Ñ‹</b> ({len(open_pulls)} ÑˆÑ‚.)\n\n"
        "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿ÑƒĞ» Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ:",
        reply_markup=keyboard,
        parse_mode="HTML",
    )
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("view_pull_matches:"), state="*")
async def view_pull_matches(callback: types.CallbackQuery):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğ¹ Ğ´Ğ»Ñ Ğ¿ÑƒĞ»Ğ°"""
    try:
        pull_id = parse_callback_id(callback.data)
    except (IndexError, ValueError) as e:
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
        return

    user_id = callback.from_user.id

    if pull_id not in pulls.get("pulls", {}):
        await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    pull = pulls["pulls"][pull_id]
    if pull["exporter_id"] != user_id:
        await callback.answer("âŒ ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ° Ğº ÑÑ‚Ğ¾Ğ¼Ñƒ Ğ¿ÑƒĞ»Ñƒ", show_alert=True)
        return
    pull_matches = []
    for match in matches.values():
        if match["pull_id"] == pull_id and match["status"] == "active":
            pull_matches.append(match)

    if not pull_matches:
        await callback.answer("ğŸ¤·â€â™‚ï¸ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğ¹ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾", show_alert=True)
        return

    text = f"ğŸ¯ <b>Ğ¡Ğ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ Ğ´Ğ»Ñ Ğ¿ÑƒĞ»Ğ° #{pull_id}</b>\n\n"
    text += f"ğŸŒ¾ {pull['culture']} â€¢ {pull['target_volume']} Ñ‚ â€¢ â‚½{pull['price']}/Ñ‚\n\n"

    for i, match in enumerate(pull_matches[:5], 1):
        batch_id = match["batch_id"]
        batch_info = None
        for user_batches in batches.values():
            for batch in user_batches:
                if batch["id"] == batch_id:
                    batch_info = batch
                    break
            if batch_info:
                break

        if batch_info:
            text += f"{i}. <b>ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ #{batch_id}</b>\n"
            text += f"   ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: {batch_info['volume']} Ñ‚\n"
            text += f"   ğŸ’° Ğ¦ĞµĞ½Ğ°: {batch_info['price']:,.0f} â‚½/Ñ‚\n"
            text += f"   ğŸ“ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½: {batch_info['region']}\n"
            text += f"   ğŸ‘¤ Ğ¤ĞµÑ€Ğ¼ĞµÑ€: {batch_info['farmer_name']}\n\n"

    if len(pull_matches) > 5:
        text += f"<i>... Ğ¸ ĞµÑ‰Ñ‘ {len(pull_matches) - 5} ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğ¹</i>\n\n"

    text += "ğŸ’¡ <b>Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ğ¸Ñ:</b> Ğ¡Ğ²ÑĞ¶Ğ¸Ñ‚ĞµÑÑŒ Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°Ğ¼Ğ¸ Ğ´Ğ»Ñ Ğ¾Ğ±ÑÑƒĞ¶Ğ´ĞµĞ½Ğ¸Ñ Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹."

    await callback.message.answer(text, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data == "back_to_my_pulls", state="*")
async def back_to_my_pulls(callback: types.CallbackQuery, state: FSMContext):
    """âœ… Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğº ÑĞ¿Ğ¸ÑĞºÑƒ Ğ¿ÑƒĞ»Ğ¾Ğ² ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°"""
    await state.finish()

    user_id = callback.from_user.id
    logging.info(f"ğŸ”™ Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğº Ğ¿ÑƒĞ»Ğ°Ğ¼: user_id={user_id}")

    if user_id not in users or users[user_id].get("role") != "exporter":
        await callback.answer(
            "âŒ Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°Ğ¼", show_alert=True
        )
        return

    all_pulls = pulls.get("pulls", {})
    my_pulls = {
        pid: pull
        for pid, pull in all_pulls.items()
        if isinstance(pull, dict) and pull.get("exporter_id") == user_id
    }

    if not my_pulls:
        keyboard = InlineKeyboardMarkup().add(
            InlineKeyboardButton("ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main")
        )
        await callback.message.edit_text(
            "ğŸ“‹ <b>ĞœĞ¾Ğ¸ Ğ¿ÑƒĞ»Ñ‹</b>\n\n"
            "Ğ£ Ğ²Ğ°Ñ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ¿ÑƒĞ»Ğ¾Ğ².\n\n"
            "ğŸ’¡ <i>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¹ Ğ¿ÑƒĞ» Ñ‡ĞµÑ€ĞµĞ· Ğ¼ĞµĞ½Ñ</i>",
            reply_markup=keyboard,
            parse_mode="HTML",
        )
        await callback.answer()
        return

    culture_emoji = {
        "Ğ¿ÑˆĞµĞ½Ğ¸Ñ†Ğ°": "ğŸŒ¾",
        "ÑÑ‡Ğ¼ĞµĞ½ÑŒ": "ğŸŒ¾",
        "ĞºÑƒĞºÑƒÑ€ÑƒĞ·Ğ°": "ğŸŒ½",
        "Ğ¿Ğ¾Ğ´ÑĞ¾Ğ»Ğ½ĞµÑ‡Ğ½Ğ¸Ğº": "ğŸŒ»",
        "ÑĞ¾Ñ": "ğŸ«˜",
        "Ñ€Ğ°Ğ¿Ñ": "ğŸŒ¿",
    }

    keyboard = InlineKeyboardMarkup(row_width=1)
    for pull_id, pull in my_pulls.items():
        culture = pull.get("culture", "").lower()
        culture_icon = culture_emoji.get(culture, "ğŸŒ¾")
        status = pull.get("status", "active").lower()
        status_icon = status_map.get(status, "âšª").split()[0]
        current = pull.get("current_volume", 0)
        target = pull.get("target_volume", 1)
        progress = (current / target * 100) if target > 0 else 0
        button_text = (
            f"{status_icon} {culture_icon} {pull.get('culture', '?')} ({progress:.0f}%)"
        )
        keyboard.add(
            InlineKeyboardButton(button_text, callback_data=f"view_pull:{pull_id}")
        )

    keyboard.add(InlineKeyboardButton("ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main"))
    try:
        await callback.message.edit_text(
            f"ğŸ“‹ <b>ĞœĞ¾Ğ¸ Ğ¿ÑƒĞ»Ñ‹</b> ({len(my_pulls)} ÑˆÑ‚.)\n\n"
            "<i>Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿ÑƒĞ» Ğ´Ğ»Ñ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ:</i>",
            reply_markup=keyboard,
            parse_mode="HTML",
        )
    except MessageNotModified:
        pass
    await callback.answer()
    logging.info(f"âœ… ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¾ {len(my_pulls)} Ğ¿ÑƒĞ»Ğ¾Ğ²")


@dp.message_handler(lambda m: m.text == "ğŸ“‹ ĞœĞ¾Ğ¸ Ğ¿ÑƒĞ»Ñ‹", state="*")
async def view_my_pulls(message: types.Message, state: FSMContext):
    """âœ… ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ Ğ¿ÑƒĞ»Ñ‹ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ° - Ğ•Ğ”Ğ˜ĞĞ¡Ğ¢Ğ’Ğ•ĞĞĞĞ¯ Ğ’Ğ•Ğ Ğ¡Ğ˜Ğ¯"""
    userid = message.from_user.id
    logging.critical(f"ğŸ”” Ğ’Ğ«Ğ—Ğ’ĞĞĞ Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ¯ view_my_pulls: user_id={userid}")

    if userid not in users or users[userid].get("role") != "exporter":
        await message.answer("âŒ Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°Ğ¼")
        return

    all_pulls = pulls.get("pulls", {})
    my_pulls = {
        pid: pull
        for pid, pull in all_pulls.items()
        if isinstance(pull, dict) and pull.get("exporter_id") == userid
    }
    if not my_pulls:
        await message.answer(
            "ğŸ“‹ <b>ĞœĞ¾Ğ¸ Ğ¿ÑƒĞ»Ñ‹</b>\n\n"
            "Ğ£ Ğ²Ğ°Ñ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ¿ÑƒĞ»Ğ¾Ğ².\n\n"
            "ğŸ’¡ <i>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¹ Ğ¿ÑƒĞ» Ñ‡ĞµÑ€ĞµĞ· Ğ¼ĞµĞ½Ñ</i>",
            parse_mode="HTML",
        )
        return

    logging.info(f"âœ… Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€ {userid}: Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¾ {len(my_pulls)} Ğ¿ÑƒĞ»Ğ¾Ğ²")
    culture_emoji = {
        "Ğ¿ÑˆĞµĞ½Ğ¸Ñ†Ğ°": "ğŸŒ¾",
        "ÑÑ‡Ğ¼ĞµĞ½ÑŒ": "ğŸŒ¾",
        "ĞºÑƒĞºÑƒÑ€ÑƒĞ·Ğ°": "ğŸŒ½",
        "Ğ¿Ğ¾Ğ´ÑĞ¾Ğ»Ğ½ĞµÑ‡Ğ½Ğ¸Ğº": "ğŸŒ»",
        "ÑĞ¾Ñ": "ğŸ«˜",
        "Ñ€Ğ°Ğ¿Ñ": "ğŸŒ¿",
    }

    keyboard = InlineKeyboardMarkup(row_width=1)
    for pull_id, pull in my_pulls.items():
        culture = pull.get("culture", "").lower()
        culture_icon = culture_emoji.get(culture, "ğŸŒ¾")
        status = pull.get("status", "active").lower()
        status_icon = status_map.get(status, "âšª").split()[0]
        current = pull.get("current_volume", 0)
        target = pull.get("target_volume", 1)
        progress = (current / target * 100) if target > 0 else 0
        button_text = (
            f"{status_icon} {culture_icon} {pull.get('culture', '?')} ({progress:.0f}%)"
        )
        keyboard.add(
            InlineKeyboardButton(button_text, callback_data=f"view_pull:{pull_id}")
        )

    await message.answer(
        f"ğŸ“‹ <b>ĞœĞ¾Ğ¸ Ğ¿ÑƒĞ»Ñ‹</b> ({len(my_pulls)} ÑˆÑ‚.)\n\n"
        "<i>Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿ÑƒĞ» Ğ´Ğ»Ñ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ:</i>",
        reply_markup=keyboard,
        parse_mode="HTML",
    )


@dp.callback_query_handler(lambda c: c.data.startswith("view_pull:"), state="*")
async def view_pull_details(callback: types.CallbackQuery):
    """âœ… ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹ Ğ¿ÑƒĞ»Ğ° Ñ ÑƒÑ‡ĞµÑ‚Ğ¾Ğ¼ Ñ€Ğ¾Ğ»Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¸ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ¹ ĞºĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ¾Ğ¹."""
    try:
        pull_id = parse_callback_id(callback.data)
        if pull_id is None:
            await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
            return

        user_id = callback.from_user.id
        user = users.get(user_id)
        role = user.get("role") if user else None

        logging.info(
            f"ğŸ“„ ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ¿ÑƒĞ»Ğ° {pull_id} Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¼ {user_id} (Ñ€Ğ¾Ğ»ÑŒ: {role})"
        )

        all_pulls = pulls.get("pulls", {})
        if not all_pulls:
            await callback.answer("âŒ ĞŸÑƒĞ»Ñ‹ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ñ‹ Ğ² ÑĞ¸ÑÑ‚ĞµĞ¼Ğµ", show_alert=True)
            return

        pull = (
            all_pulls.get(pull_id)
            or all_pulls.get(str(pull_id))
            or all_pulls.get(int(pull_id) if str(pull_id).isdigit() else None)
        )
        if not pull:
            logging.warning(
                f"âš ï¸ ĞŸÑƒĞ» {pull_id} Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½. Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ: {list(all_pulls.keys())}"
            )
            await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
            return

        # Ğ¡Ğ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, Ğ´Ğ»Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€Ğ°)
        active_matches = []
        if matches:
            active_matches = [
                m
                for m in matches.values()
                if m.get("pull_id") == pull_id and m.get("status") == "active"
            ]

        exporter_id = pull.get("exporter_id")
        exporter_name = pull.get("exporter_name", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚ĞµĞ½")
        exporter_phone = "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"
        exporter_region = "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"
        if exporter_id and exporter_id in users:
            exporter_data = users[exporter_id]
            exporter_phone = exporter_data.get("phone", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
            exporter_region = exporter_data.get("region", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")

        target_volume = float(pull.get("target_volume", 1))
        current_volume = float(pull.get("current_volume", 0))
        progress = (current_volume / target_volume * 100) if target_volume > 0 else 0

        text = f"""ğŸ“¦ <b>ĞŸÑƒĞ» #{pull.get('id', pull_id)}</b>

ğŸŒ¾ <b>ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°:</b> {pull.get('culture', '?')}
ğŸ“¦ <b>ĞĞ±ÑŠÑ‘Ğ¼:</b> {current_volume:.0f}/{target_volume:.0f} Ñ‚ ({progress:.0f}%)
ğŸ’° <b>Ğ¦ĞµĞ½Ğ° FOB:</b> â‚½{pull.get('price', 0):,.0f}/Ñ‚
ğŸš¢ <b>ĞŸĞ¾Ñ€Ñ‚:</b> {pull.get('port', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}

<b>â”â”â” Ğ¢Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ â”â”â”</b>
ğŸ’§ <b>Ğ’Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ:</b> Ğ´Ğ¾ {pull.get('moisture', '?')}%
ğŸ‹ï¸ <b>ĞĞ°Ñ‚ÑƒÑ€Ğ°:</b> Ğ¾Ñ‚ {pull.get('nature', '?')} Ğ³/Ğ»
ğŸŒ¾ <b>Ğ¡Ğ¾Ñ€Ğ½Ğ¾ÑÑ‚ÑŒ:</b> Ğ´Ğ¾ {pull.get('impurity', '?')}%

<b>â”â”â” Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€ â”â”â”</b>
ğŸ‘¤ <b>Ğ˜Ğ¼Ñ:</b> {exporter_name}
ğŸ“ <b>Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½:</b> {exporter_phone}
ğŸ¢ <b>Ğ ĞµĞ³Ğ¸Ğ¾Ğ½:</b> {exporter_region}
ğŸ“… <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½:</b> {pull.get('created_at', '?')}
"""

        if active_matches:
            text += f"\nğŸ¯ <b>Ğ¡Ğ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ:</b> {len(active_matches)}"

        keyboard = InlineKeyboardMarkup(row_width=2)

        # ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ´Ğ»Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€Ğ° (Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞµÑĞ»Ğ¸ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€ Ğ¸ Ğ²Ğ»Ğ°Ğ´ĞµĞ»ĞµÑ†)
        if role == "exporter" and pull.get("exporter_id") == user_id:
            keyboard.add(
                InlineKeyboardButton(
                    "âœï¸ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ", callback_data=f"editpull_{pull_id}"
                ),
                InlineKeyboardButton(
                    "ğŸ—‘ Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ", callback_data=f"deletepull_{pull_id}"
                ),
                InlineKeyboardButton(
                    "ğŸ”„ Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ÑÑ‚Ğ°Ñ‚ÑƒÑ", callback_data=f"change_pull_status:{pull_id}"
                ),
            )
            if active_matches:
                keyboard.add(
                    InlineKeyboardButton(
                        f"ğŸ¯ Ğ¡Ğ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ ({len(active_matches)})",
                        callback_data=f"view_pull_matches:{pull_id}",
                    )
                )
            keyboard.add(
                InlineKeyboardButton(
                    "ğŸ‘¥ Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¸", callback_data=f"pullparticipants:{pull_id}"
                ),
                InlineKeyboardButton(
                    "ğŸšš Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºĞ°", callback_data=f"pull_logistics:{pull_id}"
                ),
            )
        # ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ´Ğ»Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ° (Ğ¸Ğ»Ğ¸ Ğ´Ñ€ÑƒĞ³Ğ¸Ñ… Ñ€Ğ¾Ğ»ĞµĞ¹)
        elif role == "farmer":
            # ĞœĞ¾Ğ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºÑƒ, Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½ÑĞ»ÑÑ Ğ»Ğ¸ ÑƒĞ¶Ğµ, Ğ¸ Ğ½Ğµ Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°Ñ‚ÑŒ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€Ğ½Ğ¾
            keyboard.add(
                InlineKeyboardButton(
                    "âœ… ĞŸÑ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½Ğ¸Ñ‚ÑŒÑÑ", callback_data=f"join_pull:{pull_id}"
                )
            )
        # ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ñ‹ Ğ´Ğ»Ñ Ğ´Ñ€ÑƒĞ³Ğ¸Ñ… Ñ€Ğ¾Ğ»ĞµĞ¹ (Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚, ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€) Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾ Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸

        keyboard.add(InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_my_pulls"))

        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
        await callback.answer()
        logging.info(f"âœ… ĞŸÑƒĞ» {pull_id} Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶Ñ‘Ğ½ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {e}", exc_info=True)
        await callback.message.reply("âŒ <b>ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹</b>", parse_mode="HTML")


@dp.message_handler(lambda m: m.text == "ğŸ” ĞĞ°Ğ¹Ñ‚Ğ¸ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸", state="*")
async def search_batches_for_exporter(message: types.Message, state: FSMContext):
    """Ğ Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ¸ÑĞº Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ´Ğ»Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°"""
    await state.finish()

    user_id = message.from_user.id
    if user_id not in users or users[user_id].get("role") != "exporter":
        await message.answer("âŒ Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°Ğ¼")
        return

    await message.answer(
        "ğŸ” <b>Ğ Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ¸ÑĞº Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹</b>\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºÑ€Ğ¸Ñ‚ĞµÑ€Ğ¸Ğ¸ Ğ¿Ğ¾Ğ¸ÑĞºĞ°:",
        reply_markup=search_criteria_keyboard(),
        parse_mode="HTML",
    )


@dp.callback_query_handler(lambda c: c.data.startswith("search_by:"), state="*")
async def handle_search_criteria(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° ĞºÑ€Ğ¸Ñ‚ĞµÑ€Ğ¸Ñ Ğ¿Ğ¾Ğ¸ÑĞºĞ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹"""
    await state.finish()

    criteria = callback.data.split(":", 1)[1]

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ĞŸĞĞ˜Ğ¡Ğš ĞŸĞ ĞšĞ£Ğ›Ğ¬Ğ¢Ğ£Ğ Ğ•
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if criteria == "culture":
        try:
            await callback.message.edit_text(
                "ğŸŒ¾ <b>ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğµ</b>\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñƒ:",
                reply_markup=culture_keyboard(),
                parse_mode="HTML",
            )
        except Exception as e:
            logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° edit_text: {e}")
            await callback.message.answer(
                "ğŸŒ¾ <b>ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğµ</b>\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñƒ:",
                reply_markup=culture_keyboard(),
                parse_mode="HTML",
            )
        await SearchByCulture.waiting_culture.set()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ĞŸĞĞ˜Ğ¡Ğš ĞŸĞ Ğ Ğ•Ğ“Ğ˜ĞĞĞ£
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    elif criteria == "region":
        try:
            await callback.message.edit_text(
                "ğŸ“ <b>ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñƒ</b>\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½:",
                reply_markup=region_keyboard(),
                parse_mode="HTML",
            )
        except Exception as e:
            logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° edit_text: {e}")
            await callback.message.answer(
                "ğŸ“ <b>ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñƒ</b>\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½:",
                reply_markup=region_keyboard(),
                parse_mode="HTML",
            )
        await SearchBatchesStatesGroup.enter_region.set()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ĞŸĞĞ˜Ğ¡Ğš Ğ”ĞĞ¡Ğ¢Ğ£ĞŸĞĞ«Ğ¥ ĞŸĞĞ Ğ¢Ğ˜Ğ™
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    elif criteria == "available":
        await callback.answer("ğŸ” Ğ˜Ñ‰ĞµĞ¼ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸...")

        available_batches = []

        # Ğ˜Ñ‚ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾ Ğ²ÑĞµĞ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸ÑĞ¼
        for user_id, user_batches in batches.items():
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # Ğ—ĞĞ©Ğ˜Ğ¢Ğ 1: ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ user_batches â€” ÑĞ¿Ğ¸ÑĞ¾Ğº
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if not isinstance(user_batches, list):
                logging.error(
                    f"âŒ Ğ£ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ {user_id} Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ ĞĞ• ÑĞ¿Ğ¸ÑĞ¾Ğº: {type(user_batches)}, value={user_batches}"
                )
                continue

            # Ğ˜Ñ‚ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾ Ğ¿Ğ°Ñ€Ñ‚Ğ¸ÑĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
            for batch in user_batches:
                # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                # Ğ—ĞĞ©Ğ˜Ğ¢Ğ 2: ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ batch â€” ÑĞ»Ğ¾Ğ²Ğ°Ñ€ÑŒ
                # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if not isinstance(batch, dict):
                    logging.error(
                        f"âŒ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ ĞĞ• ÑĞ»Ğ¾Ğ²Ğ°Ñ€ÑŒ: user_id={user_id}, batch={batch}, type={type(batch)}"
                    )
                    continue

                # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ
                if batch.get("status") in [
                    "active",
                    "ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ°",
                    "available",
                    "Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ°",
                ]:
                    available_batches.append(batch)

        logging.info(f"âœ… ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹: {len(available_batches)}")

        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Ğ¤ĞĞ ĞœĞ˜Ğ ĞĞ’ĞĞĞ˜Ğ• ĞĞ¢Ğ’Ğ•Ğ¢Ğ
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        if available_batches:
            text = f"ğŸŒ¾ <b>ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹: {len(available_batches)}</b>\n\n"

            # ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¿ĞµÑ€Ğ²Ñ‹Ğµ 10 Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹
            for i, batch in enumerate(available_batches[:10], 1):
                culture = batch.get("culture", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°")
                volume = batch.get("volume", 0)
                price = batch.get("price", 0)
                region = batch.get("region", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")

                text += f"{i}. <b>{culture}</b> - {volume} Ñ‚\n"
                text += f"   ğŸ’° {price:,.0f} â‚½/Ñ‚ | ğŸ“ {region}\n\n"

            if len(available_batches) > 10:
                text += f"... Ğ¸ ĞµÑ‰Ñ‘ {len(available_batches) - 10} Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹\n"

            # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ ĞºĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ñƒ Ñ Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¼Ğ¸ 5 Ğ¿Ğ°Ñ€Ñ‚Ğ¸ÑĞ¼Ğ¸
            keyboard = InlineKeyboardMarkup(row_width=1)
            for batch in available_batches[:5]:
                batch_id = batch.get("id", 0)
                culture = batch.get("culture", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°")
                volume = batch.get("volume", 0)

                keyboard.add(
                    InlineKeyboardButton(
                        f"{culture} - {volume} Ñ‚",
                        callback_data=f"view_batch:{batch_id}",
                    )
                )

            keyboard.add(
                InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_search")
            )

            try:
                await callback.message.edit_text(
                    text, reply_markup=keyboard, parse_mode="HTML"
                )
            except Exception as e:
                logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° edit_text: {e}")
                await callback.message.answer(
                    text, reply_markup=keyboard, parse_mode="HTML"
                )

        else:
            # ĞŸĞ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ñ‹
            keyboard = InlineKeyboardMarkup(row_width=1)
            keyboard.add(
                InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_search")
            )

            try:
                await callback.message.edit_text(
                    "âŒ <b>Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾</b>\n\n"
                    "ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ĞºÑ€Ğ¸Ñ‚ĞµÑ€Ğ¸Ğ¸ Ğ¿Ğ¾Ğ¸ÑĞºĞ°.",
                    reply_markup=keyboard,
                    parse_mode="HTML",
                )
            except Exception as e:
                logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° edit_text: {e}")
                await callback.message.answer(
                    "âŒ <b>Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾</b>\n\n"
                    "ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ĞºÑ€Ğ¸Ñ‚ĞµÑ€Ğ¸Ğ¸ Ğ¿Ğ¾Ğ¸ÑĞºĞ°.",
                    reply_markup=keyboard,
                    parse_mode="HTML",
                )

    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("view_batch:"), state="*")
async def view_batch_details(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ´ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ğ¾Ğ¹ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸ Ğ¾ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""
    logging.info(f"ğŸ“¦ ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ {callback.data}")

    try:
        batch_id = int(callback.data.split(":")[1])
    except (IndexError, ValueError) as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ°Ñ€ÑĞ¸Ğ½Ğ³Ğ° batch_id: {e}")
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ½ĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¹ ID Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸", show_alert=True)
        return

    user_id = callback.from_user.id
    user = users.get(user_id, {})
    user_role = user.get("role", "unknown").lower()

    logging.info(f"ğŸ‘¤ user_id={user_id}, Ñ€Ğ¾Ğ»ÑŒ={user_role}")
    logging.info(f"ğŸ” Ğ˜Ñ‰ĞµĞ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ batch_id={batch_id}")
    logging.info(f"ğŸ“‹ Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° batches: ĞºĞ»ÑÑ‡ĞµĞ¹={len(batches)}")

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ² ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğµ {farmer_id: [batch_list]}
    found_batch = None
    farmer_id = None

    for fid, batch_list in batches.items():
        if isinstance(batch_list, list):
            for batch in batch_list:
                if isinstance(batch, dict) and batch.get("id") == batch_id:
                    found_batch = batch
                    farmer_id = fid
                    logging.info(f"âœ… ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ {batch_id} Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ° Ñƒ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ° {fid}")
                    break
        elif isinstance(batch_list, dict):
            # ĞĞ° ÑĞ»ÑƒÑ‡Ğ°Ğ¹ ĞµÑĞ»Ğ¸ Ğ¾Ğ´Ğ½Ğ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ (ÑĞ»Ğ¾Ğ²Ğ°Ñ€ÑŒ)
            if batch_list.get("id") == batch_id:
                found_batch = batch_list
                farmer_id = fid
                logging.info(f"âœ… ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ {batch_id} Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ° Ñƒ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ° {fid}")
                break

        if found_batch:
            break

    if not found_batch:
        logging.error(f"âŒ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ {batch_id} ĞĞ• ĞĞĞ™Ğ”Ğ•ĞĞ!")
        await callback.answer("âŒ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ²Ğ»Ğ°Ğ´ĞµĞ»ÑŒÑ†Ğ°
    is_owner = farmer_id == user_id
    logging.info(f"ğŸ‘¥ farmer_id={farmer_id}, user_id={user_id}, is_owner={is_owner}")

    # âœ… Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ
    text = f"ğŸ“¦ <b>Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ #{batch_id}</b>\n\n"
    text += f"ğŸŒ¾ <b>ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°:</b> {found_batch.get('culture', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}\n"
    text += f"ğŸ“¦ <b>ĞĞ±ÑŠÑ‘Ğ¼:</b> {found_batch.get('volume', 0)} Ñ‚\n"
    text += f"ğŸ’° <b>Ğ¦ĞµĞ½Ğ°:</b> {found_batch.get('price', 0):,.0f} â‚½/Ñ‚\n"
    text += f"ğŸ“ <b>Ğ›Ğ¾ĞºĞ°Ñ†Ğ¸Ñ:</b> {found_batch.get('location', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}\n"
    text += f"ğŸš¢ <b>ĞŸĞ¾Ñ€Ñ‚:</b> {found_batch.get('port', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
    text += f"ğŸ› <b>Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ:</b> {found_batch.get('status', 'ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ°')}\n"

    # ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»Ğ¸ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ°
    if "quality" in found_batch:
        quality = found_batch["quality"]
        text += f"\n<b>ğŸ“Š ĞšĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ¾:</b>\n"
        text += f"ğŸ’§ <b>Ğ’Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ:</b> {quality.get('moisture', '-')}%\n"
        text += f"ğŸŒ¾ <b>ĞĞ°Ñ‚ÑƒÑ€Ğ°:</b> {quality.get('nature', '-')} Ğ³/Ğ»\n"
        text += f"ğŸŒ¿ <b>ĞŸÑ€Ğ¸Ğ¼ĞµÑÑŒ:</b> {quality.get('impurity', '-')}%\n"
        text += f"ğŸŒ± <b>Ğ‘ĞµĞ»Ğ¾Ğº:</b> {quality.get('protein', '-')}%\n"
        if "weed" in quality:
            text += f"ğŸŒ¿ <b>Ğ¡Ğ¾Ñ€Ğ½Ğ°Ñ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑÑŒ:</b> {quality.get('weed', '-')}%\n"

    # Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ°Ñ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ
    if "storage_type" in found_batch:
        text += f"ğŸ­ <b>Ğ¥Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ:</b> {found_batch['storage_type']}\n"
    if "documents" in found_batch:
        text += f"ğŸ“„ <b>Ğ”Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ñ‹:</b> {found_batch['documents']}\n"
    if "created_at" in found_batch:
        text += f"ğŸ“… <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¾:</b> {found_batch['created_at']}\n"

    # âœ… Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ Ğ’ Ğ—ĞĞ’Ğ˜Ğ¡Ğ˜ĞœĞĞ¡Ğ¢Ğ˜ ĞĞ¢ Ğ ĞĞ›Ğ˜
    keyboard = InlineKeyboardMarkup(row_width=1)

    if is_owner and user_role == "farmer":
        # âœ… CASE 1: Ğ¤ĞµÑ€Ğ¼ĞµÑ€ ÑĞ¼Ğ¾Ñ‚Ñ€Ğ¸Ñ‚ ÑĞ²Ğ¾Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ
        logging.info(f"âœ… CASE 1: Ğ¤ĞµÑ€Ğ¼ĞµÑ€ {user_id} ÑĞ¼Ğ¾Ñ‚Ñ€Ğ¸Ñ‚ ÑĞ²Ğ¾Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ {batch_id}")
        keyboard.add(
            InlineKeyboardButton(
                "âœï¸ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ", callback_data=f"edit_batch:{batch_id}"
            )
        )
        keyboard.add(
            InlineKeyboardButton(
                "ğŸ—‘ Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ", callback_data=f"delete_batch:{batch_id}"
            )
        )
        keyboard.add(
            InlineKeyboardButton(
                "ğŸ¯ ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ", callback_data=f"view_matches:{batch_id}"
            )
        )
        keyboard.add(
            InlineKeyboardButton(
                "â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğº Ğ¼Ğ¾Ğ¸Ğ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸ÑĞ¼", callback_data="back_to_my_batches"
            )
        )

    elif user_role == "exporter":
        # âœ… CASE 2: Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€ ÑĞ¼Ğ¾Ñ‚Ñ€Ğ¸Ñ‚ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ
        logging.info(f"âœ… CASE 2: Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€ {user_id} ÑĞ¼Ğ¾Ñ‚Ñ€Ğ¸Ñ‚ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ {batch_id}")

        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°
        if farmer_id:
            farmer_info = users.get(farmer_id, {})
            farmer_name = farmer_info.get("name", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")
            farmer_phone = farmer_info.get("phone", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
            farmer_email = farmer_info.get("email", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
            farmer_company = farmer_info.get("company_name", farmer_name)

            text += f"\n<b>ğŸ“ ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°:</b>\n"
            text += f"ğŸ¢ <b>ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ:</b> {farmer_company}\n"
            text += f"ğŸ‘¤ <b>Ğ˜Ğ¼Ñ:</b> {farmer_name}\n"
            text += f"ğŸ“± <b>Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½:</b> <code>{farmer_phone}</code>\n"
            text += f"ğŸ“§ <b>Email:</b> {farmer_email}\n"

            keyboard.add(
                InlineKeyboardButton(
                    "ğŸ“ Ğ¡Ğ²ÑĞ·Ğ°Ñ‚ÑŒÑÑ Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ¼",
                    callback_data=f"contact_farmer:{batch_id}:{farmer_id}",
                )
            )

        keyboard.add(
            InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğº Ğ¿Ğ¾Ğ¸ÑĞºÑƒ", callback_data="back_to_search")
        )

    elif user_role == "logistic":
        # âœ… CASE 3: Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ ÑĞ¼Ğ¾Ñ‚Ñ€Ğ¸Ñ‚ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ
        logging.info(f"âœ… CASE 3: Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ {user_id} ÑĞ¼Ğ¾Ñ‚Ñ€Ğ¸Ñ‚ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ {batch_id}")
        keyboard.add(
            InlineKeyboardButton(
                "ğŸ“¦ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶Ğ¸Ñ‚ÑŒ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ", callback_data=f"offer_delivery:{batch_id}"
            )
        )
        keyboard.add(
            InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğº Ğ¿Ğ¾Ğ¸ÑĞºÑƒ", callback_data="back_to_search")
        )

    elif user_role == "farmer" and not is_owner:
        # âœ… CASE 4: Ğ¤ĞµÑ€Ğ¼ĞµÑ€ ÑĞ¼Ğ¾Ñ‚Ñ€Ğ¸Ñ‚ Ñ‡ÑƒĞ¶ÑƒÑ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ
        logging.warning(
            f"âš ï¸ CASE 4: Ğ¤ĞµÑ€Ğ¼ĞµÑ€ {user_id} Ğ¿Ñ‹Ñ‚Ğ°Ğ»ÑÑ Ğ¿Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ñ‡ÑƒĞ¶ÑƒÑ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ {batch_id}!"
        )
        keyboard.add(
            InlineKeyboardButton(
                "â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğº Ğ¼Ğ¾Ğ¸Ğ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸ÑĞ¼", callback_data="back_to_my_batches"
            )
        )
        text += "\n\nâŒ <b>Ğ’Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ°Ñ‚Ñ€Ğ¸Ğ²Ğ°Ñ‚ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¡Ğ’ĞĞ˜ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸!</b>"

    else:
        # âœ… CASE 5: ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ°Ñ Ñ€Ğ¾Ğ»ÑŒ
        logging.error(
            f"âŒ CASE 5: ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ°Ñ Ñ€Ğ¾Ğ»ÑŒ '{user_role}' Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ {user_id}"
        )
        keyboard.add(InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_search"))
        text += f"\n\nâŒ <b>ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ½ĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ°Ñ Ñ€Ğ¾Ğ»ÑŒ '{user_role}'</b>"

    try:
        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° edit_text: {e}")
        await callback.message.answer(text, reply_markup=keyboard, parse_mode="HTML")

    await callback.answer()


@dp.callback_query_handler(lambda c: c.data == "back_to_search", state="*")
async def back_to_search_menu(callback: types.CallbackQuery, state: FSMContext):
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğ² Ğ¼ĞµĞ½Ñ Ğ¿Ğ¾Ğ¸ÑĞºĞ°"""
    await state.finish()

    await callback.message.edit_text(
        "ğŸ” <b>Ğ Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ¸ÑĞº Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹</b>\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºÑ€Ğ¸Ñ‚ĞµÑ€Ğ¸Ğ¸ Ğ¿Ğ¾Ğ¸ÑĞºĞ°:",
        reply_markup=search_criteria_keyboard(),
        parse_mode="HTML",
    )
    await callback.answer()


# ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñ‹


# ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ°
@dp.callback_query_handler(
    lambda c: c.data.startswith("region:") or c.data.startswith("searchregion:"),
    state="*",
)
async def search_by_region_selected(callback: types.CallbackQuery, state: FSMContext):
    if ":" in callback.data:
        region = callback.data.split(":", 1)[1]
    else:
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ°Ñ€ÑĞ¸Ğ½Ğ³Ğ°", show_alert=True)
        return

    # ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ¿Ğ¾ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñƒ
    found_batches = []
    for user_batches in batches.values():
        for batch in user_batches:
            if batch.get("region") == region and batch.get("status") in [
                "active",
                "ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ°",
                "available",
                "Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ°",
            ]:
                found_batches.append(batch)

    await state.finish()

    if found_batches:
        text = f"ğŸ“ <b>ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ² '{region}': {len(found_batches)}</b>\n\n"

        for i, batch in enumerate(found_batches[:10], 1):
            text += f"{i}. {batch['culture']} - {batch['volume']} Ñ‚\n"
            text += f"   ğŸ’° {batch['price']:,.0f} â‚½/Ñ‚\n\n"

        if len(found_batches) > 10:
            text += f"... Ğ¸ ĞµÑ‰Ñ‘ {len(found_batches) - 10} Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹"

        keyboard = InlineKeyboardMarkup(row_width=1)
        for batch in found_batches[:5]:
            keyboard.add(
                InlineKeyboardButton(
                    f"{batch['culture']} - {batch['volume']} Ñ‚",
                    callback_data=f"view_batch:{batch['id']}",
                )
            )
        keyboard.add(InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_search"))

        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    else:
        await callback.message.edit_text(
            f"âŒ ĞŸĞ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ² '{region}' Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾", parse_mode="HTML"
        )

    await callback.answer()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ ĞĞ¡Ğ¨Ğ˜Ğ Ğ•ĞĞĞ«Ğ™ Ğ¤Ğ£ĞĞšĞ¦Ğ˜ĞĞĞĞ› Ğ­ĞšĞ¡ĞŸĞĞ Ğ¢ĞĞ Ğ
# Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ² Ğ¿ÑƒĞ»Ğ», Ğ²Ñ‹Ğ±Ğ¾Ñ€ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ² Ğ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


@dp.callback_query_handler(lambda c: c.data.startswith("add_batch_to_pull:"), state="*")
async def add_batch_to_pull_select(callback: types.CallbackQuery):
    """Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ¿ÑƒĞ»Ğ»Ğ° Ğ´Ğ»Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""
    global batches
    try:
        batch_id = parse_callback_id(callback.data)
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
        return

    user_id = callback.from_user.id

    if batch_id not in batches:
        await callback.answer("âŒ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    batch = batches[batch_id]

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ¿ÑƒĞ»Ñ‹ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ° Ñ Ñ‚Ğ¾Ğ¹ Ğ¶Ğµ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ¾Ğ¹
    user_pulls = []
    for pid, p in pulls.items():
        if (
            p.get("creator_id") == user_id
            and p.get("culture", "").lower() == batch.get("culture", "").lower()
            and p.get("status", "active") in ["active", "Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚", "Ğ°ĞºÑ‚Ğ¸Ğ²ĞµĞ½"]
        ):
            user_pulls.append((pid, p))

    if not user_pulls:
        await callback.answer(
            f"âŒ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ¿ÑƒĞ»Ğ¾Ğ² Ğ´Ğ»Ñ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñ‹: {batch.get('culture', 'ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾')}\n"
            "Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ Ğ¿ÑƒĞ»Ğ» ÑĞ½Ğ°Ñ‡Ğ°Ğ»Ğ°!",
            show_alert=True,
        )
        return

    # ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ¿ÑƒĞ»Ğ¾Ğ²
    keyboard = InlineKeyboardMarkup(row_width=1)

    for pull_id, pull in user_pulls:
        # Ğ¡Ñ‡Ğ¸Ñ‚Ğ°ĞµĞ¼ Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğ¹ Ğ¾Ğ±ÑŠÑ‘Ğ¼
        current_vol = 0
        if "batches" in pull and pull["batches"]:
            for b_id in pull["batches"]:
                if b_id in batches:
                    current_vol += batches[b_id].get("volume", 0)

        target_vol = pull.get("target_volume", 0)

        keyboard.add(
            InlineKeyboardButton(
                f"ĞŸÑƒĞ»Ğ» #{pull_id}: {current_vol:.1f}/{target_vol:.1f} Ñ‚",
                callback_data=f"confirm_add_batch:{batch_id}:{pull_id}",
            )
        )

    keyboard.add(InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="cancel_action"))

    await callback.message.edit_text(
        f"ğŸ“¦ <b>Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ² Ğ¿ÑƒĞ»Ğ»</b>\n\n"
        f"ğŸŒ¾ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ: {batch.get('culture', 'ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾')} â€¢ {batch.get('volume', 0):.1f} Ñ‚\n"
        f"ğŸ“ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½: {batch.get('region', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
        f"ğŸ’° Ğ¦ĞµĞ½Ğ°: {batch.get('price', 0):,} â‚½/Ñ‚\n\n"
        f"Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿ÑƒĞ»Ğ» Ğ´Ğ»Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ:",
        parse_mode="HTML",
        reply_markup=keyboard,
    )
    await callback.answer()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞĞĞ¯ Ğ’Ğ•Ğ Ğ¡Ğ˜Ğ¯
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
@dp.callback_query_handler(lambda c: c.data.startswith("confirm_add_batch:"), state="*")
async def confirm_add_batch_to_pull(callback: types.CallbackQuery):
    """âœ… ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ² Ğ¿ÑƒĞ»Ğ» - ĞŸĞĞ›ĞĞĞ¡Ğ¢Ğ¬Ğ® Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞĞĞ¯ Ğ’Ğ•Ğ Ğ¡Ğ˜Ğ¯"""
    global batches, pulls, users

    try:
        _, batch_id, pull_id = callback.data.split(":")
        batch_id = int(batch_id)
        pull_id = int(pull_id)

        # ğŸ” Ğ›ĞĞ“Ğ˜Ğ Ğ£Ğ•Ğœ Ğ¢Ğ˜ĞŸ Ğ˜ Ğ—ĞĞĞ§Ğ•ĞĞ˜Ğ•
        logging.info(f"ğŸ” batch_id type: {type(batch_id).__name__}, value: {batch_id}")
        logging.info(f"ğŸ” pull_id type: {type(pull_id).__name__}, value: {pull_id}")

    except (ValueError, IndexError) as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ°Ñ€ÑĞ¸Ğ½Ğ³Ğ°: {e}")
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
        return

    try:
        # 1ï¸âƒ£ Ğ˜Ğ©Ğ•Ğœ ĞŸĞĞ Ğ¢Ğ˜Ğ® Ğ˜ Ğ¤Ğ•Ğ ĞœĞ•Ğ Ğ
        batch = None
        farmer_id = None

        for f_id, farmer_batches in batches.items():
            if not isinstance(farmer_batches, list):
                continue
            for b in farmer_batches:
                if isinstance(b, dict) and b.get("id") == batch_id:
                    batch = b
                    farmer_id = f_id
                    break
            if batch:
                break

        if not batch or not farmer_id:
            logging.error(
                f"âŒ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°: batch_id={batch_id}, farmer_id={farmer_id}"
            )
            await callback.answer("âŒ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
            return

        # 2ï¸âƒ£ Ğ˜Ğ©Ğ•Ğœ ĞŸĞ£Ğ›Ğ›
        pulls_dict = pulls.get("pulls", {})
        if pull_id not in pulls_dict:
            logging.error(f"âŒ ĞŸÑƒĞ»Ğ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½: pull_id={pull_id}")
            await callback.answer("âŒ ĞŸÑƒĞ»Ğ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
            return

        pull = pulls_dict[pull_id]

        # 3ï¸âƒ£ ĞŸĞ ĞĞ’Ğ•Ğ Ğ¯Ğ•Ğœ ĞŸĞ ĞĞ’Ğ
        if pull.get("creator_id") != callback.from_user.id:
            await callback.answer("âŒ Ğ­Ñ‚Ğ¾ Ğ½Ğµ Ğ²Ğ°Ñˆ Ğ¿ÑƒĞ»Ğ»", show_alert=True)
            return

        # 4ï¸âƒ£ Ğ˜ĞĞ˜Ğ¦Ğ˜ĞĞ›Ğ˜Ğ—Ğ˜Ğ Ğ£Ğ•Ğœ ĞŸĞĞ›Ğ¯ ĞŸĞ£Ğ›Ğ›Ğ
        if "batches" not in pull:
            pull["batches"] = []
        if "batch_ids" not in pull:
            pull["batch_ids"] = []
        if "farmer_ids" not in pull:
            pull["farmer_ids"] = []

        # Ğ˜ĞĞ˜Ğ¦Ğ˜ĞĞ›Ğ˜Ğ—Ğ˜Ğ Ğ£Ğ•Ğœ pullparticipants
        if "pullparticipants" not in pulls:
            pulls["pullparticipants"] = {}
        if pull_id not in pulls["pullparticipants"]:
            pulls["pullparticipants"][pull_id] = []

        # 5ï¸âƒ£ ĞŸĞ ĞĞ’Ğ•Ğ Ğ¯Ğ•Ğœ Ğ§Ğ¢Ğ ĞŸĞĞ Ğ¢Ğ˜Ğ¯ ĞĞ• Ğ”ĞĞ‘ĞĞ’Ğ›Ğ•ĞĞ
        if batch_id in pull["batch_ids"]:
            await callback.answer("âš ï¸ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ ÑƒĞ¶Ğµ Ğ² Ğ¿ÑƒĞ»Ğµ", show_alert=True)
            return

        # 6ï¸âƒ£ Ğ”ĞĞ‘ĞĞ’Ğ›Ğ¯Ğ•Ğœ ĞŸĞĞ Ğ¢Ğ˜Ğ® Ğ’ ĞŸĞ£Ğ›
        pull["batches"].append(batch_id)
        pull["batch_ids"].append(batch_id)
        batch["status"] = "in_pull"
        batch["pull_id"] = pull_id

        # 7ï¸âƒ£ Ğ”ĞĞ‘ĞĞ’Ğ›Ğ¯Ğ•Ğœ Ğ¤Ğ•Ğ ĞœĞ•Ğ Ğ
        if farmer_id not in pull["farmer_ids"]:
            pull["farmer_ids"].append(farmer_id)
            logging.info(f"âœ… Ğ¤ĞµÑ€Ğ¼ĞµÑ€ {farmer_id} Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½ Ğ² Ğ¿ÑƒĞ»Ğ» {pull_id}")

        # 8ï¸âƒ£ Ğ”ĞĞ‘ĞĞ’Ğ›Ğ¯Ğ•Ğœ Ğ’ pullparticipants
        farmer_info = users.get(farmer_id, {})
        participant_record = {
            "batch_id": batch_id,
            "farmer_id": farmer_id,
            "farmer_name": farmer_info.get("name", "Unknown"),
            "volume": batch.get("volume", 0),
            "quality_class": batch.get("quality_class", ""),
            "culture": batch.get("culture", ""),
            "price_per_ton": batch.get("price", 0),
        }

        pulls["pullparticipants"][pull_id].append(participant_record)
        logging.info(
            f"âœ… Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸Ğº Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½: farmer_id={farmer_id}, batch_id={batch_id}"
        )

        # 9ï¸âƒ£ Ğ¡Ğ§Ğ˜Ğ¢ĞĞ•Ğœ ĞĞ‘ĞªĞĞœ
        current_volume = 0
        for b_id in pull["batch_ids"]:
            for farmer_batches in batches.values():
                if isinstance(farmer_batches, list):
                    for b in farmer_batches:
                        if isinstance(b, dict) and b.get("id") == b_id:
                            current_volume += b.get("volume", 0)
                            break

        target_volume = pull.get("target_volume", 0)
        pull["current_volume"] = current_volume

        # ğŸ”Ÿ ĞŸĞ ĞĞ’Ğ•Ğ Ğ¯Ğ•Ğœ Ğ—ĞĞŸĞĞ›ĞĞ•ĞĞ˜Ğ•
        status_msg = ""
        if current_volume >= target_volume:
            pull["status"] = "completed"
            status_msg = "ğŸ‰ ĞŸÑƒĞ»Ğ» ÑĞ¾Ğ±Ñ€Ğ°Ğ½!"
            logging.info(f"ğŸ‰ ĞŸÑƒĞ»Ğ» #{pull_id} Ğ¡ĞĞ‘Ğ ĞĞ!")

            try:
                await bot.send_message(
                    callback.from_user.id,
                    f"ğŸ‰ <b>ĞŸÑƒĞ»Ğ» #{pull_id} ÑĞ¾Ğ±Ñ€Ğ°Ğ½!</b>\n\n"
                    f"ğŸŒ¾ {pull.get('culture', 'ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°')}\n"
                    f"ğŸ“Š ĞĞ±ÑŠÑ‘Ğ¼: {current_volume:.1f}/{target_volume:.1f} Ñ‚\n"
                    f"ğŸ‘¥ Ğ¤ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ²: <b>{len(pull['farmer_ids'])}</b>\n"
                    f"ğŸ“¦ ĞŸĞ°Ñ€Ñ‚Ğ¸Ğ¹: <b>{len(pull['batch_ids'])}</b>\n"
                    f"ğŸ“ ĞŸĞ¾Ñ€Ñ‚: {pull.get('port', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}",
                    parse_mode="HTML",
                )
            except Exception as e:
                logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°: {e}")
        else:
            status_msg = "âœ… ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ°"

        # 1ï¸âƒ£1ï¸âƒ£ Ğ£Ğ’Ğ•Ğ”ĞĞœĞ›Ğ¯Ğ•Ğœ Ğ¤Ğ•Ğ ĞœĞ•Ğ Ğ
        if farmer_id in users:
            try:
                await bot.send_message(
                    farmer_id,
                    f"âœ… <b>Ğ’Ğ°ÑˆĞ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ° Ğ² Ğ¿ÑƒĞ»Ğ»!</b>\n\n"
                    f"ğŸŒ¾ {batch.get('culture', 'ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°')} â€¢ {batch.get('volume', 0):.1f} Ñ‚\n"
                    f"ğŸ“¦ ĞŸÑƒĞ»Ğ» #{pull_id}\n"
                    f"ğŸ‘¥ Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² Ğ² Ğ¿ÑƒĞ»Ğµ: <b>{len(pull['farmer_ids'])}</b>\n"
                    f"ğŸ“Š Ğ¡Ğ¾Ğ±Ñ€Ğ°Ğ½Ğ¾: {current_volume:.1f}/{target_volume:.1f} Ñ‚\n"
                    f"ğŸš¢ ĞŸĞ¾Ñ€Ñ‚: {pull.get('port', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
                    f"ğŸ’° Ğ¦ĞµĞ½Ğ°: {batch.get('price', 0):,} â‚½/Ñ‚",
                    parse_mode="HTML",
                )
            except Exception as e:
                logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°: {e}")

        # ğŸ”´ Ğ“Ğ›ĞĞ’ĞĞĞ¯ Ğ˜Ğ¡ĞŸĞ ĞĞ’ĞšĞ - Ğ¡ĞĞ¥Ğ ĞĞĞ¯Ğ•Ğœ ĞŸĞ£Ğ›Ğ› Ğ’ Ğ“Ğ›ĞĞ‘ĞĞ›Ğ¬ĞĞ«Ğ™ Ğ¡Ğ›ĞĞ’ĞĞ Ğ¬!
        pulls["pulls"][pull_id] = pull

        # 1ï¸âƒ£2ï¸âƒ£ Ğ¡ĞĞ¥Ğ ĞĞĞ¯Ğ•Ğœ Ğ”ĞĞĞĞ«Ğ•
        save_data()

        # âœ… Ğ›ĞĞ“Ğ˜Ğ Ğ£Ğ•Ğœ Ğ Ğ•Ğ—Ğ£Ğ›Ğ¬Ğ¢ĞĞ¢
        logging.info(f"âœ… Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ñ‹:")
        logging.info(
            f"   pulls['pulls'][{pull_id}]['batch_ids'] = {pulls['pulls'][pull_id].get('batch_ids', [])}"
        )
        logging.info(
            f"   pulls['pullparticipants'][{pull_id}] ĞºĞ¾Ğ»-Ğ²Ğ¾ = {len(pulls['pullparticipants'].get(pull_id, []))}"
        )

        # 1ï¸âƒ£3ï¸âƒ£ ĞĞ¢Ğ’Ğ•Ğ¢ ĞŸĞĞ›Ğ¬Ğ—ĞĞ’ĞĞ¢Ğ•Ğ›Ğ®
        await callback.message.edit_text(
            f"âœ… <b>ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ° Ğ² Ğ¿ÑƒĞ»Ğ» #{pull_id}!</b>\n\n"
            f"ğŸ“Š Ğ¢ĞµĞºÑƒÑ‰Ğ¸Ğ¹ Ğ¾Ğ±ÑŠÑ‘Ğ¼: {current_volume:.1f}/{target_volume:.1f} Ñ‚\n"
            f"ğŸ‘¥ Ğ¤ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ² Ğ² Ğ¿ÑƒĞ»Ğµ: <b>{len(pull['farmer_ids'])}</b>\n"
            f"ğŸ“¦ ĞŸĞ°Ñ€Ñ‚Ğ¸Ğ¹: <b>{len(pull['batch_ids'])}</b>\n"
            f"ğŸ“‹ Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¾: <b>{len(pulls['pullparticipants'][pull_id])}</b>\n"
            f"{status_msg}",
            parse_mode="HTML",
        )
        await callback.answer("âœ… ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ°!")

    except Exception as e:
        logging.error(f"âŒ ĞĞ¨Ğ˜Ğ‘ĞšĞ Ğ² confirm_add_batch_to_pull: {e}", exc_info=True)
        await callback.answer(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)[:100]}", show_alert=True)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸšš Ğ¤Ğ•Ğ ĞœĞ•Ğ  Ğ¡ĞĞ—Ğ”ĞĞ•Ğ¢ Ğ—ĞĞ¯Ğ’ĞšĞ£ ĞĞ Ğ”ĞĞ¡Ğ¢ĞĞ’ĞšĞ£ (ĞºĞ¾Ğ¿Ğ¸Ñ Ğ»Ğ¾Ğ³Ğ¸ĞºĞ¸ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€Ğ°)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
@dp.message_handler(lambda m: m.text == "ğŸšš Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ", state="*")
async def create_logistics_request_start(message: types.Message, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ğ»Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ â€” Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚"""
    await state.finish()
    user_id = message.from_user.id

    if user_id not in users or users[user_id].get("role") != "exporter":
        await message.answer("âŒ Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°Ğ¼")
        return

    # --- Ğ£Ğ½Ğ¸Ğ²ĞµÑ€ÑĞ°Ğ»ÑŒĞ½Ğ¾ Ğ´Ğ¾ÑÑ‚Ğ°Ñ‚ÑŒ Ğ¿ÑƒĞ»Ñ‹
    true_pulls = None
    if (
        isinstance(pulls, dict)
        and "pulls" in pulls
        and isinstance(pulls["pulls"], dict)
    ):
        true_pulls = pulls["pulls"]
    elif isinstance(pulls, dict):
        true_pulls = pulls
    else:
        true_pulls = {}

    logging.info(f"\n{'='*50}")
    logging.info(f"USER {user_id} requested logistics")
    logging.info(f"ALL PULLS IN SYSTEM: {len(true_pulls)}")
    for pid, p in true_pulls.items():
        logging.info(
            f"  Pull #{pid}: exporter_id={p.get('exporter_id')}, status={p.get('status')}, culture={p.get('culture')}"
        )
    logging.info(f"{'='*50}\n")

    exporter_pulls = {}
    for pid, p in true_pulls.items():
        exp_id = p.get("exporter_id")
        pull_status = str(p.get("status", "")).lower().strip()
        logging.info(
            f"Checking pull {pid}: exp_id={exp_id}, user_id={user_id}, match={exp_id == user_id}, status={pull_status}"
        )
        # Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ÑƒĞµĞ¼ Ğ¿ÑƒĞ»Ñ‹ Ğ¿Ğ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑÑƒ 'filled' Ğ¸ 'Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½'
        if exp_id == user_id and pull_status in [
            "filled",
            "Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½",
        ]:
            exporter_pulls[pid] = p
            logging.info(f"  âœ… ADDED to exporter_pulls")

    logging.info(f"FOUND {len(exporter_pulls)} filled pulls for user {user_id}")

    if not exporter_pulls:
        await message.answer(
            "âŒ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ½Ñ‹Ñ… Ğ¿ÑƒĞ»Ğ¾Ğ².\n\n"
            "Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ Ğ¿ÑƒĞ» Ğ¸ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚Ğµ ĞµĞ³Ğ¾, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ·Ğ°ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ.",
            reply_markup=exporter_keyboard(),
        )
        return

    keyboard = InlineKeyboardMarkup(row_width=1)
    for pull_id, pull in list(exporter_pulls.items())[:10]:
        culture = pull.get("culture", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")
        current_vol = pull.get("current_volume", 0) or 0
        btn_text = f"#{pull_id} â€¢ {culture} â€¢ {current_vol:.0f} Ñ‚"
        keyboard.add(
            InlineKeyboardButton(
                btn_text, callback_data=f"create_logistic_req:{pull_id}"
            )
        )

    await message.answer(
        "ğŸšš <b>Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ</b>\n\n"
        f"<b>ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ½Ñ‹Ñ… Ğ¿ÑƒĞ»Ğ¾Ğ²: {len(exporter_pulls)}</b>\n\n"
        "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿ÑƒĞ» Ğ´Ğ»Ñ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºĞ¸:",
        reply_markup=keyboard,
        parse_mode="HTML",
    )


@dp.callback_query_handler(
    lambda c: c.data.startswith("create_logistic_req:"), state="*"
)
async def select_pull_for_logistics(callback: types.CallbackQuery, state: FSMContext):
    """Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ¿ÑƒĞ»Ğ° Ğ´Ğ»Ñ Ğ·Ğ°ÑĞ²ĞºĞ¸"""
    try:
        pull_id = parse_callback_id(callback.data)
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    if pull_id not in pulls.get("pulls", {}):
        await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    pull = pulls["pulls"][pull_id]

    await state.update_data(
        pull_id=pull_id,
        culture=pull["culture"],
        volume=pull.get("current_volume", 0),
        port=pull.get("port", ""),
    )

    await callback.message.edit_text(
        f"ğŸšš <b>Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ</b>\n\n"
        f"<b>Ğ¨Ğ°Ğ³ 1 Ğ¸Ğ· 4</b>\n\n"
        f"ĞŸÑƒĞ»: #{pull_id} â€¢ {pull['culture']} â€¢ {pull.get('current_volume', 0):.0f} Ñ‚\n"
        f"ĞŸĞ¾Ñ€Ñ‚: {pull.get('port', '')}\n\n"
        f"ĞÑ‚ĞºÑƒĞ´Ğ° (Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½/Ğ³Ğ¾Ñ€Ğ¾Ğ´ Ğ¿Ğ¾Ğ³Ñ€ÑƒĞ·ĞºĞ¸):",
        parse_mode="HTML",
    )

    await CreateLogisticRequestStatesGroup.route_from.set()
    await callback.answer()

@dp.callback_query_handler(
    lambda c: c.data.startswith("farmer_select_port:"), state="farmer_selecting_port"
)
async def farmer_select_port(callback: types.CallbackQuery, state: FSMContext):
    """Ğ¨ĞĞ“ 3: Ğ¤ĞµÑ€Ğ¼ĞµÑ€ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ» Ğ¿Ğ¾Ñ€Ñ‚, Ğ²Ñ‹Ğ±Ğ¸Ñ€Ğ°ĞµÑ‚ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚"""
    try:
        port = callback.data.split(":")[-1]
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    async with state.proxy() as data:
        data["port"] = port

    keyboard = InlineKeyboardMarkup(row_width=1)
    transports = [
        ("ğŸš‚ Ğ–Ğ”", "railway"),
        ("ğŸšš Ğ—ĞµÑ€Ğ½Ğ¾Ğ²Ğ¾Ğ·", "grain"),
        ("ğŸš› Ğ¤ÑƒÑ€Ğ°", "truck"),
    ]

    for transport_name, transport_code in transports:
        keyboard.add(
            InlineKeyboardButton(
                transport_name,
                callback_data=f"farmer_select_transport:{transport_code}",
            )
        )

    keyboard.add(InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="farmer_main_menu"))

    await callback.message.edit_text(
        "ğŸšš <b>Ğ’Ğ«Ğ‘Ğ•Ğ Ğ˜Ğ¢Ğ• Ğ¢Ğ˜ĞŸ Ğ¢Ğ ĞĞĞ¡ĞŸĞĞ Ğ¢Ğ</b>", reply_markup=keyboard, parse_mode="HTML"
    )

    await state.set_state("farmer_selecting_transport")
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("farmer_select_transport:"),
    state="farmer_selecting_transport",
)
async def farmer_select_transport(callback: types.CallbackQuery, state: FSMContext):
    """Ğ¨ĞĞ“ 4: Ğ¤ĞµÑ€Ğ¼ĞµÑ€ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ» Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚, Ğ²Ğ²Ğ¾Ğ´Ğ¸Ñ‚ Ñ†ĞµĞ½Ñƒ"""
    try:
        transport = callback.data.split(":")[-1]
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    async with state.proxy() as data:
        data["transport"] = transport

    await callback.message.edit_text(
        "ğŸ’° <b>ĞĞ–Ğ˜Ğ”ĞĞ•ĞœĞĞ¯ Ğ¦Ğ•ĞĞ Ğ”ĞĞ¡Ğ¢ĞĞ’ĞšĞ˜</b>\n\n"
        "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ†ĞµĞ½Ñƒ Ğ² â‚½/Ñ‚Ğ¾Ğ½Ğ½Ñƒ\n\n"
        "ĞŸÑ€Ğ¸Ğ¼ĞµÑ€: <code>1500</code>",
        reply_markup=InlineKeyboardMarkup().add(
            InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="farmer_main_menu")
        ),
        parse_mode="HTML",
    )

    await state.set_state("farmer_entering_price")
    await callback.answer()


@dp.message_handler(state="farmer_entering_price")
async def farmer_enter_price(message: types.Message, state: FSMContext):
    """Ğ¨ĞĞ“ 5: ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ"""
    try:
        price = float(message.text.strip().replace(",", "."))
        if price <= 0:
            raise ValueError
    except ValueError:
        await message.answer(
            "âŒ ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚!\n\nĞ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾: <code>1500</code>", parse_mode="HTML"
        )
        return

    data = await state.get_data()
    batch = data["batch"]
    port = data["port"]
    transport = data["transport"]

    # ĞŸĞµÑ€ĞµĞ²Ğ¾Ğ´Ğ¸Ğ¼ ĞºĞ¾Ğ´Ñ‹ Ğ² Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ñ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ
    ports_dict = {
        "ariyb": "â›´ï¸ ĞÑ€Ğ¸Ğ±",
        "volga_port": "â›´ï¸ ĞŸĞšĞ¤ Â«Ğ’Ğ¾Ğ»Ğ³Ğ°-ĞŸĞ¾Ñ€Ñ‚Â»",
        "yug_ter": "â›´ï¸ ĞŸĞšĞ¤ Â«Ğ®Ğ³-Ğ¢ĞµÑ€Â»",
        "astr_port": "â›´ï¸ ĞŸĞĞ Â«ĞÑÑ‚Ñ€.ĞŸĞ¾Ñ€Ñ‚Â»",
        "univer_port": "â›´ï¸ Ğ£Ğ½Ğ¸Ğ²ĞµÑ€.ĞŸĞ¾Ñ€Ñ‚",
        "yuzh_port": "â›´ï¸ Ğ®Ğ¶.ĞŸĞ¾Ñ€Ñ‚",
        "agrofud": "â›´ï¸ ĞĞ³Ñ€Ğ¾Ñ„ÑƒĞ´",
        "mosport": "â›´ï¸ ĞœĞ¾ÑĞ¿Ğ¾Ñ€Ñ‚",
        "cgp": "â›´ï¸ Ğ¦Ğ“ĞŸ",
        "fzt": "â›´ï¸ Ğ¤Ğ—Ğ¢",
        "amp": "â›´ï¸ ĞĞœĞŸ",
        "armada": "â›´ï¸ ĞÑ€Ğ¼Ğ°Ğ´Ğ°",
        "strelec": "â›´ï¸ Ğ¡Ñ‚Ñ€ĞµĞ»ĞµÑ†",
        "alfa": "â›´ï¸ ĞĞ»ÑŒÑ„Ğ°",
    }

    transports_dict = {
        "railway": "ğŸš‚ Ğ–Ğ”",
        "grain": "ğŸšš Ğ—ĞµÑ€Ğ½Ğ¾Ğ²Ğ¾Ğ·",
        "truck": "ğŸš› Ğ¤ÑƒÑ€Ğ°",
    }

    port_name = ports_dict.get(port, port)
    transport_name = transports_dict.get(transport, transport)

    text = (
        f"âœ… <b>ĞŸĞĞ”Ğ¢Ğ’Ğ•Ğ Ğ”Ğ˜Ğ¢Ğ• Ğ—ĞĞ¯Ğ’ĞšĞ£</b>\n\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        f"ğŸŒ¾ <b>ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°:</b> {batch['culture']}\n"
        f"ğŸ“¦ <b>ĞĞ±ÑŠÑ‘Ğ¼:</b> {batch['volume']} Ñ‚\n"
        f"ğŸ’° <b>Ğ¦ĞµĞ½Ğ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸:</b> {batch['price']:,} â‚½/Ñ‚\n"
        f"ğŸ’µ <b>Ğ˜Ñ‚Ğ¾Ğ³Ğ¾:</b> {batch['volume'] * batch['price']:,} â‚½\n\n"
        f"ğŸ“ <b>ĞÑ‚ĞºÑƒĞ´Ğ°:</b> {batch.get('region', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
        f"â›´ï¸ <b>ĞšÑƒĞ´Ğ°:</b> {port_name}\n"
        f"ğŸšš <b>Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚:</b> {transport_name}\n"
        f"ğŸ’³ <b>ĞĞ¶Ğ¸Ğ´Ğ°ĞµĞ¼Ğ°Ñ Ñ†ĞµĞ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸:</b> {price:,.0f} â‚½/Ñ‚\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    )

    keyboard = InlineKeyboardMarkup()
    keyboard.add(
        InlineKeyboardButton(
            "âœ… Ğ¡ĞĞ—Ğ”ĞĞ¢Ğ¬ Ğ—ĞĞ¯Ğ’ĞšĞ£", callback_data="farmer_confirm_logistics_request"
        )
    )
    keyboard.add(InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="farmer_main_menu"))

    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")
    await state.update_data(desired_price=price)


@dp.callback_query_handler(text="farmer_confirm_logistics_request", state="*")
async def farmer_confirm_logistics_request(
    callback: types.CallbackQuery, state: FSMContext
):
    """Ğ¨ĞĞ“ 6: Ğ¡ĞĞ—Ğ”ĞĞĞ˜Ğ• Ğ—ĞĞ¯Ğ’ĞšĞ˜"""
    user_id = callback.from_user.id
    data = await state.get_data()

    if not data.get("batch"):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿Ğ¾Ñ‚ĞµÑ€ÑĞ½Ñ‹", show_alert=True)
        return

    batch = data["batch"]
    port = data["port"]
    transport = data["transport"]

    ports_dict = {
        "ariyb": "ĞÑ€Ğ¸Ğ±",
        "volga_port": "ĞŸĞšĞ¤ Â«Ğ’Ğ¾Ğ»Ğ³Ğ°-ĞŸĞ¾Ñ€Ñ‚Â»",
        "yug_ter": "ĞŸĞšĞ¤ Â«Ğ®Ğ³-Ğ¢ĞµÑ€Â»",
        "astr_port": "ĞŸĞĞ Â«ĞÑÑ‚Ñ€.ĞŸĞ¾Ñ€Ñ‚Â»",
        "univer_port": "Ğ£Ğ½Ğ¸Ğ²ĞµÑ€.ĞŸĞ¾Ñ€Ñ‚",
        "yuzh_port": "Ğ®Ğ¶.ĞŸĞ¾Ñ€Ñ‚",
        "agrofud": "ĞĞ³Ñ€Ğ¾Ñ„ÑƒĞ´",
        "mosport": "ĞœĞ¾ÑĞ¿Ğ¾Ñ€Ñ‚",
        "cgp": "Ğ¦Ğ“ĞŸ",
        "fzt": "Ğ¤Ğ—Ğ¢",
        "amp": "ĞĞœĞŸ",
        "armada": "ĞÑ€Ğ¼Ğ°Ğ´Ğ°",
        "strelec": "Ğ¡Ñ‚Ñ€ĞµĞ»ĞµÑ†",
        "alfa": "ĞĞ»ÑŒÑ„Ğ°",
    }

    transports_dict = {
        "railway": "Ğ–Ğ”",
        "grain": "Ğ—ĞµÑ€Ğ½Ğ¾Ğ²Ğ¾Ğ·",
        "truck": "Ğ¤ÑƒÑ€Ğ°",
    }

    port_name = ports_dict.get(port, port)
    transport_name = transports_dict.get(transport, transport)

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: Ğ‘ĞµÑ€Ñ‘Ğ¼ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½ Ğ¸Ğ· Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°
    farmer_region = users[user_id].get("region", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")

    request_id = len(farmer_logistics_requests) + 1

    farmer_logistics_requests[request_id] = {
        "id": request_id,
        "farmer_id": user_id,
        "farmer_name": users[user_id].get("name", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾"),
        "farmer_phone": users[user_id].get("phone", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"),
        "farmer_email": users[user_id].get("email", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°"),
        "farmer_region": farmer_region,  # âœ… ĞĞĞ’ĞĞ•
        "batch_id": data["batch_id"],
        "culture": batch["culture"],
        "volume": batch["volume"],
        "price_per_ton": batch["price"],
        "total_sum": batch["volume"] * batch["price"],
        # âœ… Ğ’Ğ¡Ğ• ĞœĞĞ Ğ¨Ğ Ğ£Ğ¢Ğ« Ğ—ĞĞŸĞĞ›ĞĞ•ĞĞ«
        "route_from": farmer_region,  # âœ… ĞĞ¢ (Ğ¸Ğ· Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ)
        "route_to": port_name,  # âœ… Ğ”Ğ (Ğ¿Ğ¾Ñ€Ñ‚)
        "port_to": port_name,
        "port_code": port,
        "transport_type": transport_name,
        "transport_code": transport,
        "desired_price": data["desired_price"],
        "status": "active",
        "offers_count": 0,
        "created_at": datetime.now().strftime("%d.%m.%Y %H:%M"),
        "offers": [],
    }

    save_data()

    logging.info(
        f"âœ… Ğ¤ĞµÑ€Ğ¼ĞµÑ€ {user_id} ÑĞ¾Ğ·Ğ´Ğ°Ğ» Ğ·Ğ°ÑĞ²ĞºÑƒ #{request_id}: "
        f"{batch['culture']} {batch['volume']}Ñ‚, {port_name}, {transport_name}, {data['desired_price']}â‚½/Ñ‚"
    )

    # Ğ£Ğ’Ğ•Ğ”ĞĞœĞ›Ğ¯Ğ•Ğœ Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢ĞĞ’
    logists_count = 0
    for logist_id in users:
        if users[logist_id].get("role") in ["logistic", "logistics"]:
            try:
                msg = (
                    f"ğŸ“¬ <b>ĞĞĞ’ĞĞ¯ Ğ—ĞĞ¯Ğ’ĞšĞ ĞĞ Ğ”ĞĞ¡Ğ¢ĞĞ’ĞšĞ£!</b>\n\n"
                    f"ğŸŒ¾ {batch['culture']} â€¢ {batch['volume']}Ñ‚\n"
                    f"ğŸ’° Ğ¦ĞµĞ½Ğ°: {data['desired_price']:,} â‚½/Ñ‚\n"
                    f"ğŸ“ ĞÑ‚: {farmer_region}\n"
                    f"â›´ï¸ ĞŸĞ¾Ñ€Ñ‚: {port_name}\n"
                    f"ğŸšš Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚: {transport_name}\n"
                    f"ğŸ‘¤ Ğ¤ĞµÑ€Ğ¼ĞµÑ€: {users[user_id].get('name', '')}\n"
                    f"â˜ï¸ {users[user_id].get('phone', '')}\n\n"
                    f"ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ 'ĞĞ¢ĞšĞ›Ğ˜ĞšĞĞ£Ğ¢Ğ¬Ğ¡Ğ¯' ĞµÑĞ»Ğ¸ Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ñ‹ Ğ²ĞµĞ·Ñ‚Ğ¸"
                )

                keyboard = InlineKeyboardMarkup()
                keyboard.add(
                    InlineKeyboardButton(
                        "âœ… ĞĞ¢ĞšĞ›Ğ˜ĞšĞĞ£Ğ¢Ğ¬Ğ¡Ğ¯",
                        callback_data=f"logist_respond_farmer_request:{request_id}",
                    ),
                    InlineKeyboardButton(
                        "ğŸ“‹ Ğ”Ğ•Ğ¢ĞĞ›Ğ˜", callback_data=f"view_request:farmer:{request_id}"
                    ),
                )

                await bot.send_message(
                    logist_id, msg, reply_markup=keyboard, parse_mode="HTML"
                )
                logists_count += 1
            except Exception as e:
                logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° {logist_id}: {e}")

    success_text = (
        f"âœ… <b>Ğ—ĞĞ¯Ğ’ĞšĞ ĞĞ Ğ”ĞĞ¡Ğ¢ĞĞ’ĞšĞ£ Ğ¡ĞĞ—Ğ”ĞĞĞ!</b>\n\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        f"ğŸ¯ <b>ID:</b> #{request_id}\n"
        f"ğŸ“Š <b>Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ:</b> ĞĞ¶Ğ¸Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²\n\n"
        f"ğŸŒ¾ {batch['culture']} - {batch['volume']} Ñ‚\n"
        f"ğŸ’° {batch['price']:,} â‚½/Ñ‚ â€¢ Ğ˜Ñ‚Ğ¾Ğ³Ğ¾: {batch['volume'] * batch['price']:,} â‚½\n\n"
        f"ğŸ“ ĞÑ‚: {farmer_region}\n"
        f"â›´ï¸ ĞŸĞ¾Ñ€Ñ‚: {port_name}\n"
        f"ğŸšš Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚: {transport_name}\n"
        f"ğŸ’³ Ğ¦ĞµĞ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸: {data['desired_price']:,} â‚½/Ñ‚\n\n"
        f"ğŸ“¢ Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¾ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²: {logists_count}\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    )

    keyboard = InlineKeyboardMarkup()
    keyboard.add(
        InlineKeyboardButton("ğŸ“¬ ĞœĞĞ˜ Ğ—ĞĞ¯Ğ’ĞšĞ˜", callback_data="farmer_my_requests_menu")
    )
    keyboard.add(
        InlineKeyboardButton("ğŸ  Ğ“Ğ›ĞĞ’ĞĞĞ• ĞœĞ•ĞĞ®", callback_data="farmer_main_menu")
    )

    await callback.message.edit_text(
        success_text, reply_markup=keyboard, parse_mode="HTML"
    )
    await state.finish()
    await callback.answer("âœ… Ğ—Ğ°ÑĞ²ĞºĞ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ°!", show_alert=True)


@dp.callback_query_handler(text="farmer_my_requests_menu", state="*")
async def farmer_my_requests_menu(callback: types.CallbackQuery, state: FSMContext):
    """ĞœĞĞ˜ Ğ—ĞĞ¯Ğ’ĞšĞ˜ - Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ ÑĞ¿Ğ¸ÑĞºĞ°"""
    try:
        await state.finish()
        user_id = callback.from_user.id

        # Ğ˜Ñ‰ĞµĞ¼ Ğ·Ğ°ÑĞ²ĞºĞ¸ ÑÑ‚Ğ¾Ğ³Ğ¾ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°
        my_requests = [
            r for r in farmer_logistics_requests.values() if r["farmer_id"] == user_id
        ]

        if not my_requests:
            await callback.message.edit_text(
                "ğŸ“¬ <b>ĞœĞĞ˜ Ğ—ĞĞ¯Ğ’ĞšĞ˜</b>\n\n" "âŒ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ·Ğ°ÑĞ²Ğ¾Ğº Ğ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ",
                reply_markup=InlineKeyboardMarkup().add(
                    InlineKeyboardButton(
                        "ğŸ  Ğ“Ğ›ĞĞ’ĞĞĞ• ĞœĞ•ĞĞ®", callback_data="farmer_main_menu"
                    )
                ),
                parse_mode="HTML",
            )
            await callback.answer()
            return

        # Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°Ğ¼
        active = [r for r in my_requests if r["status"] == "active"]
        completed = [r for r in my_requests if r["status"] == "completed"]

        text = f"ğŸ“¬ <b>ĞœĞĞ˜ Ğ—ĞĞ¯Ğ’ĞšĞ˜</b>\n\n"
        text += f"ğŸŸ¢ <b>ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ…:</b> {len(active)}\n"
        text += f"âœ… <b>Ğ—Ğ°Ğ²ĞµÑ€ÑˆÑ‘Ğ½Ğ½Ñ‹Ñ…:</b> {len(completed)}\n\n"

        keyboard = InlineKeyboardMarkup(row_width=1)

        if active:
            text += "â”â”â”â”â”â” ĞĞšĞ¢Ğ˜Ğ’ĞĞ«Ğ• â”â”â”â”â”â”\n"
            for r in active:
                label = f"#{r['id']} â€¢ {r['culture']} â€¢ {r['volume']}Ñ‚ â€¢ {r['offers_count']} Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ¾Ğ²"
                keyboard.add(
                    InlineKeyboardButton(
                        label, callback_data=f"farmer_request_view:{r['id']}"
                    )
                )

        if completed:
            text += "â”â”â”â”â” Ğ—ĞĞ’Ğ•Ğ Ğ¨ĞĞĞĞ«Ğ• â”â”â”â”â”\n"
            for r in completed:
                label = f"#{r['id']} â€¢ {r['culture']} â€¢ {r['volume']}Ñ‚"
                keyboard.add(
                    InlineKeyboardButton(
                        label, callback_data=f"farmer_request_view:{r['id']}"
                    )
                )

        keyboard.add(
            InlineKeyboardButton("ğŸ  Ğ“Ğ›ĞĞ’ĞĞĞ• ĞœĞ•ĞĞ®", callback_data="farmer_main_menu")
        )

        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
        await callback.answer()

    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ² farmer_my_requests_menu: {e}")
        try:
            await callback.answer(f"âš ï¸ ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)[:50]}", show_alert=True)
        except:
            pass


# âœ… Ğ”ĞĞ‘ĞĞ’Ğ˜Ğ¢Ğ¬ Ğ²Ñ‚Ğ¾Ñ€Ğ¾Ğ¹ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ñ Ñ‚Ğ¾Ğ¹ Ğ¶Ğµ Ğ»Ğ¾Ğ³Ğ¸ĞºĞ¾Ğ¹:
@dp.message_handler(text="ğŸ“¬ ĞœĞĞ˜ Ğ—ĞĞ¯Ğ’ĞšĞ˜", state="*")
async def farmer_my_requests_text(message: types.Message, state: FSMContext):
    """ĞœĞĞ˜ Ğ—ĞĞ¯Ğ’ĞšĞ˜ - Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ²Ğ°Ñ ĞºĞ½Ğ¾Ğ¿ĞºĞ°"""
    await state.finish()
    user_id = message.from_user.id

    my_requests = [
        r for r in farmer_logistics_requests.values() if r["farmer_id"] == user_id
    ]

    if not my_requests:
        await message.answer(
            "ğŸ“¬ <b>ĞœĞĞ˜ Ğ—ĞĞ¯Ğ’ĞšĞ˜</b>\n\nâŒ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ·Ğ°ÑĞ²Ğ¾Ğº",
            reply_markup=InlineKeyboardMarkup().add(
                InlineKeyboardButton(
                    "ğŸ  Ğ“Ğ›ĞĞ’ĞĞĞ• ĞœĞ•ĞĞ®", callback_data="farmer_main_menu"
                )
            ),
            parse_mode="HTML",
        )
        return

    active = [r for r in my_requests if r["status"] == "active"]
    completed = [r for r in my_requests if r["status"] == "completed"]

    text = f"ğŸ“¬ <b>ĞœĞĞ˜ Ğ—ĞĞ¯Ğ’ĞšĞ˜</b>\n\nğŸŸ¢ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ…: {len(active)}\nâœ… Ğ—Ğ°Ğ²ĞµÑ€ÑˆÑ‘Ğ½Ğ½Ñ‹Ñ…: {len(completed)}\n\n"

    keyboard = InlineKeyboardMarkup(row_width=1)

    if active:
        text += "â”â”â”â”â”â” ĞĞšĞ¢Ğ˜Ğ’ĞĞ«Ğ• â”â”â”â”â”â”\n"
        for r in active:
            label = f"#{r['id']} â€¢ {r['culture']} â€¢ {r['volume']}Ñ‚ â€¢ {r['offers_count']} Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ¾Ğ²"
            keyboard.add(
                InlineKeyboardButton(
                    label, callback_data=f"farmer_request_view:{r['id']}"
                )
            )

    if completed:
        text += "â”â”â”â”â” Ğ—ĞĞ’Ğ•Ğ Ğ¨ĞĞĞĞ«Ğ• â”â”â”â”â”\n"
        for r in completed:
            label = f"#{r['id']} â€¢ {r['culture']} â€¢ {r['volume']}Ñ‚"
            keyboard.add(
                InlineKeyboardButton(
                    label, callback_data=f"farmer_request_view:{r['id']}"
                )
            )

    keyboard.add(
        InlineKeyboardButton("ğŸ  Ğ“Ğ›ĞĞ’ĞĞĞ• ĞœĞ•ĞĞ®", callback_data="farmer_main_menu")
    )

    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")


@dp.callback_query_handler(
    lambda c: c.data.startswith("farmer_request_view:"), state="*"
)
async def farmer_request_view(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹ Ğ·Ğ°ÑĞ²ĞºĞ¸"""
    await state.finish()

    try:
        request_id = int(callback.data.split(":")[-1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑÑƒÑ‰ĞµÑÑ‚Ğ²Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ·Ğ°ÑĞ²ĞºĞ¸
    if (
        request_id not in farmer_logistics_requests
        and str(request_id) not in farmer_logistics_requests
    ):
        await callback.answer("âŒ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ·Ğ°ÑĞ²ĞºÑƒ (Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¾Ğ±Ğ° Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ğ° ĞºĞ»ÑÑ‡Ğ°)
    request = farmer_logistics_requests.get(
        request_id
    ) or farmer_logistics_requests.get(str(request_id))

    if not request:
        await callback.answer("âŒ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    user_id = callback.from_user.id

    if request["farmer_id"] != user_id:
        await callback.answer("âŒ Ğ­Ñ‚Ğ¾ Ğ½Ğµ Ğ²Ğ°ÑˆĞ° Ğ·Ğ°ÑĞ²ĞºĞ°", show_alert=True)
        return

    text = (
        f"ğŸ“‹ <b>Ğ—ĞĞ¯Ğ’ĞšĞ #{request['id']}</b>\n\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        f"<b>Ğ¡Ğ¢ĞĞ¢Ğ£Ğ¡:</b> {request['status']}\n\n"
        f"ğŸŒ¾ <b>ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°:</b> {request['culture']}\n"
        f"ğŸ“¦ <b>ĞĞ±ÑŠÑ‘Ğ¼:</b> {request['volume']} Ñ‚\n"
        f"ğŸ’° <b>Ğ¦ĞµĞ½Ğ°:</b> {request['price_per_ton']:,} â‚½/Ñ‚\n"
        f"ğŸ’µ <b>Ğ˜Ñ‚Ğ¾Ğ³Ğ¾:</b> {request['total_sum']:,} â‚½\n\n"
        f"ğŸ“ <b>ĞÑ‚:</b> {request['farmer_region']}\n"
        f"â›´ï¸ <b>ĞšÑƒĞ´Ğ°:</b> {request['port_to']}\n"
        f"ğŸšš <b>Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚:</b> {request['transport_type']}\n"
        f"ğŸ’³ <b>Ğ¦ĞµĞ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸:</b> {request['desired_price']:,} â‚½/Ñ‚\n\n"
        f"ğŸ“ <b>ĞÑ‚ĞºĞ»Ğ¸ĞºĞ¾Ğ²:</b> {request['offers_count']}\n"
        f"ğŸ“… <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ°:</b> {request['created_at']}\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    )

    keyboard = InlineKeyboardMarkup(row_width=2)

    # Ğ•ÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ¸
    if request["offers_count"] > 0:
        keyboard.add(
            InlineKeyboardButton(
                f"ğŸ“ ĞĞ¢ĞšĞ›Ğ˜ĞšĞĞ’: {request['offers_count']}",
                callback_data=f"farmer_view_offers:{request['id']}",
            )
        )

    # âœ… Ğ”ĞĞ‘ĞĞ’Ğ›Ğ¯Ğ•Ğœ ĞšĞĞĞŸĞšĞ˜ Ğ£ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ¯ Ğ—ĞĞ¯Ğ’ĞšĞĞ™
    keyboard.add(
        InlineKeyboardButton(
            "âœï¸ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ", callback_data=f"edit_request:{request['id']}"
        ),
        InlineKeyboardButton(
            "ğŸ—‘ï¸ Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ", callback_data=f"delete_request:{request['id']}"
        ),
    )

    keyboard.add(
        InlineKeyboardButton("ğŸ“¬ ĞœĞĞ˜ Ğ—ĞĞ¯Ğ’ĞšĞ˜", callback_data="farmer_my_requests_menu")
    )
    keyboard.add(
        InlineKeyboardButton("ğŸ  Ğ“Ğ›ĞĞ’ĞĞĞ• ĞœĞ•ĞĞ®", callback_data="farmer_main_menu")
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


def get_choice_keyboard(field, request_id):
    keyboard = InlineKeyboardMarkup(row_width=2)
    if field == "culture":
        for option in CULTURES:
            keyboard.insert(
                InlineKeyboardButton(
                    option,
                    callback_data=f"edit_field_val:{field}:{option}:{request_id}",
                )
            )
    elif field == "transport_type":
        for t, emoji in TRANSPORT_TYPES.items():
            keyboard.insert(
                InlineKeyboardButton(
                    f"{emoji} {t}",
                    callback_data=f"edit_field_val:{field}:{t}:{request_id}",
                )
            )
    elif field == "port_to":
        for port in PORTS:
            keyboard.insert(
                InlineKeyboardButton(
                    port, callback_data=f"edit_field_val:{field}:{port}:{request_id}"
                )
            )
    keyboard.add(
        InlineKeyboardButton(
            "â• Ğ”Ñ€ÑƒĞ³Ğ¾Ğµ", callback_data=f"edit_field_custom:{field}:{request_id}"
        )
    )
    keyboard.add(
        InlineKeyboardButton("â¬…ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data=f"edit_request:{request_id}")
    )
    return keyboard


@dp.callback_query_handler(lambda c: c.data.startswith("edit_request:"), state="*")
async def edit_request_start(callback: types.CallbackQuery, state: FSMContext):
    request_id = int(callback.data.split(":")[-1])
    user_id = callback.from_user.id
    request = farmer_logistics_requests.get(
        request_id
    ) or farmer_logistics_requests.get(str(request_id))
    if not request or request["farmer_id"] != user_id:
        await callback.answer("âŒ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°, Ğ»Ğ¸Ğ±Ğ¾ Ğ½Ğµ Ğ²Ğ°ÑˆĞ°", show_alert=True)
        return
    await state.update_data(request_id=request_id)
    text = f"âœï¸ <b>Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸ #{request_id}</b>\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ğ»Ğµ Ğ´Ğ»Ñ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ:"
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton(
            "ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°", callback_data=f"edit_req_field:culture:{request_id}"
        ),
        InlineKeyboardButton(
            "ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼", callback_data=f"edit_req_field:volume:{request_id}"
        ),
        InlineKeyboardButton(
            "ğŸ’° Ğ¦ĞµĞ½Ğ°/Ñ‚", callback_data=f"edit_req_field:price_per_ton:{request_id}"
        ),
        InlineKeyboardButton(
            "â›´ï¸ ĞŸĞ¾Ñ€Ñ‚", callback_data=f"edit_req_field:port_to:{request_id}"
        ),
        InlineKeyboardButton(
            "ğŸšš Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚", callback_data=f"edit_req_field:transport_type:{request_id}"
        ),
        InlineKeyboardButton(
            "ğŸ—‘ï¸ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data=f"farmer_request_view:{request_id}"
        ),
    )
    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("edit_req_field:"), state="*")
async def edit_req_field_handler(callback: types.CallbackQuery, state: FSMContext):
    _, field, request_id = callback.data.split(":")
    await state.update_data(edit_field=field, request_id=int(request_id))
    if field in ["culture", "transport_type", "port_to"]:
        await callback.message.edit_text(
            f"ğŸ“ Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ <b>{field}</b>:",
            reply_markup=get_choice_keyboard(field, request_id),
            parse_mode="HTML",
        )
        await EditRequestStates.waiting_for_choice.set()
    elif field in ["volume", "price_per_ton"]:
        await callback.message.edit_text(
            f"ğŸ“ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ <b>{field}</b> (Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ‡Ğ¸ÑĞ»Ğ¾):",
            parse_mode="HTML",
        )
        await EditRequestStates.waiting_for_number.set()
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("edit_field_val:"),
    state=EditRequestStates.waiting_for_choice,
)
async def edit_field_value_choice(callback: types.CallbackQuery, state: FSMContext):
    _, field, value, request_id = callback.data.split(":")
    await state.finish()
    request_id = int(request_id)
    user_id = callback.from_user.id
    request = farmer_logistics_requests.get(
        request_id
    ) or farmer_logistics_requests.get(str(request_id))
    if not request or request["farmer_id"] != user_id:
        await callback.answer("âŒ Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰Ñ‘Ğ½", show_alert=True)
        return
    request[field] = value
    with open("data/farmer_logistics_requests.pkl", "wb") as f:
        pickle.dump(farmer_logistics_requests, f)
    keyboard = InlineKeyboardMarkup().add(
        InlineKeyboardButton(
            "â¬…ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğº Ğ·Ğ°ÑĞ²ĞºĞµ", callback_data=f"farmer_request_view:{request_id}"
        )
    )
    await callback.message.edit_text(
        f"âœ… Ğ—Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»Ñ <b>{field}</b> Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾!",
        reply_markup=keyboard,
        parse_mode="HTML",
    )
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("edit_field_custom:"),
    state=EditRequestStates.waiting_for_choice,
)
async def edit_field_custom_choice(callback: types.CallbackQuery, state: FSMContext):
    _, field, request_id = callback.data.split(":")
    await state.update_data(edit_field=field, request_id=int(request_id))
    await callback.message.edit_text(
        f"ğŸ“ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ÑĞ²Ğ¾Ñ‘ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ <b>{field}</b>:", parse_mode="HTML"
    )
    await EditRequestStates.waiting_for_custom_value.set()
    await callback.answer()


@dp.message_handler(state=EditRequestStates.waiting_for_custom_value)
async def process_custom_value(message: types.Message, state: FSMContext):
    user_data = await state.get_data()
    field = user_data.get("edit_field")
    request_id = user_data.get("request_id")
    new_value = message.text.strip()
    request = farmer_logistics_requests.get(
        request_id
    ) or farmer_logistics_requests.get(str(request_id))
    if not request or request["farmer_id"] != message.from_user.id:
        await message.answer("âŒ Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰Ñ‘Ğ½")
        await state.finish()
        return
    request[field] = new_value
    with open("data/farmer_logistics_requests.pkl", "wb") as f:
        pickle.dump(farmer_logistics_requests, f)
    keyboard = InlineKeyboardMarkup().add(
        InlineKeyboardButton(
            "â¬…ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğº Ğ·Ğ°ÑĞ²ĞºĞµ", callback_data=f"farmer_request_view:{request_id}"
        )
    )
    await message.answer(
        f"âœ… Ğ—Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ <b>{field}</b> Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾!",
        reply_markup=keyboard,
        parse_mode="HTML",
    )
    await state.finish()


@dp.message_handler(state=EditRequestStates.waiting_for_number)
async def process_number_field(message: types.Message, state: FSMContext):
    user_data = await state.get_data()
    field = user_data.get("edit_field")
    request_id = user_data.get("request_id")
    value = message.text.strip().replace(",", ".")
    try:
        value = float(value)
        if value <= 0:
            raise ValueError
    except ValueError:
        await message.answer("âŒ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğµ Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾!")
        return
    request = farmer_logistics_requests.get(
        request_id
    ) or farmer_logistics_requests.get(str(request_id))
    if not request or request["farmer_id"] != message.from_user.id:
        await message.answer("âŒ Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰Ñ‘Ğ½")
        await state.finish()
        return
    request[field] = value
    if field == "volume":
        request["total_sum"] = value * float(request.get("price_per_ton", 0))
    if field == "price_per_ton":
        request["total_sum"] = float(request.get("volume", 0)) * value
    with open("data/farmer_logistics_requests.pkl", "wb") as f:
        pickle.dump(farmer_logistics_requests, f)
    keyboard = InlineKeyboardMarkup().add(
        InlineKeyboardButton(
            "â¬…ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğº Ğ·Ğ°ÑĞ²ĞºĞµ", callback_data=f"farmer_request_view:{request_id}"
        )
    )
    await message.answer(
        f"âœ… Ğ—Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ <b>{field}</b> Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾!",
        reply_markup=keyboard,
        parse_mode="HTML",
    )
    await state.finish()


@dp.callback_query_handler(
    lambda c: c.data.startswith("farmer_request_view:"), state="*"
)
async def show_request_view(callback: types.CallbackQuery, state: FSMContext):
    await state.finish()
    await farmer_request_view(
        callback, state
    )  # Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ° Ğ¸Ğ»Ğ¸ ÑƒĞ¶Ğµ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ° Ñƒ Ğ²Ğ°Ñ
    await callback.answer()


# ============================================================================
# Ğ£Ğ”ĞĞ›Ğ•ĞĞ˜Ğ• Ğ—ĞĞ¯Ğ’ĞšĞ˜ Ğ¤Ğ•Ğ ĞœĞ•Ğ Ğ ĞĞ Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢Ğ˜ĞšĞ£
# ============================================================================


@dp.callback_query_handler(lambda c: c.data.startswith("delete_request:"), state="*")
async def confirm_delete_request(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ Ğ·Ğ°ÑĞ²ĞºĞ¸"""
    await state.finish()

    try:
        request_id = int(callback.data.split(":", 1)[1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑÑƒÑ‰ĞµÑÑ‚Ğ²Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ·Ğ°ÑĞ²ĞºĞ¸ (Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¾Ğ±Ğ° Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ğ° ĞºĞ»ÑÑ‡Ğ°)
    if (
        request_id not in farmer_logistics_requests
        and str(request_id) not in farmer_logistics_requests
    ):
        await callback.answer("âŒ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ·Ğ°ÑĞ²ĞºÑƒ
    request = farmer_logistics_requests.get(
        request_id
    ) or farmer_logistics_requests.get(str(request_id))

    if not request:
        await callback.answer("âŒ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    user_id = callback.from_user.id

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ²Ğ»Ğ°Ğ´ĞµĞ»ÑŒÑ†Ğ°
    if request.get("farmer_id") != user_id:
        await callback.answer("âŒ Ğ­Ñ‚Ğ¾ Ğ½Ğµ Ğ²Ğ°ÑˆĞ° Ğ·Ğ°ÑĞ²ĞºĞ°", show_alert=True)
        return

    # Ğ¡Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ñ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸ĞµĞ¼
    text = f"""
âš ï¸ <b>ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ</b>

Ğ’Ñ‹ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ·Ğ°ÑĞ²ĞºÑƒ?

ğŸ“‹ <b>Ğ—Ğ°ÑĞ²ĞºĞ° #{request['id']}</b>
ğŸŒ¾ {request.get('culture', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')} - {request.get('volume', 0)} Ñ‚
ğŸ“ {request.get('farmer_region', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')} â†’ {request.get('port_to', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}
ğŸ’° Ğ¦ĞµĞ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸: {request.get('desired_price', 0):,} â‚½/Ñ‚
ğŸ“ ĞÑ‚ĞºĞ»Ğ¸ĞºĞ¾Ğ²: {request.get('offers_count', 0)}

â—ï¸ <b>Ğ­Ñ‚Ğ¾ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ½ĞµĞ»ÑŒĞ·Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ!</b>
"""

    if request.get("offers_count", 0) > 0:
        text += f"\nâš ï¸ Ğ£ Ğ·Ğ°ÑĞ²ĞºĞ¸ ĞµÑÑ‚ÑŒ {request['offers_count']} Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ¾Ğ² Ğ¾Ñ‚ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²!"

    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton(
            "âœ… Ğ”Ğ°, ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ", callback_data=f"confirm_delete_request:{request['id']}"
        ),
        InlineKeyboardButton(
            "âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data=f"farmer_request_view:{request['id']}"
        ),
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("confirm_delete_request:"), state="*"
)
async def delete_request_final(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞºĞ¾Ğ½Ñ‡Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğµ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸"""
    await state.finish()

    try:
        request_id = int(callback.data.split(":", 1)[1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑÑƒÑ‰ĞµÑÑ‚Ğ²Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ·Ğ°ÑĞ²ĞºĞ¸
    if (
        request_id not in farmer_logistics_requests
        and str(request_id) not in farmer_logistics_requests
    ):
        await callback.answer("âŒ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ·Ğ°ÑĞ²ĞºÑƒ
    request = farmer_logistics_requests.get(
        request_id
    ) or farmer_logistics_requests.get(str(request_id))

    if not request:
        await callback.answer("âŒ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    user_id = callback.from_user.id

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ²Ğ»Ğ°Ğ´ĞµĞ»ÑŒÑ†Ğ°
    if request.get("farmer_id") != user_id:
        await callback.answer("âŒ Ğ­Ñ‚Ğ¾ Ğ½Ğµ Ğ²Ğ°ÑˆĞ° Ğ·Ğ°ÑĞ²ĞºĞ°", show_alert=True)
        return

    # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ»Ñ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹
    culture = request.get("culture", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾")
    volume = request.get("volume", 0)
    offers = request.get("offers", [])

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ², ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ½ÑƒĞ»Ğ¸ÑÑŒ
    logist_ids = [offer.get("logist_id") for offer in offers if offer.get("logist_id")]

    # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ·Ğ°ÑĞ²ĞºÑƒ (Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¾Ğ±Ğ° Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ğ° ĞºĞ»ÑÑ‡Ğ°)
    if request_id in farmer_logistics_requests:
        del farmer_logistics_requests[request_id]
    elif str(request_id) in farmer_logistics_requests:
        del farmer_logistics_requests[str(request_id)]

    # âœ… Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ² Ñ„Ğ°Ğ¹Ğ»
    try:
        save_farmers_logistics()
        logging.info(f"âœ… Ğ—Ğ°ÑĞ²ĞºĞ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ñ‹ Ğ¿Ğ¾ÑĞ»Ğµ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ #{request_id}")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ğ·Ğ°ÑĞ²Ğ¾Ğº: {e}")

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ² Ğ¾Ğ± ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ğ¸ Ğ·Ğ°ÑĞ²ĞºĞ¸
    for logist_id in logist_ids:
        try:
            await bot.send_message(
                logist_id,
                f"â„¹ï¸ <b>Ğ—Ğ°ÑĞ²ĞºĞ° ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ°</b>\n\n"
                f"Ğ—Ğ°ÑĞ²ĞºĞ° #{request_id} ({culture}, {volume}Ñ‚) Ğ±Ñ‹Ğ»Ğ° ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ° Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ¼.\n\n"
                f"ĞŸÑ€Ğ¸Ğ½Ğ¾ÑĞ¸Ğ¼ Ğ¸Ğ·Ğ²Ğ¸Ğ½ĞµĞ½Ğ¸Ñ Ğ·Ğ° Ğ½ĞµÑƒĞ´Ğ¾Ğ±ÑÑ‚Ğ²Ğ°.",
                parse_mode="HTML",
            )
        except Exception as e:
            logging.error(f"ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° {logist_id}: {e}")

    logging.info(f"ğŸ—‘ï¸ Ğ—Ğ°ÑĞ²ĞºĞ° #{request_id} ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¼ {user_id}")

    # ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ¾ÑÑ‚Ğ°Ğ²ÑˆĞ¸Ñ…ÑÑ Ğ·Ğ°ÑĞ²Ğ¾Ğº
    my_requests = [
        r for r in farmer_logistics_requests.values() if r.get("farmer_id") == user_id
    ]

    if not my_requests:
        text = "ğŸ“¬ <b>ĞœĞĞ˜ Ğ—ĞĞ¯Ğ’ĞšĞ˜</b>\n\nâœ… Ğ—Ğ°ÑĞ²ĞºĞ° ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ°!\n\nâŒ Ğ£ Ğ²Ğ°Ñ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ½ĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ·Ğ°ÑĞ²Ğ¾Ğº"
        keyboard = InlineKeyboardMarkup()
        keyboard.add(
            InlineKeyboardButton("ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="farmer_main_menu")
        )
    else:
        active = [r for r in my_requests if r.get("status") == "active"]
        completed = [r for r in my_requests if r.get("status") == "completed"]

        text = f"ğŸ“¬ <b>ĞœĞĞ˜ Ğ—ĞĞ¯Ğ’ĞšĞ˜</b>\n\nâœ… <b>Ğ—Ğ°ÑĞ²ĞºĞ° #{request_id} ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ°!</b>\n\n"
        text += f"ğŸŸ¢ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ…: {len(active)}\n"
        text += f"âœ… Ğ—Ğ°Ğ²ĞµÑ€ÑˆÑ‘Ğ½Ğ½Ñ‹Ñ…: {len(completed)}\n\n"

        keyboard = InlineKeyboardMarkup(row_width=1)

        if active:
            text += "â”â”â”â”â”â” ĞĞšĞ¢Ğ˜Ğ’ĞĞ«Ğ• â”â”â”â”â”â”\n"
            for r in active:
                label = f"#{r['id']} â€¢ {r.get('culture', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')} â€¢ {r.get('volume', 0)}Ñ‚ â€¢ {r.get('offers_count', 0)} Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ¾Ğ²"
                keyboard.add(
                    InlineKeyboardButton(
                        label, callback_data=f"farmer_request_view:{r['id']}"
                    )
                )

        keyboard.add(
            InlineKeyboardButton("ğŸ  Ğ“Ğ›ĞĞ’ĞĞĞ• ĞœĞ•ĞĞ®", callback_data="farmer_main_menu")
        )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer("âœ… Ğ—Ğ°ÑĞ²ĞºĞ° ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ°!", show_alert=True)


@dp.callback_query_handler(
    lambda c: c.data.startswith("farmer_view_offers:"), state="*"
)
async def farmer_view_offers(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ¾Ğ² Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²"""
    await state.finish()

    try:
        request_id = int(callback.data.split(":")[-1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    if request_id not in farmer_logistics_requests:
        await callback.answer("âŒ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    request = farmer_logistics_requests[request_id]
    user_id = callback.from_user.id

    if request["farmer_id"] != user_id:
        await callback.answer("âŒ Ğ­Ñ‚Ğ¾ Ğ½Ğµ Ğ²Ğ°ÑˆĞ° Ğ·Ğ°ÑĞ²ĞºĞ°", show_alert=True)
        return

    if not request["offers"]:
        await callback.message.edit_text(
            "âŒ ĞÑ‚ĞºĞ»Ğ¸ĞºĞ¾Ğ² Ğ½ĞµÑ‚",
            reply_markup=InlineKeyboardMarkup().add(
                InlineKeyboardButton(
                    "ğŸ“‹ Ğš Ğ—ĞĞ¯Ğ’ĞšĞ•", callback_data=f"farmer_request_view:{request_id}"
                )
            ),
        )
        await callback.answer()
        return

    text = f"ğŸ“ <b>ĞĞ¢ĞšĞ›Ğ˜ĞšĞ˜ ĞĞ Ğ—ĞĞ¯Ğ’ĞšĞ£ #{request_id}</b>\n\n"

    keyboard = InlineKeyboardMarkup(row_width=1)

    for i, offer in enumerate(request["offers"], 1):
        text += (
            f"â”â”â” ĞĞ¢ĞšĞ›Ğ˜Ğš {i} â”â”â”\n"
            f"ğŸ‘¤ {offer['logist_name']}\n"
            f"â˜ï¸ <code>{offer['logist_phone']}</code>\n"
            f"â° {offer['responded_at']}\n\n"
        )

        keyboard.add(
            InlineKeyboardButton(
                f"ğŸ“ Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢ {i}: {offer['logist_name']}",
                callback_data=f"farmer_contact_logist:{request_id}:{offer['logist_id']}",
            )
        )

    keyboard.add(
        InlineKeyboardButton(
            "ğŸ“‹ Ğš Ğ—ĞĞ¯Ğ’ĞšĞ•", callback_data=f"farmer_request_view:{request_id}"
        )
    )
    keyboard.add(
        InlineKeyboardButton("ğŸ“¬ ĞœĞĞ˜ Ğ—ĞĞ¯Ğ’ĞšĞ˜", callback_data="farmer_my_requests_menu")
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("farmer_contact_logist:"), state="*"
)
async def farmer_contact_logist(callback: types.CallbackQuery, state: FSMContext):
    """Ğ¡Ğ²ÑĞ·Ğ°Ñ‚ÑŒÑÑ Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ¼"""
    await state.finish()

    try:
        parts = callback.data.split(":")
        request_id = int(parts[1])
        logist_id = int(parts[2])

        # âœ… Ğ”ĞĞ‘ĞĞ’Ğ¬ Ğ›ĞĞ“Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ•
        logging.info(f"âœ… HANDLER TRIGGERED: source=farmer, req_id={request_id}")
        logging.debug(f"Available requests: {list(farmer_logistics_requests.keys())}")

    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    # âœ… ĞŸĞ ĞĞ’Ğ•Ğ ĞšĞ Ğ˜ Ğ”Ğ›Ğ¯ INT Ğ˜ Ğ”Ğ›Ğ¯ STR
    if (
        request_id not in farmer_logistics_requests
        and str(request_id) not in farmer_logistics_requests
    ):
        logging.error(f"âŒ REQUEST NOT FOUND: {request_id}")
        logging.error(f"Available keys: {farmer_logistics_requests.keys()}")
        await callback.answer("âŒ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    # âœ… ĞŸĞĞ›Ğ£Ğ§ĞĞ•Ğœ Ğ—ĞĞ¯Ğ’ĞšĞ£ (Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¾Ğ±Ğ° Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ğ°)
    request = farmer_logistics_requests.get(
        request_id
    ) or farmer_logistics_requests.get(str(request_id))

    if not request:
        await callback.answer("âŒ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    # Ğ˜Ñ‰ĞµĞ¼ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° Ğ² Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ°Ñ…
    offer = None
    for o in request.get("offers", []):
        if o.get("logist_id") == logist_id:
            offer = o
            break

    if not offer:
        await callback.answer("âŒ ĞÑ‚ĞºĞ»Ğ¸Ğº Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    text = (
        f"ğŸ“ <b>ĞšĞĞĞ¢ĞĞšĞ¢Ğ« Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢Ğ</b>\n\n"
        f"ğŸ‘¤ {offer['logist_name']}\n"
        f"â˜ï¸ <code>{offer['logist_phone']}</code>\n"
        f"ğŸ“§ Email: Ğ¡Ğ²ÑĞ¶Ğ¸Ñ‚ĞµÑÑŒ Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ÑƒÑ Ğ¿Ğ¾ Ğ½Ğ¾Ğ¼ĞµÑ€Ñƒ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°\n\n"
        f"ğŸ’¬ Ğ—Ğ°ÑĞ²ĞºĞ° #{request_id}: {request['culture']} {request['volume']}Ñ‚\n"
        f"â›´ï¸ {request['port_to']}\n"
        f"ğŸšš {request['transport_type']}\n"
        f"ğŸ’³ Ğ¦ĞµĞ½Ğ°: {request['desired_price']:,} â‚½/Ñ‚"
    )

    keyboard = InlineKeyboardMarkup()
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ“ ĞĞ¢ĞšĞ›Ğ˜ĞšĞ«", callback_data=f"farmer_view_offers:{request_id}"
        )
    )
    keyboard.add(
        InlineKeyboardButton("ğŸ“¬ ĞœĞĞ˜ Ğ—ĞĞ¯Ğ’ĞšĞ˜", callback_data="farmer_my_requests_menu")
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


# ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜Ğš ĞšĞĞĞŸĞšĞ˜: Ğ¡ĞĞ—Ğ”ĞĞ¢Ğ¬ Ğ—ĞĞ¯Ğ’ĞšĞ£ (Ğ¼Ğ¸Ğ½Ğ¸-ĞºĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ² Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğ¸)
@dp.callback_query_handler(text="farmer_confirm_request", state="*")
async def farmer_confirm_request_button(
    callback: types.CallbackQuery, state: FSMContext
):
    """ĞšĞ½Ğ¾Ğ¿ĞºĞ° Ğ¡ĞĞ—Ğ”ĞĞ¢Ğ¬ Ğ—ĞĞ¯Ğ’ĞšĞ£ Ğ² Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğ¸"""
    user_id = callback.from_user.id

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¸Ğ· state
    data = await state.get_data()

    if not data:
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°! Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ñ‹", show_alert=True)
        return

    # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ğ·Ğ°ÑĞ²ĞºÑƒ Ğ² farmer_logistics_requests
    request_id = len(farmer_logistics_requests) + 1

    farmer_logistics_requests[request_id] = {
        "id": request_id,
        "user_id": user_id,
        "culture": data.get("culture"),
        "volume": data.get("volume"),
        "price": data.get("price"),
        "departure": data.get("departure"),
        "destination": data.get("destination"),
        "transport": data.get("transport"),
        "delivery_price": data.get("delivery_price"),
        "created_at": datetime.now().strftime("%d.%m.%Y %H:%M"),
        "status": "active",
    }

    await state.finish()

    await callback.message.edit_text(
        f"âœ… <b>Ğ—Ğ°ÑĞ²ĞºĞ° #{request_id} ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ°!</b>\n\n"
        f"Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: <b>Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ°</b>\n"
        f"Ğ”Ğ°Ñ‚Ğ°: {datetime.now().strftime('%d.%m.%Y %H:%M')}",
        parse_mode="HTML",
    )
    await callback.answer("âœ… Ğ—Ğ°ÑĞ²ĞºĞ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ°!", show_alert=False)


# Ğ’Ñ‚Ğ¾Ñ€Ğ¾Ğ¹ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº - Ğ¾ÑÑ‚Ğ°Ğ²ÑŒÑ‚Ğµ ĞºĞ°Ğº ĞµÑÑ‚ÑŒ!
@dp.callback_query_handler(text="farmer_cancel_request", state="*")
async def farmer_cancel_request_button(
    callback: types.CallbackQuery, state: FSMContext
):
    """ĞšĞ½Ğ¾Ğ¿ĞºĞ° ĞĞ¢ĞœĞ•ĞĞ"""
    await state.finish()

    keyboard = InlineKeyboardMarkup()
    keyboard.add(
        InlineKeyboardButton("ğŸ  Ğ“Ğ›ĞĞ’ĞĞĞ• ĞœĞ•ĞĞ®", callback_data="farmer_main_menu")
    )

    await callback.message.edit_text(
        "âŒ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾.", reply_markup=keyboard
    )
    await callback.answer()


# Ğ“Ğ›ĞĞ’ĞĞĞ• ĞœĞ•ĞĞ® Ğ¤Ğ•Ğ ĞœĞ•Ğ Ğ (Ğ´Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº ĞµÑĞ»Ğ¸ ĞµĞ³Ğ¾ Ğ½ĞµÑ‚)
@dp.callback_query_handler(text="farmer_main_menu", state="*")
async def farmer_main_menu(callback: types.CallbackQuery, state: FSMContext):
    """Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°"""
    await state.finish()

    # âœ… Ğ‘Ğ•Ğ— ĞšĞĞĞŸĞĞš - Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ Ñ‚ĞµĞºÑÑ‚:
    await callback.message.edit_text(
        "ğŸ  <b>Ğ“Ğ›ĞĞ’ĞĞĞ• ĞœĞ•ĞĞ® Ğ¤Ğ•Ğ ĞœĞ•Ğ Ğ</b>", parse_mode="HTML"
    )
    await callback.answer()


# Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢ ĞĞ¢ĞšĞ›Ğ˜ĞšĞĞ•Ğ¢Ğ¡Ğ¯ ĞĞ Ğ—ĞĞ¯Ğ’ĞšĞ£ Ğ¤Ğ•Ğ ĞœĞ•Ğ Ğ
@dp.callback_query_handler(
    lambda c: c.data.startswith("logist_respond_farmer_request:"), state="*"
)
async def logist_respond_farmer_request(
    callback: types.CallbackQuery, state: FSMContext
):
    """Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ°ĞµÑ‚ÑÑ Ğ½Ğ° Ğ·Ğ°ÑĞ²ĞºÑƒ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°"""

    await state.finish()
    logist_id = callback.from_user.id

    try:
        request_id = int(callback.data.split(":")[-1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    if request_id not in farmer_logistics_requests:
        await callback.answer("âŒ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    request = farmer_logistics_requests[request_id]

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğµ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ°Ğ»ÑÑ Ğ»Ğ¸ ÑƒĞ¶Ğµ
    if any(o.get("logist_id") == logist_id for o in request.get("offers", [])):
        await callback.answer("âŒ Ğ’Ñ‹ ÑƒĞ¶Ğµ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ½ÑƒĞ»Ğ¸ÑÑŒ Ğ½Ğ° ÑÑ‚Ñƒ Ğ·Ğ°ÑĞ²ĞºÑƒ", show_alert=True)
        return

    # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¾Ñ‚ĞºĞ»Ğ¸Ğº
    request["offers"].append(
        {
            "logist_id": logist_id,
            "logist_name": users[logist_id].get("name", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾"),
            "logist_phone": users[logist_id].get("phone", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"),
            "responded_at": datetime.now().strftime("%d.%m.%Y %H:%M"),
            "created_at": datetime.now().strftime("%d.%m.%Y %H:%M"),
        }
    )

    request["offers_count"] = len(request["offers"])

    logging.info(f"âœ… Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ {logist_id} Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ½ÑƒĞ»ÑÑ Ğ½Ğ° Ğ·Ğ°ÑĞ²ĞºÑƒ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ° #{request_id}")

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°
    farmer_id = request["farmer_id"]

    try:
        msg = (
            f"ğŸ“ <b>Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢ ĞĞ¢ĞšĞ›Ğ˜ĞšĞĞ£Ğ›Ğ¡Ğ¯ ĞĞ Ğ’ĞĞ¨Ğ£ Ğ—ĞĞ¯Ğ’ĞšĞ£!</b>\n\n"
            f"ğŸ‘¤ <b>Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚:</b> {users[logist_id].get('name', 'ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾')}\n"
            f"â˜ï¸ <code>{users[logist_id].get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>\n"
            f"ğŸ“§ <code>{users[logist_id].get('email', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>\n\n"
            f"ğŸ“Š <b>Ğ—Ğ°ÑĞ²ĞºĞ° #{request_id}:</b>\n"
            f"ğŸŒ¾ {request['culture']} - {request['volume']} Ñ‚\n"
            f"ğŸ’° {request['price_per_ton']:,} â‚½/Ñ‚\n\n"
            f"Ğ’ÑĞµĞ³Ğ¾ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ¾Ğ²: {request['offers_count']}\n\n"
            f"Ğ¡Ğ²ÑĞ¶Ğ¸Ñ‚ĞµÑÑŒ Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ¼ Ğ´Ğ»Ñ Ğ¾Ğ±ÑÑƒĞ¶Ğ´ĞµĞ½Ğ¸Ñ Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹."
        )

        keyboard = InlineKeyboardMarkup()
        keyboard.add(
            InlineKeyboardButton(
                "ğŸ“‹ ĞŸĞ ĞĞ¡ĞœĞĞ¢Ğ Ğ•Ğ¢Ğ¬ Ğ—ĞĞ¯Ğ’ĞšĞ£",
                callback_data=f"farmer_request_details:{request_id}",
            )
        )

        await bot.send_message(farmer_id, msg, reply_markup=keyboard, parse_mode="HTML")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°: {e}")

    # ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ñƒ
    await callback.message.edit_text(
        f"âœ… <b>Ğ’Ğ« ĞĞ¢ĞšĞ›Ğ˜ĞšĞĞ£Ğ›Ğ˜Ğ¡Ğ¬!</b>\n\n"
        f"Ğ¤ĞµÑ€Ğ¼ĞµÑ€ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ğ» ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ.\n"
        f"Ğ¡Ğ²ÑĞ¶Ğ¸Ñ‚ĞµÑÑŒ Ñ Ğ½Ğ¸Ğ¼ Ğ´Ğ»Ñ Ğ¾Ğ±ÑÑƒĞ¶Ğ´ĞµĞ½Ğ¸Ñ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ğ¹ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸.",
        reply_markup=InlineKeyboardMarkup().add(
            InlineKeyboardButton("ğŸ  Ğ“Ğ›ĞĞ’ĞĞĞ• ĞœĞ•ĞĞ®", callback_data="logist_main_menu")
        ),
        parse_mode="HTML",
    )

    await callback.answer("âœ… ĞÑ‚ĞºĞ»Ğ¸Ğº Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½!", show_alert=True)


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 2. ĞŸĞ ĞĞ¡ĞœĞĞ¢Ğ  Ğ˜ Ğ’Ğ«Ğ‘ĞĞ  Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢Ğ
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


@dp.callback_query_handler(
    lambda c: c.data.startswith("select_logistics_for_pull:"), state="*"
)
async def show_logistics_for_pull(callback: types.CallbackQuery):
    """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ² Ğ´Ğ»Ñ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ°"""
    try:
        pull_id = parse_callback_id(callback.data)
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
        return

    if pull_id not in pulls.get("pulls", {}):
        await callback.answer("âŒ ĞŸÑƒĞ»Ğ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    pull = pulls["pulls"][pull_id]

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ñ‡Ñ‚Ğ¾ Ğ¿ÑƒĞ»Ğ» ÑĞ¾Ğ±Ñ€Ğ°Ğ½
    if pull.get("status") not in ["completed", "ÑĞ¾Ğ±Ñ€Ğ°Ğ½", "Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚"]:
        await callback.answer("âš ï¸ ĞŸÑƒĞ»Ğ» ĞµÑ‰Ñ‘ Ğ½Ğµ ÑĞ¾Ğ±Ñ€Ğ°Ğ½", show_alert=True)
        return

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²
    available_logistics = []

    for user_id, user_data in users.items():
        if user_data.get("role") == "logist":
            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ĞµÑÑ‚ÑŒ Ğ»Ğ¸ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°
            logistic_card = user_data.get("logistics_card", {})
            if logistic_card:
                available_logistics.append((user_id, logistic_card, user_data))

    if not available_logistics:
        await callback.answer(
            "âš ï¸ ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²\nĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ·Ğ¶Ğµ", show_alert=True
        )
        return

    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ ÑĞ¾ ÑĞ¿Ğ¸ÑĞºĞ¾Ğ¼
    text = f"ğŸšš <b>Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° Ğ´Ğ»Ñ Ğ¿ÑƒĞ»Ğ»Ğ° #{pull_id}</b>\n\n"
    text += (
        f"ğŸŒ¾ {pull.get('culture', 'ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°')} â€¢ {pull.get('target_volume', 0):.1f} Ñ‚\n"
    )
    text += f"ğŸš¢ ĞŸĞ¾Ñ€Ñ‚: {pull.get('port', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n\n"
    text += f"<b>Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²: {len(available_logistics)}</b>\n"

    keyboard = InlineKeyboardMarkup(row_width=1)

    for log_id, log_card, log_user in available_logistics:
        # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ ĞºÑ€Ğ°Ñ‚ĞºÑƒÑ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ
        company = log_card.get("company_name", "ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ")
        price = log_card.get("price_per_ton", 0)

        btn_text = f"ğŸšš {company} â€¢ {price:,} â‚½/Ñ‚"

        keyboard.add(
            InlineKeyboardButton(
                btn_text, callback_data=f"view_logistic_card:{pull_id}:{log_id}"
            )
        )

    keyboard.add(InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="cancel_action"))

    await callback.message.edit_text(text, parse_mode="HTML", reply_markup=keyboard)
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("view_logistic_card:"), state="*"
)
async def view_logistic_card_for_selection(callback: types.CallbackQuery):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° Ğ¸ Ğ²Ñ‹Ğ±Ğ¾Ñ€"""
    try:
        _, pull_id, log_id = callback.data.split(":")
        pull_id = int(pull_id)
        log_id = int(log_id)
    except (ValueError, IndexError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
        return

    if log_id not in users:
        await callback.answer("âŒ Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    log_user = users[log_id]
    log_card = log_user.get("logistics_card", {})

    if not log_card:
        await callback.answer("âŒ ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ Ğ´ĞµÑ‚Ğ°Ğ»ÑŒĞ½ÑƒÑ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ
    text = "ğŸšš <b>ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°</b>\n\n"
    text += f"ğŸ¢ <b>{log_card.get('company_name', 'ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ')}</b>\n"
    text += f"ğŸ“ ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚: {log_card.get('route', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
    text += f"ğŸ’° Ğ¢Ğ°Ñ€Ğ¸Ñ„: {log_card.get('price_per_ton', 0):,} â‚½/Ñ‚\n"
    text += f"ğŸš› Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚: {log_card.get('transport_type', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
    text += f"â± Ğ¡Ñ€Ğ¾Ğº Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸: {log_card.get('delivery_days', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')} Ğ´Ğ½ĞµĞ¹\n"

    if log_card.get("additional_info"):
        text += f"\nğŸ“ {log_card['additional_info']}\n"

    # ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹
    text += "\n<b>ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹:</b>\n"
    if log_user.get("username"):
        text += f"Telegram: @{log_user['username']}\n"
    if log_user.get("phone"):
        text += f"ğŸ“ {log_user['phone']}\n"

    keyboard = InlineKeyboardMarkup(row_width=1)
    keyboard.add(
        InlineKeyboardButton(
            "âœ… Ğ’Ñ‹Ğ±Ñ€Ğ°Ñ‚ÑŒ ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°",
            callback_data=f"confirm_select_logistic:{pull_id}:{log_id}",
        )
    )
    keyboard.add(
        InlineKeyboardButton(
            "â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğº ÑĞ¿Ğ¸ÑĞºÑƒ", callback_data=f"select_logistics_for_pull:{pull_id}"
        )
    )

    await callback.message.edit_text(text, parse_mode="HTML", reply_markup=keyboard)
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("confirm_select_logistic:"), state="*"
)
async def confirm_select_logistic(callback: types.CallbackQuery):
    """ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°"""
    try:
        _, pull_id, log_id = callback.data.split(":")
        pull_id = int(pull_id)
        log_id = int(log_id)
    except (ValueError, IndexError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
        return

    if pull_id not in pulls.get("pulls", {}):
        await callback.answer("âŒ ĞŸÑƒĞ»Ğ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    pull = pulls["pulls"][pull_id]

    # ĞĞ°Ğ·Ğ½Ğ°Ñ‡Ğ°ĞµĞ¼ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°
    pull["selected_logistic"] = log_id

    save_data()

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°
    log_user = users.get(log_id, {})
    try:
        await bot.send_message(
            log_id,
            f"ğŸ‰ <b>Ğ’Ñ‹ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½Ñ‹ Ğ´Ğ»Ñ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºĞ¸!</b>\n\n"
            f"ğŸ“¦ ĞŸÑƒĞ»Ğ» #{pull_id}\n"
            f"ğŸŒ¾ {pull.get('culture', 'ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°')} â€¢ {pull.get('target_volume', 0):.1f} Ñ‚\n"
            f"ğŸš¢ ĞŸĞ¾Ñ€Ñ‚: {pull.get('port', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n\n"
            f"Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€ ÑĞ²ÑĞ¶ĞµÑ‚ÑÑ Ñ Ğ²Ğ°Ğ¼Ğ¸ Ğ´Ğ»Ñ ÑƒÑ‚Ğ¾Ñ‡Ğ½ĞµĞ½Ğ¸Ñ Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹.",
            parse_mode="HTML",
        )
    except Exception as e:
        logging.error(f"ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° {log_id}: {e}")

    company_name = log_user.get("logistics_card", {}).get("company_name", "Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚")

    await callback.message.edit_text(
        f"âœ… <b>Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½!</b>\n\n"
        f"ğŸšš ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ: {company_name}\n"
        f"ğŸ“¦ Ğ”Ğ»Ñ Ğ¿ÑƒĞ»Ğ»Ğ° #{pull_id}\n\n"
        f"Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ğ» ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ.",
        parse_mode="HTML",
    )
    await callback.answer("âœ… Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½!")


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 3. ĞŸĞ ĞĞ¡ĞœĞĞ¢Ğ  Ğ˜ Ğ’Ğ«Ğ‘ĞĞ  Ğ­ĞšĞ¡ĞŸĞ•Ğ”Ğ˜Ğ¢ĞĞ Ğ
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


@dp.callback_query_handler(
    lambda c: c.data.startswith("select_expeditor_for_pull:"), state="*"
)
async def show_expeditors_for_pull(callback: types.CallbackQuery):
    """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ÑĞ¿Ğ¸ÑĞ¾Ğº ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ² Ğ´Ğ»Ñ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ°"""
    try:
        pull_id = parse_callback_id(callback.data)
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
        return

    if pull_id not in pulls.get("pulls", {}):
        await callback.answer("âŒ ĞŸÑƒĞ»Ğ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    pull = pulls["pulls"][pull_id]

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ñ‡Ñ‚Ğ¾ Ğ¿ÑƒĞ»Ğ» ÑĞ¾Ğ±Ñ€Ğ°Ğ½
    if pull.get("status") not in ["completed", "ÑĞ¾Ğ±Ñ€Ğ°Ğ½", "Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚"]:
        await callback.answer("âš ï¸ ĞŸÑƒĞ»Ğ» ĞµÑ‰Ñ‘ Ğ½Ğµ ÑĞ¾Ğ±Ñ€Ğ°Ğ½", show_alert=True)
        return

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ÑĞ¿Ğ¸ÑĞ¾Ğº ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²
    available_expeditors = []

    for user_id, user_data in users.items():
        if user_data.get("role") == "expeditor":
            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ĞµÑÑ‚ÑŒ Ğ»Ğ¸ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ°
            expeditor_card = user_data.get("expeditor_card", {})
            if expeditor_card:
                available_expeditors.append((user_id, expeditor_card, user_data))

    if not available_expeditors:
        await callback.answer(
            "âš ï¸ ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²\nĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ·Ğ¶Ğµ", show_alert=True
        )
        return

    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ
    text = f"ğŸ“„ <b>Ğ’Ñ‹Ğ±Ğ¾Ñ€ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ° Ğ´Ğ»Ñ Ğ¿ÑƒĞ»Ğ»Ğ° #{pull_id}</b>\n\n"
    text += (
        f"ğŸŒ¾ {pull.get('culture', 'ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°')} â€¢ {pull.get('target_volume', 0):.1f} Ñ‚\n"
    )
    text += f"ğŸš¢ ĞŸĞ¾Ñ€Ñ‚: {pull.get('port', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n\n"
    text += f"<b>Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²: {len(available_expeditors)}</b>\n"

    keyboard = InlineKeyboardMarkup(row_width=1)

    for exp_id, exp_card, exp_user in available_expeditors:
        company = exp_card.get("company_name", "Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€")
        price = exp_card.get("customs_fee", 0)

        btn_text = f"ğŸ“„ {company} â€¢ {price:,} â‚½"

        keyboard.add(
            InlineKeyboardButton(
                btn_text, callback_data=f"view_expeditor_card:{pull_id}:{exp_id}"
            )
        )

    keyboard.add(InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="cancel_action"))

    await callback.message.edit_text(text, parse_mode="HTML", reply_markup=keyboard)
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("view_expeditor_card:"), state="*"
)
async def view_expeditor_card_for_selection(callback: types.CallbackQuery):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ° Ğ¸ Ğ²Ñ‹Ğ±Ğ¾Ñ€"""
    try:
        _, pull_id, exp_id = callback.data.split(":")
        pull_id = int(pull_id)
        exp_id = int(exp_id)
    except (ValueError, IndexError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
        return

    # Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: Ğ‘ĞµÑ€Ñ‘Ğ¼ Ğ¸Ğ· expeditor_cards, Ğ° Ğ½Ğµ Ğ¸Ğ· users
    if exp_id not in expeditor_cards:
        await callback.answer("âŒ ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    card = expeditor_cards[exp_id]
    exp_user = users.get(exp_id, {})

    # Ğ˜Ğ·Ğ²Ğ»ĞµĞºĞ°ĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
    transport = card.get("transport_type", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
    capacity = card.get("capacity", 0)
    regions = card.get("regions", [])
    price = card.get("price_per_km", 0)
    description = card.get("description", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾")

    # Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹
    if isinstance(regions, list):
        regions_text = ", ".join(regions) if regions else "Ğ ĞµĞ³Ğ¸Ğ¾Ğ½ Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"
    else:
        regions_text = str(regions)

    # Ğ­Ğ¼Ğ¾Ğ´Ğ·Ğ¸ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°
    transport_emoji = TRANSPORT_TYPES.get(transport, "ğŸš›")

    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ
    text = (
        f"ğŸ’³ <b>ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°</b>\n\n"
        f"{transport_emoji} <b>Ğ¢Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°:</b> {transport}\n"
        f"ğŸ“¦ <b>Ğ“Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ:</b> {capacity} Ñ‚\n"
        f"ğŸ“ <b>Ğ ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹:</b> {regions_text}\n"
        f"ğŸ’° <b>Ğ¦ĞµĞ½Ğ° Ğ·Ğ° ĞºĞ¼:</b> {price:.2f} â‚½/ĞºĞ¼\n"
        f"ğŸ“ <b>ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ:</b>\n{description}\n\n"
    )

    # ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹
    text += "<b>ğŸ‘¤ ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹:</b>\n"
    text += f"Ğ˜Ğ¼Ñ: {card.get('user_name', exp_user.get('full_name', 'N/A'))}\n"
    text += f"ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ: {card.get('company', exp_user.get('company_name', 'N/A'))}\n"

    if exp_user.get("username"):
        text += f"Telegram: @{exp_user['username']}\n"
    if card.get("phone") or exp_user.get("phone"):
        phone = card.get("phone") or exp_user.get("phone")
        text += f"ğŸ“ {phone}\n"
    if card.get("email") or exp_user.get("email"):
        email = card.get("email") or exp_user.get("email")
        text += f"âœ‰ï¸ {email}\n"

    text += f"\nğŸ“… Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ°: {card.get('created_at', 'Ğ/Ğ”')}\n"
    text += f"ğŸ‘ ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ¾Ğ²: {card.get('views', 0)}"

    keyboard = InlineKeyboardMarkup(row_width=1)
    keyboard.add(
        InlineKeyboardButton(
            "âœ… Ğ’Ñ‹Ğ±Ñ€Ğ°Ñ‚ÑŒ ÑÑ‚Ğ¾Ğ³Ğ¾ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°",
            callback_data=f"confirm_select_expeditor:{pull_id}:{exp_id}",
        )
    )
    keyboard.add(
        InlineKeyboardButton(
            "â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğº ÑĞ¿Ğ¸ÑĞºÑƒ", callback_data=f"select_expeditor_for_pull:{pull_id}"
        )
    )

    await callback.message.edit_text(text, parse_mode="HTML", reply_markup=keyboard)
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("confirm_select_expeditor:"), state="*"
)
async def confirm_select_expeditor(callback: types.CallbackQuery):
    """ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°"""
    try:
        _, pull_id, exp_id = callback.data.split(":")
        pull_id = int(pull_id)
        exp_id = int(exp_id)
    except (ValueError, IndexError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
        return

    if pull_id not in pulls.get("pulls", {}):
        await callback.answer("âŒ ĞŸÑƒĞ»Ğ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    pull = pulls["pulls"][pull_id]

    # ĞĞ°Ğ·Ğ½Ğ°Ñ‡Ğ°ĞµĞ¼ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°
    pull["selected_expeditor"] = exp_id

    save_data()

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°
    exp_user = users.get(exp_id, {})
    try:
        await bot.send_message(
            exp_id,
            f"ğŸ‰ <b>Ğ’Ñ‹ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½Ñ‹ Ğ´Ğ»Ñ Ğ¾Ñ„Ğ¾Ñ€Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ”Ğ¢!</b>\n\n"
            f"ğŸ“¦ ĞŸÑƒĞ»Ğ» #{pull_id}\n"
            f"ğŸŒ¾ {pull.get('culture', 'ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°')} â€¢ {pull.get('target_volume', 0):.1f} Ñ‚\n"
            f"ğŸš¢ ĞŸĞ¾Ñ€Ñ‚: {pull.get('port', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n\n"
            f"Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€ ÑĞ²ÑĞ¶ĞµÑ‚ÑÑ Ñ Ğ²Ğ°Ğ¼Ğ¸ Ğ´Ğ»Ñ ÑƒÑ‚Ğ¾Ñ‡Ğ½ĞµĞ½Ğ¸Ñ Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹.",
            parse_mode="HTML",
        )
    except Exception as e:
        logging.error(f"ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ° {exp_id}: {e}")

    company_name = exp_user.get("expeditor_card", {}).get("company_name", "Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€")

    await callback.message.edit_text(
        f"âœ… <b>Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½!</b>\n\n"
        f"ğŸ“„ ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ: {company_name}\n"
        f"ğŸ“¦ Ğ”Ğ»Ñ Ğ¿ÑƒĞ»Ğ»Ğ° #{pull_id}\n\n"
        f"Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ğ» ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ.",
        parse_mode="HTML",
    )
    await callback.answer("âœ… Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½!")


async def select_search_criteria(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° ĞºÑ€Ğ¸Ñ‚ĞµÑ€Ğ¸ĞµĞ² Ğ¿Ğ¾Ğ¸ÑĞºĞ°"""
    search_type = callback.data.split(":", 1)[1]

    await state.update_data(search_type=search_type)

    if search_type == "culture":
        await callback.message.edit_text(
            "ğŸ” <b>ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğµ</b>\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñƒ:",
            reply_markup=culture_keyboard(),
        )
        await SearchByCulture.waiting_culture.set()

    elif search_type == "region":
        await callback.message.edit_text(
            "ğŸ” <b>ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñƒ</b>\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½:",
            reply_markup=region_keyboard(),
        )
        await SearchBatchesStatesGroup.enter_region.set()

    elif search_type == "volume":
        await callback.message.edit_text(
            "ğŸ” <b>ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾ Ğ¾Ğ±ÑŠÑ‘Ğ¼Ñƒ</b>\n\n" "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¾Ğ±ÑŠÑ‘Ğ¼ (Ğ² Ñ‚Ğ¾Ğ½Ğ½Ğ°Ñ…):"
        )
        await SearchBatchesStatesGroup.enter_min_volume.set()

    elif search_type == "price":
        await callback.message.edit_text(
            "ğŸ” <b>ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾ Ñ†ĞµĞ½Ğµ</b>\n\n" "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½ÑƒÑ Ñ†ĞµĞ½Ñƒ (â‚½/Ñ‚Ğ¾Ğ½Ğ½Ğ°):"
        )
        await SearchBatchesStatesGroup.enter_min_price.set()

    elif search_type == "quality":
        await callback.message.edit_text(
            "ğŸ” <b>ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾ ĞºĞ»Ğ°ÑÑÑƒ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ°</b>\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºĞ»Ğ°ÑÑ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ°:",
            reply_markup=quality_class_keyboard(),
        )
        await SearchBatchesStatesGroup.enter_quality_class.set()

    elif search_type == "storage":
        await callback.message.edit_text(
            "ğŸ” <b>ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾ Ñ‚Ğ¸Ğ¿Ñƒ Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ</b>\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ‚Ğ¸Ğ¿ Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ:",
            reply_markup=storage_type_keyboard(),
        )
        await SearchBatchesStatesGroup.enter_storage_type.set()

    elif search_type == "all":
        await callback.message.edit_text(
            "ğŸ” <b>ĞšĞ¾Ğ¼Ğ¿Ğ»ĞµĞºÑĞ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ¸ÑĞº</b>\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñƒ:",
            reply_markup=culture_keyboard(),
        )
        await SearchByCulture.waiting_culture.set()

    elif search_type == "active":
        await perform_search(callback.message, {"status": "ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ°"})

    await callback.answer()

    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ° Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ¸ÑĞºĞµ"""
    region = callback.data.split(":", 1)[1]

    data = await state.get_data()
    search_type = data.get("search_type")

    if search_type == "region":
        await perform_search(callback.message, {"region": region})
        await state.finish()
    else:
        await state.update_data(region=region)
        await callback.message.edit_text(
            "ğŸ” <b>ĞšĞ¾Ğ¼Ğ¿Ğ»ĞµĞºÑĞ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ¸ÑĞº</b>\n\n" "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¾Ğ±ÑŠÑ‘Ğ¼ (Ğ² Ñ‚Ğ¾Ğ½Ğ½Ğ°Ñ…):"
        )
        await SearchBatchesStatesGroup.enter_min_volume.set()

    await callback.answer()


@dp.message_handler(state=SearchBatchesStatesGroup.enter_min_volume)
async def search_min_volume(message: types.Message, state: FSMContext):
    """Ğ’Ğ²Ğ¾Ğ´ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¾Ğ±ÑŠÑ‘Ğ¼Ğ° Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ¸ÑĞºĞµ"""
    try:
        min_volume = float(message.text.strip().replace(",", "."))
        if min_volume < 0:
            raise ValueError

        data = await state.get_data()

        if data.get("search_type") == "volume":
            await perform_search(message, {"min_volume": min_volume})
            await state.finish()
        else:
            await state.update_data(min_volume=min_volume)
            await message.answer(
                "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¾Ğ±ÑŠÑ‘Ğ¼ (Ğ² Ñ‚Ğ¾Ğ½Ğ½Ğ°Ñ…, Ğ¸Ğ»Ğ¸ 0 ĞµÑĞ»Ğ¸ Ğ½Ğµ Ğ²Ğ°Ğ¶Ğ½Ğ¾):"
            )
            await SearchBatchesStatesGroup.enter_max_volume.set()

    except ValueError:
        await message.answer("âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾:")


@dp.message_handler(state=SearchBatchesStatesGroup.enter_max_volume)
async def search_max_volume(message: types.Message, state: FSMContext):
    """Ğ’Ğ²Ğ¾Ğ´ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¾Ğ±ÑŠÑ‘Ğ¼Ğ° Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ¸ÑĞºĞµ"""
    try:
        max_volume_text = message.text.strip()
        max_volume = (
            float(max_volume_text.replace(",", ".")) if max_volume_text != "0" else 0
        )

        if max_volume < 0:
            raise ValueError

        await state.update_data(max_volume=max_volume)
        await message.answer("Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½ÑƒÑ Ñ†ĞµĞ½Ñƒ (â‚½/Ñ‚Ğ¾Ğ½Ğ½Ğ°):")
        await SearchBatchesStatesGroup.enter_min_price.set()

    except ValueError:
        await message.answer("âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾:")


@dp.message_handler(state=SearchBatchesStatesGroup.enter_min_price)
async def search_min_price(message: types.Message, state: FSMContext):
    """Ğ’Ğ²Ğ¾Ğ´ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğ¹ Ñ†ĞµĞ½Ñ‹ Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ¸ÑĞºĞµ"""
    try:
        min_price = float(message.text.strip().replace(",", "."))
        if min_price < 0:
            raise ValueError

        await state.update_data(min_price=min_price)
        await message.answer(
            "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½ÑƒÑ Ñ†ĞµĞ½Ñƒ (â‚½/Ñ‚Ğ¾Ğ½Ğ½Ğ°, Ğ¸Ğ»Ğ¸ 0 ĞµÑĞ»Ğ¸ Ğ½Ğµ Ğ²Ğ°Ğ¶Ğ½Ğ¾):"
        )
        await SearchBatchesStatesGroup.enter_max_price.set()

    except ValueError:
        await message.answer("âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾:")


@dp.message_handler(state=SearchBatchesStatesGroup.enter_max_price)
async def search_max_price(message: types.Message, state: FSMContext):
    """Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğµ ĞºĞ¾Ğ¼Ğ¿Ğ»ĞµĞºÑĞ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ¸ÑĞºĞ°"""
    try:
        max_price_text = message.text.strip()
        max_price = (
            float(max_price_text.replace(",", ".")) if max_price_text != "0" else 0
        )

        if max_price < 0:
            raise ValueError

        data = await state.get_data()
        search_params = {
            "culture": data.get("culture"),
            "region": data.get("region"),
            "min_volume": data.get("min_volume", 0),
            "max_volume": data.get("max_volume", 0),
            "min_price": data.get("min_price", 0),
            "max_price": max_price,
            "status": "ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ°",
        }

        await perform_search(message, search_params)
        await state.finish()

    except ValueError:
        await message.answer("âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾:")


@dp.callback_query_handler(
    lambda c: c.data.startswith("quality:"),
    state=SearchBatchesStatesGroup.enter_quality_class,
)
async def search_by_quality(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° ĞºĞ»Ğ°ÑÑĞ° ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ° Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ¸ÑĞºĞµ"""
    quality_class = callback.data.split(":", 1)[1]

    await perform_search(callback.message, {"quality_class": quality_class})
    await state.finish()
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("storage:"),
    state=SearchBatchesStatesGroup.enter_storage_type,
)
async def search_by_storage(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ñ‚Ğ¸Ğ¿Ğ° Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ¸ÑĞºĞµ"""
    storage_type = callback.data.split(":", 1)[1]

    await perform_search(callback.message, {"storage_type": storage_type})
    await state.finish()
    await callback.answer()


async def perform_search(message, search_params):
    """Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ¸ÑĞºĞ° Ğ¿Ğ¾ Ğ·Ğ°Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ°Ğ¼"""
    found_batches = []
    for user_batches in batches.values():
        for batch in user_batches:
            if matches_search_criteria(batch, search_params):
                found_batches.append(batch)

    if not found_batches:
        await message.answer(
            "ğŸ” <b>Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹ Ğ¿Ğ¾Ğ¸ÑĞºĞ°</b>\n\n"
            "ĞŸĞ¾ Ğ²Ğ°ÑˆĞµĞ¼Ñƒ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑÑƒ Ğ½Ğ¸Ñ‡ĞµĞ³Ğ¾ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾.\n\n"
            "ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ĞºÑ€Ğ¸Ñ‚ĞµÑ€Ğ¸Ğ¸ Ğ¿Ğ¾Ğ¸ÑĞºĞ°.",
            parse_mode="HTML",
        )
        return
    found_batches.sort(key=lambda x: x["price"])

    text = "ğŸ” <b>Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹ Ğ¿Ğ¾Ğ¸ÑĞºĞ°</b>\n\n"
    text += f"ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹: {len(found_batches)}\n\n"

    for i, batch in enumerate(found_batches[:10], 1):  # ĞĞ³Ñ€Ğ°Ğ½Ğ¸Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ¿Ğ¾ĞºĞ°Ğ·
        text += f"{i}. <b>ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ #{batch['id']}</b>\n"
        text += f"   ğŸŒ¾ {batch['culture']} â€¢ {batch['volume']} Ñ‚\n"
        text += f"   ğŸ’° {batch['price']:,.0f} â‚½/Ñ‚\n"
        text += f"   ğŸ“ {batch.get('region', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
        text += f"   â­ {batch.get('quality_class', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n"
        text += f"   ğŸ‘¤ {batch['farmer_name']}\n\n"

    if len(found_batches) > 10:
        text += f"<i>... Ğ¸ ĞµÑ‰Ñ‘ {len(found_batches) - 10} Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹</i>\n\n"

    text += "ğŸ’¡ <b>Ğ”Ğ»Ñ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ° Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹ ÑĞ²ÑĞ¶Ğ¸Ñ‚ĞµÑÑŒ Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ¼.</b>"

    await message.answer(text, parse_mode="HTML")


def matches_search_criteria(batch, search_params):
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑĞ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²Ğ¸Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ ĞºÑ€Ğ¸Ñ‚ĞµÑ€Ğ¸ÑĞ¼ Ğ¿Ğ¾Ğ¸ÑĞºĞ°"""
    if batch.get("status") != "ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ°":
        return False
    if search_params.get("culture") and batch["culture"] != search_params["culture"]:
        return False
    if (
        search_params.get("region")
        and batch.get("region", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½") != search_params["region"]
    ):
        return False
    if (
        search_params.get("min_volume", 0) > 0
        and batch["volume"] < search_params["min_volume"]
    ):
        return False
    if (
        search_params.get("max_volume", 0) > 0
        and search_params["max_volume"] < batch["volume"]
    ):
        return False
    if (
        search_params.get("min_price", 0) > 0
        and batch["price"] < search_params["min_price"]
    ):
        return False
    if (
        search_params.get("max_price", 0) > 0
        and search_params["max_price"] < batch["price"]
    ):
        return False
    if search_params.get("quality_class") and batch.get(
        "quality_class"
    ) != search_params.get("quality_class"):
        return False
    if search_params.get("storage_type") and batch.get(
        "storage_type"
    ) != search_params.get("storage_type"):
        return False

    return True


@dp.callback_query_handler(lambda c: c.data.startswith("attach_files:"), state="*")
async def attach_files_start(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ğ»Ğ¾ Ğ¿Ñ€Ğ¸ĞºÑ€ĞµĞ¿Ğ»ĞµĞ½Ğ¸Ñ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² Ğº Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""
    batch_id = parse_callback_id(callback.data)
    await state.update_data(attach_batch_id=batch_id)

    await callback.message.edit_text(
        f"ğŸ“ <b>ĞŸÑ€Ğ¸ĞºÑ€ĞµĞ¿Ğ»ĞµĞ½Ğ¸Ğµ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² Ğº Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ #{batch_id}</b>\n\n"
        "ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ Ñ„Ğ°Ğ¹Ğ»Ñ‹ (Ñ„Ğ¾Ñ‚Ğ¾, PDF, Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ñ‹):\n"
        "â€¢ Ğ¡ĞµÑ€Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ‚Ñ‹ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ°\n"
        "â€¢ Ğ¤Ğ¾Ñ‚Ğ¾ Ğ·ĞµÑ€Ğ½Ğ°\n"
        "â€¢ Ğ”Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ñ‹ Ğ½Ğ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ\n"
        "â€¢ Ğ”Ñ€ÑƒĞ³Ğ¸Ğµ relevant Ñ„Ğ°Ğ¹Ğ»Ñ‹\n\n"
        "ĞšĞ¾Ğ³Ğ´Ğ° Ğ·Ğ°ĞºĞ¾Ğ½Ñ‡Ğ¸Ñ‚Ğµ, Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ /done",
        parse_mode="HTML",
    )
    await AttachFilesStatesGroup.upload_files.set()
    await callback.answer()


@dp.message_handler(
    content_types=["photo", "document"], state=AttachFilesStatesGroup.upload_files
)
async def attach_files_upload(message: types.Message, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²"""
    data = await state.get_data()
    batch_id = data.get("attach_batch_id")
    user_id = message.from_user.id
    batch = None
    farmer_id = None

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ•: Ğ˜Ñ‰ĞµĞ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ñƒ Ğ’Ğ¡Ğ•Ğ¥ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹
    for uid, user_batches in batches.items():
        for b in user_batches:
            if b["id"] == batch_id:
                batch = b
                farmer_id = uid
                break
        if batch:
            break

    if not batch:
        await message.answer("âŒ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°")
        await state.finish()
        return
    if "files" not in batch:
        batch["files"] = []
    file_info = None
    if message.photo:
        file_info = {
            "type": "photo",
            "file_id": message.photo[-1].file_id,
            "caption": message.caption or "",
            "uploaded_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        }
    elif message.document:
        file_info = {
            "type": "document",
            "file_id": message.document.file_id,
            "file_name": message.document.file_name,
            "mime_type": message.document.mime_type,
            "caption": message.caption or "",
            "uploaded_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        }

    if file_info:
        batch["files"].append(file_info)
        save_batches_to_pickle()
        if gs and gs.spreadsheet:
            gs.update_batch_in_sheets(batch)

        await message.answer(
            f"âœ… Ğ¤Ğ°Ğ¹Ğ» Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½ ({len(batch['files'])} Ğ²ÑĞµĞ³Ğ¾)\n"
            "ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ ĞµÑ‰Ñ‘ Ğ¸Ğ»Ğ¸ Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ /done Ğ´Ğ»Ñ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ"
        )


@dp.message_handler(commands=["done"], state=AttachFilesStatesGroup.upload_files)
async def attach_files_done(message: types.Message, state: FSMContext):
    """Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¸ĞºÑ€ĞµĞ¿Ğ»ĞµĞ½Ğ¸Ñ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²"""
    data = await state.get_data()
    batch_id = data.get("attach_batch_id")
    user_id = message.from_user.id

    batch = None
    farmer_id = None

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ•: Ğ˜Ñ‰ĞµĞ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ñƒ Ğ’Ğ¡Ğ•Ğ¥ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹
    for uid, user_batches in batches.items():
        for b in user_batches:
            if b["id"] == batch_id:
                batch = b
                farmer_id = uid
                break
        if batch:
            break

    await state.finish()

    files_count = len(batch.get("files", [])) if batch else 0

    role = users[user_id].get("role")
    keyboard = get_role_keyboard(role)

    await message.answer(
        f"âœ… <b>Ğ¤Ğ°Ğ¹Ğ»Ñ‹ Ğ¿Ñ€Ğ¸ĞºÑ€ĞµĞ¿Ğ»ĞµĞ½Ñ‹!</b>\n\n"
        f"ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ #{batch_id}\n"
        f"Ğ’ÑĞµĞ³Ğ¾ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²: {files_count}",
        reply_markup=keyboard,
        parse_mode="HTML",
    )
    await view_batch_details_direct(message, batch_id, user_id)


@dp.callback_query_handler(lambda c: c.data.startswith("view_files:"), state="*")
async def view_batch_files(callback: types.CallbackQuery):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""
    batch_id = parse_callback_id(callback.data)
    user_id = callback.from_user.id
    batch = None
    farmer_id = None

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ•: Ğ˜Ñ‰ĞµĞ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ñƒ Ğ’Ğ¡Ğ•Ğ¥ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹
    for uid, user_batches in batches.items():
        for b in user_batches:
            if b["id"] == batch_id:
                batch = b
                farmer_id = uid
                break
        if batch:
            break

    if not batch or not batch.get("files"):
        await callback.answer("ğŸ“ Ğ¤Ğ°Ğ¹Ğ»Ğ¾Ğ² Ğ½ĞµÑ‚", show_alert=True)
        return

    await callback.message.answer(
        f"ğŸ“ <b>Ğ¤Ğ°Ğ¹Ğ»Ñ‹ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ #{batch_id}</b>\n\n"
        f"Ğ’ÑĞµĞ³Ğ¾ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²: {len(batch['files'])}",
        parse_mode="HTML",
    )
    for file_info in batch["files"]:
        try:
            if file_info["type"] == "photo":
                await callback.message.answer_photo(
                    file_info["file_id"],
                    caption=file_info.get("caption", "")
                    or f"ğŸ“· Ğ¤Ğ¾Ñ‚Ğ¾ Ğ´Ğ»Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ #{batch_id}",
                )
            elif file_info["type"] == "document":
                caption = f"ğŸ“„ {file_info.get('file_name', 'Ğ”Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚')}"
                if file_info.get("caption"):
                    caption += f"\n{file_info['caption']}"

                await callback.message.answer_document(
                    file_info["file_id"], caption=caption
                )
        except Exception as e:
            logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ Ñ„Ğ°Ğ¹Ğ»Ğ°: {e}")
            await callback.message.answer(
                f"âŒ ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ»: {file_info.get('file_name', 'ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ñ‹Ğ¹ Ñ„Ğ°Ğ¹Ğ»')}"
            )

    await callback.answer()


@dp.callback_query_handler(lambda c: c.data == "back_to_pulls", state="*")
async def back_to_pulls(callback: types.CallbackQuery):
    """âœ… Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğº ÑĞ¿Ğ¸ÑĞºÑƒ Ğ¿ÑƒĞ»Ğ¾Ğ² (Ğ£ĞĞ˜Ğ’Ğ•Ğ Ğ¡ĞĞ›Ğ¬ĞĞ«Ğ™ Ğ´Ğ»Ñ Ğ²ÑĞµÑ… Ñ€Ğ¾Ğ»ĞµĞ¹)"""

    user_id = callback.from_user.id

    try:
        # âœ… ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ĞµÑÑ‚ÑŒ Ğ»Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ² Ğ±Ğ°Ğ·Ğµ
        if user_id not in users:
            logging.warning(f"âš ï¸ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ {user_id} Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ Ğ² Ğ±Ğ°Ğ·Ğµ")
            await callback.answer("âŒ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½", show_alert=True)
            return

        user_role = users[user_id].get("role", "unknown")
        logging.info(
            f"ğŸ“‹ Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğº ÑĞ¿Ğ¸ÑĞºĞ°Ğ¼. ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ {user_id} Ñ Ñ€Ğ¾Ğ»ÑŒÑ: {user_role}"
        )

        # âœ… Ğ­ĞšĞ¡ĞŸĞĞ Ğ¢Ğ•Ğ  - Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ ĞµĞ³Ğ¾ Ğ¿ÑƒĞ»Ñ‹ Ğ¡ ĞšĞĞĞŸĞšĞĞœĞ˜
        if user_role == "exporter":
            all_pulls = pulls.get("pulls", {})
            my_pulls = {
                pid: pull
                for pid, pull in all_pulls.items()
                if isinstance(pull, dict) and pull.get("exporter_id") == user_id
            }

            if not my_pulls:
                await callback.message.edit_text(
                    "ğŸ“‹ <b>ĞœĞ¾Ğ¸ Ğ¿ÑƒĞ»Ñ‹</b>\n\n"
                    "Ğ£ Ğ²Ğ°Ñ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ¿ÑƒĞ»Ğ¾Ğ².\n\n"
                    "ğŸ’¡ <i>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¹ Ğ¿ÑƒĞ» Ñ‡ĞµÑ€ĞµĞ· Ğ¼ĞµĞ½Ñ</i>",
                    parse_mode="HTML",
                )
                await callback.answer()
                logging.info(f"âœ… Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€ {user_id}: Ğ¿ÑƒĞ»Ğ¾Ğ² Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾")
                return

            logging.info(f"âœ… Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€ {user_id}: Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¾ {len(my_pulls)} Ğ¿ÑƒĞ»Ğ¾Ğ²")

            culture_emoji = {
                "Ğ¿ÑˆĞµĞ½Ğ¸Ñ†Ğ°": "ğŸŒ¾",
                "ÑÑ‡Ğ¼ĞµĞ½ÑŒ": "ğŸŒ¾",
                "ĞºÑƒĞºÑƒÑ€ÑƒĞ·Ğ°": "ğŸŒ½",
                "Ğ¿Ğ¾Ğ´ÑĞ¾Ğ»Ğ½ĞµÑ‡Ğ½Ğ¸Ğº": "ğŸŒ»",
                "ÑĞ¾Ñ": "ğŸ«˜",
                "Ñ€Ğ°Ğ¿Ñ": "ğŸŒ¿",
            }

            # Ğ¡ĞĞ—Ğ”ĞĞĞœ ĞšĞ›ĞĞ’Ğ˜ĞĞ¢Ğ£Ğ Ğ£ Ğ¡ ĞšĞĞĞŸĞšĞĞœĞ˜
            keyboard = InlineKeyboardMarkup(row_width=1)

            for pull_id, pull in my_pulls.items():
                culture = pull.get("culture", "").lower()
                culture_icon = culture_emoji.get(culture, "ğŸŒ¾")
                status = pull.get("status", "active").lower()
                status_icon = status_map.get(status, "âšª").split()[0]
                current = pull.get("current_volume", 0)
                target = pull.get("target_volume", 1)
                progress = (current / target * 100) if target > 0 else 0

                # Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ ĞºĞ°Ğº Ğ² Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¼ Ğ¼ĞµĞ½Ñ
                button_text = f"{status_icon} {culture_icon} {pull.get('culture', '?')} ({progress:.0f}%)"

                # Ğ”ĞĞ‘ĞĞ’Ğ›Ğ¯Ğ•Ğœ ĞšĞĞĞŸĞšĞ£
                keyboard.add(
                    InlineKeyboardButton(
                        button_text, callback_data=f"view_pull:{pull_id}"
                    )
                )

            # ĞĞ¢ĞŸĞ ĞĞ’Ğ›Ğ¯Ğ•Ğœ Ğ¡ ĞšĞ›ĞĞ’Ğ˜ĞĞ¢Ğ£Ğ ĞĞ™
            await callback.message.edit_text(
                f"ğŸ“‹ <b>ĞœĞ¾Ğ¸ Ğ¿ÑƒĞ»Ñ‹</b> ({len(my_pulls)} ÑˆÑ‚.)\n\n"
                "<i>Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿ÑƒĞ» Ğ´Ğ»Ñ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ:</i>",
                reply_markup=keyboard,
                parse_mode="HTML",
            )
            await callback.answer()
            logging.info(
                f"âœ… Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€ {user_id}: Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ Ğ¼ĞµĞ½Ñ Ñ {len(my_pulls)} ĞºĞ½Ğ¾Ğ¿ĞºĞ°Ğ¼Ğ¸"
            )

        # âœ… Ğ¤Ğ•Ğ ĞœĞ•Ğ  - Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ Ğ¿ÑƒĞ»Ñ‹
        elif user_role == "farmer":
            all_pulls = pulls.get("pulls", {})
            open_pulls = [
                (k, v)
                for k, v in all_pulls.items()
                if isinstance(v, dict)
                and v.get("status") in ["active", "open", "ĞÑ‚ĞºÑ€Ñ‹Ñ‚"]
            ]

            if not open_pulls:
                await callback.message.edit_text(
                    "ğŸ¯ <b>Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ¿ÑƒĞ»Ñ‹</b>\n\n"
                    "Ğ¡ĞµĞ¹Ñ‡Ğ°Ñ Ğ½ĞµÑ‚ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… Ğ¿ÑƒĞ»Ğ¾Ğ² Ğ´Ğ»Ñ ÑƒÑ‡Ğ°ÑÑ‚Ğ¸Ñ.",
                    reply_markup=InlineKeyboardMarkup().add(
                        InlineKeyboardButton(
                            "ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="back_to_pulls"
                        )
                    ),
                    parse_mode="HTML",
                )
                await callback.answer()
                logging.info(f"âœ… Ğ¤ĞµÑ€Ğ¼ĞµÑ€ {user_id}: Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… Ğ¿ÑƒĞ»Ğ¾Ğ² Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾")
                return

            keyboard = InlineKeyboardMarkup(row_width=1)

            for pull_id, pull in open_pulls[:10]:
                progress = (
                    pull.get("current_volume", 0) / pull.get("target_volume", 1) * 100
                    if pull.get("target_volume", 1) > 0
                    else 0
                )

                button_text = (
                    f"ğŸŒ¾ {pull.get('culture', '?')} - "
                    f"{pull.get('current_volume', 0):.0f}/{pull.get('target_volume', 0):.0f} Ñ‚ "
                    f"({progress:.0f}%)"
                )
                keyboard.add(
                    InlineKeyboardButton(
                        button_text, callback_data=f"view_pull:{pull_id}"
                    )
                )

            await callback.message.edit_text(
                f"ğŸ¯ <b>Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ¿ÑƒĞ»Ñ‹</b> ({len(open_pulls)} ÑˆÑ‚.)\n\n"
                "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿ÑƒĞ» Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ° Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹:",
                reply_markup=keyboard,
                parse_mode="HTML",
            )
            await callback.answer()
            logging.info(
                f"âœ… Ğ¤ĞµÑ€Ğ¼ĞµÑ€ {user_id}: Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¾ {len(open_pulls)} Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… Ğ¿ÑƒĞ»Ğ¾Ğ²"
            )

        # âœ… Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢ Ğ¸ Ğ´Ñ€. - Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ² Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ
        else:
            await callback.message.edit_text(
                "ğŸ  <b>Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ</b>\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ:",
                reply_markup=InlineKeyboardMarkup().add(
                    InlineKeyboardButton("ğŸ¯ ĞŸÑƒĞ»Ñ‹", callback_data="view_pools")
                ),
                parse_mode="HTML",
            )
            await callback.answer()
            logging.info(
                f"âœ… ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ {user_id} ({user_role}): Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğ² Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ"
            )

    except KeyError as e:
        logging.error(f"âŒ KeyError: {e}")
        await callback.message.reply("âŒ <b>ĞÑˆĞ¸Ğ±ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…</b>", parse_mode="HTML")
    except Exception as e:
        logging.error(f"âŒ ĞšÑ€Ğ¸Ñ‚Ğ¸Ñ‡Ğ½Ğ°Ñ Ğ¾ÑˆĞ¸Ğ±ĞºĞ° Ğ² back_to_pulls: {e}", exc_info=True)
        await callback.message.reply(
            "âŒ <b>ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹</b>\nĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ·Ğ¶Ğµ",
            parse_mode="HTML",
        )


@dp.message_handler(commands=["stats"], state="*")
@dp.message_handler(commands=["help"], state="*")
async def cmd_help(message: types.Message, state: FSMContext):
    """Ğ¡Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ¿Ğ¾ Ğ±Ğ¾Ñ‚Ñƒ"""
    await state.finish()

    user_id = message.from_user.id
    if user_id not in users:
        await message.answer(
            "â„¹ï¸ <b>Ğ¡Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ¿Ğ¾ Exportum</b>\n\n"
            "Exportum - Ğ¿Ğ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼Ğ° Ğ´Ğ»Ñ Ñ‚Ğ¾Ñ€Ğ³Ğ¾Ğ²Ğ»Ğ¸ Ğ·ĞµÑ€Ğ½Ğ¾Ğ¼\n\n"
            "Ğ”Ğ»Ñ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹:\n"
            "1. ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ /start Ğ´Ğ»Ñ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸\n"
            "2. Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ²Ğ°ÑˆÑƒ Ñ€Ğ¾Ğ»ÑŒ\n"
            "3. Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ\n"
            "4. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ğ¼ĞµĞ½Ñ Ğ´Ğ»Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹\n\n"
            "Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ñ€Ğ¾Ğ»Ğ¸:\n"
            "â€¢ ğŸŒ¾ Ğ¤ĞµÑ€Ğ¼ĞµÑ€ - Ğ¿Ñ€Ğ¾Ğ´Ğ°Ğ¶Ğ° Ğ·ĞµÑ€Ğ½Ğ°\n"
            "â€¢ ğŸ“¦ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€ - Ğ¿Ğ¾ĞºÑƒĞ¿ĞºĞ° Ğ¸ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚\n"
            "â€¢ ğŸšš Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ - Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºĞ¸\n"
            "â€¢ ğŸš› Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€ - Ğ¾Ñ„Ğ¾Ñ€Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²",
            parse_mode="HTML",
        )
        return

    user = users[user_id]
    role = user.get("role")

    text = f"â„¹ï¸ <b>Ğ¡Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ´Ğ»Ñ {ROLES.get(role, role)}</b>\n\n"

    if role == "farmer":
        text += (
            "ğŸ“¦ <b>Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹:</b>\n"
            "â€¢ Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñƒ, Ğ¾Ğ±ÑŠÑ‘Ğ¼, Ñ†ĞµĞ½Ñƒ\n"
            "â€¢ Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ°\n"
            "â€¢ ĞŸÑ€Ğ¸ĞºÑ€ĞµĞ¿Ğ¸Ñ‚Ğµ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ñ‹ Ğ¸ Ñ„Ğ¾Ñ‚Ğ¾\n\n"
            "ğŸ” <b>ĞŸĞ¾Ğ¸ÑĞº ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ²:</b>\n"
            "â€¢ ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ¿Ğ¾Ğ¸ÑĞº Ğ¿Ğ¾ Ğ¿ÑƒĞ»Ğ°Ğ¼\n"
            "â€¢ Ğ ÑƒÑ‡Ğ½Ğ¾Ğ¹ Ğ¿Ğ¾Ğ¸ÑĞº Ğ¿Ğ¾ ĞºÑ€Ğ¸Ñ‚ĞµÑ€Ğ¸ÑĞ¼\n"
            "â€¢ Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ¾ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸ÑÑ…\n\n"
            "ğŸ“‹ <b>Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸ÑĞ¼Ğ¸:</b>\n"
            "â€¢ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ¾Ğ²\n"
            "â€¢ Ğ˜Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°\n"
            "â€¢ ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸\n\n"
            "ğŸ’¡ <b>Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ğ¸Ğ¸:</b>\n"
            "â€¢ ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°Ğ¹Ñ‚Ğµ Ğ°ĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ñ‹Ğµ Ñ†ĞµĞ½Ñ‹\n"
            "â€¢ Ğ£ĞºĞ°Ğ·Ñ‹Ğ²Ğ°Ğ¹Ñ‚Ğµ Ñ‚Ğ¾Ñ‡Ğ½Ñ‹Ğµ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹\n"
            "â€¢ ĞŸÑ€Ğ¸ĞºÑ€ĞµĞ¿Ğ»ÑĞ¹Ñ‚Ğµ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ñ‹ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ°"
        )

    elif role == "exporter":
        text += (
            "ğŸ“¦ <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ¾Ğ²:</b>\n"
            "â€¢ Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ñ‚Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğº Ğ·ĞµÑ€Ğ½Ñƒ\n"
            "â€¢ Ğ—Ğ°Ğ´Ğ°Ğ¹Ñ‚Ğµ Ñ†ĞµĞ½Ñƒ FOB\n"
            "â€¢ Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ñ€Ñ‚ Ğ¾Ñ‚Ğ³Ñ€ÑƒĞ·ĞºĞ¸\n\n"
            "ğŸ” <b>ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹:</b>\n"
            "â€¢ Ğ Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ¸ÑĞº Ğ¿Ğ¾ ĞºÑ€Ğ¸Ñ‚ĞµÑ€Ğ¸ÑĞ¼\n"
            "â€¢ ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ¿Ğ¾Ğ´Ğ±Ğ¾Ñ€\n"
            "â€¢ Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñƒ Ğ¸ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ñƒ\n\n"
            "ğŸšš <b>Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºĞ°:</b>\n"
            "â€¢ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°ÑĞ²Ğ¾Ğº Ğ½Ğ° Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºÑƒ\n"
            "â€¢ Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²\n"
            "â€¢ ĞÑ‚ÑĞ»ĞµĞ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸\n\n"
            "ğŸ’¡ <b>Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ğ¸Ğ¸:</b>\n"
            "â€¢ Ğ§Ñ‘Ñ‚ĞºĞ¾ Ñ„Ğ¾Ñ€Ğ¼ÑƒĞ»Ğ¸Ñ€ÑƒĞ¹Ñ‚Ğµ Ñ‚Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ\n"
            "â€¢ Ğ£Ñ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°Ğ¹Ñ‚Ğµ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¾ÑĞ¾Ğ±ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸\n"
            "â€¢ Ğ¡Ğ²Ğ¾ĞµĞ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ÑĞ¹Ñ‚Ğµ Ğ¿ÑƒĞ»Ñ‹"
        )

    elif role == "logistic":
        text += (
            "ğŸšš <b>Ğ’Ğ°ÑˆĞ¸ ÑƒÑĞ»ÑƒĞ³Ğ¸:</b>\n"
            "â€¢ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°\n"
            "â€¢ Ğ£ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ğµ Ñ‚Ğ°Ñ€Ğ¸Ñ„Ğ¾Ğ² Ğ¸ Ğ¼Ğ°Ñ€ÑˆÑ€ÑƒÑ‚Ğ¾Ğ²\n"
            "â€¢ ĞŸÑ€Ğ¸Ñ‘Ğ¼ Ğ·Ğ°ÑĞ²Ğ¾Ğº Ğ½Ğ° Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºĞ¸\n\n"
            "ğŸ“‹ <b>Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ° Ñ Ğ·Ğ°ÑĞ²ĞºĞ°Ğ¼Ğ¸:</b>\n"
            "â€¢ ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ·Ğ°ÑĞ²Ğ¾Ğº\n"
            "â€¢ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ ÑĞ²Ğ¾Ğ¸Ñ… ÑƒÑĞ»ÑƒĞ³\n"
            "â€¢ ĞĞ±Ñ‰ĞµĞ½Ğ¸Ğµ Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°Ğ¼Ğ¸\n\n"
            "ğŸ’¼ <b>Ğ’Ğ°ÑˆĞ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ:</b>\n"
            "â€¢ Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹\n"
            "â€¢ Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑÑ‹ Ğ¿ĞµÑ€ĞµĞ³Ğ¾Ğ²Ğ¾Ñ€Ğ¾Ğ²\n"
            "â€¢ Ğ£ÑĞ¿ĞµÑˆĞ½Ñ‹Ğµ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºĞ¸\n\n"
            "ğŸ’¡ <b>Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ğ¸Ğ¸:</b>\n"
            "â€¢ Ğ£ĞºĞ°Ğ·Ñ‹Ğ²Ğ°Ğ¹Ñ‚Ğµ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğµ Ñ‚Ğ°Ñ€Ğ¸Ñ„Ñ‹\n"
            "â€¢ ĞĞ¿ĞµÑ€Ğ°Ñ‚Ğ¸Ğ²Ğ½Ğ¾ Ñ€ĞµĞ°Ğ³Ğ¸Ñ€ÑƒĞ¹Ñ‚Ğµ Ğ½Ğ° Ğ·Ğ°ÑĞ²ĞºĞ¸\n"
            "â€¢ ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°Ğ¹Ñ‚Ğµ Ğ°ĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸"
        )

    elif role == "expeditor":
        text += (
            "ğŸš› <b>Ğ’Ğ°ÑˆĞ¸ ÑƒÑĞ»ÑƒĞ³Ğ¸:</b>\n"
            "â€¢ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°\n"
            "â€¢ Ğ£ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ğµ ÑƒÑĞ»ÑƒĞ³ Ğ¸ Ñ‚Ğ°Ñ€Ğ¸Ñ„Ğ¾Ğ²\n"
            "â€¢ ĞŸÑ€Ğ¸Ñ‘Ğ¼ Ğ·Ğ°ÑĞ²Ğ¾Ğº Ğ½Ğ° Ğ¾Ñ„Ğ¾Ñ€Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ\n\n"
            "ğŸ“‹ <b>Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ° Ñ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°Ğ¼Ğ¸:</b>\n"
            "â€¢ Ğ¤Ğ¸Ñ‚Ğ¾ÑĞ°Ğ½Ğ¸Ñ‚Ğ°Ñ€Ğ½Ñ‹Ğµ ÑĞµÑ€Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ‚Ñ‹\n"
            "â€¢ Ğ’ĞµÑ‚ĞµÑ€Ğ¸Ğ½Ğ°Ñ€Ğ½Ñ‹Ğµ ÑĞ²Ğ¸Ğ´ĞµÑ‚ĞµĞ»ÑŒÑÑ‚Ğ²Ğ°\n"
            "â€¢ Ğ¡ĞµÑ€Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ‚Ñ‹ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ°\n\n"
            "ğŸ’¼ <b>Ğ’Ğ°ÑˆĞ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ:</b>\n"
            "â€¢ Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ¾Ñ„Ğ¾Ñ€Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹\n"
            "â€¢ Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑÑ‹ Ğ·Ğ°ÑĞ²Ğ¾Ğº\n"
            "â€¢ Ğ£ÑĞ¿ĞµÑˆĞ½Ñ‹Ğµ ÑĞ´ĞµĞ»ĞºĞ¸\n\n"
            "ğŸ’¡ <b>Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ğ¸Ğ¸:</b>\n"
            "â€¢ Ğ§Ñ‘Ñ‚ĞºĞ¾ Ğ¾Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°Ğ¹Ñ‚Ğµ ÑƒÑĞ»ÑƒĞ³Ğ¸\n"
            "â€¢ Ğ£ĞºĞ°Ğ·Ñ‹Ğ²Ğ°Ğ¹Ñ‚Ğµ ÑÑ€Ğ¾ĞºĞ¸ Ğ¾Ñ„Ğ¾Ñ€Ğ¼Ğ»ĞµĞ½Ğ¸Ñ\n"
            "â€¢ ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°Ğ¹Ñ‚Ğµ Ñ€ĞµĞ¿ÑƒÑ‚Ğ°Ñ†Ğ¸Ñ"
        )

    text += "\n\nğŸ“ <b>ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ°:</b> @exportum_support"

    await message.answer(text, parse_mode="HTML")


@dp.callback_query_handler(lambda c: c.data.startswith("edit_batch:"), state="*")
async def start_edit_batch(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ğ»Ğ¾ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ½Ğ¾Ğ¹ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""
    batch_id = parse_callback_id(callback.data)
    user_id = callback.from_user.id
    batch = None
    farmer_id = None

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ•: Ğ˜Ñ‰ĞµĞ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ñƒ Ğ’Ğ¡Ğ•Ğ¥ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹
    for uid, user_batches in batches.items():
        for b in user_batches:
            if b["id"] == batch_id:
                batch = b
                farmer_id = uid
                break
        if batch:
            break

    if not batch:
        await callback.answer("âŒ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    await state.update_data(editing_batch_id=batch_id)

    await callback.message.edit_text(
        f"âœï¸ <b>Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ #{batch_id}</b>\n\n"
        "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ğ»Ğµ Ğ´Ğ»Ñ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ:",
        reply_markup=edit_batch_fields_keyboard(batch_id),
        parse_mode="HTML",
    )
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("edit_field:"), state="*")
async def edit_batch_field_selected(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ğ¿Ğ¾Ğ»Ñ Ğ´Ğ»Ñ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""
    field = callback.data.split(":", 1)[1]

    data = await state.get_data()
    batch_id = data.get("editing_batch_id")

    if not batch_id:
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    await state.update_data(edit_field=field, editing_batch_id=batch_id)
    field_names = {
        "price": "Ğ½Ğ¾Ğ²ÑƒÑ Ñ†ĞµĞ½Ñƒ (â‚½/Ñ‚Ğ¾Ğ½Ğ½Ğ°)",
        "volume": "Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ¾Ğ±ÑŠÑ‘Ğ¼ (Ğ² Ñ‚Ğ¾Ğ½Ğ½Ğ°Ñ…)",
        "humidity": "Ğ½Ğ¾Ğ²ÑƒÑ Ğ²Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ (%)",
        "impurity": "Ğ½Ğ¾Ğ²ÑƒÑ ÑĞ¾Ñ€Ğ½Ğ¾ÑÑ‚ÑŒ (%)",
        "quality_class": "Ğ½Ğ¾Ğ²Ñ‹Ğ¹ ĞºĞ»Ğ°ÑÑ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ°",
        "storage_type": "Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ñ‚Ğ¸Ğ¿ Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ",
        "readiness_date": "Ğ½Ğ¾Ğ²ÑƒÑ Ğ´Ğ°Ñ‚Ñƒ Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸ (Ğ”Ğ”.ĞœĞœ.Ğ“Ğ“Ğ“Ğ“)",
        "status": "Ğ½Ğ¾Ğ²Ñ‹Ğ¹ ÑÑ‚Ğ°Ñ‚ÑƒÑ",
    }

    if field == "status":
        await callback.message.edit_text(
            f"âœï¸ <b>Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ #{batch_id}</b>\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ ÑÑ‚Ğ°Ñ‚ÑƒÑ:",
            reply_markup=status_keyboard(),
            parse_mode="HTML",
        )
        await EditBatch.new_value.set()
    elif field == "quality_class":
        await callback.message.edit_text(
            f"âœï¸ <b>Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ #{batch_id}</b>\n\n"
            "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ ĞºĞ»Ğ°ÑÑ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ°:",
            reply_markup=quality_class_keyboard(),
            parse_mode="HTML",
        )
        await EditBatch.new_value.set()
    elif field == "storage_type":
        await callback.message.edit_text(
            f"âœï¸ <b>Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ #{batch_id}</b>\n\n"
            "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ñ‚Ğ¸Ğ¿ Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ:",
            reply_markup=storage_type_keyboard(),
            parse_mode="HTML",
        )
        await EditBatch.new_value.set()
    else:
        await callback.message.edit_text(
            f"âœï¸ <b>Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ #{batch_id}</b>\n\n"
            f"Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ {field_names.get(field, 'Ğ½Ğ¾Ğ²Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ')}:"
        )
        await EditBatch.new_value.set()

    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("status:"), state=EditBatch.new_value
)
async def edit_batch_status_selected(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° ÑÑ‚Ğ°Ñ‚ÑƒÑĞ° Ğ¿Ñ€Ğ¸ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¸ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""
    new_status = callback.data.split(":", 1)[1]

    data = await state.get_data()
    batch_id = data.get("editing_batch_id")
    user_id = callback.from_user.id

    if not batch_id:
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        await state.finish()
        return
    batch = None
    farmer_id = None

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ•: Ğ˜Ñ‰ĞµĞ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ñƒ Ğ’Ğ¡Ğ•Ğ¥ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹
    for uid, user_batches in batches.items():
        for b in user_batches:
            if b["id"] == batch_id:
                batch = b
                farmer_id = uid
                break
        if batch:
            break

    if not batch:
        await callback.answer("âŒ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        await state.finish()
        return
    old_value = batch.get("status", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
    batch["status"] = new_status
    save_batches_to_pickle()
    if gs and gs.spreadsheet:
        gs.update_batch_in_sheets(batch)

    await state.finish()
    await callback.message.edit_text(
        f"âœ… <b>Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»Ñ‘Ğ½!</b>\n\n"
        f"ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ #{batch_id}\n"
        f"Ğ¡Ñ‚Ğ°Ñ€Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ: {old_value}\n"
        f"ĞĞ¾Ğ²Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ: {new_status}"
    )
    await asyncio.sleep(1)
    await view_batch_details_direct(callback.message, batch_id, user_id)
    await callback.answer("âœ… Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»Ñ‘Ğ½")


@dp.callback_query_handler(
    lambda c: c.data.startswith("quality:"), state=EditBatch.new_value
)
async def edit_batch_quality_selected(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° ĞºĞ»Ğ°ÑÑĞ° ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ° Ğ¿Ñ€Ğ¸ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¸ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""
    new_quality = callback.data.split(":", 1)[1]

    data = await state.get_data()
    batch_id = data.get("editing_batch_id")
    user_id = callback.from_user.id

    if not batch_id:
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        await state.finish()
        return
    batch = None
    farmer_id = None

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ•: Ğ˜Ñ‰ĞµĞ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ñƒ Ğ’Ğ¡Ğ•Ğ¥ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹
    for uid, user_batches in batches.items():
        for b in user_batches:
            if b["id"] == batch_id:
                batch = b
                farmer_id = uid
                break
        if batch:
            break

    if not batch:
        await callback.answer("âŒ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        await state.finish()
        return
    old_value = batch.get("quality_class", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
    batch["quality_class"] = new_quality
    save_batches_to_pickle()
    if gs and gs.spreadsheet:
        gs.update_batch_in_sheets(batch)

    await state.finish()

    await callback.message.edit_text(
        f"âœ… <b>ĞšĞ»Ğ°ÑÑ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»Ñ‘Ğ½!</b>\n\n"
        f"ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ #{batch_id}\n"
        f"Ğ¡Ñ‚Ğ°Ñ€Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ: {old_value}\n"
        f"ĞĞ¾Ğ²Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ: {new_quality}"
    )
    await asyncio.sleep(1)
    await view_batch_details_direct(callback.message, batch_id, user_id)
    await callback.answer("âœ… ĞšĞ»Ğ°ÑÑ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»Ñ‘Ğ½")


@dp.callback_query_handler(
    lambda c: c.data.startswith("storage:"), state=EditBatch.new_value
)
async def edit_batch_storage_selected(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ñ‚Ğ¸Ğ¿Ğ° Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ğ¿Ñ€Ğ¸ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¸ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""
    new_storage = callback.data.split(":", 1)[1]

    data = await state.get_data()
    batch_id = data.get("editing_batch_id")
    user_id = callback.from_user.id

    if not batch_id:
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        await state.finish()
        return
    batch = None
    farmer_id = None

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ•: Ğ˜Ñ‰ĞµĞ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ñƒ Ğ’Ğ¡Ğ•Ğ¥ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹
    for uid, user_batches in batches.items():
        for b in user_batches:
            if b["id"] == batch_id:
                batch = b
                farmer_id = uid
                break
        if batch:
            break

    if not batch:
        await callback.answer("âŒ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        await state.finish()
        return
    old_value = batch.get("storage_type", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
    batch["storage_type"] = new_storage
    save_batches_to_pickle()
    if gs and gs.spreadsheet:
        gs.update_batch_in_sheets(batch)

    await state.finish()

    await callback.message.edit_text(
        f"âœ… <b>Ğ¢Ğ¸Ğ¿ Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»Ñ‘Ğ½!</b>\n\n"
        f"ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ #{batch_id}\n"
        f"Ğ¡Ñ‚Ğ°Ñ€Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ: {old_value}\n"
        f"ĞĞ¾Ğ²Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ: {new_storage}"
    )
    await asyncio.sleep(1)
    await view_batch_details_direct(callback.message, batch_id, user_id)
    await callback.answer("âœ… Ğ¢Ğ¸Ğ¿ Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»Ñ‘Ğ½")


@dp.message_handler(state=EditBatch.new_value)
async def edit_batch_new_value(message: types.Message, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ğ²Ğ¾Ğ´Ğ° Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ Ğ´Ğ»Ñ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""
    data = await state.get_data()
    batch_id = data.get("editing_batch_id")
    field = data.get("edit_field")
    user_id = message.from_user.id

    if not batch_id or not field:
        await message.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ñ‹")
        await state.finish()
        return
    batch = None
    farmer_id = None

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ•: Ğ˜Ñ‰ĞµĞ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ñƒ Ğ’Ğ¡Ğ•Ğ¥ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹
    for uid, user_batches in batches.items():
        for b in user_batches:
            if b["id"] == batch_id:
                batch = b
                farmer_id = uid
                break
        if batch:
            break

    if not batch:
        await message.answer("âŒ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°")
        await state.finish()
        return

    new_value = message.text.strip()
    try:
        if field in ["price", "volume", "humidity", "impurity"]:
            new_value_float = float(new_value.replace(",", "."))
            if field == "price" and new_value_float <= 0:
                await message.answer(
                    "âŒ Ğ¦ĞµĞ½Ğ° Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ 0. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·:"
                )
                return
            elif field == "volume" and new_value_float <= 0:
                await message.answer(
                    "âŒ ĞĞ±ÑŠÑ‘Ğ¼ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ±Ñ‹Ñ‚ÑŒ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ 0. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·:"
                )
                return
            elif field in ["humidity", "impurity"] and not (
                0 <= new_value_float <= 100
            ):
                await message.answer(
                    "âŒ Ğ—Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ¾ Ğ±Ñ‹Ñ‚ÑŒ Ğ¾Ñ‚ 0 Ğ´Ğ¾ 100. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·:"
                )
                return

            old_value = batch.get(field, "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾")
            batch[field] = new_value_float
            if field in ["humidity", "impurity"]:
                batch["quality_class"] = determine_quality_class(
                    batch.get("humidity", 0), batch.get("impurity", 0)
                )

        elif field == "readiness_date":
            if new_value.lower() == "ÑĞµĞ¹Ñ‡Ğ°Ñ":
                new_value = datetime.now().strftime("%d.%m.%Y")
            elif not validate_date(new_value):
                await message.answer(
                    "âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ°Ñ Ğ´Ğ°Ñ‚Ğ°. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ğ”Ğ”.ĞœĞœ.Ğ“Ğ“Ğ“Ğ“ Ğ¸Ğ»Ğ¸ 'ÑĞµĞ¹Ñ‡Ğ°Ñ'. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·:"
                )
                return

            old_value = batch.get(field, "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾")
            batch[field] = new_value

        else:
            old_value = batch.get(field, "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾")
            batch[field] = new_value
        save_batches_to_pickle()
        if gs and gs.spreadsheet:
            gs.update_batch_in_sheets(batch)

        await state.finish()
        field_names_ru = {
            "price": "Ğ¦ĞµĞ½Ğ°",
            "volume": "ĞĞ±ÑŠÑ‘Ğ¼",
            "humidity": "Ğ’Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ",
            "impurity": "Ğ¡Ğ¾Ñ€Ğ½Ğ¾ÑÑ‚ÑŒ",
            "readiness_date": "Ğ”Ğ°Ñ‚Ğ° Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸",
        }

        role = users[user_id].get("role")
        keyboard = get_role_keyboard(role)

        await message.answer(
            f"âœ… <b>{field_names_ru.get(field, field.capitalize())} Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°!</b>\n\n"
            f"ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ #{batch_id}\n"
            f"Ğ¡Ñ‚Ğ°Ñ€Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ: {old_value}\n"
            f"ĞĞ¾Ğ²Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ: {new_value}",
            reply_markup=keyboard,
            parse_mode="HTML",
        )
        await view_batch_details_direct(message, batch_id, user_id)

    except ValueError:
        await message.answer(
            "âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾.\n" "ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·:"
        )


@dp.callback_query_handler(lambda c: c.data == "edit_cancel", state="*")
async def edit_cancel(callback: types.CallbackQuery, state: FSMContext):
    """ĞÑ‚Ğ¼ĞµĞ½Ğ° Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ"""
    await state.finish()
    await callback.message.edit_text("âŒ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾")
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("delete_batch:"), state="*")
async def delete_batch_start(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ğ»Ğ¾ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""
    batch_id = parse_callback_id(callback.data)
    user_id = callback.from_user.id
    batch_exists = False
    if user_id in batches:
        for b in batches[user_id]:
            if b["id"] == batch_id:
                batch_exists = True
                break

    if not batch_exists:
        await callback.answer("âŒ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton(
            "âœ… Ğ”Ğ°, ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ", callback_data=f"confirm_delete_batch:{batch_id}"
        ),
        InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="cancel_delete_batch"),
    )

    await callback.message.edit_text(
        f"âš ï¸ <b>ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ</b>\n\n"
        f"Ğ’Ñ‹ ÑƒĞ²ĞµÑ€ĞµĞ½Ñ‹, Ñ‡Ñ‚Ğ¾ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ #{batch_id}?\n\n"
        f"<b>Ğ­Ñ‚Ğ¾ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ½ĞµĞ»ÑŒĞ·Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ!</b>",
        reply_markup=keyboard,
        parse_mode="HTML",
    )
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("confirm_delete_batch:"), state="*"
)
async def delete_batch_confirmed(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ - ÑƒĞ»ÑƒÑ‡ÑˆĞµĞ½Ğ½Ğ°Ñ Ğ²ĞµÑ€ÑĞ¸Ñ"""
    global batches, pulls, pullparticipants
    await state.finish()

    try:
        batch_id = int(callback.data.split(":")[-1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°!", show_alert=True)
        return

    user_id = callback.from_user.id

    # ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ² batches
    batch = None
    if user_id in batches:
        for b in batches[user_id]:
            if b["id"] == batch_id:
                batch = b
                break

    if not batch:
        await callback.answer("âŒ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°!", show_alert=True)
        return

    # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ¸Ğ· batches
    if user_id in batches:
        batches[user_id] = [b for b in batches[user_id] if b["id"] != batch_id]
        save_batches_to_pickle()
        logging.info(f"âœ… ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ #{batch_id} ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ° Ğ¸Ğ· batches")

    # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ¸Ğ· Ğ¿ÑƒĞ»Ğ¾Ğ²
    removed_from_pulls = []
    all_pulls = pulls.get("pulls", {})

    for pull_id, pull in all_pulls.items():
        if not isinstance(pull, dict):
            continue

        if "batch_ids" in pull and batch_id in pull["batch_ids"]:
            pull["batch_ids"].remove(batch_id)
            logging.info(f"ğŸ—‘ï¸ Ğ£Ğ´Ğ°Ğ»ĞµĞ½ batch_id={batch_id} Ğ¸Ğ· pull #{pull_id}")

            # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ¸Ğ· pull['batches']
            initial_len = len(pull.get("batches", []))
            pull["batches"] = [
                b for b in pull.get("batches", []) if b.get("id") != batch_id
            ]
            if len(pull["batches"]) < initial_len:
                logging.info(f"ğŸ—‘ï¸ Ğ£Ğ´Ğ°Ğ»ĞµĞ½ batch Ğ¸Ğ· pull['batches']")

            # ĞŸĞµÑ€ĞµÑÑ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ current_volume
            new_volume = sum(b.get("volume", 0) for b in pull.get("batches", []))
            pull["current_volume"] = new_volume
            logging.info(f"ğŸ“‰ ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½ current_volume: {pull.get('current_volume')}")

            # Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ, ĞµÑĞ»Ğ¸ Ğ¿ÑƒĞ» Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ½Ğµ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½
            if pull.get("status") == "filled" and pull["current_volume"] < pull.get(
                "target_volume", 0
            ):
                pull["status"] = "open"
                logging.info(f"âœ… ĞŸÑƒĞ» #{pull_id} Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰ĞµĞ½ Ğ² ÑÑ‚Ğ°Ñ‚ÑƒÑ 'open'")

            # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ farmer_id, ĞµÑĞ»Ğ¸ Ñƒ Ğ½ĞµĞ³Ğ¾ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ½ĞµÑ‚ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹
            if "farmer_ids" in pull:
                farmer_batches = [
                    b for b in pull.get("batches", []) if b.get("farmer_id") == user_id
                ]
                if not farmer_batches and user_id in pull["farmer_ids"]:
                    pull["farmer_ids"].remove(user_id)
                    logging.info(f"ğŸ—‘ï¸ Ğ£Ğ´Ğ°Ğ»ĞµĞ½ farmer_id={user_id} Ğ¸Ğ· Ğ¿ÑƒĞ»Ğ»Ğ°")

            removed_from_pulls.append(pull_id)

    # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ° Ğ² pullparticipants Ğ´Ğ»Ñ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¿ÑƒĞ»Ğ¾Ğ²
    pull_participants = pulls.get("pullparticipants", {})
    for pull_id in removed_from_pulls:
        if pull_id in pull_participants:
            old_len = len(pull_participants[pull_id])
            pull_participants[pull_id] = [
                p for p in pull_participants[pull_id] if p.get("batch_id") != batch_id
            ]
            if len(pull_participants[pull_id]) < old_len:
                logging.info(
                    f"ğŸ—‘ï¸ Ğ£Ğ´Ğ°Ğ»ĞµĞ½ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸Ğº Ñ batch_id={batch_id} Ğ¸Ğ· pullparticipants {pull_id}"
                )

    # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ, ĞµÑĞ»Ğ¸ Ğ¿ÑƒĞ»Ñ‹ Ğ±Ñ‹Ğ»Ğ¸ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ñ‹
    if removed_from_pulls:
        save_pulls_to_pickle()
        logging.info(f"âœ… ĞŸÑƒĞ»Ñ‹ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ñ‹")

    # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ¸Ğ· Google Sheets, ĞµÑĞ»Ğ¸ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾
    if gs and hasattr(gs, "spreadsheet") and gs.spreadsheet:
        try:
            gs.delete_batch_from_sheets(batch_id)
        except Exception as e:
            logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Google Sheets: {e}")

    # Ğ¡Ğ¾Ğ¾Ğ±Ñ‰Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¾Ğ± ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾Ğ¼ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ğ¸
    message = f"âœ… ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ <b>#{batch_id}</b> ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ°!"
    if removed_from_pulls:
        message += f"\nğŸ”„ Ğ¢Ğ°ĞºĞ¶Ğµ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ° Ğ¸Ğ· Ğ¿ÑƒĞ»Ğ¾Ğ²: {', '.join(f'#{pid}' for pid in removed_from_pulls)}"

    await callback.message.edit_text(message, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("editfield_crop_"), state="*")
async def edit_crop_field(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñ‹"""
    await state.finish()

    try:
        batch_id = int(callback.data.split("_")[2])
    except (IndexError, ValueError) as e:
        logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ°Ñ€ÑĞ¸Ğ½Ğ³Ğ° batch_id: {e}")
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    user_id = callback.from_user.id
    load_batches_from_pickle()

    batch = None
    farmer_id = None
    for f_id, user_batches in batches.items():
        for b in user_batches:
            if isinstance(b, dict) and b.get("id") == batch_id:
                batch = b
                farmer_id = f_id
                break
        if batch:
            break

    if not batch or farmer_id != user_id:
        await callback.answer("âŒ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    await state.update_data(batch_id=batch_id)

    keyboard = InlineKeyboardMarkup(row_width=2)
    cultures = ["ĞŸÑˆĞµĞ½Ğ¸Ñ†Ğ°", "ĞšÑƒĞºÑƒÑ€ÑƒĞ·Ğ°", "Ğ¯Ñ‡Ğ¼ĞµĞ½ÑŒ", "ĞŸĞ¾Ğ´ÑĞ¾Ğ»Ğ½ĞµÑ‡Ğ½Ğ¸Ğº", "Ğ Ğ°Ğ¿Ñ", "Ğ¡Ğ¾Ñ"]

    for culture in cultures:
        keyboard.insert(
            InlineKeyboardButton(culture, callback_data=f"setcrop_{batch_id}_{culture}")
        )

    keyboard.add(
        InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data=f"editcancel_{batch_id}")
    )

    await callback.message.edit_text(
        f"âœï¸ <b>Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ #{batch_id}</b>\n\n"
        f"Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²ÑƒÑ <b>ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñƒ</b>:",
        reply_markup=keyboard,
        parse_mode="HTML",
    )
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("setcrop_"), state="*")
async def set_crop_value(callback: types.CallbackQuery, state: FSMContext):
    """Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ° Ğ½Ğ¾Ğ²Ğ¾Ğ¹ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñ‹"""
    await state.finish()

    try:
        parts = callback.data.split("_")
        batch_id = int(parts[1])
        new_crop = "_".join(parts[2:])
    except (IndexError, ValueError) as e:
        logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ°Ñ€ÑĞ¸Ğ½Ğ³Ğ°: {e}")
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    user_id = callback.from_user.id
    load_batches_from_pickle()

    updated = False
    old_crop = "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾"

    for farmer_id, user_batches in batches.items():
        if farmer_id != user_id:
            continue
        for batch in user_batches:
            if isinstance(batch, dict) and batch.get("id") == batch_id:
                old_crop = batch.get("culture", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")
                batch["culture"] = new_crop
                updated = True
                break
        if updated:
            break

    if not updated:
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ", show_alert=True)
        return

    await callback.message.edit_text(
        f"âœ… <b>ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°!</b>\n\n"
        f"ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ #{batch_id}\n"
        f"Ğ‘Ñ‹Ğ»Ğ¾: {old_crop}\n"
        f"Ğ¡Ñ‚Ğ°Ğ»Ğ¾: {new_crop}",
        reply_markup=batch_actions_keyboard(batch_id),
        parse_mode="HTML",
    )
    await callback.answer("âœ… ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°!")


@dp.callback_query_handler(lambda c: c.data.startswith("editpull_"), state="*")
async def start_edit_pull(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ğ»Ğ¾ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¿ÑƒĞ»Ğ°"""
    try:
        # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: Ğ¿Ğ°Ñ€ÑĞ¸Ğ¼ Ñ‡ĞµÑ€ĞµĞ· Ğ¿Ğ¾Ğ´Ñ‡ĞµÑ€ĞºĞ¸Ğ²Ğ°Ğ½Ğ¸Ğµ
        pull_id = parse_callback_id(callback.data)
    except (IndexError, ValueError) as e:
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
        return

    user_id = callback.from_user.id

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿ÑƒĞ»Ñ‹ Ğ¸Ğ· Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑÑ‚Ğ°
    all_pulls = pulls.get("pulls", {})

    if pull_id not in all_pulls:
        await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    pull = all_pulls.get(pull_id) or all_pulls.get(str(pull_id))

    if not pull:
        await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    if pull.get("exporter_id") != user_id:
        await callback.answer(
            "âŒ ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ° Ğº Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ¿ÑƒĞ»Ğ°", show_alert=True
        )
        return

    await state.update_data(editing_pull_id=pull_id)

    try:
        await callback.message.edit_text(
            f"âœï¸ <b>Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ° #{pull_id}</b>\n\n"
            "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ğ»Ğµ Ğ´Ğ»Ñ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ:",
            reply_markup=edit_pull_fields_keyboard(),
            parse_mode="HTML",
        )
    except MessageNotModified:
        pass  # Ğ¡Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ ÑƒĞ¶Ğµ Ğ² Ğ½ÑƒĞ¶Ğ½Ğ¾Ğ¼ Ğ²Ğ¸Ğ´Ğµ
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("edit_pull_field:"), state="*")
async def edit_pull_field_selected(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ğ¿Ğ¾Ğ»Ñ Ğ´Ğ»Ñ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¿ÑƒĞ»Ğ°"""
    field = callback.data.split(":", 1)[1]

    data = await state.get_data()
    pull_id = data.get("editing_pull_id")

    if not pull_id:
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ¿ÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    await state.update_data(edit_pull_field=field, editing_pull_id=pull_id)

    field_names = {
        "culture": "Ğ½Ğ¾Ğ²ÑƒÑ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñƒ",
        "volume": "Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ñ†ĞµĞ»ĞµĞ²Ğ¾Ğ¹ Ğ¾Ğ±ÑŠÑ‘Ğ¼ (Ğ² Ñ‚Ğ¾Ğ½Ğ½Ğ°Ñ…)",
        "price": "Ğ½Ğ¾Ğ²ÑƒÑ Ñ†ĞµĞ½Ñƒ FOB (â‚½/Ñ‚Ğ¾Ğ½Ğ½Ğ°)",
        "port": "Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ¿Ğ¾Ñ€Ñ‚ Ğ¾Ñ‚Ğ³Ñ€ÑƒĞ·ĞºĞ¸",
        "moisture": "Ğ½Ğ¾Ğ²ÑƒÑ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½ÑƒÑ Ğ²Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ (%)",
        "nature": "Ğ½Ğ¾Ğ²ÑƒÑ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½ÑƒÑ Ğ½Ğ°Ñ‚ÑƒÑ€Ñƒ (Ğ³/Ğ»)",
        "impurity": "Ğ½Ğ¾Ğ²ÑƒÑ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½ÑƒÑ ÑĞ¾Ñ€Ğ½Ğ¾ÑÑ‚ÑŒ (%)",
        "weed": "Ğ½Ğ¾Ğ²ÑƒÑ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½ÑƒÑ Ğ·Ğ°ÑĞ¾Ñ€Ñ‘Ğ½Ğ½Ğ¾ÑÑ‚ÑŒ (%)",
    }

    if field == "culture":
        await callback.message.edit_text(
            f"âœï¸ <b>Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ° #{pull_id}</b>\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²ÑƒÑ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñƒ:",
            reply_markup=culture_keyboard(),
        )
        await EditPullStatesGroup.edit_culture.set()
    elif field == "port":
        await callback.message.edit_text(
            f"âœï¸ <b>Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ° #{pull_id}</b>\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ¿Ğ¾Ñ€Ñ‚:",
            reply_markup=port_keyboard(),
        )
        await EditPullStatesGroup.edit_port.set()
    else:
        await callback.message.edit_text(
            f"âœï¸ <b>Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ° #{pull_id}</b>\n\n"
            f"Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ {field_names.get(field, 'Ğ½Ğ¾Ğ²Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ')}:"
        )
        state_mapping = {
            "volume": EditPullStatesGroup.edit_volume,
            "price": EditPullStatesGroup.edit_price,
            "moisture": EditPullStatesGroup.edit_moisture,
            "nature": EditPullStatesGroup.edit_nature,
            "impurity": EditPullStatesGroup.edit_impurity,
            "weed": EditPullStatesGroup.edit_weed,
        }

        await state_mapping.get(field, EditPullStatesGroup.edit_volume).set()

    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("culture:"), state=EditPullStatesGroup.edit_culture
)
async def edit_pull_culture(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñ‹ Ğ¿Ñ€Ğ¸ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¸ Ğ¿ÑƒĞ»Ğ°"""
    new_culture = callback.data.split(":", 1)[1]

    data = await state.get_data()
    pull_id = data.get("editing_pull_id")

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿ÑƒĞ»Ñ‹ Ğ¸Ğ· Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑÑ‚Ğ°
    all_pulls = pulls.get("pulls", {})

    if not pull_id or pull_id not in all_pulls:
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ¿ÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        await state.finish()
        return

    pull = all_pulls.get(pull_id) or all_pulls.get(str(pull_id))

    if not pull:
        await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        await state.finish()
        return

    old_value = pull.get("culture")
    pull["culture"] = new_culture

    save_pulls_to_pickle()

    if gs and gs.spreadsheet:
        gs.update_pull_in_sheets(pull)

    await state.finish()

    await callback.message.edit_text(
        f"âœ… <b>ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°!</b>\n\n"
        f"ĞŸÑƒĞ» #{pull_id}\n"
        f"Ğ¡Ñ‚Ğ°Ñ€Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ: {old_value}\n"
        f"ĞĞ¾Ğ²Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ: {new_culture}",
        parse_mode="HTML",
    )
    await asyncio.sleep(1)
    await callback.answer("âœ… ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°")


@dp.callback_query_handler(
    lambda c: c.data.startswith("port:"), state=EditPullStatesGroup.edit_port
)
async def edit_pull_port(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ğ¿Ğ¾Ñ€Ñ‚Ğ° Ğ¿Ñ€Ğ¸ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¸ Ğ¿ÑƒĞ»Ğ°"""
    port_index = parse_callback_id(callback.data)

    # ğŸ“ ĞĞ¾Ğ²Ñ‹Ğ¹ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ¿Ğ¾Ñ€Ñ‚Ğ¾Ğ²
    ports = [
        "ĞÑ€Ğ¸Ğ±",
        "ĞŸĞšĞ¤ Â«Ğ’Ğ¾Ğ»Ğ³Ğ°-ĞŸĞ¾Ñ€Ñ‚Â»",
        "ĞŸĞšĞ¤ Â«Ğ®Ğ³-Ğ¢ĞµÑ€Â»",
        "ĞŸĞĞ Â«ĞÑÑ‚Ñ€.ĞŸĞ¾Ñ€Ñ‚Â»",
        "Ğ£Ğ½Ğ¸Ğ²ĞµÑ€.ĞŸĞ¾Ñ€Ñ‚",
        "Ğ®Ğ¶.ĞŸĞ¾Ñ€Ñ‚",
        "ĞĞ³Ñ€Ğ¾Ñ„ÑƒĞ´",
        "ĞœĞ¾ÑĞ¿Ğ¾Ñ€Ñ‚",
        "Ğ¦Ğ“ĞŸ",
        "Ğ¤Ğ—Ğ¢",
        "ĞĞœĞŸ",
        "ĞÑ€Ğ¼Ğ°Ğ´Ğ°",
        "Ğ¡Ñ‚Ñ€ĞµĞ»ĞµÑ†",
        "ĞĞ»ÑŒÑ„Ğ°",
    ]

    new_port = ports[port_index] if port_index < len(ports) else "ĞÑÑ‚Ñ€Ğ°Ñ…Ğ°Ğ½ÑŒ"

    data = await state.get_data()
    pull_id = data.get("editing_pull_id")

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿ÑƒĞ»Ñ‹ Ğ¸Ğ· Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑÑ‚Ğ°
    all_pulls = pulls.get("pulls", {})

    if not pull_id or pull_id not in all_pulls:
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ¿ÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        await state.finish()
        return

    pull = all_pulls.get(pull_id) or all_pulls.get(str(pull_id))

    if not pull:
        await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        await state.finish()
        return

    old_value = pull.get("port")
    pull["port"] = new_port

    save_pulls_to_pickle()

    if gs and gs.spreadsheet:
        gs.update_pull_in_sheets(pull)

    await state.finish()

    await callback.message.edit_text(
        f"âœ… <b>ĞŸĞ¾Ñ€Ñ‚ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»Ñ‘Ğ½!</b>\n\n"
        f"ĞŸÑƒĞ» #{pull_id}\n"
        f"Ğ¡Ñ‚Ğ°Ñ€Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ: {old_value}\n"
        f"ĞĞ¾Ğ²Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ: {new_port}",
        parse_mode="HTML",
    )
    await asyncio.sleep(1)
    await callback.answer("âœ… ĞŸĞ¾Ñ€Ñ‚ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»Ñ‘Ğ½")


@dp.message_handler(state=EditPullStatesGroup.edit_volume)
async def edit_pull_volume(message: types.Message, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ğ²Ğ¾Ğ´Ğ° Ğ¾Ğ±ÑŠÑ‘Ğ¼Ğ° Ğ¿Ñ€Ğ¸ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¸ Ğ¿ÑƒĞ»Ğ°"""
    await edit_pull_numeric_field(message, state, "target_volume", "ĞĞ±ÑŠÑ‘Ğ¼")


@dp.message_handler(state=EditPullStatesGroup.edit_price)
async def edit_pull_price(message: types.Message, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ğ²Ğ¾Ğ´Ğ° Ñ†ĞµĞ½Ñ‹ Ğ¿Ñ€Ğ¸ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¸ Ğ¿ÑƒĞ»Ğ°"""
    await edit_pull_numeric_field(message, state, "price", "Ğ¦ĞµĞ½Ğ°")


@dp.message_handler(state=EditPullStatesGroup.edit_moisture)
async def edit_pull_moisture(message: types.Message, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ğ²Ğ¾Ğ´Ğ° Ğ²Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ¿Ñ€Ğ¸ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¸ Ğ¿ÑƒĞ»Ğ°"""
    await edit_pull_numeric_field(message, state, "moisture", "Ğ’Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ", 0, 100)


@dp.message_handler(state=EditPullStatesGroup.edit_nature)
async def edit_pull_nature(message: types.Message, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ğ²Ğ¾Ğ´Ğ° Ğ½Ğ°Ñ‚ÑƒÑ€Ñ‹ Ğ¿Ñ€Ğ¸ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¸ Ğ¿ÑƒĞ»Ğ°"""
    await edit_pull_numeric_field(message, state, "nature", "ĞĞ°Ñ‚ÑƒÑ€Ğ°")


@dp.message_handler(state=EditPullStatesGroup.edit_impurity)
async def edit_pull_impurity(message: types.Message, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ğ²Ğ¾Ğ´Ğ° ÑĞ¾Ñ€Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ¿Ñ€Ğ¸ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¸ Ğ¿ÑƒĞ»Ğ°"""
    await edit_pull_numeric_field(message, state, "impurity", "Ğ¡Ğ¾Ñ€Ğ½Ğ¾ÑÑ‚ÑŒ", 0, 100)


@dp.message_handler(state=EditPullStatesGroup.edit_weed)
async def edit_pull_weed(message: types.Message, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ğ²Ğ¾Ğ´Ğ° Ğ·Ğ°ÑĞ¾Ñ€Ñ‘Ğ½Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ¿Ñ€Ğ¸ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¸ Ğ¿ÑƒĞ»Ğ°"""
    await edit_pull_numeric_field(message, state, "weed", "Ğ—Ğ°ÑĞ¾Ñ€Ñ‘Ğ½Ğ½Ğ¾ÑÑ‚ÑŒ", 0, 100)


async def edit_pull_numeric_field(
    message: types.Message,
    state: FSMContext,
    field: str,
    field_name: str,
    min_val: float = 0,
    max_val: float = None,
):
    """Ğ£Ğ½Ğ¸Ğ²ĞµÑ€ÑĞ°Ğ»ÑŒĞ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ñ‡Ğ¸ÑĞ»Ğ¾Ğ²Ñ‹Ñ… Ğ¿Ğ¾Ğ»ĞµĞ¹ Ğ¿ÑƒĞ»Ğ°"""
    try:
        new_value = float(message.text.strip().replace(",", "."))

        if new_value < min_val:
            await message.answer(f"âŒ Ğ—Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ¾ Ğ±Ñ‹Ñ‚ÑŒ Ğ½Ğµ Ğ¼ĞµĞ½ĞµĞµ {min_val}")
            return

        if max_val is not None and new_value > max_val:
            await message.answer(f"âŒ Ğ—Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ¾ Ğ±Ñ‹Ñ‚ÑŒ Ğ½Ğµ Ğ±Ğ¾Ğ»ĞµĞµ {max_val}")
            return

        data = await state.get_data()
        pull_id = data.get("editing_pull_id")

        # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿ÑƒĞ»Ñ‹ Ğ¸Ğ· Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑÑ‚Ğ°
        all_pulls = pulls.get("pulls", {})

        if not pull_id or pull_id not in all_pulls:
            await message.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½")
            await state.finish()
            return

        pull = all_pulls.get(pull_id) or all_pulls.get(str(pull_id))

        if not pull:
            await message.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½")
            await state.finish()
            return

        old_value = pull.get(field, 0)
        pull[field] = new_value

        save_pulls_to_pickle()

        if gs and gs.spreadsheet:
            gs.update_pull_in_sheets(pull)

        await state.finish()

        keyboard = get_role_keyboard("exporter")
        await message.answer(
            f"âœ… <b>{field_name} Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ°!</b>\n\n"
            f"ĞŸÑƒĞ» #{pull_id}\n"
            f"Ğ‘Ñ‹Ğ»Ğ¾: {old_value}\n"
            f"Ğ¡Ñ‚Ğ°Ğ»Ğ¾: {new_value}",
            reply_markup=keyboard,
            parse_mode="HTML",
        )

    except ValueError:
        await message.answer("âŒ ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ²Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾")


# ==================== Ğ’Ğ¡ĞŸĞĞœĞĞ“ĞĞ¢Ğ•Ğ›Ğ¬ĞĞĞ¯ Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ¯ Ğ”Ğ›Ğ¯ ĞĞ¢Ğ›ĞĞ”ĞšĞ˜ ====================
# âš ï¸ Ğ’ĞĞ˜ĞœĞĞĞ˜Ğ•: Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ Ğ’Ğ«Ğ¨Ğ• Ğ²ÑĞµÑ… Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ¾Ğ²!


async def debug_pull_deletion(pullid: int):
    """ĞÑ‚Ğ»Ğ°Ğ´Ğ¾Ñ‡Ğ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ Ğ¿ÑƒĞ»Ğ°"""
    logging.info(f"=== DEBUG: ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ Ğ¿ÑƒĞ»Ğ° {pullid} ===")

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ñ Ğ² Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸
    in_memory = pullid in pulls
    logging.info(f"Ğ’ Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸ (pulls dict): {in_memory}")

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ñ Ğ² pickle
    try:
        with open(PULLSFILE, "rb") as f:
            saved_pulls = pickle.load(f)
            in_pickle = pullid in saved_pulls.get("pulls", {})
            logging.info(f"Ğ’ pickle Ñ„Ğ°Ğ¹Ğ»Ğµ: {in_pickle}")
    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ñ‡Ñ‚ĞµĞ½Ğ¸Ñ pickle: {e}")

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ñ Ğ² Google Sheets
    if gs and gs.spreadsheet:
        try:
            worksheet = gs.spreadsheet.worksheet("Pulls")
            all_values = worksheet.get_all_values()

            found_in_sheets = False
            for row in all_values[1:]:
                if row and len(row) > 0:
                    try:
                        if int(row[0]) == pullid:
                            found_in_sheets = True
                            break
                    except (ValueError, IndexError):
                        continue

            logging.info(f"Ğ’ Google Sheets: {found_in_sheets}")
        except Exception as e:
            logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Google Sheets: {e}")

    logging.info("=== DEBUG: Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¾ ===")


async def notify_logistic_pull_closed(pullid: int):
    """Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ² Ğ¾ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ğ¸ Ğ¿ÑƒĞ»Ğ°"""
    try:
        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ²ÑĞµÑ… Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²
        logistics = [
            uid for uid, user in users.items() if user.get("role") == "logistic"
        ]

        if pullid not in pulls:
            logging.error(f"ĞŸÑƒĞ» {pullid} Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ Ğ´Ğ»Ñ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²")
            return

        pull = pulls[pullid]

        # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ
        message = (
            f"ğŸ”” <b>ĞŸÑƒĞ» #{pullid} Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚ Ğ¸ Ğ³Ğ¾Ñ‚Ğ¾Ğ² Ğº Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºĞµ</b>\n\n"
            f"ğŸŒ¾ <b>ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°:</b> {pull.get('culture', 'Ğ/Ğ”')}\n"
            f"ğŸ“¦ <b>ĞĞ±ÑŠÑ‘Ğ¼:</b> {pull.get('targetvolume', 0)} Ñ‚Ğ¾Ğ½Ğ½\n"
            f"ğŸ’° <b>Ğ¦ĞµĞ½Ğ° FOB:</b> â‚½{pull.get('price', 0):,.0f}/Ñ‚Ğ¾Ğ½Ğ½Ğ°\n"
            f"ğŸš¢ <b>ĞŸĞ¾Ñ€Ñ‚:</b> {pull.get('port', 'Ğ/Ğ”')}\n\n"
            f"ğŸ“‹ Ğ’Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¿Ğ¾Ğ´Ğ°Ñ‚ÑŒ Ğ·Ğ°ÑĞ²ĞºÑƒ Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ¿ÑƒĞ»Ğ°."
        )

        # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ²ÑĞµĞ¼ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°Ğ¼
        for logistic_id in logistics:
            try:
                await bot.send_message(logistic_id, message, parse_mode="HTML")
                logging.info(
                    f"Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ğ¸ Ğ¿ÑƒĞ»Ğ° {pullid} Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ñƒ {logistic_id}"
                )
            except Exception as e:
                logging.error(f"ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° {logistic_id}: {e}")

        logging.info(
            f"Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ¾ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ğ¸ Ğ¿ÑƒĞ»Ğ° {pullid} Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ñ‹ {len(logistics)} Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°Ğ¼"
        )

    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ² notify_logistic_pull_closed: {e}")


# ==================== ĞĞĞ§ĞĞ›Ğ Ğ£Ğ”ĞĞ›Ğ•ĞĞ˜Ğ¯ ĞŸĞ£Ğ›Ğ ====================
@dp.callback_query_handler(lambda c: c.data.startswith("deletepull_"), state="*")
async def deletepullstart_callback(callback: types.CallbackQuery, state: FSMContext):
    """Ğ—Ğ°Ğ¿Ñ€Ğ¾Ñ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ Ğ¿ÑƒĞ»Ğ°"""
    try:
        pullid = parse_callback_id(callback.data)
    except (IndexError, ValueError) as e:
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ½ĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¹ ID Ğ¿ÑƒĞ»Ğ°", show_alert=True)
        return

    userid = callback.from_user.id

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿ÑƒĞ»Ñ‹ Ğ¸Ğ· Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑÑ‚Ğ°
    all_pulls = pulls.get("pulls", {})

    if pullid not in all_pulls:
        await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    pull = all_pulls.get(pullid) or all_pulls.get(str(pullid))

    if not pull:
        await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    if pull.get("exporter_id") != userid:
        await callback.answer(
            "âŒ Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ĞµĞ»ÑŒ Ğ¿ÑƒĞ»Ğ° Ğ¼Ğ¾Ğ¶ĞµÑ‚ ĞµĞ³Ğ¾ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ", show_alert=True
        )
        return

    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton(
            "âœ… Ğ”Ğ°, ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ", callback_data=f"confirmdeletepull_{pullid}"
        ),
        InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="canceldeletepull"),
    )

    await callback.message.edit_text(
        f"<b>âš ï¸ ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ</b>\n\n"
        f"â“ Ğ’Ñ‹ ÑƒĞ²ĞµÑ€ĞµĞ½Ñ‹, Ñ‡Ñ‚Ğ¾ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ¿ÑƒĞ» â„–{pullid}?\n\n"
        f"ğŸŒ¾ <b>ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°:</b> {pull.get('culture', 'Ğ/Ğ”')}\n"
        f"ğŸ“¦ <b>ĞĞ±ÑŠÑ‘Ğ¼:</b> {pull.get('target_volume', 0)} Ñ‚Ğ¾Ğ½Ğ½\n"
        f"ğŸ’° <b>Ğ¦ĞµĞ½Ğ° FOB:</b> â‚½{pull.get('price', 0):,.0f}/Ñ‚Ğ¾Ğ½Ğ½Ğ°\n\n"
        f"<b>âš ï¸ Ğ­Ñ‚Ğ¾ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ½ĞµĞ»ÑŒĞ·Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ!</b>",
        reply_markup=keyboard,
        parse_mode="HTML",
    )

    await callback.answer()


# ==================== ĞŸĞĞ”Ğ¢Ğ’Ğ•Ğ Ğ–Ğ”Ğ•ĞĞ˜Ğ• Ğ£Ğ”ĞĞ›Ğ•ĞĞ˜Ğ¯ ====================
@dp.callback_query_handler(lambda c: c.data.startswith("confirmdeletepull_"), state="*")
async def deletepullconfirmed_callback(
    callback: types.CallbackQuery, state: FSMContext
):
    """Ğ¤Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ° Ğ¿Ğ¾ÑĞ»Ğµ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ"""
    await state.finish()

    try:
        pullid = parse_callback_id(callback.data)
    except (IndexError, ValueError) as e:
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ½ĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¹ ID Ğ¿ÑƒĞ»Ğ°", show_alert=True)
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ°Ñ€ÑĞ¸Ğ½Ğ³Ğ° Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğ¸: {e}, data: {callback.data}")
        return

    userid = callback.from_user.id

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿ÑƒĞ»Ñ‹ Ğ¸Ğ· Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑÑ‚Ğ°
    all_pulls = pulls.get("pulls", {})

    if pullid not in all_pulls:
        await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    pull = all_pulls.get(pullid) or all_pulls.get(str(pullid))

    if not pull:
        await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    if pull.get("exporter_id") != userid:
        await callback.answer(
            "âŒ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ¿Ñ€Ğ°Ğ² Ğ½Ğ° ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ¿ÑƒĞ»Ğ°", show_alert=True
        )
        return

    # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ»Ñ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
    pull_culture = pull.get("culture", "Ğ/Ğ”")
    pull_volume = pull.get("target_volume", 0)
    pull_price = pull.get("price", 0)

    # ========== Ğ£Ğ”ĞĞ›Ğ•ĞĞ˜Ğ• Ğ¡Ğ’Ğ¯Ğ—ĞĞĞĞ«Ğ¥ Ğ”ĞĞĞĞ«Ğ¥ ==========

    # 1. Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ²ÑĞµ Ğ¼Ğ°Ñ‚Ñ‡Ğ¸
    matches_to_delete = [
        mid
        for mid, m in matches.items()
        if m.get("pull_id") == pullid or m.get("pullid") == pullid
    ]
    for mid in matches_to_delete:
        del matches[mid]

    # 2. âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¸ ÑƒĞ´Ğ°Ğ»ÑĞµĞ¼ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² Ğ¸Ğ· pulls['pullparticipants']
    pullparticipants = pulls.get("pullparticipants", {})
    participants = pullparticipants.get(pullid, []) or pullparticipants.get(
        str(pullid), []
    )

    if pullid in pullparticipants:
        del pullparticipants[pullid]
    if str(pullid) in pullparticipants:
        del pullparticipants[str(pullid)]

    # 3. âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ ÑĞ°Ğ¼ Ğ¿ÑƒĞ» Ğ¸Ğ· pulls['pulls']
    if pullid in all_pulls:
        del all_pulls[pullid]
    if str(pullid) in all_pulls:
        del all_pulls[str(pullid)]

    # 4. Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ
    save_pulls_to_pickle()

    # ========== Ğ¡Ğ˜ĞĞ¥Ğ ĞĞĞ˜Ğ—ĞĞ¦Ğ˜Ğ¯ Ğ¡ GOOGLE SHEETS ==========
    if gs and gs.spreadsheet:
        try:
            worksheet = gs.spreadsheet.worksheet("Pulls")
            all_values = worksheet.get_all_values()

            rows_to_delete = []
            for i, row in enumerate(all_values[1:], start=2):
                if row and len(row) > 0:
                    try:
                        if int(row[0]) == pullid:
                            rows_to_delete.append(i)
                    except (ValueError, IndexError):
                        continue

            for row_num in reversed(rows_to_delete):
                worksheet.delete_rows(row_num)

            logging.info(f"ĞŸÑƒĞ» {pullid} ÑƒĞ´Ğ°Ğ»Ñ‘Ğ½ Ğ¸Ğ· Google Sheets")
        except Exception as e:
            logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ Ğ¸Ğ· Google Sheets: {e}")

    # ========== Ğ£Ğ’Ğ•Ğ”ĞĞœĞ›Ğ•ĞĞ˜Ğ¯ ==========

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²
    farmer_ids = pull.get("farmer_ids", [])
    for farmer_id in farmer_ids:
        try:
            await bot.send_message(
                farmer_id,
                f"<b>ğŸ—‘ ĞŸÑƒĞ» â„–{pullid} Ğ±Ñ‹Ğ» ÑƒĞ´Ğ°Ğ»Ñ‘Ğ½</b>\n\n"
                f"Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ğ» Ğ¿ÑƒĞ»:\n"
                f"ğŸŒ¾ {pull_culture}\n"
                f"ğŸ“¦ {pull_volume:.1f} Ñ‚\n"
                f"ğŸ’° â‚½{pull_price:,.0f}/Ñ‚\n\n"
                f'Ğ’Ğ°ÑˆĞ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰ĞµĞ½Ğ° Ğ² ÑÑ‚Ğ°Ñ‚ÑƒÑ "ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ°"',
                parse_mode="HTML",
            )
        except Exception as e:
            logging.warning(f"âš ï¸ Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ñƒ {farmer_id}: {e}")

    # âœ… Ğ”ĞĞ‘ĞĞ’Ğ›Ğ•ĞĞ ĞĞ”ĞĞ Ğ¡Ğ¢Ğ ĞĞšĞ - ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ĞºĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ñ‹
    keyboard = InlineKeyboardMarkup().add(
        InlineKeyboardButton("â¬…ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_pulls")
    )

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²
    await callback.message.edit_text(
        f"âœ… <b>ĞŸÑƒĞ» ÑƒĞ´Ğ°Ğ»Ñ‘Ğ½</b>\n\n"
        f"ğŸ—‘ï¸ <b>Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¾:</b>\n"
        f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {pull_culture}\n"
        f"ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: {pull_volume:.1f} Ñ‚\n"
        f"ğŸ’° Ğ¦ĞµĞ½Ğ°: â‚½{pull_price:,.0f}/Ñ‚\n"
        f"ğŸ†” ID: {pullid}\n\n"
        f"ğŸ”” Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¾: {len(farmer_ids)}\n"
        f"ğŸ—‘ï¸ ĞœĞ°Ñ‚Ñ‡ĞµĞ¹ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¾: {len(matches_to_delete)}",
        reply_markup=keyboard,
        parse_mode="HTML",
    )
    logging.info(
        f"âœ… ĞŸÑƒĞ» {pullid} ÑƒĞ´Ğ°Ğ»Ñ‘Ğ½ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¼ {userid}. Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²: {len(participants)}, Ğ¼Ğ°Ñ‚Ñ‡ĞµĞ¹: {len(matches_to_delete)}"
    )

    await callback.answer("âœ… ĞŸÑƒĞ» ÑƒĞ´Ğ°Ğ»Ñ‘Ğ½")


# ==================== ĞĞ¢ĞœĞ•ĞĞ Ğ£Ğ”ĞĞ›Ğ•ĞĞ˜Ğ¯ ====================
@dp.callback_query_handler(lambda c: c.data == "canceldeletepull", state="*")
async def canceldeletepull_callback(callback: types.CallbackQuery, state: FSMContext):
    """âœ… ĞÑ‚Ğ¼ĞµĞ½Ğ° Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑĞ° ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ Ğ¿ÑƒĞ»Ğ° - Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ"""

    # âœ… ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ pull_id Ğ¸Ğ· state
    user_data = await state.get_data()
    pull_id = user_data.get("delete_pull_id")

    # âœ… ĞÑ‡Ğ¸Ñ‰Ğ°ĞµĞ¼ state
    await state.finish()

    # âœ… Ğ•ÑĞ»Ğ¸ pull_id ĞµÑÑ‚ÑŒ - Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ÑÑ Ğº Ğ´ĞµÑ‚Ğ°Ğ»ÑĞ¼ Ğ¿ÑƒĞ»Ğ°
    if pull_id:
        all_pulls = pulls.get("pulls", {})
        pull = all_pulls.get(pull_id)

        if pull:
            # ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ´ĞµÑ‚Ğ°Ğ»Ğ¸ Ğ¿ÑƒĞ»Ğ°
            keyboard = InlineKeyboardMarkup(row_width=2)
            keyboard.add(
                InlineKeyboardButton(
                    "âœï¸ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ", callback_data=f"editpull_{pull_id}"
                ),
                InlineKeyboardButton(
                    "ğŸ—‘ Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ", callback_data=f"deletepull_{pull_id}"
                ),
            )
            keyboard.add(
                InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_my_pulls")
            )

            text = f"""ğŸ“¦ <b>ĞŸÑƒĞ» #{pull_id}</b>

âŒ <i>Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾</i>

ğŸŒ¾ <b>ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°:</b> {pull.get('culture', '?')}
ğŸ“¦ <b>ĞĞ±ÑŠÑ‘Ğ¼:</b> {pull.get('current_volume', 0):.0f}/{pull.get('target_volume', 0):.0f} Ñ‚
ğŸ’° <b>Ğ¦ĞµĞ½Ğ° FOB:</b> â‚½{pull.get('price', 0):,.0f}/Ñ‚
"""

            await callback.message.edit_text(
                text, reply_markup=keyboard, parse_mode="HTML"
            )
        else:
            await callback.message.edit_text("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½")
    else:
        # Ğ•ÑĞ»Ğ¸ Ğ½ĞµÑ‚ pull_id - Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ
        await callback.message.edit_text("âŒ Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾")

    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("confirmclosepull_"), state="*")
async def confirm_close_pull_callback(callback_query: types.CallbackQuery):
    """ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ğ¸Ñ‚ÑŒ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ»Ğ° Ğ¸ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ Ğ²ÑĞµÑ… ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² Ğ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²"""
    try:
        pull_id = int(callback_query.data.split("_")[3])
    except (IndexError, ValueError) as e:
        await callback_query.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ½ĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ ID Ğ¿ÑƒĞ»Ğ»Ğ°", show_alert=True)
        return

    user_id = callback_query.from_user.id

    if pull_id not in pulls.get("pulls", {}):
        await callback_query.answer("âŒ ĞŸÑƒĞ»Ğ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    pull = pulls["pulls"][pull_id]

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ñ€Ğ°Ğ²Ğ¾ Ğ½Ğ° Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ
    if pull.get("exporter_id") != user_id:
        await callback_query.answer(
            "âš ï¸ Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ²Ğ»Ğ°Ğ´ĞµĞ»ĞµÑ† Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ¿ÑƒĞ»Ğ»", show_alert=True
        )
        return

    # Ğ˜Ğ·Ğ¼ĞµĞ½ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ½Ğ° 'closed'
    pull["status"] = "closed"
    pull["closedat"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    save_pulls_to_pickle()

    # Google Sheets
    if gs and gs.spreadsheet:
        try:
            gs.updatepullinsheets(pull)
        except Exception as e:
            logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¿ÑƒĞ»Ğ»Ğ° Ğ² Google Sheets: {e}")

    # Ğ¡Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ
    close_text = (
        f"ğŸ”’ <b>ĞŸÑƒĞ»Ğ» #{pull_id} Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚</b>\n\n"
        f"ğŸŒ¾ {pull.get('culture', 'N/A')}\n"
        f"ğŸ“¦ {pull.get('targetvolume', 0)} Ñ‚\n"
        f"ğŸ’° {pull.get('price', 0)} â‚½/Ñ‚\n\n"
        f"Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾ Ğ·Ğ° ÑƒÑ‡Ğ°ÑÑ‚Ğ¸Ğµ!"
    )

    # Ğ’ÑĞµ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ñ‹ Ğ¿Ğ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼Ñ‹
    logist_ids = [uid for uid, u in users.items() if u.get("role") == "logistic"]
    # Ğ’ÑĞµ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ñ‹ - ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¸ Ğ¿ÑƒĞ»Ğ°
    participant_list = pullparticipants.get(pull_id, [])
    farmer_ids = [p.get("farmer_id") for p in participant_list if p.get("farmer_id")]

    # Ğ”Ğ»Ñ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ!
    all_notify_ids = set(farmer_ids) | set(logist_ids)
    logging.info(
        f"[CONFIRM CLOSE DEBUG] pull_id={pull_id} logist_ids={logist_ids} "
        f"farmer_ids={farmer_ids} all_notify_ids={list(all_notify_ids)}"
    )

    sent_count = 0
    failed_ids = []
    for notify_id in all_notify_ids:
        try:
            await bot.send_message(notify_id, close_text, parse_mode="HTML")
            logging.info(
                f"[CONFIRM CLOSE DEBUG] ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ user_id={notify_id}"
            )
            sent_count += 1
        except Exception as e:
            logging.error(
                f"[CONFIRM CLOSE ERROR] ĞÑˆĞ¸Ğ±ĞºĞ° Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸ user_id={notify_id}: {e}"
            )
            failed_ids.append(notify_id)

    # Ğ’ĞµÑÑŒ Ğ¸Ñ‚Ğ¾Ğ³ Ğ¿Ğ¾ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞµ:
    logging.info(
        f"[CONFIRM CLOSE RESULT] Ğ˜Ñ‚Ğ¾Ğ³: {sent_count} ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾, "
        f"{len(failed_ids)} Ğ½Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾: {failed_ids}"
    )

    await callback_query.message.edit_text(
        f"âœ… <b>ĞŸÑƒĞ»Ğ» #{pull_id} ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚!</b>\n\n"
        f"ğŸŒ¾ {pull.get('culture', 'N/A')}\n"
        f"ğŸ“¦ {pull.get('targetvolume', 0)} Ñ‚\n"
        f"ğŸ’° {pull.get('price', 0)} â‚½/Ñ‚\n\n"
        f"ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹: {sent_count} (Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ñ‹: {len(logist_ids)}, Ñ„ĞµÑ€Ğ¼ĞµÑ€Ñ‹: {len(farmer_ids)})",
        parse_mode="HTML",
    )
    await callback_query.answer("âœ… ĞŸÑƒĞ»Ğ» Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚!")
    logging.info(
        f"ĞŸÑƒĞ»Ğ» {pull_id} Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¼ {user_id}, ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ {sent_count}"
    )


@dp.callback_query_handler(lambda c: c.data == "cancel_delete_pull", state="*")
async def cancel_delete_pull(callback: types.CallbackQuery):
    """ĞÑ‚Ğ¼ĞµĞ½Ğ° ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ Ğ¿ÑƒĞ»Ğ°"""
    await callback.message.edit_text("âŒ Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾")
    await callback.answer()


# ================================
# ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜Ğš Ğ—ĞĞšĞ Ğ«Ğ¢Ğ˜Ğ¯ ĞŸĞ£Ğ›Ğ›Ğ
# ================================
@dp.callback_query_handler(lambda c: c.data == "get_partner_contacts", state="*")
async def get_partner_contacts_handler(callback: types.CallbackQuery):
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ğ¾Ğ² Ğ¿Ğ°Ñ€Ñ‚Ğ½Ñ‘Ñ€Ğ° Ğ¿Ğ¾ ÑĞ´ĞµĞ»ĞºĞµ"""
    user_id = callback.from_user.id
    partner_info = None

    # Ğ˜Ñ‰ĞµĞ¼ ÑĞ´ĞµĞ»ĞºÑƒ, Ğ³Ğ´Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ ÑƒÑ‡Ğ°ÑÑ‚Ğ²ÑƒĞµÑ‚
    for deal_id, deal in deals.items():
        if deal.get("logistic_id") == user_id:
            # Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ - Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°
            exporter_id = deal.get("exporter_id")
            exporter = users.get(exporter_id)
            if exporter:
                partner_info = "ğŸ“¦ <b>ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°:</b>\n\n"
                partner_info += f"ğŸ“ {exporter.get('name', 'ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾')}\n"
                partner_info += f"ğŸ“± {exporter.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
                partner_info += f"ğŸ“§ {exporter.get('email', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
                partner_info += f"ğŸ“ {exporter.get('region', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
                break

        elif deal.get("expeditor_id") == user_id:
            # Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€ - Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°
            exporter_id = deal.get("exporter_id")
            exporter = users.get(exporter_id)
            if exporter:
                partner_info = "ğŸ“¦ <b>ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°:</b>\n\n"
                partner_info += f"ğŸ“ {exporter.get('name', 'ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾')}\n"
                partner_info += f"ğŸ“± {exporter.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
                partner_info += f"ğŸ“§ {exporter.get('email', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
                partner_info += f"ğŸ“ {exporter.get('region', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
                break

    if not partner_info:
        await callback.answer("ğŸ¤·â€â™‚ï¸ ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ñ‹", show_alert=True)
        return

    await callback.message.answer(partner_info, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("complete_deal:"), state="*")
async def complete_deal(callback: types.CallbackQuery):
    """Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğµ ÑĞ´ĞµĞ»ĞºĞ¸"""
    deal_id = parse_callback_id(callback.data)

    if deal_id not in deals:
        await callback.answer("âŒ Ğ¡Ğ´ĞµĞ»ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    deal = deals[deal_id]
    user_id = callback.from_user.id
    if userid != deal.get("exporterid") and userid not in deal.get("farmerids", []):
        await callback.answer(
            "âš ï¸ Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¸ ÑĞ´ĞµĞ»ĞºĞ¸ Ğ¼Ğ¾Ğ³ÑƒÑ‚ ĞµÑ‘ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚ÑŒ", showalert=True
        )
        return

    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton(
            "âœ… Ğ”Ğ°, Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚ÑŒ", callback_data=f"confirm_complete_deal:{deal_id}"
        ),
        InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="cancel_complete_deal"),
    )

    await callback.message.edit_text(
        f"âœ… <b>ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ</b>\n\n"
        f"Ğ’Ñ‹ ÑƒĞ²ĞµÑ€ĞµĞ½Ñ‹, Ñ‡Ñ‚Ğ¾ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚ÑŒ ÑĞ´ĞµĞ»ĞºÑƒ #{deal_id}?\n\n"
        f"ĞŸĞ¾ÑĞ»Ğµ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ:\n"
        f"â€¢ Ğ¡Ğ´ĞµĞ»ĞºĞ° Ğ¿ĞµÑ€ĞµĞ¼ĞµÑÑ‚Ğ¸Ñ‚ÑÑ Ğ² Ğ°Ñ€Ñ…Ğ¸Ğ²\n"
        f"â€¢ Ğ’ÑĞµ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¸ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°Ñ‚ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ\n"
        f"â€¢ Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ±ÑƒĞ´ĞµÑ‚ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°\n\n"
        f"<b>Ğ­Ñ‚Ğ¾ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ½ĞµĞ»ÑŒĞ·Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ!</b>",
        reply_markup=keyboard,
        parse_mode="HTML",
    )
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("confirm_complete_deal:"), state="*"
)
async def confirm_complete_deal(callback: types.CallbackQuery):
    """ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ ÑĞ´ĞµĞ»ĞºĞ¸"""
    deal_id = parse_callback_id(callback.data)

    if deal_id not in deals:
        await callback.answer("âŒ Ğ¡Ğ´ĞµĞ»ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    deal = deals[deal_id]
    deal["status"] = "completed"
    deal["completed_at"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    save_pulls_to_pickle()
    await notify_deal_participants(deal_id, "âœ… Ğ¡Ğ´ĞµĞ»ĞºĞ° Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°!")

    await callback.message.edit_text(
        f"ğŸ‰ <b>Ğ¡Ğ´ĞµĞ»ĞºĞ° #{deal_id} Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°!</b>\n\n"
        f"Ğ’ÑĞµ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¸ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ñ‹ Ğ¾ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğ¸ ÑĞ´ĞµĞ»ĞºĞ¸.\n"
        f"Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾ Ğ·Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼Ñ‹ Exportum!",
        parse_mode="HTML",
    )
    await callback.answer("âœ… Ğ¡Ğ´ĞµĞ»ĞºĞ° Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°")


@dp.callback_query_handler(lambda c: c.data.startswith("cancel_deal:"), state="*")
async def cancel_deal(callback: types.CallbackQuery):
    """ĞÑ‚Ğ¼ĞµĞ½Ğ° ÑĞ´ĞµĞ»ĞºĞ¸"""
    deal_id = parse_callback_id(callback.data)

    if deal_id not in deals:
        await callback.answer("âŒ Ğ¡Ğ´ĞµĞ»ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    deal = deals[deal_id]
    user_id = callback.from_user.id
    if deal.get("exporter_id") != user_id:
        await callback.answer(
            "âŒ Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ÑĞ´ĞµĞ»ĞºÑƒ", show_alert=True
        )
        return

    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton(
            "âœ… Ğ”Ğ°, Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ", callback_data=f"confirm_cancel_deal:{deal_id}"
        ),
        InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="cancel_cancel_deal"),
    )

    await callback.message.edit_text(
        f"âŒ <b>ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‹</b>\n\n"
        f"Ğ’Ñ‹ ÑƒĞ²ĞµÑ€ĞµĞ½Ñ‹, Ñ‡Ñ‚Ğ¾ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ÑĞ´ĞµĞ»ĞºÑƒ #{deal_id}?\n\n"
        f"ĞŸĞ¾ÑĞ»Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‹:\n"
        f"â€¢ Ğ¡Ğ´ĞµĞ»ĞºĞ° Ğ±ÑƒĞ´ĞµÑ‚ Ğ¿Ğ¾Ğ¼ĞµÑ‡ĞµĞ½Ğ° ĞºĞ°Ğº Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‘Ğ½Ğ½Ğ°Ñ\n"
        f"â€¢ Ğ’ÑĞµ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¸ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°Ñ‚ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ\n"
        f"â€¢ Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ±ÑƒĞ´ĞµÑ‚ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°\n\n"
        f"<b>Ğ­Ñ‚Ğ¾ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ½ĞµĞ»ÑŒĞ·Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ!</b>",
        reply_markup=keyboard,
        parse_mode="HTML",
    )
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("confirm_cancel_deal:"), state="*"
)
async def confirm_cancel_deal(callback: types.CallbackQuery):
    """ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‹ ÑĞ´ĞµĞ»ĞºĞ¸"""
    deal_id = parse_callback_id(callback.data)

    if deal_id not in deals:
        await callback.answer("âŒ Ğ¡Ğ´ĞµĞ»ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    deal = deals[deal_id]
    deal["status"] = "cancelled"
    deal["completed_at"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    save_pulls_to_pickle()
    await notify_deal_participants(deal_id, "âŒ Ğ¡Ğ´ĞµĞ»ĞºĞ° Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ°")

    await callback.message.edit_text(
        f"âŒ <b>Ğ¡Ğ´ĞµĞ»ĞºĞ° #{deal_id} Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ°!</b>\n\n"
        f"Ğ’ÑĞµ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¸ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ñ‹ Ğ¾Ğ± Ğ¾Ñ‚Ğ¼ĞµĞ½Ğµ ÑĞ´ĞµĞ»ĞºĞ¸.",
        parse_mode="HTML",
    )
    await callback.answer("âœ… Ğ¡Ğ´ĞµĞ»ĞºĞ° Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ°")


@dp.callback_query_handler(
    lambda c: c.data in ["cancel_complete_deal", "cancel_cancel_deal"], state="*"
)
async def cancel_deal_action(callback: types.CallbackQuery):
    """ĞÑ‚Ğ¼ĞµĞ½Ğ° Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ ÑĞ¾ ÑĞ´ĞµĞ»ĞºĞ¾Ğ¹"""
    await callback.message.edit_text("âŒ Ğ”ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾")
    await callback.answer()


async def notify_deal_participants(deal_id: int, message: str):
    """Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ²ÑĞµÑ… ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² ÑĞ´ĞµĞ»ĞºĞ¸"""
    deal = deals.get(deal_id)
    if not deal:
        return

    participants = []
    if deal.get("exporter_id"):
        participants.append(deal["exporter_id"])
    if deal.get("farmer_ids"):
        participants.extend(deal["farmer_ids"])
    if deal.get("logistic_id"):
        participants.append(deal["logistic_id"])
    if deal.get("expeditor_id"):
        participants.append(deal["expeditor_id"])
    for user_id in participants:
        try:
            await bot.send_message(
                user_id,
                f"ğŸ“‹ <b>Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ ÑĞ´ĞµĞ»ĞºĞµ #{deal_id}</b>\n\n{message}",
                parse_mode="HTML",
            )
            await asyncio.sleep(0.1)  # Ğ—Ğ°Ğ´ĞµÑ€Ğ¶ĞºĞ° Ğ¼ĞµĞ¶Ğ´Ñƒ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ°Ğ¼Ğ¸
        except Exception as e:
            logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ {user_id}: {e}")


@dp.callback_query_handler(lambda c: c.data.startswith("logistics:"), state="*")
async def deal_logistics(callback: types.CallbackQuery):
    """Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºĞ¾Ğ¹ Ğ´Ğ»Ñ ÑĞ´ĞµĞ»ĞºĞ¸"""
    deal_id = parse_callback_id(callback.data)

    if deal_id not in deals:
        await callback.answer("âŒ Ğ¡Ğ´ĞµĞ»ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    deal = deals[deal_id]

    text = f"ğŸšš <b>Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºĞ° ÑĞ´ĞµĞ»ĞºĞ¸ #{deal_id}</b>\n\n"

    if deal.get("logistic_id"):
        logistic = users.get(deal["logistic_id"])
        if logistic:
            text += "âœ… <b>Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½:</b>\n"
            text += f"ğŸ‘¤ {logistic.get('name', 'ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾')}\n"
            text += f"ğŸ¢ {logistic.get('company_details', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}\n"
            text += f"ğŸ“‹ Ğ˜ĞĞ: <code>{logistic.get('inn', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>\n"
            text += f"ğŸ“‹ ĞĞ“Ğ Ğ: <code>{logistic.get('ogrn', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>\n"
            text += f"ğŸ“± {logistic.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
            text += f"ğŸ“§ {logistic.get('email', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
        else:
            text += "âŒ Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ Ğ² ÑĞ¸ÑÑ‚ĞµĞ¼Ğµ\n"
    else:
        text += "ğŸ¤·â€â™‚ï¸ <b>Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ Ğ½Ğµ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½</b>\n\n"
        text += "Ğ”Ğ»Ñ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° ÑĞ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ Ğ·Ğ°ÑĞ²ĞºÑƒ Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ.\n"

    if deal.get("expeditor_id"):
        expeditor = users.get(deal["expeditor_id"])
        if expeditor:
            text += "\nâœ… <b>Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½:</b>\n"
            text += f"ğŸ‘¤ {expeditor.get('name', 'ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾')}\n"
            text += f"ğŸ¢ {expeditor.get('company_details', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}\n"
            text += f"ğŸ“‹ Ğ˜ĞĞ: <code>{expeditor.get('inn', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>\n"
            text += f"ğŸ“‹ ĞĞ“Ğ Ğ: <code>{expeditor.get('ogrn', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>\n"
            text += f"ğŸ“± {expeditor.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
            text += f"ğŸ“§ {expeditor.get('email', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
        else:
            text += "\nâŒ Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ Ğ² ÑĞ¸ÑÑ‚ĞµĞ¼Ğµ\n"
    else:
        text += "\nğŸ¤·â€â™‚ï¸ <b>Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€ Ğ½Ğµ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½</b>\n\n"
        text += "Ğ”Ğ»Ñ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ° ÑĞ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ Ğ·Ğ°ÑĞ²ĞºÑƒ Ğ½Ğ° Ğ¾Ñ„Ğ¾Ñ€Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ¾Ğ².\n"

    keyboard = InlineKeyboardMarkup()
    keyboard.add(
        InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğº ÑĞ´ĞµĞ»ĞºĞµ", callback_data=f"view_deal:{deal_id}")
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("pullparticipants:"), state="*")
async def show_pullparticipants(callback: types.CallbackQuery):
    """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² Ğ¿ÑƒĞ»Ğ°"""
    try:
        pull_id = parse_callback_id(callback.data)
    except (IndexError, ValueError) as e:
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
        return

    if pull_id not in pulls.get("pulls", {}):
        await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    pull = pulls["pulls"][pull_id]
    participants = pullparticipants.get(pull_id, [])

    text = f"ğŸ‘¥ <b>Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¸ Ğ¿ÑƒĞ»Ğ° #{pull_id}</b>\n\n"
    text += f"ğŸŒ¾ {pull['culture']} â€¢ {pull['target_volume']} Ñ‚\n\n"

    if not participants:
        text += "ğŸ¤·â€â™‚ï¸ Ğ£ Ğ¿ÑƒĞ»Ğ° Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²"
    else:
        total_participant_volume = 0
        for i, participant in enumerate(participants, 1):
            farmer_id = participant.get("farmer_id")
            farmer = users.get(farmer_id)
            batch_id = participant.get("batch_id")
            volume = participant.get("volume", 0)
            total_participant_volume += volume

            farmer_name = farmer.get("name", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾") if farmer else "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾"

            text += f"{i}. ğŸ‘¤ {farmer_name}\n"
            text += f"   ğŸ“¦ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ #{batch_id}: {volume} Ñ‚\n"
            text += f"   ğŸ“ {farmer.get('region', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½') if farmer else 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½'}\n\n"

        fill_percentage = (
            (total_participant_volume / pull["target_volume"] * 100)
            if pull["target_volume"] > 0
            else 0
        )
        text += f"ğŸ“Š <b>Ğ˜Ñ‚Ğ¾Ğ³Ğ¾:</b> {total_participant_volume:.0f}/{pull['target_volume']:.0f} Ñ‚ ({fill_percentage:.1f}%)"

    keyboard = InlineKeyboardMarkup()
    keyboard.add(
        InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğº Ğ¿ÑƒĞ»Ñƒ", callback_data=f"view_pull:{pull_id}")
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("pull_logistics:"), state="*")
async def pull_logistics_menu(callback: types.CallbackQuery):
    """ĞœĞµĞ½Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºĞ¸ Ğ´Ğ»Ñ Ğ¿ÑƒĞ»Ğ°"""
    try:
        pull_id = parse_callback_id(callback.data)
    except (IndexError, ValueError) as e:
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
        return

    if pull_id not in pulls.get("pulls", {}):
        await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    pull = pulls["pulls"][pull_id]

    text = f"ğŸšš <b>Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ¿ÑƒĞ»Ğ° #{pull_id}</b>\n\n"
    text += f"ğŸŒ¾ {pull['culture']} â€¢ {pull['target_volume']} Ñ‚ â€¢ {pull['port']}\n\n"

    keyboard = InlineKeyboardMarkup(row_width=1)
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ“‹ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ·Ğ°ÑĞ²ĞºÑƒ Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ", callback_data=f"create_shipping:{pull_id}"
        ),
        InlineKeyboardButton(
            "ğŸ‘€ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸", callback_data=f"view_shipping_requests:{pull_id}"
        ),
        InlineKeyboardButton(
            "ğŸ“ ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²", callback_data="view_logistics_contacts"
        ),
    )
    keyboard.add(
        InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğº Ğ¿ÑƒĞ»Ñƒ", callback_data=f"view_pull:{pull_id}")
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("create_shipping:"), state="*")
async def create_shipping_from_pull(callback: types.CallbackQuery, state: FSMContext):
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ Ğ¸Ğ· Ğ¿ÑƒĞ»Ğ°"""
    try:
        pull_id = int(callback.data.split(":")[1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
        return

    if pull_id not in pulls.get("pulls", {}):
        await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    pull = pulls["pulls"][pull_id]
    await state.update_data(pull_id=pull_id)

    await callback.message.edit_text(
        f"ğŸšš <b>Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ Ğ´Ğ»Ñ Ğ¿ÑƒĞ»Ğ° #{pull_id}</b>\n\n"
        f"ğŸŒ¾ {pull.get('culture', '')} â€¢ {pull.get('target_volume', 0):.0f} Ñ‚ â€¢ {pull.get('port', '')}\n\n"
        "<b>Ğ¨Ğ°Ğ³ 1 Ğ¸Ğ· 5</b>\n\n"
        "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¿ÑƒĞ½ĞºÑ‚ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ (Ğ³Ğ¾Ñ€Ğ¾Ğ´/Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½):",
        parse_mode="HTML",
    )

    await ShippingRequestStatesGroup.route_from.set()
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data == "view_logistics_contacts", state="*")
async def view_logistics_contacts(callback: types.CallbackQuery):
    """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ² Ñ Ñ€ĞµĞºĞ²Ğ¸Ğ·Ğ¸Ñ‚Ğ°Ğ¼Ğ¸"""

    logistics_users = [
        user for user in users.values() if user.get("role") == "logistic"
    ]

    if not logistics_users:
        await callback.answer("ğŸ¤·â€â™‚ï¸ Ğ’ ÑĞ¸ÑÑ‚ĞµĞ¼Ğµ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²", show_alert=True)
        return

    text = "<b>ğŸšš Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢Ğ« ĞĞ ĞŸĞ›ĞĞ¢Ğ¤ĞĞ ĞœĞ•</b>\n\n"

    for i, logistic in enumerate(logistics_users[:10], 1):
        name = logistic.get("name", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")
        phone = logistic.get("phone", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        email = logistic.get("email", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        region = logistic.get("region", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")

        inn = logistic.get("inn", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        ogrn = logistic.get("ogrn", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        company = logistic.get("company_details", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°")

        text += f"{i}. ğŸ‘¤ <b>{name}</b>\n"
        text += f"   ğŸ¢ {company}\n"
        text += f"   ğŸ“‹ Ğ˜ĞĞ: <code>{inn}</code>\n"
        text += f"   ğŸ“‹ ĞĞ“Ğ Ğ: <code>{ogrn}</code>\n"
        text += f"   ğŸ“± <code>{phone}</code>\n"

        if email != "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½":
            text += f"   ğŸ“§ <code>{email}</code>\n"

        text += f"   ğŸ“ {region}\n\n"

    if len(logistics_users) > 10:
        text += f"\n<i>â„¹ï¸ Ğ•Ñ‰Ñ‘ {len(logistics_users) - 10} Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ² Ğ½Ğ° Ğ¿Ğ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼Ğµ</i>"

    text += "\n\nğŸ’¡ <b>Ğ¡Ğ²ÑĞ¶Ğ¸Ñ‚ĞµÑÑŒ Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°Ğ¼Ğ¸ Ğ´Ğ»Ñ Ğ¾Ğ±ÑÑƒĞ¶Ğ´ĞµĞ½Ğ¸Ñ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ğ¹ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºĞ¸.</b>"

    keyboard = InlineKeyboardMarkup()
    keyboard.add(InlineKeyboardButton("â¬…ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_main"))

    await callback.message.edit_text(text, parse_mode="HTML", reply_markup=keyboard)
    await callback.answer()


@dp.message_handler(
    lambda m: m.text in ["ğŸšš ĞœĞ¾Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ°", "ğŸš› ĞœĞ¾Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ°"], state="*"
)
async def show_logistics_card(message: types.Message):
    """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°/ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°"""
    user_id = message.from_user.id

    if user_id not in users:
        await message.answer(
            "âŒ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½. ĞŸÑ€Ğ¾Ğ¹Ğ´Ğ¸Ñ‚Ğµ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ¾Ğ¹ /start"
        )
        return

    user = users[user_id]
    role = user.get("role")

    if role not in ["logistic", "expeditor"]:
        await message.answer("âŒ Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°Ğ¼ Ğ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°Ğ¼")
        return

    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ
    role_emoji = "ğŸšš" if role == "logistic" else "ğŸš›"
    role_name = "Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚" if role == "logistic" else "Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€"

    text = f"{role_emoji} <b>ĞœĞ¾Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° ({role_name})</b>\n\n"
    text += f"ğŸ‘¤ Ğ˜Ğ¼Ñ: {user.get('name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n"
    text += f"ğŸ“ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <code>{user.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>\n"
    text += f"ğŸ“§ Email: {user.get('email', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
    text += f"ğŸ“ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½: {user.get('region', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n\n"

    if user.get("inn"):
        text += f"ğŸ¢ Ğ˜ĞĞ: <code>{user['inn']}</code>\n"

    if user.get("company_details"):
        text += f"ğŸ“‹ Ğ ĞºĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ğ¸:\n{user['company_details'][:300]}\n\n"

    # Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°
    if role == "logistic":
        # Ğ¡Ñ‡Ğ¸Ñ‚Ğ°ĞµĞ¼ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°
        logistics_requests = [
            req for req in shipping_requests.values() if req.get("logist_id") == user_id
        ]
        active_requests = [
            req for req in logistics_requests if req.get("status") == "active"
        ]
        text += "ğŸ“Š <b>Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°:</b>\n"
        text += f"  â€¢ Ğ’ÑĞµĞ³Ğ¾ Ğ·Ğ°ÑĞ²Ğ¾Ğº: {len(logistics_requests)}\n"
        text += f"   â€¢ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ…: {len(active_requests)}\n"
    else:  # expeditor
        # Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°
        text += "ğŸ“Š <b>Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°:</b>\n"
        text += "   â€¢ ĞÑ„Ğ¾Ñ€Ğ¼Ğ»ĞµĞ½Ğ½Ñ‹Ñ… ÑĞ´ĞµĞ»Ğ¾Ğº: 0\n"
        text += "   â€¢ Ğ’ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑĞµ: 0\n"

    keyboard = InlineKeyboardMarkup()
    keyboard.add(
        InlineKeyboardButton("âœï¸ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ", callback_data="edit_profile")
    )

    await message.answer(text, parse_mode="HTML", reply_markup=keyboard)


@dp.message_handler(lambda m: m.text == "ğŸšš ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸", state="*")
async def show_active_requests(message: types.Message, state: FSMContext):
    """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ - ĞĞ‘ĞªĞ•Ğ”Ğ˜ĞĞĞĞĞ Ğ´Ğ»Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°"""
    await state.finish()
    user_id = message.from_user.id

    if user_id not in users:
        await message.answer(
            "âŒ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½. ĞŸÑ€Ğ¾Ğ¹Ğ´Ğ¸Ñ‚Ğµ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ¾Ğ¹ /start"
        )
        return

    user = users[user_id]
    role = user.get("role")

    # Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ÑƒĞµĞ¼ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ² Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ¾Ñ‚ Ñ€Ğ¾Ğ»Ğ¸
    if role == "logistic":
        # âœ… Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢ - ĞĞĞ’ĞĞ¯ ĞšĞ ĞĞ¡Ğ˜Ğ’ĞĞ¯ Ğ’Ğ•Ğ Ğ¡Ğ˜Ğ¯ Ğ¡ Ğ¤ĞĞ ĞœĞĞ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ•Ğœ
        all_requests = []

        # ğŸ“Š Ğ›ĞĞ“Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ•
        logging.info(f"ğŸ” DEBUG: shipping_requests ({len(shipping_requests)} Ğ²ÑĞµĞ³Ğ¾)")
        for req_id, req in shipping_requests.items():
            status = req.get("status")
            logging.info(f"   - ID {req_id}: status='{status}'")
            if status == "active":
                all_requests.append(
                    {
                        "id": req_id,
                        "source": "exporter",
                        "culture": req.get("culture", "â€”"),
                        "volume": req.get("volume", 0),
                    }
                )

        logging.info(
            f"ğŸ” DEBUG: farmer_logistics_requests ({len(farmer_logistics_requests)} Ğ²ÑĞµĞ³Ğ¾)"
        )
        for req_id, req in farmer_logistics_requests.items():
            status = req.get("status")
            logging.info(f"   - ID {req_id}: status='{status}'")
            if status == "active":
                all_requests.append(
                    {
                        "id": req_id,
                        "source": "farmer",
                        "culture": req.get("culture", "â€”"),
                        "volume": req.get("volume", 0),
                    }
                )

        logging.info(f"âœ… Ğ˜Ğ¢ĞĞ“Ğ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ·Ğ°ÑĞ²Ğ¾Ğº: {len(all_requests)}")
        for req in all_requests:
            logging.info(
                f"   - {req['source'].upper()}: #{req['id']} ({req['culture']})"
            )

        # ğŸ“Š Ğ¤ĞĞ ĞœĞ˜Ğ Ğ£Ğ•Ğœ ĞšĞ ĞĞ¡Ğ˜Ğ’Ğ«Ğ™ Ğ¢Ğ•ĞšĞ¡Ğ¢
        text = f"""ğŸšš <b>ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸</b>



ğŸ“‹ Ğ’ÑĞµĞ³Ğ¾ Ğ·Ğ°ÑĞ²Ğ¾Ğº: {len(all_requests)}
ğŸš› ĞÑ‚ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ² | ğŸŒ¾ ĞÑ‚ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ²



Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ·Ğ°ÑĞ²ĞºÑƒ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ° Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹ Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ:
"""

        # ğŸ¯ ĞšĞĞĞŸĞšĞ˜ Ğ¡ Ğ—ĞĞ¯Ğ’ĞšĞĞœĞ˜
        keyboard = InlineKeyboardMarkup(row_width=1)

        if not all_requests:
            text = (
                "ğŸšš <b>ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸</b>\n\nâŒ ĞĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ğ¼Ğ¾Ğ¼ĞµĞ½Ñ‚ Ğ½ĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ·Ğ°ÑĞ²Ğ¾Ğº."
            )
        else:
            for req in all_requests:
                if req["source"] == "exporter":
                    emoji = "ğŸš›"
                else:
                    emoji = "ğŸŒ¾"

                label = f"{emoji} {req['culture']} â€¢ {req['volume']:.0f}Ñ‚"
                keyboard.add(
                    InlineKeyboardButton(
                        label, callback_data=f"view_request:{req['source']}:{req['id']}"
                    )
                )
        await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

    elif role == "exporter":
        # Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€ Ğ²Ğ¸Ğ´Ğ¸Ñ‚ Ğ¡Ğ’ĞĞ˜ Ğ·Ğ°ÑĞ²ĞºĞ¸
        user_requests = [
            {"req": req, "source": "exporter"}
            for req in shipping_requests.values()
            if req.get("exporter_id") == user_id
        ]
        title = "ğŸ“‹ <b>ĞœĞ¾Ğ¸ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ</b>"
        show_buttons = False

    elif role == "expeditor":
        # Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€ Ğ²Ğ¸Ğ´Ğ¸Ñ‚ Ğ·Ğ°ÑĞ²ĞºĞ¸, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ ĞµĞ¼Ñƒ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ñ‹
        user_requests = []
        title = "ğŸš› <b>ĞœĞ¾Ğ¸ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ½Ğ° Ğ¾Ñ„Ğ¾Ñ€Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ</b>"
        show_buttons = False
    else:
        await message.answer("âŒ Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° Ğ´Ğ»Ñ Ğ²Ğ°ÑˆĞµĞ¹ Ñ€Ğ¾Ğ»Ğ¸")
        return

    # ĞĞ¡Ğ¢ĞĞ›Ğ¬ĞĞĞ• Ğ”Ğ›Ğ¯ Ğ­ĞšĞ¡ĞŸĞĞ Ğ¢ĞĞ Ğ Ğ˜ Ğ­ĞšĞ¡ĞŸĞ•Ğ”Ğ˜Ğ¢ĞĞ Ğ (Ğ½Ğµ Ğ¼ĞµĞ½ÑĞµĞ¼)
    if role != "logistic":
        if not user_requests:
            msg_text = f"{title}\n\n"
            if role == "logistic":
                msg_text += "ğŸ“‹ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ·Ğ°ÑĞ²Ğ¾Ğº Ğ½ĞµÑ‚\n\n"
                msg_text += (
                    "ĞšĞ°Ğº Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ñ‹ Ğ¸Ğ»Ğ¸ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ñ‹ ÑĞ¾Ğ·Ğ´Ğ°Ğ´ÑƒÑ‚ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ, "
                )
                msg_text += "Ğ¾Ğ½Ğ¸ Ğ¿Ğ¾ÑĞ²ÑÑ‚ÑÑ Ğ·Ğ´ĞµÑÑŒ. Ğ’Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚Ğµ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ."
            else:
                msg_text += "âŒ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ·Ğ°ÑĞ²Ğ¾Ğº"

            await message.answer(
                msg_text,
                reply_markup=logistic_keyboard() if role == "logistic" else None,
                parse_mode="HTML",
            )
            return

        if show_buttons:
            keyboard = InlineKeyboardMarkup(row_width=1)

            for item in user_requests[:20]:
                req = item["req"]
                source = item["source"]

                req_id = req.get("id", "N/A")
                culture = req.get("culture", "N/A")
                volume = req.get("volume", 0) or 0
                route_from = req.get("route_from", "â€”")
                route_to = req.get("route_to", "â€”")

                emoji = "ğŸš›" if source == "exporter" else "ğŸŒ¾"
                source_label = "Ğ­" if source == "exporter" else "Ğ¤"

                btn_text = f"{emoji} [{source_label}] #{req_id} | {culture} | {volume:.0f}Ñ‚ | {route_from}â†’{route_to}"
                keyboard.add(
                    InlineKeyboardButton(
                        btn_text, callback_data=f"view_request:{source}:{req_id}"
                    )
                )

            await message.answer(
                f"{title}\n\n"
                f"ğŸ“‹ Ğ’ÑĞµĞ³Ğ¾ Ğ·Ğ°ÑĞ²Ğ¾Ğº: <b>{len(user_requests)}</b>\n"
                f"ğŸš› ĞÑ‚ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ² | ğŸŒ¾ ĞÑ‚ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ²\n\n"
                f"Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ·Ğ°ÑĞ²ĞºÑƒ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ° Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹ Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ:",
                reply_markup=keyboard,
                parse_mode="HTML",
            )
        else:
            text = f"{title}\n\n"

            for idx, item in enumerate(user_requests[:10], 1):
                req = item["req"]
                req_id = req.get("id", "N/A")
                volume = req.get("volume", 0) or 0
                route_from = req.get("route_from", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾")
                route_to = req.get("route_to", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾")
                culture = req.get("culture", "N/A")
                status = req.get("status", "unknown")

                text += f"{idx}. ğŸ“¦ Ğ—Ğ°ÑĞ²ĞºĞ° #{req_id}\n"
                text += f"   â€¢ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {culture}\n"
                text += f"   â€¢ ĞĞ±ÑŠÑ‘Ğ¼: {volume:.0f} Ñ‚\n"
                text += f"   â€¢ ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚: {route_from} â†’ {route_to}\n"
                text += f"   â€¢ Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: {status}\n\n"

            if len(user_requests) > 10:
                text += f"<i>... Ğ¸ ĞµÑ‰Ñ‘ {len(user_requests) - 10} Ğ·Ğ°ÑĞ²Ğ¾Ğº</i>\n\n"

            await message.answer(text, parse_mode="HTML")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ­ĞšĞ¡ĞŸĞ•Ğ”Ğ˜Ğ¢ĞĞ : ĞœĞĞ¯ ĞšĞĞ Ğ¢ĞĞ§ĞšĞ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


@dp.message_handler(lambda m: m.text == "ğŸ’³ ĞœĞ¾Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ°", state="*")
async def show_expeditor_card(message: types.Message, state: FSMContext):
    """Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€ ÑĞ¼Ğ¾Ñ‚Ñ€Ğ¸Ñ‚/Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ ÑĞ²Ğ¾Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ"""
    await state.finish()

    user_id = message.from_user.id

    if user_id not in users or users[user_id].get("role") != "expeditor":
        await message.answer("âŒ Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°Ğ¼")
        return

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°
    card = expeditor_cards.get(user_id)

    if not card:
        # ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ğ½ĞµÑ‚ - Ğ¿Ñ€ĞµĞ´Ğ»Ğ°Ğ³Ğ°ĞµĞ¼ ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ
        await message.answer(
            "ğŸ’³ <b>ĞœĞ¾Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°</b>\n\n"
            "Ğ£ Ğ²Ğ°Ñ ĞµÑ‰Ñ‘ Ğ½ĞµÑ‚ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸.\n"
            "Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ñ‹ Ğ¼Ğ¾Ğ³Ğ»Ğ¸ Ğ½Ğ°Ğ¹Ñ‚Ğ¸ Ğ²Ğ°Ñ Ğ¸ Ğ¿Ğ¾Ñ€ÑƒÑ‡Ğ°Ñ‚ÑŒ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸!\n\n"
            "ğŸ“‹ <b>Ğ’ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞµ ÑƒĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ÑÑ:</b>\n"
            "â€¢ Ğ¢Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°\n"
            "â€¢ Ğ“Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ\n"
            "â€¢ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹\n"
            "â€¢ Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ ÑƒÑĞ»ÑƒĞ³\n"
            "â€¢ ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ",
            reply_markup=InlineKeyboardMarkup(row_width=1).add(
                InlineKeyboardButton(
                    "â• Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ", callback_data="create_expeditor_card"
                )
            ),
            parse_mode="HTML",
        )
        return

    transport = card.get("transport_type", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
    emoji = get_vehicle_emoji(transport)
    # ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ
    text = (
        f"ğŸ’³ <b>ĞœĞ¾Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°</b>\n\n"
        f"{emoji} <b>Ğ¢Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°:</b> {transport}\n"
        f"ğŸ“¦ <b>Ğ“Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ:</b> {card.get('capacity', 0)} Ñ‚\n"
        f"ğŸ“ <b>Ğ ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹:</b> {card.get('regions', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ñ‹')}\n"
        f"ğŸ’° <b>Ğ¦ĞµĞ½Ğ° Ğ·Ğ° ĞºĞ¼:</b> {card.get('price_per_km', 0):.2f} â‚½/ĞºĞ¼\n"
        f"ğŸ“ <b>ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ:</b>\n{card.get('description', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n\n"
        f"ğŸ“… <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ°:</b> {card.get('created_at', 'Ğ/Ğ”')}\n"
        f"ğŸ‘ <b>ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ¾Ğ²:</b> {card.get('views', 0)}"
    )

    keyboard = InlineKeyboardMarkup(row_width=1)
    keyboard.add(
        InlineKeyboardButton("âœï¸ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ", callback_data="edit_expeditor_card"),
        InlineKeyboardButton(
            "ğŸ—‘ Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ", callback_data="delete_expeditor_card"
        ),
    )

    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ¡ĞĞ—Ğ”ĞĞĞ˜Ğ• ĞšĞĞ Ğ¢ĞĞ§ĞšĞ˜ - Ğ¨ĞĞ“ 1: Ğ¢Ğ˜ĞŸ Ğ¢Ğ ĞĞĞ¡ĞŸĞĞ Ğ¢Ğ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


@dp.callback_query_handler(lambda c: c.data == "create_expeditor_card", state="*")
async def create_expeditor_card_start(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ğ»Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°"""
    await state.finish()

    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("ğŸš› Ğ¤ÑƒÑ€Ğ°", callback_data="etype_Ğ¤ÑƒÑ€Ğ°"),
        InlineKeyboardButton("ğŸšš Ğ“Ñ€ÑƒĞ·Ğ¾Ğ²Ğ¸Ğº", callback_data="etype_Ğ“Ñ€ÑƒĞ·Ğ¾Ğ²Ğ¸Ğº"),
        InlineKeyboardButton("ğŸš Ğ“Ğ°Ğ·ĞµĞ»ÑŒ", callback_data="etype_Ğ“Ğ°Ğ·ĞµĞ»ÑŒ"),
        InlineKeyboardButton("ğŸš‚ Ğ–/Ğ´ Ğ²Ğ°Ğ³Ğ¾Ğ½", callback_data="etype_Ğ–/Ğ´ Ğ²Ğ°Ğ³Ğ¾Ğ½"),
        InlineKeyboardButton("ğŸš¢ Ğ‘Ğ°Ñ€Ğ¶Ğ°", callback_data="etype_Ğ‘Ğ°Ñ€Ğ¶Ğ°"),
        InlineKeyboardButton("âœï¸ Ğ¡Ğ²Ğ¾Ğ¹ Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚", callback_data="etype_custom"),
    )
    keyboard.add(
        InlineKeyboardButton(
            "âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="cancel_expeditor_card_creation"
        )
    )

    await callback.message.edit_text(
        "ğŸ’³ <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°</b>\n\n"
        "Ğ¨Ğ°Ğ³ 1 Ğ¸Ğ· 5\n\n"
        "ğŸš› Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ‚Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°:",
        reply_markup=keyboard,
        parse_mode="HTML",
    )
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("etype_"), state="*")
async def create_expeditor_card_vehicle_type(
    callback: types.CallbackQuery, state: FSMContext
):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ñ‚Ğ¸Ğ¿Ğ° Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°"""
    vehicle_type = callback.data.split("_")[1]

    if vehicle_type == "custom":
        await callback.message.edit_text(
            "ğŸ’³ <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°</b>\n\n"
            "Ğ¨Ğ°Ğ³ 1 Ğ¸Ğ· 5\n\n"
            "ğŸš› Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‚Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°:\n"
            "(Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: Ğ ĞµÑ„Ñ€Ğ¸Ğ¶ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€, ĞšĞ¾Ğ½Ñ‚ĞµĞ¹Ğ½ĞµÑ€Ğ¾Ğ²Ğ¾Ğ·)",
            parse_mode="HTML",
        )
        await ExpeditorCardStates.vehicle_type.set()
    else:
        await state.update_data(vehicle_type=vehicle_type)
        await callback.message.edit_text(
            "ğŸ’³ <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°</b>\n\n"
            "Ğ¨Ğ°Ğ³ 2 Ğ¸Ğ· 5\n\n"
            f"âœ… Ğ¢Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°: {vehicle_type}\n\n"  # â† Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ!
            "ğŸ“¦ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ³Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ (Ğ² Ñ‚Ğ¾Ğ½Ğ½Ğ°Ñ…):\n"
            "(Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: 20)",
            parse_mode="HTML",
        )
        await ExpeditorCardStates.capacity.set()

    await callback.answer()


@dp.message_handler(state=ExpeditorCardStates.vehicle_type)
async def expeditor_card_vehicle_custom(message: types.Message, state: FSMContext):
    """Ğ’Ğ²Ğ¾Ğ´ ÑĞ²Ğ¾ĞµĞ³Ğ¾ Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ğ° Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°"""
    vehicle_type = message.text.strip()

    await state.update_data(vehicle_type=vehicle_type)
    await message.answer(
        "ğŸ’³ <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°</b>\n\n"
        "Ğ¨Ğ°Ğ³ 2 Ğ¸Ğ· 5\n\n"
        f"âœ… Ğ¢Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°: {transport}\n\n"
        "ğŸ“¦ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ³Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ (Ğ² Ñ‚Ğ¾Ğ½Ğ½Ğ°Ñ…):\n"
        "(Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: 20)",
        parse_mode="HTML",
    )
    await ExpeditorCardStates.capacity.set()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ¨ĞĞ“ 2: Ğ“Ğ Ğ£Ğ—ĞĞŸĞĞ”ĞªĞĞœĞĞĞ¡Ğ¢Ğ¬
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


@dp.message_handler(state=ExpeditorCardStates.capacity)
async def expeditor_card_capacity(message: types.Message, state: FSMContext):
    """Ğ’Ğ²Ğ¾Ğ´ Ğ³Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚Ğ¸"""
    try:
        capacity = float(message.text.replace(",", "."))
        if capacity <= 0:
            raise ValueError
    except ValueError:
        await message.answer("âŒ ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚!\n" "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: 20)")
        return

    await state.update_data(capacity=capacity)

    data = await state.get_data()

    await message.answer(
        "ğŸ’³ <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°</b>\n\n"
        "Ğ¨Ğ°Ğ³ 3 Ğ¸Ğ· 5\n\n"
        f"âœ… Ğ¢Ğ¸Ğ¿: {data['vehicle_type']}\n"
        f"âœ… Ğ“Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ: {capacity} Ñ‚\n\n"
        "ğŸ“ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹:\n"
        "(Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: ĞšÑ€Ğ°ÑĞ½Ğ¾Ğ´Ğ°Ñ€ÑĞºĞ¸Ğ¹ ĞºÑ€Ğ°Ğ¹, Ğ Ğ¾ÑÑ‚Ğ¾Ğ²ÑĞºĞ°Ñ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ)",
        parse_mode="HTML",
    )
    await ExpeditorCardStates.regions.set()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ¨ĞĞ“ 3: Ğ Ğ•Ğ“Ğ˜ĞĞĞ«
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


@dp.message_handler(state=ExpeditorCardStates.regions)
async def expeditor_card_regions(message: types.Message, state: FSMContext):
    """Ğ’Ğ²Ğ¾Ğ´ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ¾Ğ² Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹"""
    regions = message.text.strip()

    await state.update_data(regions=regions)

    data = await state.get_data()

    await message.answer(
        "ğŸ’³ <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°</b>\n\n"
        "Ğ¨Ğ°Ğ³ 4 Ğ¸Ğ· 5\n\n"
        f"âœ… Ğ¢Ğ¸Ğ¿: {data['vehicle_type']}\n"
        f"âœ… Ğ“Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ: {data['capacity']} Ñ‚\n"
        f"âœ… Ğ ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹: {regions}\n\n"
        "ğŸ’° Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ÑÑ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ Ğ·Ğ° ĞºĞ¼ (â‚½/ĞºĞ¼):\n"
        "(Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: 25.50)",
        parse_mode="HTML",
    )
    await ExpeditorCardStates.price_per_km.set()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ¨ĞĞ“ 4: Ğ¦Ğ•ĞĞ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


@dp.message_handler(state=ExpeditorCardStates.price_per_km)
async def expeditor_card_price(message: types.Message, state: FSMContext):
    """Ğ’Ğ²Ğ¾Ğ´ Ñ†ĞµĞ½Ñ‹ Ğ·Ğ° ĞºĞ¼"""
    try:
        price = float(message.text.replace(",", "."))
        if price <= 0:
            raise ValueError
    except ValueError:
        await message.answer("âŒ ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚!\n" "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: 25.50)")
        return

    await state.update_data(price_per_km=price)

    data = await state.get_data()

    await message.answer(
        "ğŸ’³ <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°</b>\n\n"
        "Ğ¨Ğ°Ğ³ 5 Ğ¸Ğ· 5\n\n"
        f"âœ… Ğ¢Ğ¸Ğ¿: {data['vehicle_type']}\n"
        f"âœ… Ğ“Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ: {data['capacity']} Ñ‚\n"
        f"âœ… Ğ ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹: {data['regions']}\n"
        f"âœ… Ğ¦ĞµĞ½Ğ°: {price:.2f} â‚½/ĞºĞ¼\n\n"
        "ğŸ“ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ (Ğ¾Ğ¿Ñ‹Ñ‚ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹, Ğ¾ÑĞ¾Ğ±ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸):\n"
        "Ğ¸Ğ»Ğ¸ /skip Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ",
        parse_mode="HTML",
    )
    await ExpeditorCardStates.description.set()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ¨ĞĞ“ 5: ĞĞŸĞ˜Ğ¡ĞĞĞ˜Ğ• (Ğ¤Ğ˜ĞĞĞ›) - Ğ¡ĞĞ¥Ğ ĞĞĞ•ĞĞ˜Ğ• ĞšĞĞ Ğ¢ĞĞ§ĞšĞ˜
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
@dp.message_handler(lambda m: m.text == "/skip", state=ExpeditorCardStates.description)
@dp.message_handler(state=ExpeditorCardStates.description)
async def expeditor_card_description(message: types.Message, state: FSMContext):
    """Ğ’Ğ²Ğ¾Ğ´ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ Ğ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸"""

    try:
        if message.text != "/skip":
            description = message.text.strip()
        else:
            description = "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾"

        await state.update_data(description=description)
        data = await state.get_data()
        user_id = message.from_user.id

        logging.info(f"ğŸ“ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ğ´Ğ»Ñ user_id={user_id}")

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Ğ¡ĞĞ—Ğ”ĞĞĞœ ĞšĞĞ Ğ¢ĞĞ§ĞšĞ£
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        expeditor_cards[user_id] = {
            "user_id": user_id,
            "vehicle_type": data["vehicle_type"],
            "capacity": data["capacity"],
            "regions": data["regions"],
            "price_per_km": data["price_per_km"],
            "description": description,
            "status": "active",
            "created_at": datetime.now().strftime("%d.%m.%Y %H:%M"),
            "views": 0,
            "user_name": users.get(user_id, {}).get("name", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾"),
            "company": users.get(user_id, {}).get("company_details", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°"),
            "phone": users.get(user_id, {}).get("phone", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"),
            "email": users.get(user_id, {}).get("email", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"),
            "inn": users.get(user_id, {}).get("inn", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"),  # âœ…
            "ogrn": users.get(user_id, {}).get("ogrn", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"),  # âœ…
        }

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Ğ¡ĞĞ¥Ğ ĞĞĞ¯Ğ•Ğœ
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        save_data()

        logging.info(f"âœ… Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€ {user_id} ÑĞ¾Ğ·Ğ´Ğ°Ğ» ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ")

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ĞŸĞĞšĞĞ—Ğ«Ğ’ĞĞ•Ğœ Ğ Ğ•Ğ—Ğ£Ğ›Ğ¬Ğ¢ĞĞ¢
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        card = expeditor_cards[user_id]
        transport = data.get("vehicle_type", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        emoji = get_vehicle_emoji(transport)

        text = (
            "âœ… <b>ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ°!</b>\n\n"
            f"{emoji} <b>Ğ¢Ğ¸Ğ¿:</b> {transport}\n"
            f"ğŸ“¦ <b>Ğ“Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ:</b> {data['capacity']} Ñ‚\n"
            f"ğŸ“ <b>Ğ ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹:</b> {data['regions']}\n"
            f"ğŸ’° <b>Ğ¦ĞµĞ½Ğ°:</b> {data['price_per_km']:.2f} â‚½/ĞºĞ¼\n"
            f"ğŸ“ <b>ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ:</b> {description}\n\n"
            "âœ¨ Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ñ‹ ÑĞ¼Ğ¾Ğ³ÑƒÑ‚ Ğ½Ğ°Ğ¹Ñ‚Ğ¸ Ğ²Ğ°ÑˆÑƒ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ!"
        )

        keyboard = expeditor_keyboard()

        await message.answer(text, reply_markup=keyboard, parse_mode="HTML")
        await state.finish()

    except Exception as e:
        logging.error(f"âŒ ĞĞ¨Ğ˜Ğ‘ĞšĞ Ğ² expeditor_card_description: {e}", exc_info=True)
        await message.answer("âŒ ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ÑĞ½Ğ¾Ğ²Ğ° /start")
        await state.finish()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ Ğ•Ğ”ĞĞšĞ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ• ĞšĞĞ Ğ¢ĞĞ§ĞšĞ˜
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


@dp.callback_query_handler(lambda c: c.data == "edit_expeditor_card", state="*")
async def edit_expeditor_card_callback(
    callback: types.CallbackQuery, state: FSMContext
):
    """Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°"""
    await state.finish()

    user_id = callback.from_user.id
    offer_id = None
    offer = None

    for oid, off in expeditor_offers.items():
        if off.get("expeditor_id") == user_id:
            offer_id = oid
            offer = off
            break

    if not offer_id and "expeditor_cards" in globals():
        for cid, card in expeditor_cards.items():
            if card.get("user_id") == user_id or card.get("expeditor_id") == user_id:
                offer_id = cid
                offer = card
                break

    if not offer_id or not offer:
        await callback.answer("âŒ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸", show_alert=True)
        return

    status = offer.get("status", "active")
    if status != "active":
        await callback.answer(
            "âŒ ĞœĞ¾Ğ¶Ğ½Ğ¾ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸", show_alert=True
        )
        return

    text = "âœï¸ <b>Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸</b>\n"
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"

    service_type = offer.get(
        "service_type",
        offer.get("vehicle_type", offer.get("transport_type", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")),
    )
    price = offer.get("price", offer.get("price_per_km", 0))
    capacity = offer.get("capacity", offer.get("cargo_capacity", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°"))
    regions = offer.get("ports", offer.get("regions", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ñ‹"))
    description = offer.get("description", offer.get("notes", ""))

    emoji = get_vehicle_emoji(service_type)
    text += f"{emoji} <b>Ğ¢Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°</b>\n   <code>{service_type}</code>\n\n"
    text += f"ğŸ’° <b>Ğ¦ĞµĞ½Ğ° Ğ·Ğ° ĞºĞ¼</b>\n   <code>{price:,.2f} â‚½/ĞºĞ¼</code>\n\n"
    text += f"ğŸ“¦ <b>Ğ“Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ</b>\n   <code>{capacity} Ñ‚</code>\n\n"
    text += f"ğŸ—º <b>Ğ ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹</b>\n   <code>{regions}</code>\n\n"

    text += f"ğŸ“ <b>ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ</b>\n"
    if description and description != "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾":
        desc_preview = (
            description[:50] + "..." if len(description) > 50 else description
        )
        text += f"   <code>{desc_preview}</code>\n"  # â† Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ!
    else:
        text += f"   <i>ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾</i>\n"

    text += "\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
    text += "<i>ğŸ‘‡ Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€ Ğ´Ğ»Ñ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ</i>"

    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton(
            "ğŸš› Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚", callback_data=f"edit_exp_field_service_type_{offer_id}"
        ),
        InlineKeyboardButton(
            "ğŸ’° Ğ¦ĞµĞ½Ğ°", callback_data=f"edit_exp_field_price_{offer_id}"
        ),
    )
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ“¦ Ğ“Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ", callback_data=f"edit_exp_field_capacity_{offer_id}"
        ),
        InlineKeyboardButton(
            "ğŸ—º Ğ ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹", callback_data=f"edit_exp_field_ports_{offer_id}"
        ),
    )
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ“ ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ", callback_data=f"edit_exp_field_description_{offer_id}"
        )
    )
    keyboard.add(
        InlineKeyboardButton("â—€ï¸ Ğš ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞµ", callback_data="expeditor_my_card")
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("edit_exp_field_"), state="*")
async def edit_expeditor_field_handler(
    callback: types.CallbackQuery, state: FSMContext
):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ğ¿Ğ¾Ğ»Ñ Ğ´Ğ»Ñ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ"""
    await state.finish()

    try:
        # edit_exp_field_service_type_1481790360
        # ['edit', 'exp', 'field', 'service', 'type', '1481790360']

        parts = callback.data.split("_")

        # ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğ¹ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚ - Ğ²ÑĞµĞ³Ğ´Ğ° ID
        offer_id = int(parts[-1])

        # ĞŸĞ¾Ğ»Ğµ - Ğ²ÑÑ‘ Ğ¼ĞµĞ¶Ğ´Ñƒ 'field' Ğ¸ ID
        # ĞĞ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: service_type, price, capacity, ports, description
        field_parts = parts[3:-1]  # ['service', 'type'] Ğ¸Ğ»Ğ¸ ['price']
        field = "_".join(field_parts)  # 'service_type' Ğ¸Ğ»Ğ¸ 'price'

    except (IndexError, ValueError) as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ°Ñ€ÑĞ¸Ğ½Ğ³Ğ° callback_data: {callback.data} | {e}")
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
        return

    user_id = callback.from_user.id

    # ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ
    if (
        offer_id in expeditor_cards
        and expeditor_cards[offer_id].get("user_id") == user_id
    ):
        offer = expeditor_cards[offer_id]
    elif (
        offer_id in expeditor_offers
        and expeditor_offers[offer_id].get("expeditor_id") == user_id
    ):
        offer = expeditor_offers[offer_id]
    else:
        await callback.answer("âŒ ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ğ Ğ•Ğ”ĞĞšĞ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ• Ğ¢Ğ˜ĞŸ Ğ¢Ğ ĞĞĞ¡ĞŸĞĞ Ğ¢Ğ
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if field == "service_type":  # â† Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ!
        keyboard = InlineKeyboardMarkup(row_width=2)
        keyboard.add(
            InlineKeyboardButton(
                "ğŸš› Ğ¤ÑƒÑ€Ğ°", callback_data=f"exp_update_type_Ğ¤ÑƒÑ€Ğ°_{offer_id}"
            ),
            InlineKeyboardButton(
                "ğŸšš Ğ“Ñ€ÑƒĞ·Ğ¾Ğ²Ğ¸Ğº", callback_data=f"exp_update_type_Ğ“Ñ€ÑƒĞ·Ğ¾Ğ²Ğ¸Ğº_{offer_id}"
            ),
            InlineKeyboardButton(
                "ğŸš Ğ“Ğ°Ğ·ĞµĞ»ÑŒ", callback_data=f"exp_update_type_Ğ“Ğ°Ğ·ĞµĞ»ÑŒ_{offer_id}"
            ),
            InlineKeyboardButton(
                "ğŸš‚ Ğ–/Ğ´ Ğ²Ğ°Ğ³Ğ¾Ğ½", callback_data=f"exp_update_type_Ğ–/Ğ´ Ğ²Ğ°Ğ³Ğ¾Ğ½_{offer_id}"
            ),
            InlineKeyboardButton(
                "ğŸš¢ Ğ‘Ğ°Ñ€Ğ¶Ğ°", callback_data=f"exp_update_type_Ğ‘Ğ°Ñ€Ğ¶Ğ°_{offer_id}"
            ),
        )
        keyboard.add(
            InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="edit_expeditor_card")
        )

        await callback.message.edit_text(
            "ğŸš› <b>Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ñ‚Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°:</b>",
            reply_markup=keyboard,
            parse_mode="HTML",
        )

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ğ Ğ•Ğ”ĞĞšĞ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ• Ğ¦Ğ•ĞĞ
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    elif field == "price":
        await state.update_data(edit_offer_id=offer_id, edit_field="price")
        await callback.message.edit_text(
            "ğŸ’° <b>Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ†ĞµĞ½Ñ‹</b>\n\n"
            f"Ğ¢ĞµĞºÑƒÑ‰Ğ°Ñ Ñ†ĞµĞ½Ğ°: {offer.get('price', offer.get('price_per_km', 0)):.2f} â‚½/ĞºĞ¼\n\n"
            "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²ÑƒÑ Ñ†ĞµĞ½Ñƒ Ğ·Ğ° ĞºĞ¼:",
            parse_mode="HTML",
        )
        await ExpeditorEditStates.price.set()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ğ Ğ•Ğ”ĞĞšĞ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ• Ğ“Ğ Ğ£Ğ—ĞĞŸĞĞ”ĞªĞĞœĞĞĞ¡Ğ¢Ğ¬
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    elif field == "capacity":
        await state.update_data(edit_offer_id=offer_id, edit_field="capacity")
        await callback.message.edit_text(
            "ğŸ“¦ <b>Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ³Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚Ğ¸</b>\n\n"
            f"Ğ¢ĞµĞºÑƒÑ‰Ğ°Ñ Ğ³Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ: {offer.get('capacity', offer.get('cargo_capacity', 0))} Ñ‚\n\n"
            "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²ÑƒÑ Ğ³Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ (Ğ² Ñ‚Ğ¾Ğ½Ğ½Ğ°Ñ…):",
            parse_mode="HTML",
        )
        await ExpeditorEditStates.capacity.set()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ğ Ğ•Ğ”ĞĞšĞ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ• Ğ Ğ•Ğ“Ğ˜ĞĞĞ«
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    elif field == "ports":
        await state.update_data(edit_offer_id=offer_id, edit_field="regions")
        await callback.message.edit_text(
            "ğŸ—º <b>Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ¾Ğ²</b>\n\n"
            f"Ğ¢ĞµĞºÑƒÑ‰Ğ¸Ğµ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹: {offer.get('ports', offer.get('regions', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ñ‹'))}\n\n"
            "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ñ‹Ğµ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹:",
            parse_mode="HTML",
        )
        await ExpeditorEditStates.regions.set()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ğ Ğ•Ğ”ĞĞšĞ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ• ĞĞŸĞ˜Ğ¡ĞĞĞ˜Ğ•
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    elif field == "description":
        await state.update_data(edit_offer_id=offer_id, edit_field="description")
        await callback.message.edit_text(
            "ğŸ“ <b>Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ</b>\n\n"
            f"Ğ¢ĞµĞºÑƒÑ‰ĞµĞµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ: {offer.get('description', offer.get('notes', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾'))}\n\n"
            "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ğ¾Ğµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ:",
            parse_mode="HTML",
        )
        await ExpeditorEditStates.description.set()

    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("exp_update_type_"), state="*")
async def update_expeditor_type(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ñ‚Ğ¸Ğ¿Ğ° Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°"""
    await state.finish()

    try:
        # exp_update_type_Ğ¤ÑƒÑ€Ğ°_1481790360
        parts = callback.data.split("_")

        # ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğ¹ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚ - ID
        offer_id = int(parts[-1])

        # Ğ’ÑÑ‘ Ğ¼ĞµĞ¶Ğ´Ñƒ 'type' Ğ¸ ID - Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°
        # ĞœĞ¾Ğ¶ĞµÑ‚ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ğ±ĞµĞ»Ñ‹, Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: "Ğ–/Ğ´ Ğ²Ğ°Ğ³Ğ¾Ğ½"
        new_type = "_".join(parts[3:-1])

    except (IndexError, ValueError) as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ°Ñ€ÑĞ¸Ğ½Ğ³Ğ°: {callback.data} | {e}")
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    user_id = callback.from_user.id

    logging.info(
        f"ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ñ‚Ğ¸Ğ¿Ğ° Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°: offer_id={offer_id}, new_type='{new_type}'"
    )

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ĞĞ‘ĞĞĞ’Ğ›Ğ¯Ğ•Ğœ Ğ”ĞĞĞĞ«Ğ•
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    updated = False

    if (
        offer_id in expeditor_cards
        and expeditor_cards[offer_id].get("user_id") == user_id
    ):
        expeditor_cards[offer_id]["transport_type"] = new_type
        updated = True
        logging.info(f"âœ… ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾ Ğ² expeditor_cards")
    elif (
        offer_id in expeditor_offers
        and expeditor_offers[offer_id].get("expeditor_id") == user_id
    ):
        expeditor_offers[offer_id]["service_type"] = new_type
        updated = True
        logging.info(f"âœ… ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾ Ğ² expeditor_offers")

    if not updated:
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°", show_alert=True)
        return

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ğ¡ĞĞ¥Ğ ĞĞĞ¯Ğ•Ğœ
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    save_data()

    await callback.answer(f"âœ… Ğ¢Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ° Ğ¸Ğ·Ğ¼ĞµĞ½Ñ‘Ğ½ Ğ½Ğ°: {new_type}")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ğ’ĞĞ—Ğ’Ğ ĞĞ©ĞĞ•ĞœĞ¡Ğ¯ Ğš ĞœĞ•ĞĞ® Ğ Ğ•Ğ”ĞĞšĞ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ¯
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»Ñ‘Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
    if offer_id in expeditor_cards:
        offer = expeditor_cards[offer_id]
    else:
        offer = expeditor_offers[offer_id]

    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¼ĞµĞ½Ñ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ñ Ğ½Ğ¾Ğ²Ñ‹Ğ¼Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸
    text = "âœï¸ <b>Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸</b>\n"
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"

    service_type = offer.get(
        "service_type",
        offer.get("vehicle_type", offer.get("transport_type", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")),
    )
    price = offer.get("price", offer.get("price_per_km", 0))
    capacity = offer.get("capacity", offer.get("cargo_capacity", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°"))
    regions = offer.get("ports", offer.get("regions", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ñ‹"))
    description = offer.get("description", offer.get("notes", ""))

    emoji = get_vehicle_emoji(service_type)
    text += f"{emoji} <b>Ğ¢Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°</b>\n   <code>{service_type}</code>\n\n"
    text += f"ğŸ’° <b>Ğ¦ĞµĞ½Ğ° Ğ·Ğ° ĞºĞ¼</b>\n   <code>{price:,.2f} â‚½/ĞºĞ¼</code>\n\n"
    text += f"ğŸ“¦ <b>Ğ“Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ</b>\n   <code>{capacity} Ñ‚</code>\n\n"
    text += f"ğŸ—º <b>Ğ ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹</b>\n   <code>{regions}</code>\n\n"

    text += f"ğŸ“ <b>ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ</b>\n"
    if description and description != "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾":
        desc_preview = (
            description[:50] + "..." if len(description) > 50 else description
        )
        text += f"   <code>{desc_preview}</code>\n"
    else:
        text += f"   <i>ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾</i>\n"

    text += "\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
    text += "<i>ğŸ‘‡ Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€ Ğ´Ğ»Ñ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ</i>"

    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton(
            "ğŸš› Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚", callback_data=f"edit_exp_field_service_type_{offer_id}"
        ),
        InlineKeyboardButton(
            "ğŸ’° Ğ¦ĞµĞ½Ğ°", callback_data=f"edit_exp_field_price_{offer_id}"
        ),
    )
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ“¦ Ğ“Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ", callback_data=f"edit_exp_field_capacity_{offer_id}"
        ),
        InlineKeyboardButton(
            "ğŸ—º Ğ ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹", callback_data=f"edit_exp_field_ports_{offer_id}"
        ),
    )
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ“ ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ", callback_data=f"edit_exp_field_description_{offer_id}"
        )
    )
    keyboard.add(
        InlineKeyboardButton("â—€ï¸ Ğš ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞµ", callback_data="expeditor_my_card")
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜ĞšĞ˜ Ğ’Ğ’ĞĞ”Ğ ĞĞĞ’Ğ«Ğ¥ Ğ—ĞĞĞ§Ğ•ĞĞ˜Ğ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


@dp.message_handler(state=ExpeditorEditStates.price)
async def update_expeditor_price(message: types.Message, state: FSMContext):
    """ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ñ†ĞµĞ½Ñ‹"""
    try:
        new_price = float(message.text.replace(",", "."))
        if new_price <= 0:
            raise ValueError
    except ValueError:
        await message.answer("âŒ ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚! Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: 25.50)")
        return

    data = await state.get_data()
    offer_id = data.get("edit_offer_id")
    user_id = message.from_user.id

    if (
        offer_id in expeditor_cards
        and expeditor_cards[offer_id].get("user_id") == user_id
    ):
        expeditor_cards[offer_id]["price_per_km"] = new_price
    elif (
        offer_id in expeditor_offers
        and expeditor_offers[offer_id].get("expeditor_id") == user_id
    ):
        expeditor_offers[offer_id]["price"] = new_price

    save_data()

    await message.answer(
        f"âœ… Ğ¦ĞµĞ½Ğ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°: {new_price:.2f} â‚½/ĞºĞ¼", reply_markup=expeditor_keyboard()
    )
    await state.finish()


@dp.message_handler(state=ExpeditorEditStates.capacity)
async def update_expeditor_capacity(message: types.Message, state: FSMContext):
    """ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ³Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚Ğ¸"""
    try:
        new_capacity = float(message.text.replace(",", "."))
        if new_capacity <= 0:
            raise ValueError
    except ValueError:
        await message.answer("âŒ ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚! Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: 20)")
        return

    data = await state.get_data()
    offer_id = data.get("edit_offer_id")
    user_id = message.from_user.id

    if (
        offer_id in expeditor_cards
        and expeditor_cards[offer_id].get("user_id") == user_id
    ):
        expeditor_cards[offer_id]["capacity"] = new_capacity
    elif (
        offer_id in expeditor_offers
        and expeditor_offers[offer_id].get("expeditor_id") == user_id
    ):
        expeditor_offers[offer_id]["capacity"] = new_capacity

    save_data()

    await message.answer(
        f"âœ… Ğ“Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°: {new_capacity} Ñ‚",
        reply_markup=expeditor_keyboard(),
    )
    await state.finish()


@dp.message_handler(state=ExpeditorEditStates.regions)
async def update_expeditor_regions(message: types.Message, state: FSMContext):
    """ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ¾Ğ²"""
    new_regions = message.text.strip()

    data = await state.get_data()
    offer_id = data.get("edit_offer_id")
    user_id = message.from_user.id

    if (
        offer_id in expeditor_cards
        and expeditor_cards[offer_id].get("user_id") == user_id
    ):
        expeditor_cards[offer_id]["regions"] = new_regions
    elif (
        offer_id in expeditor_offers
        and expeditor_offers[offer_id].get("expeditor_id") == user_id
    ):
        expeditor_offers[offer_id]["ports"] = new_regions

    save_data()

    await message.answer(
        f"âœ… Ğ ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ñ‹: {new_regions}", reply_markup=expeditor_keyboard()
    )
    await state.finish()


@dp.message_handler(state=ExpeditorEditStates.description)
async def update_expeditor_description(message: types.Message, state: FSMContext):
    """ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ"""
    new_description = message.text.strip()

    data = await state.get_data()
    offer_id = data.get("edit_offer_id")
    user_id = message.from_user.id

    if (
        offer_id in expeditor_cards
        and expeditor_cards[offer_id].get("user_id") == user_id
    ):
        expeditor_cards[offer_id]["description"] = new_description
    elif (
        offer_id in expeditor_offers
        and expeditor_offers[offer_id].get("expeditor_id") == user_id
    ):
        expeditor_offers[offer_id]["description"] = new_description

    save_data()

    await message.answer(f"âœ… ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾", reply_markup=expeditor_keyboard())
    await state.finish()


@dp.callback_query_handler(lambda c: c.data == "expeditor_my_card", state="*")
async def expeditor_my_card_callback(callback: types.CallbackQuery, state: FSMContext):
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğº Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ñƒ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°"""
    await state.finish()

    user_id = callback.from_user.id

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ
    card = expeditor_cards.get(user_id)

    if not card:
        await callback.answer("âŒ ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    # ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ
    transport = card.get("transport_type", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
    emoji = get_vehicle_emoji(transport)

    text = (
        f"ğŸ’³ <b>ĞœĞ¾Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°</b>\n\n"
        f"{emoji} <b>Ğ¢Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°:</b> {transport}\n"
        f"ğŸ“¦ <b>Ğ“Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ:</b> {card.get('capacity', 0)} Ñ‚\n"
        f"ğŸ“ <b>Ğ ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹:</b> {card.get('regions', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ñ‹')}\n"
        f"ğŸ’° <b>Ğ¦ĞµĞ½Ğ° Ğ·Ğ° ĞºĞ¼:</b> {card.get('price_per_km', 0):.2f} â‚½/ĞºĞ¼\n"
        f"ğŸ“ <b>ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ:</b>\n{card.get('description', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n\n"
        f"ğŸ“… <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ°:</b> {card.get('created_at', 'Ğ/Ğ”')}\n"
        f"ğŸ‘ <b>ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ¾Ğ²:</b> {card.get('views', 0)}"
    )

    keyboard = InlineKeyboardMarkup(row_width=1)
    keyboard.add(
        InlineKeyboardButton("âœï¸ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ", callback_data="edit_expeditor_card"),
        InlineKeyboardButton(
            "ğŸ—‘ Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ", callback_data="delete_expeditor_card"
        ),
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ£Ğ”ĞĞ›Ğ•ĞĞ˜Ğ• ĞšĞĞ Ğ¢ĞĞ§ĞšĞ˜
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


@dp.callback_query_handler(lambda c: c.data == "delete_expeditor_card", state="*")
async def delete_expeditor_card(callback: types.CallbackQuery):
    """Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°"""
    user_id = callback.from_user.id

    if user_id in expeditor_cards:
        del expeditor_cards[user_id]
        await callback.answer("âœ… ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ°", show_alert=True)
        await callback.message.edit_text(
            "ğŸ—‘ <b>ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ°</b>\n\n"
            "Ğ’Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²ÑƒÑ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ Ğ² Ğ»ÑĞ±Ğ¾Ğ¹ Ğ¼Ğ¾Ğ¼ĞµĞ½Ñ‚.",
            parse_mode="HTML",
        )
        logging.info(f"ğŸ—‘ Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€ {user_id} ÑƒĞ´Ğ°Ğ»Ğ¸Ğ» ÑĞ²Ğ¾Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ")
    else:
        await callback.answer("âŒ ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ĞĞ¢ĞœĞ•ĞĞ Ğ¡ĞĞ—Ğ”ĞĞĞ˜Ğ¯
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


@dp.callback_query_handler(
    lambda c: c.data == "cancel_expeditor_card_creation", state="*"
)
async def cancel_expeditor_card_creation(
    callback: types.CallbackQuery, state: FSMContext
):
    """ĞÑ‚Ğ¼ĞµĞ½Ğ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸"""
    await state.finish()
    await callback.answer("âŒ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾")
    await callback.message.edit_text(
        "âŒ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾.\n" "Ğ’Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒÑÑ Ğº ÑÑ‚Ğ¾Ğ¼Ñƒ Ğ¿Ğ¾Ğ·Ğ¶Ğµ.",
        parse_mode="HTML",
    )


@dp.callback_query_handler(lambda c: c.data.startswith("view_request:"), state="*")
async def view_request_details(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹ Ğ·Ğ°ÑĞ²ĞºĞ¸ - Ğ£ĞĞ˜Ğ’Ğ•Ğ Ğ¡ĞĞ›Ğ¬ĞĞ«Ğ™ Ğ´Ğ»Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ² Ğ¸ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ²"""
    await state.finish()

    try:
        await callback.answer()
    except Exception as e:
        logging.warning(f"Callback answer error: {e}")

    parts = callback.data.split(":")

    if len(parts) == 2:
        source = "exporter"
        try:
            request_id = int(parts[1])
        except ValueError:
            return
    elif len(parts) == 3:
        source = parts[1]
        try:
            request_id = int(parts[2])
        except ValueError:
            return
    else:
        return

    # ============ Ğ—ĞĞ¯Ğ’ĞšĞ ĞĞ¢ Ğ­ĞšĞ¡ĞŸĞĞ Ğ¢Ğ•Ğ Ğ ============
    if source == "exporter":
        if request_id not in shipping_requests:
            return

        request = shipping_requests[request_id]
        pull_id = request.get("pull_id")
        pull = pulls.get(pull_id, {})
        user_id = request.get("exporter_id")
        user = users.get(user_id, {})

        price_fob = pull.get("price", 0)
        price_rub = int(price_fob * 95) if price_fob else 0

        text = f"""ğŸšš <b>Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ #{request_id}</b>



<b>Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ³Ñ€ÑƒĞ·Ğµ:</b>
ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {request.get('culture', 'â€”')}
ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: {request.get('volume', 0):.0f} Ñ‚
ğŸ’° Ğ¦ĞµĞ½Ğ° FOB: {price_rub:,} â‚½/Ñ‚
ğŸš¢ ĞŸĞ¾Ñ€Ñ‚: {pull.get('port', 'â€”')}



<b>ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚:</b>
ğŸ“ ĞÑ‚ĞºÑƒĞ´Ğ°: {request.get('route_from', 'â€”')}
ğŸ“ ĞšÑƒĞ´Ğ°: {request.get('route_to', 'â€”')}
ğŸ“… Ğ–ĞµĞ»Ğ°ĞµĞ¼Ğ°Ñ Ğ´Ğ°Ñ‚Ğ°: {request.get('desired_date', 'â€”')}



<b>ğŸ‘¤ Ğ—Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸Ğº (ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€):</b>
ğŸ¢ ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ: {user.get('company_name', 'N/A')}
ğŸ‘¤ Ğ˜Ğ¼Ñ: {user.get('name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}
ğŸ“ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <code>{user.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>
ğŸ“§ Email: {user.get('email', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}
ğŸ“ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½: {user.get('region', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}
ğŸ’¬ Username: @{user.get('username', 'Ğ½ĞµÑ‚')}



<b>Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ:</b> {request.get('status', 'active').upper()}
ğŸ“… Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ°: {request.get('created_at', 'â€”')}
"""

    # ============ Ğ—ĞĞ¯Ğ’ĞšĞ ĞĞ¢ Ğ¤Ğ•Ğ ĞœĞ•Ğ Ğ ============
    else:
        if request_id not in farmer_logistics_requests:
            return

        request = farmer_logistics_requests[request_id]
        user_id = request.get("farmer_id")
        user = users.get(user_id, {})

        text = f"""ğŸŒ¾ <b>Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ·Ğ°ÑĞ²ĞºĞ° Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ° #{request_id}</b>



<b>Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ³Ñ€ÑƒĞ·Ğµ:</b>
ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {request.get('culture', 'â€”')}
ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: {request.get('volume', 0):.0f} Ñ‚
ğŸ’° Ğ¦ĞµĞ½Ğ°: {request.get('price_per_ton', 0):,} â‚½/Ñ‚
ğŸ’µ Ğ˜Ñ‚Ğ¾Ğ³Ğ¾: {request.get('total_sum', 0):,} â‚½



<b>ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚:</b>
ğŸ“ ĞÑ‚: {request.get('route_from', 'â€”')}
â›´ï¸ Ğ”Ğ¾ (ĞŸĞ¾Ñ€Ñ‚): {request.get('route_to', 'â€”')}
ğŸšš Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚: {request.get('transport_type', 'â€”')}
ğŸ“… Ğ”Ğ°Ñ‚Ğ°: {request.get('desired_date', 'â€”')}



<b>Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸:</b>
ğŸ’³ ĞĞ¶Ğ¸Ğ´Ğ°ĞµĞ¼Ğ°Ñ Ñ†ĞµĞ½Ğ°: {request.get('desired_price', 0):,} â‚½/Ñ‚



<b>ğŸ‘¤ Ğ—Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸Ğº (Ñ„ĞµÑ€Ğ¼ĞµÑ€):</b>
ğŸ¢ ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ: {user.get('company_name', 'N/A')}
ğŸ‘¤ Ğ˜Ğ¼Ñ: {user.get('name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}
ğŸ“ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <code>{user.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>
ğŸ“§ Email: {user.get('email', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}
ğŸ“ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½: {user.get('region', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}
ğŸ’¬ Username: @{user.get('username', 'Ğ½ĞµÑ‚')}



<b>Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ:</b> {request.get('status', 'active').upper()}
ğŸ“… Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ°: {request.get('created_at', 'â€”')}
ğŸ“¬ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹: {len(request.get('offers', []))}
"""

    # ============ ĞšĞĞĞŸĞšĞ˜ Ğ”Ğ›Ğ¯ ĞĞ‘ĞĞ˜Ğ¥ Ğ¢Ğ˜ĞŸĞĞ’ ============
    keyboard = InlineKeyboardMarkup(row_width=1)

    keyboard.add(
        InlineKeyboardButton("ğŸ“ Ğ¡Ğ²ÑĞ·Ğ°Ñ‚ÑŒÑÑ Ñ Ğ·Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸ĞºĞ¾Ğ¼", url=f"tg://user?id={user_id}")
    )

    logist_id = callback.from_user.id
    existing_offers = [
        offer
        for offer in logistic_offers.values()
        if offer.get("request_id") == request_id
        and offer.get("logist_id") == logist_id
        and offer.get("status") not in ["cancelled", "rejected"]
    ]

    if existing_offers:
        offer = existing_offers[0]
        text += f"\n\nâœ… <b>Ğ’Ñ‹ ÑƒĞ¶Ğµ ÑĞ´ĞµĞ»Ğ°Ğ»Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ:</b>\n"
        text += f"ğŸš› Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚: {offer.get('vehicle_type', 'â€”')}\n"
        text += f"ğŸ’° Ğ¦ĞµĞ½Ğ°: {offer.get('price', 0):,} â‚½\n"
        text += f"ğŸ“… Ğ”Ğ°Ñ‚Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸: {offer.get('delivery_date', 'â€”')}\n"
        text += f"ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: {get_offer_status_display(offer.get('status', 'pending'))}"  # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ

        keyboard.add(
            InlineKeyboardButton("â—€ï¸ Ğš ÑĞ¿Ğ¸ÑĞºÑƒ Ğ·Ğ°ÑĞ²Ğ¾Ğº", callback_data="back_to_requests")
        )
    else:
        keyboard.add(
            InlineKeyboardButton(
                "ğŸ’° Ğ¡Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ",
                callback_data=f"make_offer:{source}:{request_id}",
            ),
            InlineKeyboardButton("â—€ï¸ Ğš ÑĞ¿Ğ¸ÑĞºÑƒ Ğ·Ğ°ÑĞ²Ğ¾Ğº", callback_data="back_to_requests"),
        )

    try:
        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    except Exception as e:
        logging.error(f"Error editing message for request {request_id}: {e}")
        try:
            await callback.message.answer(
                text, reply_markup=keyboard, parse_mode="HTML"
            )
        except Exception as e2:
            logging.error(f"Error sending new message: {e2}")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢: Ğ‘ĞĞ—Ğ Ğ­ĞšĞ¡ĞŸĞ•Ğ”Ğ˜Ğ¢ĞĞ ĞĞ’
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


@dp.message_handler(lambda m: m.text == "ğŸš› Ğ‘Ğ°Ğ·Ğ° ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²", state="*")
async def logist_view_expeditors(message: types.Message, state: FSMContext):
    """Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ°Ñ‚Ñ€Ğ¸Ğ²Ğ°ĞµÑ‚ Ğ±Ğ°Ğ·Ñƒ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²"""
    await state.finish()

    user_id = message.from_user.id

    if user_id not in users or users[user_id].get("role") != "logistic":
        await message.answer("âŒ Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°Ğ¼")
        return

    if not expeditor_cards:
        await message.answer(
            "ğŸš› <b>Ğ‘Ğ°Ğ·Ğ° ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²</b>\n\n"
            "ğŸ“‹ Ğ’ Ğ±Ğ°Ğ·Ğµ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ².\n\n"
            "ĞšĞ°Ğº Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ñ‹ ÑĞ¾Ğ·Ğ´Ğ°Ğ´ÑƒÑ‚ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸, Ğ²Ñ‹ ÑĞ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¸Ñ… ÑƒĞ²Ğ¸Ğ´ĞµÑ‚ÑŒ Ğ·Ğ´ĞµÑÑŒ.",
            parse_mode="HTML",
        )
        return

    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ¿Ğ¸ÑĞ¾Ğº ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²
    keyboard = InlineKeyboardMarkup(row_width=1)

    text = (
        "ğŸš› <b>Ğ‘Ğ°Ğ·Ğ° ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²</b>\n\n"
        f"ğŸ“‹ Ğ’ÑĞµĞ³Ğ¾ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²: <b>{len(expeditor_cards)}</b>\n\n"
        "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ° Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ° ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸:"
    )

    for exp_id, card in list(expeditor_cards.items())[:20]:  # ĞœĞ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ 20
        # Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: transport_type Ğ²Ğ¼ĞµÑÑ‚Ğ¾ vehicle_type
        transport = card.get("transport_type", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        capacity = card.get("capacity", 0)
        regions = card.get("regions", [])
        price = card.get("price_per_km", 0)

        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ÑĞ¼Ğ¾Ğ´Ğ·Ğ¸ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°
        emoji = TRANSPORT_TYPES.get(transport, "ğŸš›")

        # Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹ (ÑĞ¿Ğ¸ÑĞ¾Ğº â†’ ÑÑ‚Ñ€Ğ¾ĞºĞ°)
        if isinstance(regions, list):
            regions_text = ", ".join(regions) if regions else "Ğ ĞµĞ³Ğ¸Ğ¾Ğ½ Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"
        else:
            regions_text = str(regions)

        # ĞĞ±Ñ€ĞµĞ·Ğ°ĞµĞ¼ ĞµÑĞ»Ğ¸ Ğ¾Ñ‡ĞµĞ½ÑŒ Ğ´Ğ»Ğ¸Ğ½Ğ½Ğ¾Ğµ (Ğ¼Ğ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ 30 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²)
        if len(regions_text) > 30:
            regions_text = regions_text[:27] + "..."

        btn_text = f"{emoji} {transport} {capacity}Ñ‚ | {regions_text} | {price}â‚½/ĞºĞ¼"
        keyboard.add(
            InlineKeyboardButton(btn_text, callback_data=f"view_expeditor:{exp_id}")
        )

    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ­ĞšĞ¡ĞŸĞ•Ğ”Ğ˜Ğ¢ĞĞ : Ğ”ĞĞ¡Ğ¢Ğ£ĞŸĞĞ«Ğ• Ğ—ĞĞ¯Ğ’ĞšĞ˜
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


@dp.message_handler(lambda m: m.text == "ğŸšš Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸", state="*")
async def expeditor_view_available_requests(message: types.Message, state: FSMContext):
    """Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ°Ñ‚Ñ€Ğ¸Ğ²Ğ°ĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ¾Ñ‚ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²"""
    await state.finish()

    user_id = message.from_user.id

    if user_id not in users or users[user_id].get("role") != "expeditor":
        await message.answer("âŒ Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°Ğ¼")
        return

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ
    available_requests = [
        req for req in shipping_requests.values() if req.get("status") == "active"
    ]

    if not available_requests:
        await message.answer(
            "ğŸšš <b>Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸</b>\n\n"
            "ğŸ“‹ ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ·Ğ°ÑĞ²Ğ¾Ğº Ğ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ.\n\n"
            "ĞšĞ°Ğº Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ñ‹ ÑĞ¾Ğ·Ğ´Ğ°Ğ´ÑƒÑ‚ Ğ·Ğ°ÑĞ²ĞºĞ¸, Ğ¾Ğ½Ğ¸ Ğ¿Ğ¾ÑĞ²ÑÑ‚ÑÑ Ğ·Ğ´ĞµÑÑŒ.",
            parse_mode="HTML",
        )
        return

    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ·Ğ°ÑĞ²Ğ¾Ğº
    keyboard = InlineKeyboardMarkup(row_width=1)

    text = (
        "ğŸšš <b>Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ</b>\n\n"
        f"ğŸ“‹ Ğ’ÑĞµĞ³Ğ¾ Ğ·Ğ°ÑĞ²Ğ¾Ğº: <b>{len(available_requests)}</b>\n\n"
        "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ·Ğ°ÑĞ²ĞºÑƒ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ° Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹:"
    )

    for req in available_requests[:15]:  # ĞœĞ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ 15
        req_id = req.get("id", "N/A")
        culture = req.get("culture", "N/A")
        volume = req.get("volume", 0) or 0
        route_from = req.get("route_from", "â€”")
        route_to = req.get("route_to", "â€”")

        btn_text = (
            f"ğŸš› #{req_id} | {culture} | {volume:.0f} Ñ‚ | {route_from}â†’{route_to}"
        )
        keyboard.add(
            InlineKeyboardButton(btn_text, callback_data=f"exp_view_req:{req_id}")
        )

    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")


@dp.callback_query_handler(lambda c: c.data.startswith("exp_view_req:"), state="*")
async def expeditor_view_request_details(
    callback: types.CallbackQuery, state: FSMContext
):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹ Ğ·Ğ°ÑĞ²ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ¼"""
    await state.finish()

    try:
        request_id = int(callback.data.split(":")[1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    if request_id not in shipping_requests:
        await callback.answer("âŒ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    request = shipping_requests[request_id]
    pull_id = request.get("pull_id")
    pull = pulls.get(pull_id, {})
    exporter_id = request.get("exporter_id")
    exporter = users.get(exporter_id, {})

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° (ĞµÑĞ»Ğ¸ Ğ·Ğ°ÑĞ²ĞºĞ° Ğ¾Ñ‚ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°)
    logist_id = request.get("logist_id")  # ĞÑƒĞ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑÑ‚Ğ¾ Ğ¿Ğ¾Ğ»Ğµ!
    logist = users.get(logist_id, {}) if logist_id else {}

    # ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ñ†ĞµĞ½Ñƒ
    price_fob = pull.get("price", 0)
    price_rub = int(price_fob * 95) if price_fob else 0

    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ Ğ´ĞµÑ‚Ğ°Ğ»Ğ¸ Ğ·Ğ°ÑĞ²ĞºĞ¸
    text = (
        f"ğŸšš <b>Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ #{request_id}</b>\n\n"
        f"<b>Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ³Ñ€ÑƒĞ·Ğµ:</b>\n"
        f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {request.get('culture', 'â€”')}\n"
        f"ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: {request.get('volume', 0):.0f} Ñ‚\n"
        f"ğŸ’° Ğ¦ĞµĞ½Ğ° FOB: {price_rub:,} â‚½/Ñ‚\n"
        f"ğŸš¢ ĞŸĞ¾Ñ€Ñ‚: {pull.get('port', 'â€”')}\n\n"
        f"<b>ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚:</b>\n"
        f"ğŸ“ ĞÑ‚ĞºÑƒĞ´Ğ°: {request.get('route_from', 'â€”')}\n"
        f"ğŸ“ ĞšÑƒĞ´Ğ°: {request.get('route_to', 'â€”')}\n"
        f"ğŸ“… Ğ–ĞµĞ»Ğ°ĞµĞ¼Ğ°Ñ Ğ´Ğ°Ñ‚Ğ°: {request.get('desired_date', 'â€”')}\n\n"
        f"<b>ğŸ‘¤ Ğ—Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸Ğº (ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€):</b>\n"
        f"ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ: {exporter.get('company_name', 'N/A')}\n"
        f"Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <code>{exporter.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>\n"
        f"Email: {exporter.get('email', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n\n"
    )

    if logist_id:
        text += (
            f"<b>ğŸ‘¤ Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚:</b>\n"
            f"Ğ˜Ğ¼Ñ: {logist.get('name', 'N/A')}\n"
            f"Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <code>{logist.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>\n"
            f"Email: {logist.get('email', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n\n"
        )

    text += f"ğŸ“… Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ°: {request.get('created_at', 'â€”')}"

    keyboard = InlineKeyboardMarkup(row_width=1)

    # ĞšĞ½Ğ¾Ğ¿ĞºĞ¸ ÑĞ²ÑĞ·Ğ¸
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ“ Ğ¡Ğ²ÑĞ·Ğ°Ñ‚ÑŒÑÑ Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ¼", url=f"tg://user?id={exporter_id}"
        )
    )

    if logist_id:
        keyboard.add(
            InlineKeyboardButton(
                "ğŸ“ Ğ¡Ğ²ÑĞ·Ğ°Ñ‚ÑŒÑÑ Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ¼", url=f"tg://user?id={logist_id}"
            )
        )

    # ĞšĞ½Ğ¾Ğ¿ĞºĞ° Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚ÑŒ Ğ·Ğ°ÑĞ²ĞºÑƒ
    keyboard.add(
        InlineKeyboardButton(
            "âœ… ĞŸÑ€Ğ¸Ğ½ÑÑ‚ÑŒ Ğ·Ğ°ÑĞ²ĞºÑƒ", callback_data=f"exp_accept:{request_id}"
        )
    )
    keyboard.add(
        InlineKeyboardButton("â—€ï¸ Ğš ÑĞ¿Ğ¸ÑĞºÑƒ Ğ·Ğ°ÑĞ²Ğ¾Ğº", callback_data="back_to_exp_requests")
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("exp_accept:"), state="*")
async def expeditor_accept_request(callback: types.CallbackQuery, state: FSMContext):
    """Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€ Ğ¿Ñ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°ĞµÑ‚ Ğ·Ğ°ÑĞ²ĞºÑƒ"""
    try:
        request_id = int(callback.data.split(":")[1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    if request_id not in shipping_requests:
        await callback.answer("âŒ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    request = shipping_requests[request_id]
    expeditor_id = callback.from_user.id

    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ·Ğ°ÑĞ²ĞºĞ¸
    request["status"] = "in_progress"
    request["expeditor_id"] = expeditor_id
    request["accepted_at"] = datetime.now().strftime("%d.%m.%Y %H:%M")

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°
    await callback.message.edit_text(
        f"âœ… <b>Ğ—Ğ°ÑĞ²ĞºĞ° #{request_id} Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ°!</b>\n\n"
        f'Ğ—Ğ°ÑĞ²ĞºĞ° Ğ¿ĞµÑ€ĞµĞ¼ĞµÑ‰ĞµĞ½Ğ° Ğ² Ñ€Ğ°Ğ·Ğ´ĞµĞ» <b>"ğŸš› ĞœĞ¾Ğ¸ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸"</b>.\n\n'
        f"Ğ¡Ğ²ÑĞ¶Ğ¸Ñ‚ĞµÑÑŒ Ñ Ğ·Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸ĞºĞ¾Ğ¼ Ğ´Ğ»Ñ ÑƒÑ‚Ğ¾Ñ‡Ğ½ĞµĞ½Ğ¸Ñ Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹.",
        parse_mode="HTML",
    )

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°
    exporter_id = request.get("exporter_id")
    if exporter_id:
        expeditor = users.get(expeditor_id, {})
        try:
            await bot.send_message(
                exporter_id,
                f"âœ… <b>Ğ—Ğ°ÑĞ²ĞºĞ° #{request_id} Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ° ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ¼!</b>\n\n"
                f"ğŸš› Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€: {expeditor.get('name', 'N/A')}\n"
                f"ğŸ“ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <code>{expeditor.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>\n"
                f"ğŸ“§ Email: {expeditor.get('email', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n\n"
                f"Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€ ÑĞºĞ¾Ñ€Ğ¾ ÑĞ²ÑĞ¶ĞµÑ‚ÑÑ Ñ Ğ²Ğ°Ğ¼Ğ¸.",
                parse_mode="HTML",
            )
        except:
            pass

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° (ĞµÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ)
    logist_id = request.get("logist_id")
    if logist_id:
        try:
            await bot.send_message(
                logist_id,
                f"âœ… <b>Ğ—Ğ°ÑĞ²ĞºĞ° #{request_id} Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ° ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ¼!</b>\n\n"
                f"ğŸš› Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€: {expeditor.get('name', 'N/A')}\n"
                f"Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° Ğ½Ğ°Ñ‡Ğ°Ñ‚Ğ°.",
                parse_mode="HTML",
            )
        except:
            pass

    await callback.answer("âœ… Ğ—Ğ°ÑĞ²ĞºĞ° Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ°!", show_alert=True)
    logging.info(f"âœ… Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€ {expeditor_id} Ğ¿Ñ€Ğ¸Ğ½ÑĞ» Ğ·Ğ°ÑĞ²ĞºÑƒ {request_id}")


@dp.callback_query_handler(lambda c: c.data == "back_to_exp_requests", state="*")
async def back_to_exp_requests(callback: types.CallbackQuery, state: FSMContext):
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğº ÑĞ¿Ğ¸ÑĞºÑƒ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ·Ğ°ÑĞ²Ğ¾Ğº"""
    await state.finish()

    available_requests = [
        req for req in shipping_requests.values() if req.get("status") == "active"
    ]

    if not available_requests:
        await callback.message.edit_text(
            "ğŸšš <b>Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸</b>\n\n" "ğŸ“‹ ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ·Ğ°ÑĞ²Ğ¾Ğº Ğ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ.",
            parse_mode="HTML",
        )
        await callback.answer()
        return

    keyboard = InlineKeyboardMarkup(row_width=1)

    text = (
        "ğŸšš <b>Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ</b>\n\n"
        f"ğŸ“‹ Ğ’ÑĞµĞ³Ğ¾ Ğ·Ğ°ÑĞ²Ğ¾Ğº: <b>{len(available_requests)}</b>\n\n"
        "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ·Ğ°ÑĞ²ĞºÑƒ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ° Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹:"
    )

    for req in available_requests[:15]:
        req_id = req.get("id", "N/A")
        culture = req.get("culture", "N/A")
        volume = req.get("volume", 0) or 0
        route_from = req.get("route_from", "â€”")
        route_to = req.get("route_to", "â€”")

        btn_text = (
            f"ğŸš› #{req_id} | {culture} | {volume:.0f} Ñ‚ | {route_from}â†’{route_to}"
        )
        keyboard.add(
            InlineKeyboardButton(btn_text, callback_data=f"exp_view_req:{req_id}")
        )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.message_handler(
    lambda m: m.text == "ğŸš› ĞœĞ¾Ğ¸ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸"
    and users.get(m.from_user.id, {}).get("role") in ["logistic", "expeditor"],
    state="*",
)
async def my_deliveries_handler(message: types.Message, state: FSMContext):
    """Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚/Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ°Ñ‚Ñ€Ğ¸Ğ²Ğ°ĞµÑ‚ ÑĞ²Ğ¾Ğ¸ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸"""
    await state.finish()

    user_id = message.from_user.id

    if user_id not in users:
        await message.answer("âŒ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ /start")
        return

    role = users[user_id].get("role")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if role == "logistic":
        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°
        my_offers = [
            (offer_id, offer)
            for offer_id, offer in logistic_offers.items()
            if offer.get("logist_id") == user_id
        ]

        in_progress = [
            (oid, o)
            for oid, o in my_offers
            if o.get("status") in ["accepted", "in_progress"]
        ]

        completed = [(oid, o) for oid, o in my_offers if o.get("status") == "completed"]

        total_earnings = sum(o.get("price", 0) for _, o in completed)

        if not my_offers:
            await message.answer(
                "ğŸš› <b>ĞœĞ¾Ğ¸ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸</b>\n\n"
                "Ğ£ Ğ²Ğ°Ñ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº.\n"
                "ĞÑ‚ĞºĞ»Ğ¸ĞºĞ°Ğ¹Ñ‚ĞµÑÑŒ Ğ½Ğ° Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ² Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ğµ Â«ğŸšš ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸Â»!\n\n"
                "ğŸ“Š <b>Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°:</b>\n"
                "â€¢ Ğ’ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑĞµ: 0\n"
                "â€¢ Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¾: 0\n"
                "â€¢ Ğ—Ğ°Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½Ğ¾: 0 â‚½",
                parse_mode="HTML",
            )
            return

        keyboard = InlineKeyboardMarkup(row_width=1)

        text = f"ğŸš› <b>ĞœĞ¾Ğ¸ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸</b>\n\n"
        text += f"ğŸ“Š <b>Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°:</b>\n"
        text += f"â€¢ Ğ’ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑĞµ: {len(in_progress)}\n"
        text += f"â€¢ Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¾: {len(completed)}\n"
        text += f"â€¢ Ğ—Ğ°Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½Ğ¾: {total_earnings:,} â‚½\n\n"

        if in_progress:
            text += f"<b>ğŸŸ¢ Ğ’ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑĞµ ({len(in_progress)}):</b>\n\n"

            for offer_id, offer in in_progress[:5]:
                request_id = offer.get("request_id")
                request = shipping_requests.get(request_id, {})

                culture = request.get("culture", "Ğ/Ğ”")
                volume = request.get("volume", 0)
                route_from = request.get("route_from", "?")
                route_to = request.get("route_to", "?")
                price = offer.get("price", 0)

                text += f"ğŸš› <b>#{offer_id}</b> | {culture} {volume:.0f}Ñ‚ | "
                text += f"{route_from}â†’{route_to} | {price:,}â‚½\n"

                keyboard.add(
                    InlineKeyboardButton(
                        f"ğŸ“¦ Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° #{offer_id}",
                        callback_data=f"view_delivery:{offer_id}",
                    )
                )

            if len(in_progress) > 5:
                text += f"\n<i>... Ğ¸ ĞµÑ‰Ñ‘ {len(in_progress) - 5} Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº</i>\n"

        if completed:
            text += f"\n<b>âœ… Ğ—Ğ°Ğ²ĞµÑ€ÑˆÑ‘Ğ½Ğ½Ñ‹Ğµ ({len(completed)}):</b>\n"
            for oid, offer in completed[:3]:
                req_id = offer.get("request_id")
                req = shipping_requests.get(req_id, {})
                text += f"âœ”ï¸ #{oid} | {req.get('culture', 'Ğ/Ğ”')} | {offer.get('price', 0):,}â‚½\n"

        if not keyboard.inline_keyboard:
            keyboard.add(
                InlineKeyboardButton("ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="refresh_deliveries")
            )

        await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ğ­ĞšĞ¡ĞŸĞ•Ğ”Ğ˜Ğ¢ĞĞ 
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    elif role == "expeditor":
        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°
        my_deliveries = [
            req
            for req in shipping_requests.values()
            if req.get("expeditor_id") == user_id and req.get("status") == "in_progress"
        ]

        if not my_deliveries:
            await message.answer(
                "ğŸš› <b>ĞœĞ¾Ğ¸ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸</b>\n\n"
                "ğŸ“‹ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº.\n\n"
                'ĞŸÑ€Ğ¸Ğ¼Ğ¸Ñ‚Ğµ Ğ·Ğ°ÑĞ²ĞºÑƒ Ğ¸Ğ· Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ğ° <b>"ğŸšš Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸"</b>.',
                parse_mode="HTML",
            )
            return

        keyboard = InlineKeyboardMarkup(row_width=1)

        text = (
            "ğŸš› <b>ĞœĞ¾Ğ¸ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸</b>\n\n"
            f"ğŸ“‹ Ğ’ÑĞµĞ³Ğ¾ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº: <b>{len(my_deliveries)}</b>\n\n"
            "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ:"
        )

        for req in my_deliveries:
            req_id = req.get("id", "N/A")
            culture = req.get("culture", "N/A")
            volume = req.get("volume", 0) or 0
            route_to = req.get("route_to", "â€”")

            btn_text = f"ğŸšš #{req_id} | {culture} | {volume:.0f} Ñ‚ â†’ {route_to}"
            keyboard.add(
                InlineKeyboardButton(btn_text, callback_data=f"exp_delivery:{req_id}")
            )

        await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

    else:
        await message.answer(
            "âŒ Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ² Ğ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²"
        )


@dp.callback_query_handler(lambda c: c.data.startswith("exp_delivery:"), state="*")
async def expeditor_delivery_details(callback: types.CallbackQuery, state: FSMContext):
    """Ğ”ĞµÑ‚Ğ°Ğ»Ğ¸ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾Ğ¹ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸"""
    try:
        request_id = int(callback.data.split(":")[1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    if request_id not in shipping_requests:
        await callback.answer("âŒ Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    request = shipping_requests[request_id]
    exporter_id = request.get("exporter_id")
    exporter = users.get(exporter_id, {})

    text = (
        f"ğŸš› <b>Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° #{request_id}</b>\n\n"
        f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {request.get('culture', 'â€”')}\n"
        f"ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: {request.get('volume', 0):.0f} Ñ‚\n"
        f"ğŸ“ ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚: {request.get('route_from', 'â€”')} â†’ {request.get('route_to', 'â€”')}\n"
        f"ğŸ“… Ğ”Ğ°Ñ‚Ğ°: {request.get('desired_date', 'â€”')}\n\n"
        f"<b>ğŸ‘¤ ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹ Ğ·Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸ĞºĞ°:</b>\n"
        f"ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ: {exporter.get('company_name', 'N/A')}\n"
        f"Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <code>{exporter.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>\n"
        f"Email: {exporter.get('email', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n\n"
        f"ğŸ“… ĞŸÑ€Ğ¸Ğ½ÑÑ‚Ğ°: {request.get('accepted_at', 'â€”')}"
    )

    keyboard = InlineKeyboardMarkup(row_width=1)
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ“ Ğ¡Ğ²ÑĞ·Ğ°Ñ‚ÑŒÑÑ Ñ Ğ·Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸ĞºĞ¾Ğ¼", url=f"tg://user?id={exporter_id}"
        ),
        InlineKeyboardButton(
            "âœ… Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚ÑŒ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ", callback_data=f"exp_complete:{request_id}"
        ),
        InlineKeyboardButton(
            "â—€ï¸ Ğš ÑĞ¿Ğ¸ÑĞºÑƒ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº", callback_data="back_to_exp_deliveries"
        ),
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("exp_complete:"), state="*")
async def expeditor_complete_delivery(callback: types.CallbackQuery, state: FSMContext):
    """âœ… Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğµ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸ Ğ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ² Google Sheets"""
    try:
        request_id = int(callback.data.split(":")[1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    if request_id not in shipping_requests:
        await callback.answer("âŒ Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    request = shipping_requests[request_id]
    request["status"] = "completed"
    request["completed_at"] = datetime.now().strftime("%d.%m.%Y %H:%M")

    # âœ… ĞŸĞĞ›Ğ£Ğ§ĞĞ•Ğœ PULL_ID
    pull_id = request.get("pull_id")
    offer_id = callback.data.split(":")[1]  # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ offer_id

    # âœ… Ğ¡ĞĞ¥Ğ ĞĞĞ¯Ğ•Ğœ Ğ’ GOOGLE SHEETS
    success = await save_completed_deal_to_sheets(pull_id, request_id, int(offer_id))

    if success:
        await callback.message.edit_text(
            f"âœ… <b>Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°!</b>\n\n"
            f"ğŸ“Š Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ñ‹ Ğ² Google Sheets\n"
            f"ğŸ“‹ Ğ’ĞºĞ»Ğ°Ğ´ĞºĞ°: 'Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ½Ñ‹Ğµ ÑĞ´ĞµĞ»ĞºĞ¸'",
            parse_mode="HTML",
        )
        logging.info(f"âœ… Ğ¡Ğ´ĞµĞ»ĞºĞ° {pull_id} ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ° Ğ² Google Sheets")
    else:
        await callback.message.edit_text(
            f"âœ… Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°\n\n" f"âš ï¸ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğ¸ Ğ² Google Sheets"
        )
        logging.warning(f"âš ï¸ ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑĞ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ² Google Sheets")

    await callback.answer()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ­ĞšĞ¡ĞŸĞ•Ğ”Ğ˜Ğ¢ĞĞ : Ğ˜Ğ¡Ğ¢ĞĞ Ğ˜Ğ¯ Ğ”ĞĞ¡Ğ¢ĞĞ’ĞĞš
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


@dp.message_handler(lambda m: m.text == "âœ”ï¸ Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº", state="*")
async def expeditor_delivery_history(message: types.Message, state: FSMContext):
    """Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ·Ğ°Ğ²ĞµÑ€ÑˆÑ‘Ğ½Ğ½Ñ‹Ñ… Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº"""
    await state.finish()

    user_id = message.from_user.id

    if user_id not in users or users[user_id].get("role") != "expeditor":
        await message.answer("âŒ Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°Ğ¼")
        return

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ·Ğ°Ğ²ĞµÑ€ÑˆÑ‘Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸
    completed = [
        req
        for req in shipping_requests.values()
        if req.get("expeditor_id") == user_id and req.get("status") == "completed"
    ]

    if not completed:
        await message.answer(
            "âœ”ï¸ <b>Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº</b>\n\n" "ğŸ“‹ Ğ£ Ğ²Ğ°Ñ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ·Ğ°Ğ²ĞµÑ€ÑˆÑ‘Ğ½Ğ½Ñ‹Ñ… Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº.",
            parse_mode="HTML",
        )
        return

    text = (
        f"âœ”ï¸ <b>Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº</b>\n\n"
        f"ğŸ“‹ Ğ’ÑĞµĞ³Ğ¾ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¾: <b>{len(completed)}</b>\n\n"
    )

    for req in completed[-10:]:  # ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ 10
        req_id = req.get("id", "N/A")
        culture = req.get("culture", "N/A")
        volume = req.get("volume", 0) or 0
        completed_at = req.get("completed_at", "â€”")

        text += (
            f"ğŸšš <b>Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° #{req_id}</b>\n"
            f"   {culture} | {volume:.0f} Ñ‚\n"
            f"   âœ… Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°: {completed_at}\n\n"
        )

    await message.answer(text, parse_mode="HTML")


@dp.callback_query_handler(lambda c: c.data.startswith("view_expeditor:"), state="*")
async def logist_view_expeditor_card(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ¼"""
    await state.finish()

    try:
        expeditor_id = int(callback.data.split(":")[1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    if expeditor_id not in expeditor_cards:
        await callback.answer("âŒ ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    card = expeditor_cards[expeditor_id]
    expeditor = users.get(expeditor_id, {})

    # Ğ£Ğ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ ÑÑ‡Ñ‘Ñ‚Ñ‡Ğ¸Ğº Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ¾Ğ²
    card["views"] = card.get("views", 0) + 1

    # Ğ¡ĞĞĞ§ĞĞ›Ğ Ğ˜Ğ—Ğ’Ğ›Ğ•ĞšĞĞ•Ğœ transport_type Ğ˜Ğ— card!
    transport_type = card.get("transport_type", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")

    # Ğ¢Ğ•ĞŸĞ•Ğ Ğ¬ ĞŸĞĞ›Ğ£Ğ§ĞĞ•Ğœ Ğ­ĞœĞĞ”Ğ—Ğ˜
    transport_emoji = TRANSPORT_TYPES.get(transport_type, "ğŸš›")

    # Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹
    regions = card.get("regions", [])
    regions_text = ", ".join(regions) if isinstance(regions, list) else str(regions)

    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ Ğ´ĞµÑ‚Ğ°Ğ»Ğ¸ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸
    text = (
        f"ğŸ’³ <b>ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°</b>\n\n"
        f"{transport_emoji} <b>Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚:</b>\n"
        f"Ğ¢Ğ¸Ğ¿: {transport_emoji} {transport_type}\n"
        f"Ğ“Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ: {card.get('capacity', 0)} Ñ‚\n\n"
        f"<b>ğŸ“ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹:</b>\n{regions_text}\n\n"
        f"<b>ğŸ’° Ğ¢Ğ°Ñ€Ğ¸Ñ„Ñ‹:</b>\n"
        f"Ğ¦ĞµĞ½Ğ° Ğ·Ğ° ĞºĞ¼: {card.get('price_per_km', 0):.2f} â‚½/ĞºĞ¼\n\n"
        f"<b>ğŸ“ ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ:</b>\n{card.get('description', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n\n"
        f"<b>ğŸ‘¤ ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°:</b>\n"
        f"Ğ˜Ğ¼Ñ: {card.get('user_name', expeditor.get('full_name', 'N/A'))}\n"
        f"ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ: {card.get('company', expeditor.get('company_name', 'N/A'))}\n"
        f"Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <code>{card.get('phone', expeditor.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½'))}</code>\n"
        f"Email: {card.get('email', expeditor.get('email', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½'))}\n"
        f"Username: @{expeditor.get('username', 'Ğ½ĞµÑ‚')}\n\n"
        f"ğŸ“… Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ°: {card.get('created_at', 'Ğ/Ğ”')}\n"
        f"ğŸ‘ ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ¾Ğ²: {card.get('views', 0)}"
    )

    keyboard = InlineKeyboardMarkup(row_width=1)

    # âœ… ĞŸĞ ĞĞ’Ğ•Ğ Ğ¯Ğ•Ğœ VALID ID Ğ˜ Ğ”ĞĞ‘ĞĞ’Ğ›Ğ¯Ğ•Ğœ ĞšĞĞĞŸĞšĞ£ Ğ‘Ğ•Ğ—ĞĞŸĞĞ¡ĞĞ
    try:
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ñ‡Ñ‚Ğ¾ ID Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ½Ñ‹Ğ¹
        if expeditor_id > 0 and expeditor_id in users:
            username = expeditor.get("username")

            if username:
                # âœ… Ğ›Ğ£Ğ§Ğ¨Ğ• Ğ˜Ğ¡ĞŸĞĞ›Ğ¬Ğ—ĞĞ’ĞĞ¢Ğ¬ USERNAME
                keyboard.add(
                    InlineKeyboardButton(
                        "ğŸ“ Ğ¡Ğ²ÑĞ·Ğ°Ñ‚ÑŒÑÑ Ñ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ¼", url=f"https://t.me/{username}"
                    )
                )
            else:
                # Ğ•ÑĞ»Ğ¸ Ğ½ĞµÑ‚ username - Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ callback Ğ´Ğ»Ñ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ğ°
                keyboard.add(
                    InlineKeyboardButton(
                        "ğŸ“ ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ",
                        callback_data=f"send_message_to:{expeditor_id}",
                    )
                )
    except Exception as e:
        logging.warning(f"âš ï¸ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ğ°: {e}")

    keyboard.add(
        InlineKeyboardButton(
            "â—€ï¸ Ğš ÑĞ¿Ğ¸ÑĞºÑƒ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²", callback_data="back_to_expeditors"
        )
    )

    # âœ… Ğ‘Ğ•Ğ—ĞĞŸĞĞ¡ĞĞĞ• Ğ Ğ•Ğ”ĞĞšĞ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ•
    try:
        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    except Exception as e:
        logging.warning(f"âš ï¸ ĞÑˆĞ¸Ğ±ĞºĞ° edit_text: {e}")
        try:
            # Fallback: Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ½Ğ¾Ğ²Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ
            await callback.message.answer(
                text, reply_markup=keyboard, parse_mode="HTML"
            )
        except Exception as e2:
            logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° answer: {e2}")
            await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞµ", show_alert=True)

    await callback.answer()


@dp.callback_query_handler(lambda c: c.data == "back_to_expeditors", state="*")
async def back_to_expeditors(callback: types.CallbackQuery, state: FSMContext):
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğº ÑĞ¿Ğ¸ÑĞºÑƒ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²"""
    await state.finish()

    if not expeditor_cards:
        await callback.message.edit_text(
            "ğŸš› <b>Ğ‘Ğ°Ğ·Ğ° ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²</b>\n\n" "ğŸ“‹ Ğ’ Ğ±Ğ°Ğ·Ğµ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ².",
            parse_mode="HTML",
        )
        await callback.answer()
        return

    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ¿Ğ¸ÑĞ¾Ğº
    keyboard = InlineKeyboardMarkup(row_width=1)

    text = (
        "ğŸš› <b>Ğ‘Ğ°Ğ·Ğ° ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²</b>\n\n"
        f"ğŸ“‹ Ğ’ÑĞµĞ³Ğ¾ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²: <b>{len(expeditor_cards)}</b>\n\n"
        "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ° Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ° ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸:"
    )

    for exp_id, card in list(expeditor_cards.items())[:20]:
        # Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: transport_type Ğ²Ğ¼ĞµÑÑ‚Ğ¾ vehicle_type
        transport = card.get("transport_type", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
        capacity = card.get("capacity", 0)
        regions = card.get("regions", [])
        price = card.get("price_per_km", 0)

        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ÑĞ¼Ğ¾Ğ´Ğ·Ğ¸ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°
        emoji = TRANSPORT_TYPES.get(transport, "ğŸš›")

        # Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹ (ÑĞ¿Ğ¸ÑĞ¾Ğº â†’ ÑÑ‚Ñ€Ğ¾ĞºĞ°)
        if isinstance(regions, list):
            regions_text = ", ".join(regions) if regions else "Ğ ĞµĞ³Ğ¸Ğ¾Ğ½ Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"
        else:
            regions_text = str(regions)

        # ĞĞ±Ñ€ĞµĞ·Ğ°ĞµĞ¼ ĞµÑĞ»Ğ¸ Ğ¾Ñ‡ĞµĞ½ÑŒ Ğ´Ğ»Ğ¸Ğ½Ğ½Ğ¾Ğµ (Ğ¼Ğ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ 30 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²)
        if len(regions_text) > 30:
            regions_text = regions_text[:27] + "..."

        btn_text = f"{emoji} {transport} {capacity}Ñ‚ | {regions_text} | {price}â‚½/ĞºĞ¼"
        keyboard.add(
            InlineKeyboardButton(btn_text, callback_data=f"view_expeditor:{exp_id}")
        )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("view_shipping_requests:"), state="*"
)
async def view_shipping_requests_callback(callback: CallbackQuery):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ·Ğ°ÑĞ²Ğ¾Ğº Ğ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ Ğ´Ğ»Ñ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ¿ÑƒĞ»Ğ°"""
    pull_id = parse_callback_id(callback.data)

    if pull_id not in pulls.get("pulls", {}):
        await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    # ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ğ²ÑĞµ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ² Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ³Ğ¾ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ°
    pull = pulls["pulls"][pull_id]
    pull_region = pull.get("region", "")

    relevant_requests = [
        req
        for req in shipping_requests.values()
        if req.get("status") == "active"
        and (pull_region in req.get("from", "") or pull_region in req.get("to", ""))
    ]

    if not relevant_requests:
        await callback.answer(
            "âŒ ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ² Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ³Ğ¾ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ°", show_alert=True
        )
        return

    # âœ… ĞŸĞĞšĞĞ—Ğ«Ğ’ĞĞ•Ğœ Ğ¡ĞŸĞ˜Ğ¡ĞĞš Ğ¡ ĞšĞĞĞŸĞšĞĞœĞ˜!
    text = f"ğŸšš <b>Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ñ‹ Ğ´Ğ»Ñ Ğ¿ÑƒĞ»Ğ° #{pull_id}</b>\n\n"
    text += "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ° Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹:"

    keyboard = InlineKeyboardMarkup(row_width=1)

    for idx, req in enumerate(relevant_requests[:10], 1):
        request_id = req.get("id")
        logist_id = req.get("logist_id")  # â† Ğ’ĞĞ¨Ğ• ĞĞĞ—Ğ’ĞĞĞ˜Ğ•!

        if logist_id and logist_id in users:
            logist = users[logist_id]
            company = logist.get("name", "Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚")  # â† Ğ’ĞĞ¨Ğ• ĞŸĞĞ›Ğ•!
            price = req.get("price", 0)

            button_text = f"ğŸš› {company} - {price:,.0f} â‚½"
            keyboard.add(
                InlineKeyboardButton(
                    button_text, callback_data=f"view_logist_request:{request_id}"
                )
            )

    keyboard.add(
        InlineKeyboardButton("ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´ Ğº Ğ¿ÑƒĞ»Ñƒ", callback_data=f"view_pull:{pull_id}")
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ĞĞĞ’Ğ«Ğ™ ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜Ğš: ĞŸĞ ĞĞ¡ĞœĞĞ¢Ğ  Ğ”Ğ•Ğ¢ĞĞ›Ğ•Ğ™ Ğ—ĞĞ¯Ğ’ĞšĞ˜ Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢Ğ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


@dp.callback_query_handler(
    lambda c: c.data.startswith("view_logist_request:"), state="*"
)
async def view_logist_request_details(callback: CallbackQuery):
    """Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€ ÑĞ¼Ğ¾Ñ‚Ñ€Ğ¸Ñ‚ Ğ´ĞµÑ‚Ğ°Ğ»Ğ¸ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°"""
    try:
        request_id = int(callback.data.split(":")[1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
        return

    if request_id not in shipping_requests:
        await callback.answer("âŒ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    request = shipping_requests[request_id]
    logist_id = request.get("logist_id")  # â† Ğ’ĞĞ¨Ğ• ĞĞĞ—Ğ’ĞĞĞ˜Ğ•!

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°
    logist_data = users.get(logist_id, {})

    text = (
        f"ğŸš› <b>Ğ—Ğ°ÑĞ²ĞºĞ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° #{request_id}</b>\n\n"
        f"<b>ğŸ‘¤ Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚:</b> {logist_data.get('name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n"
        f"<b>ğŸ“ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½:</b> <code>{logist_data.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>\n"
        f"<b>ğŸ“§ Email:</b> {logist_data.get('email', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
        f"<b>ğŸ“ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½:</b> {logist_data.get('region', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n\n"
        f"<b>ğŸ“ ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚:</b> {request.get('from', 'Ğ/Ğ”')} â†’ {request.get('to', 'Ğ/Ğ”')}\n"
        f"<b>ğŸ’° Ğ¦ĞµĞ½Ğ°:</b> {request.get('price', 0):,.0f} â‚½\n"
        f"<b>ğŸš› Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚:</b> {request.get('vehicle_type', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
        f"<b>âš–ï¸ ĞĞ±ÑŠÑ‘Ğ¼:</b> {request.get('volume', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')} Ñ‚\n\n"
        f"<b>ğŸ“ Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾:</b>\n{request.get('notes', 'ĞĞµÑ‚')}"
    )

    keyboard = InlineKeyboardMarkup(row_width=1)
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ“ Ğ¡Ğ²ÑĞ·Ğ°Ñ‚ÑŒÑÑ Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ¼",
            url=f"tg://user?id={logist_id}",  # â† ĞšĞĞĞŸĞšĞ Ğ”Ğ›Ğ¯ Ğ¡Ğ’Ğ¯Ğ—Ğ˜!
        ),
        InlineKeyboardButton(
            "âœ… Ğ’Ñ‹Ğ±Ñ€Ğ°Ñ‚ÑŒ ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°", callback_data=f"select_logist:{request_id}"
        ),
        InlineKeyboardButton(
            "ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´ Ğº ÑĞ¿Ğ¸ÑĞºÑƒ",
            callback_data=f'view_shipping_requests:{request.get("pull_id", 0)}',  # â† Ğ’ĞĞ—Ğ’Ğ ĞĞ¢ Ğš Ğ¡ĞŸĞ˜Ğ¡ĞšĞ£
        ),
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("select_logist:"), state="*")
async def select_logist_for_pull(callback: CallbackQuery):
    """Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€ Ğ²Ñ‹Ğ±Ğ¸Ñ€Ğ°ĞµÑ‚ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° Ğ´Ğ»Ñ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºĞ¸"""
    try:
        request_id = int(callback.data.split(":")[1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
        return

    if request_id not in shipping_requests:
        await callback.answer("âŒ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    request = shipping_requests[request_id]
    logist_id = request.get("logist_id")
    logist_data = users.get(logist_id, {})

    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ·Ğ°ÑĞ²ĞºĞ¸
    shipping_requests[request_id]["status"] = "selected"
    shipping_requests[request_id]["selected_by"] = callback.from_user.id
    shipping_requests[request_id]["selected_at"] = datetime.now().strftime(
        "%d.%m.%Y %H:%M"
    )

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°
    try:
        await bot.send_message(
            logist_id,
            f"ğŸ‰ <b>Ğ’Ğ°ÑˆĞ° Ğ·Ğ°ÑĞ²ĞºĞ° Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ°!</b>\n\n"
            f"Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ» Ğ²Ğ°Ñ Ğ´Ğ»Ñ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºĞ¸.\n"
            f"Ğ¡Ğ²ÑĞ¶Ğ¸Ñ‚ĞµÑÑŒ Ñ Ğ·Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸ĞºĞ¾Ğ¼ Ğ´Ğ»Ñ ÑƒÑ‚Ğ¾Ñ‡Ğ½ĞµĞ½Ğ¸Ñ Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹.",
            parse_mode="HTML",
        )
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° {logist_id}: {e}")

    await callback.message.edit_text(
        f"âœ… <b>Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½!</b>\n\n"
        f"ğŸ‘¤ Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚: {logist_data.get('name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n"
        f"ğŸ“ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <code>{logist_data.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>\n\n"
        f"Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ğ» ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ.\n"
        f"Ğ¡Ğ²ÑĞ¶Ğ¸Ñ‚ĞµÑÑŒ Ñ Ğ½Ğ¸Ğ¼ Ğ´Ğ»Ñ Ğ¾Ğ±ÑÑƒĞ¶Ğ´ĞµĞ½Ğ¸Ñ Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºĞ¸.",
        parse_mode="HTML",
    )
    await callback.answer("âœ… Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½!", show_alert=True)

    logging.info(f"âœ… Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€ {callback.from_user.id} Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ» Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° {logist_id}")


# ==================== Ğ’Ğ¡ĞŸĞĞœĞĞ“ĞĞ¢Ğ•Ğ›Ğ¬ĞĞ«Ğ• Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ˜ ====================


def edit_pull_fields_keyboard():
    """ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¿Ğ¾Ğ»ĞµĞ¹ Ğ¿ÑƒĞ»Ğ°"""
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°", callback_data="edit_pull_field:culture"),
        InlineKeyboardButton("ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼", callback_data="edit_pull_field:volume"),
        InlineKeyboardButton("ğŸ’° Ğ¦ĞµĞ½Ğ°", callback_data="edit_pull_field:price"),
        InlineKeyboardButton("ğŸš¢ ĞŸĞ¾Ñ€Ñ‚", callback_data="edit_pull_field:port"),
    )
    keyboard.add(
        InlineKeyboardButton("ğŸ’§ Ğ’Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ", callback_data="edit_pull_field:moisture"),
        InlineKeyboardButton("ğŸ‹ï¸ ĞĞ°Ñ‚ÑƒÑ€Ğ°", callback_data="edit_pull_field:nature"),
        InlineKeyboardButton("ğŸŒ¾ Ğ¡Ğ¾Ñ€Ğ½Ğ¾ÑÑ‚ÑŒ", callback_data="edit_pull_field:impurity"),
        InlineKeyboardButton("ğŸŒ¿ Ğ—Ğ°ÑĞ¾Ñ€Ñ‘Ğ½Ğ½Ğ¾ÑÑ‚ÑŒ", callback_data="edit_pull_field:weed"),
    )
    keyboard.add(InlineKeyboardButton("ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_my_pulls"))
    return keyboard


async def send_daily_stats():
    """Ğ•Ğ¶ĞµĞ´Ğ½ĞµĞ²Ğ½Ğ°Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ñƒ"""
    try:
        total_users = len(users)
        role_stats = defaultdict(int)

        # âœ… ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞ: Ğ¸Ñ‚ĞµÑ€Ğ¸Ñ€ÑƒĞµĞ¼ÑÑ Ğ¿Ğ¾ user_data
        for user in users.values():
            role = user.get("role", "unknown")
            role_stats[role] += 1

        # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ´ÑÑ‡Ñ‘Ñ‚ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹
        total_batches = sum(len(user_batches) for user_batches in batches.values())

        # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ´ÑÑ‡Ñ‘Ñ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹
        active_batches = sum(
            1
            for user_batches in batches.values()
            for batch in user_batches  # â† Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ! Ğ˜Ñ‚ĞµÑ€Ğ¸Ñ€ÑƒĞµĞ¼ÑÑ Ğ¿Ğ¾ Ğ¿Ğ°Ñ€Ñ‚Ğ¸ÑĞ¼!
            if batch.get("status") == "ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ°"
        )

        total_pulls = len(pulls)
        open_pulls = len([p for p in pulls.values() if p.get("status") == "ĞÑ‚ĞºÑ€Ñ‹Ñ‚"])
        total_deals = len(deals)
        active_deals = len(
            [
                d
                for d in deals.values()
                if d.get("status") in ["pending", "matched", "shipping"]
            ]
        )

        text = "ğŸ“Š <b>Ğ•Ğ¶ĞµĞ´Ğ½ĞµĞ²Ğ½Ğ°Ñ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Exportum</b>\n\n"
        text += f"ğŸ‘¥ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹: {total_users}\n"
        text += f"ğŸ“¦ ĞŸĞ°Ñ€Ñ‚Ğ¸Ğ¹: {total_batches} (Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ…: {active_batches})\n"
        text += f"ğŸ¯ ĞŸÑƒĞ»Ğ¾Ğ²: {total_pulls} (Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ…: {open_pulls})\n"
        text += f"ğŸ“‹ Ğ¡Ğ´ĞµĞ»Ğ¾Ğº: {total_deals} (Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ…: {active_deals})\n"
        text += f"ğŸ¯ Ğ¡Ğ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğ¹: {len(matches)}\n\n"

        text += "<b>Ğ Ğ°ÑĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ Ñ€Ğ¾Ğ»ÑĞ¼:</b>\n"
        for role, count in role_stats.items():
            role_name = ROLES.get(role, role)
            text += f"â€¢ {role_name}: {count}\n"

        await bot.send_message(ADMIN_ID, text, parse_mode="HTML")
        logging.info("âœ… Ğ•Ğ¶ĞµĞ´Ğ½ĞµĞ²Ğ½Ğ°Ñ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ° Ğ°Ğ´Ğ¼Ğ¸Ğ½Ñƒ")

    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ ĞµĞ¶ĞµĞ´Ğ½ĞµĞ²Ğ½Ğ¾Ğ¹ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸: {e}")


async def setup_scheduler():
    """ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸ĞºĞ° Ğ·Ğ°Ğ´Ğ°Ñ‡"""
    global scheduler
    try:
        scheduler.add_job(update_prices_cache, "interval", hours=6)
        scheduler.add_job(update_news_cache, "interval", hours=2)
        scheduler.add_job(auto_match_batches_and_pulls, "interval", minutes=30)
        scheduler.add_job(send_daily_stats, "cron", hour=9, minute=0)

        scheduler.start()
        logging.info("âœ… ĞŸĞ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸Ğº Ğ·Ğ°Ğ´Ğ°Ñ‡ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞ½ Ğ¸ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸ĞºĞ°: {e}")


# ==================== Ğ¡ĞĞ¡Ğ¢ĞĞ¯ĞĞ˜Ğ¯ Ğ”Ğ›Ğ¯ Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢ĞĞ’ ====================
class LogisticStatesGroup(StatesGroup):
    """Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ½Ğ° Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºÑƒ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ¼"""

    route_from = State()
    route_to = State()
    volume = State()
    price = State()
    vehicle_type = State()
    notes = State()
    desired_price = State()


class ExcavatorStatesGroup(StatesGroup):
    """Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°"""

    service_type = State()
    price = State()
    terms = State()
    ports = State()
    notes = State()


# ==================== ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜ĞšĞ˜ Ğ”Ğ›Ğ¯ Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢ĞĞ’ ====================


@dp.message_handler(lambda m: m.text == "â• Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ·Ğ°ÑĞ²ĞºÑƒ Ğ½Ğ° Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºÑƒ", state="*")
async def create_shipping_request_start(message: types.Message, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ğ»Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ½Ğ° Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºÑƒ"""
    user_id = message.from_user.id

    if user_id not in users or users[user_id].get("role") != "logistic":
        await message.answer("âŒ Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°Ğ¼")
        return

    await message.answer(
        "ğŸšš <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ½Ğ° Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºÑƒ</b>\n\n"
        "Ğ¨Ğ°Ğ³ 1/7: ĞÑ‚ĞºÑƒĞ´Ğ° (Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½/Ğ³Ğ¾Ñ€Ğ¾Ğ´)\n\n"
        "Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ğ¼ĞµÑÑ‚Ğ¾ Ğ¿Ğ¾Ğ³Ñ€ÑƒĞ·ĞºĞ¸:",
        parse_mode="HTML",
    )
    await LogisticStatesGroup.route_from.set()


@dp.message_handler(state=LogisticStatesGroup.route_from)
async def logistic_route_from(message: types.Message, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¼ĞµÑÑ‚Ğ° Ğ¿Ğ¾Ğ³Ñ€ÑƒĞ·ĞºĞ¸"""
    route_from = message.text.strip()

    await state.update_data(route_from=route_from)

    await message.answer(
        "ğŸšš <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ½Ğ° Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºÑƒ</b>\n\n"
        "Ğ¨Ğ°Ğ³ 2/7: ĞšÑƒĞ´Ğ° (Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½/Ğ³Ğ¾Ñ€Ğ¾Ğ´/Ğ¿Ğ¾Ñ€Ñ‚)\n\n"
        "Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ğ¼ĞµÑÑ‚Ğ¾ Ñ€Ğ°Ğ·Ğ³Ñ€ÑƒĞ·ĞºĞ¸:",
        parse_mode="HTML",
    )
    await LogisticStatesGroup.route_to.set()


@dp.message_handler(state=LogisticStatesGroup.route_to)
async def logistic_route_to(message: types.Message, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¼ĞµÑÑ‚Ğ° Ñ€Ğ°Ğ·Ğ³Ñ€ÑƒĞ·ĞºĞ¸"""
    route_to = message.text.strip()

    await state.update_data(route_to=route_to)

    await message.answer(
        "ğŸšš <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ½Ğ° Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºÑƒ</b>\n\n"
        "Ğ¨Ğ°Ğ³ 3/7: ĞœĞ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¾Ğ±ÑŠĞµĞ¼\n\n"
        "Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¾Ğ±ÑŠĞµĞ¼ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºĞ¸ (Ñ‚Ğ¾Ğ½Ğ½):",
        parse_mode="HTML",
    )
    await LogisticStatesGroup.volume.set()


@dp.message_handler(state=LogisticStatesGroup.volume)
async def logistic_volume(message: types.Message, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¾Ğ±ÑŠĞµĞ¼Ğ°"""
    try:
        volume = float(message.text.replace(",", "."))
        if volume <= 0:
            raise ValueError

        await state.update_data(volume=volume)

        # âœ… ĞĞĞ’Ğ«Ğ™ Ğ¨ĞĞ“ 4: ĞĞ–Ğ˜Ğ”ĞĞ•ĞœĞĞ¯ Ğ¦Ğ•ĞĞ
        await message.answer(
            "ğŸšš <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ½Ğ° Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºÑƒ</b>\n\n"
            "Ğ¨Ğ°Ğ³ 4/7: ĞĞ¶Ğ¸Ğ´Ğ°ĞµĞ¼Ğ°Ñ Ñ†ĞµĞ½Ğ° (Ğ¶ĞµĞ»Ğ°ĞµĞ¼Ğ°Ñ Ñ†ĞµĞ½Ğ° Ğ·Ğ° Ñ‚Ğ¾Ğ½Ğ½Ñƒ)\n\n"
            "Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµĞ¼ÑƒÑ Ñ†ĞµĞ½Ñƒ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸ (â‚½ Ğ·Ğ° Ñ‚Ğ¾Ğ½Ğ½Ñƒ):\n"
            "<i>ĞĞ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: 500 Ğ¸Ğ»Ğ¸ 1200.5</i>",
            parse_mode="HTML",
        )
        await LogisticStatesGroup.desired_price.set()

    except Exception as e:
        await message.answer("âŒ ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚. Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: 1500)")


@dp.message_handler(state=LogisticStatesGroup.desired_price)
async def logistic_desired_price(message: types.Message, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµĞ¼Ğ¾Ğ¹ Ñ†ĞµĞ½Ñ‹ Ğ·Ğ° Ñ‚Ğ¾Ğ½Ğ½Ñƒ"""
    try:
        desired_price = float(message.text.replace(",", ".").replace(" ", ""))
        if desired_price <= 0:
            raise ValueError

        await state.update_data(desired_price=desired_price)

        await message.answer(
            "ğŸšš <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ½Ğ° Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºÑƒ</b>\n\n"
            "Ğ¨Ğ°Ğ³ 5/7: Ğ’Ğ°Ñˆ Ñ‚Ğ°Ñ€Ğ¸Ñ„\n\n"
            "Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ğ²Ğ°Ñˆ Ñ‚Ğ°Ñ€Ğ¸Ñ„ (â‚½ Ğ·Ğ° Ñ‚Ğ¾Ğ½Ğ½Ñƒ, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ²Ñ‹ Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ñ‹ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶Ğ¸Ñ‚ÑŒ):",
            parse_mode="HTML",
        )
        await LogisticStatesGroup.price.set()

    except Exception as e:
        await message.answer(
            "âŒ ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ñ†ĞµĞ½Ñ‹. Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: 700 Ğ¸Ğ»Ğ¸ 750.5)"
        )


@dp.message_handler(state=LogisticStatesGroup.price)
async def logistic_price(message: types.Message, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ñ‚Ğ°Ñ€Ğ¸Ñ„Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°"""
    try:
        price = float(message.text.replace(",", ".").replace(" ", ""))
        if price <= 0:
            raise ValueError

        await state.update_data(price=price)
        await message.answer(
            "ğŸšš <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ½Ğ° Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºÑƒ</b>\n\n"
            "Ğ¨Ğ°Ğ³ 6/7: Ğ¢Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°\n\n"
            "Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ñ‚Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ° (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: Ğ¤ÑƒÑ€Ğ° 20Ñ‚, Ğ—ĞµÑ€Ğ½Ğ¾Ğ²Ğ¾Ğ·, Ğ•Ğ²Ñ€Ğ¾Ñ„ÑƒÑ€Ğ°):",
            parse_mode="HTML",
        )
        await LogisticStatesGroup.vehicle_type.set()

    except Exception as e:
        await message.answer("âŒ ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚. Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: 700)")


@dp.message_handler(state=LogisticStatesGroup.vehicle_type)
async def logistic_vehicle_type(message: types.Message, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ñ‚Ğ¸Ğ¿Ğ° Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°"""
    vehicle_type = message.text.strip()

    await state.update_data(vehicle_type=vehicle_type)

    await message.answer(
        "ğŸšš <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ½Ğ° Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºÑƒ</b>\n\n"
        "Ğ¨Ğ°Ğ³ 7/7: ĞŸÑ€Ğ¸Ğ¼ĞµÑ‡Ğ°Ğ½Ğ¸Ñ (Ğ½ĞµĞ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾)\n\n"
        "Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ°Ñ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¸Ğ»Ğ¸ Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ /skip Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ°:",
        parse_mode="HTML",
    )
    await LogisticStatesGroup.notes.set()


@dp.message_handler(lambda m: m.text == "/skip", state=LogisticStatesGroup.notes)
@dp.message_handler(state=LogisticStatesGroup.notes)
async def logistic_notes(message: types.Message, state: FSMContext):
    """Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğµ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ¼"""
    user_id = message.from_user.id
    notes = "" if message.text == "/skip" else message.text.strip()
    await state.update_data(notes=notes)

    data = await state.get_data()

    # âœ… Ğ“Ğ•ĞĞ•Ğ Ğ˜Ğ Ğ£Ğ•Ğœ ID ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞ (Ğ±ĞµĞ· global)
    request_id = max(logistics_requests.keys()) + 1 if logistics_requests else 1

    # âœ… Ğ¡ĞĞ—Ğ”ĞĞĞœ Ğ—ĞĞ¯Ğ’ĞšĞ£ Ğ¡ ĞŸĞĞ›ĞĞĞ™ Ğ¡Ğ¢Ğ Ğ£ĞšĞ¢Ğ£Ğ ĞĞ™
    request = {
        "id": request_id,
        "logist_id": user_id,
        "from": data["route_from"],
        "to": data["route_to"],
        "volume": data["volume"],
        "desired_price": data["desired_price"],
        "price": data["price"],
        "vehicle_type": data["vehicle_type"],
        "notes": notes,
        "status": "active",
        "offers_count": 0,  # â† Ğ”ĞĞ‘ĞĞ’Ğ˜Ğ›!
        "created_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "offers": [],  # â† Ğ”ĞĞ‘ĞĞ’Ğ˜Ğ›!
    }

    logistics_requests[request_id] = request

    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ
    logist = users[user_id]
    logist_name = logist.get("name", "Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚")
    logist_inn = logist.get("inn", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
    logist_ogrn = logist.get("ogrn", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")

    # âœ… ĞŸĞĞšĞĞ—Ğ«Ğ’ĞĞ•Ğœ Ğ¡ĞĞ—Ğ”ĞĞĞ˜Ğ• Ğ—ĞĞ¯Ğ’ĞšĞ˜
    text = f"âœ… <b>Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğ° Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºÑƒ #{request_id} ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ°!</b>\n\n"
    text += f"ğŸ“ ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚: {data['route_from']} â†’ {data['route_to']}\n"
    text += f"ğŸ“¦ ĞĞ±ÑŠĞµĞ¼: {data['volume']} Ñ‚\n"
    text += f"ğŸ’° ĞĞ¶Ğ¸Ğ´Ğ°ĞµĞ¼Ğ°Ñ Ñ†ĞµĞ½Ğ°: <code>{data['desired_price']:,.0f}</code> â‚½/Ñ‚\n"
    text += f"ğŸ’° Ğ’Ğ°Ñˆ Ñ‚Ğ°Ñ€Ğ¸Ñ„: <code>{data['price']:,.0f}</code> â‚½/Ñ‚\n"
    text += f"ğŸš› Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚: {data['vehicle_type']}\n"
    if notes:
        text += f"ğŸ“ ĞŸÑ€Ğ¸Ğ¼ĞµÑ‡Ğ°Ğ½Ğ¸Ñ: {notes}\n"

    text += f"\nğŸ‘¤ ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚: {logist_name}\n"
    text += f"ğŸ“‹ Ğ˜ĞĞ: <code>{logist_inn}</code>\n"
    text += f"ğŸ“‹ ĞĞ“Ğ Ğ: <code>{logist_ogrn}</code>\n"
    text += f"ğŸ“ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <code>{logist.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>\n"
    text += f"ğŸ“§ Email: <code>{logist.get('email', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>"

    await message.answer(text, parse_mode="HTML", reply_markup=logistic_keyboard())

    await state.finish()

    # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ² JSON
    save_data()  # â† Ğ˜Ğ¡ĞŸĞĞ›Ğ¬Ğ—Ğ£Ğ™ Ğ£ĞĞ˜Ğ’Ğ•Ğ Ğ¡ĞĞ›Ğ¬ĞĞ£Ğ® Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ® Ğ¡ĞĞ¥Ğ ĞĞĞ•ĞĞ˜Ğ¯

    logging.info(
        f"âœ… Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ {user_id} ÑĞ¾Ğ·Ğ´Ğ°Ğ» Ğ·Ğ°ÑĞ²ĞºÑƒ Ğ½Ğ° Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºÑƒ #{request_id} "
        f"Ñ Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµĞ¼Ğ¾Ğ¹ Ñ†ĞµĞ½Ğ¾Ğ¹ {data['desired_price']}"
    )


def get_status_emoji(status: str) -> str:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ ÑĞ¼Ğ¾Ğ´Ğ·Ğ¸ Ğ´Ğ»Ñ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°"""
    status_emojis = {
        "active": "ğŸŸ¢",
        "assigned": "ğŸŸ¡",
        "in_progress": "ğŸ”µ",
        "completed": "âœ…",
        "cancelled": "âŒ",
        "pending": "ğŸ•",
        "accepted": "âœ…",
        "rejected": "âŒ",
    }
    return status_emojis.get(status, "âšª")


def get_status_name(status: str) -> str:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°"""
    status_names = {
        "active": "ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ°",
        "assigned": "ĞĞ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ°",
        "in_progress": "Ğ’ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğµ",
        "completed": "Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°",
        "cancelled": "ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½Ğ°",
        "pending": "ĞĞ¶Ğ¸Ğ´Ğ°ĞµÑ‚",
        "accepted": "ĞŸÑ€Ğ¸Ğ½ÑÑ‚Ğ¾",
        "rejected": "ĞÑ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¾",
    }
    return status_names.get(status, status)


@dp.callback_query_handler(text="logistic_requests_list", state="*")
async def show_logistic_requests_list(callback: types.CallbackQuery, state: FSMContext):
    """Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ·Ğ°ÑĞ²Ğ¾Ğº Ğ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ Ğ´Ğ»Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°"""
    await state.finish()

    user_id = callback.from_user.id

    # âœ… Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµĞ¼ ĞºĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ñƒ Ğ”Ğ Ğ²ÑĞµÑ… ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ğ¹
    keyboard = InlineKeyboardMarkup(row_width=1)

    # âœ… Ğ˜Ğ¡Ğ¥ĞĞ”ĞĞ«Ğ• Ğ·Ğ°ÑĞ²ĞºĞ¸ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€Ğ¾Ğ² (ĞºĞ°Ğº Ğ±Ñ‹Ğ»Ğ¾)
    available_requests = [
        (f"exp_{req_id}", req)
        for req_id, req in shipping_requests.items()
        if req.get("status") == "active" and not req.get("logist_id")
    ]

    # âœ… Ğ”ĞĞ‘ĞĞ’Ğ›Ğ¯Ğ•Ğœ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ² (Ğ½Ğ¾Ğ²Ğ¾Ğµ)
    available_requests.extend(
        [
            (f"farm_{req_id}", req)
            for req_id, req in farmer_logistics_requests.items()
            if req.get("status") == "active"
        ]
    )

    if not available_requests:
        text = "ğŸšš <b>ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸</b>\n\n"
        text += "âŒ ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ·Ğ°ÑĞ²Ğ¾Ğº\n\n"
        text += "<i>Ğ—Ğ°ÑĞ²ĞºĞ¸ Ğ¿Ğ¾ÑĞ²ÑÑ‚ÑÑ, ĞºĞ¾Ğ³Ğ´Ğ° ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ñ‹ Ğ¸ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ñ‹ ÑĞ¾Ğ·Ğ´Ğ°Ğ´ÑƒÑ‚ Ğ½Ğ¾Ğ²Ñ‹Ğµ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑÑ‹ Ğ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ</i>"

        keyboard.add(InlineKeyboardButton("â¬…ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="logist_main_menu"))

        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
        await callback.answer()
        return

    available_requests.sort(key=lambda x: x[1].get("created_at", ""), reverse=True)

    text = "ğŸšš <b>ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸</b>\n\n"
    text += f"ğŸ“‹ Ğ’ÑĞµĞ³Ğ¾ Ğ·Ğ°ÑĞ²Ğ¾Ğº: <b>{len(available_requests)}</b>\n\n"

    for req_key, req in available_requests[:10]:
        # âœ… ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ Ñ‚Ğ¸Ğ¿ Ğ·Ğ°ÑĞ²ĞºĞ¸
        req_type = "farm" if req_key.startswith("farm_") else "exp"

        if req_type == "farm":
            # ğŸŒ¾ Ğ”Ğ»Ñ Ğ¤Ğ•Ğ ĞœĞ•Ğ Ğ
            culture = req.get("culture", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°")
            volume = req.get("volume", 0)
            port = req.get("port_to", "")
            transport = req.get("transport_type", "")

            button_text = f"ğŸŒ¾ {culture} {volume:.0f}Ñ‚ â†’ {port} ({transport})"
        else:
            # ğŸ“¦ Ğ”Ğ»Ñ Ğ­ĞšĞ¡ĞŸĞĞ Ğ¢Ğ•Ğ Ğ (ĞºĞ°Ğº Ğ±Ñ‹Ğ»Ğ¾)
            pull_id = req.get("pull_id")
            pull_info = (
                pulls["pulls"].get(pull_id) or pulls["pulls"].get(str(pull_id)) or {}
            )
            culture = pull_info.get("culture", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°")
            volume = req.get("volume", 0)
            route_from = req.get("route_from", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾")
            route_to = req.get("route_to", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾")

            button_text = f"ğŸ“¦ {culture} {volume:.0f}Ñ‚ | {route_from} â†’ {route_to}"

        keyboard.add(
            InlineKeyboardButton(button_text, callback_data=f"view_request:{req_key}")
        )

    if len(available_requests) > 10:
        text += f"\n<i>... Ğ¸ ĞµÑ‰Ñ‘ {len(available_requests) - 10} Ğ·Ğ°ÑĞ²Ğ¾Ğº</i>"

    # âœ… ĞšĞ½Ğ¾Ğ¿ĞºĞ° Â«ĞĞ°Ğ·Ğ°Ğ´Â»
    keyboard.add(InlineKeyboardButton("â¬…ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="logist_main_menu"))

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


# ============================================================================
# Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢: FSM Ğ¡ĞĞ—Ğ”ĞĞĞ˜Ğ¯ ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯
# ============================================================================
@dp.callback_query_handler(lambda c: c.data.startswith("make_offer:"), state="*")
async def make_offer_start(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ğ»Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ¼"""
    await state.finish()

    try:
        parts = callback.data.split(":")
        source = parts[1]  # exporter Ğ¸Ğ»Ğ¸ farmer
        req_id = int(parts[2])  # request_id

        logging.info(f"âœ… HANDLER TRIGGERED: source={source}, req_id={req_id}")

    except (IndexError, ValueError) as e:
        logging.error(f"âŒ PARSE ERROR: {e}, data={callback.data}")
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
        return

    # ĞŸĞ ĞĞ’Ğ•Ğ Ğ¯Ğ•Ğœ Ğ—ĞĞ¯Ğ’ĞšĞ£
    if req_id not in shipping_requests:
        logging.error(f"âŒ REQUEST NOT FOUND: {req_id}")
        await callback.answer("âŒ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    request = shipping_requests[req_id]
    user_id = callback.from_user.id

    # âœ… ĞŸĞ ĞĞ’Ğ•Ğ Ğ¯Ğ•Ğœ, ĞĞ•Ğ¢ Ğ›Ğ˜ Ğ£Ğ–Ğ• ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯
    existing_offer = any(
        o.get("request_id") == req_id
        and o.get("logist_id") == user_id
        and o.get("status") != "cancelled"
        for o in logistic_offers.values()
    )

    if existing_offer:
        logging.warning(
            f"âš ï¸ DUPLICATE OFFER: user {user_id} already has offer for request {req_id}"
        )
        await callback.answer(
            "âŒ Ğ’Ñ‹ ÑƒĞ¶Ğµ ÑĞ´ĞµĞ»Ğ°Ğ»Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ ÑÑ‚Ğ¾Ğ¹ Ğ·Ğ°ÑĞ²ĞºĞµ", show_alert=True
        )
        return

    # ğŸ’¾ Ğ¡ĞĞ¥Ğ ĞĞĞ¯Ğ•Ğœ ID Ğ—ĞĞ¯Ğ’ĞšĞ˜
    await state.update_data(request_id=req_id)

    # ğŸ“‹ Ğ˜ĞĞ¤ĞĞ ĞœĞĞ¦Ğ˜Ğ¯ Ğ Ğ—ĞĞ¯Ğ’ĞšĞ•
    pull_id = request.get("pull_id")
    pull_info = pulls.get(pull_id, {})
    expected_price = request.get("desired_price", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°")

    text = f"""âœ… <b>Ğ¡ĞĞ—Ğ”ĞĞĞ˜Ğ• ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯</b>

ğŸ“¦ Ğ—Ğ°ÑĞ²ĞºĞ° #{req_id}
ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {pull_info.get('culture', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}
ğŸ“Š ĞĞ±ÑŠÑ‘Ğ¼: {request.get('volume', 0):.1f} Ñ‚
ğŸ“ ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚: {request.get('route_from', '')} â†’ {request.get('route_to', '')}
ğŸ’° ĞĞ¶Ğ¸Ğ´Ğ°ĞµĞ¼Ğ°Ñ Ñ†ĞµĞ½Ğ°: <code>{expected_price}</code> â‚½/Ñ‚

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

<b>Ğ¨Ğ°Ğ³ 1/3: Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ‚Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°</b>"""

    keyboard = InlineKeyboardMarkup(row_width=2)

    vehicles = [
        ("ğŸš‚ Ğ–Ğ”", "railway"),
        ("ğŸšš Ğ—ĞµÑ€Ğ½Ğ¾Ğ²Ğ¾Ğ·", "grain"),
        ("ğŸš› Ğ¤ÑƒÑ€Ğ°", "fura"),
    ]

    for label, callback_data in vehicles:
        keyboard.add(InlineKeyboardButton(label, callback_data=callback_data))

    keyboard.add(InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="cancel_offer"))

    try:
        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
        logging.info(f"âœ… MESSAGE EDITED for request {req_id}")
    except Exception as e:
        logging.error(f"âŒ EDIT ERROR: {e}")
        await callback.message.answer(text, reply_markup=keyboard, parse_mode="HTML")

    # âœ… ĞŸĞ•Ğ Ğ•Ğ¥ĞĞ”Ğ˜Ğœ Ğš Ğ’Ğ«Ğ‘ĞĞ Ğ£ Ğ¢Ğ ĞĞĞ¡ĞŸĞĞ Ğ¢Ğ
    await LogisticOfferStatesGroup.vehicle_type.set()
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("vehicle_"), state=LogisticOfferStatesGroup.vehicle_type
)
async def offer_vehicle_selected(callback: types.CallbackQuery, state: FSMContext):
    """Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ñ‚Ğ¸Ğ¿Ğ° Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°"""
    # ğŸ“ ĞŸĞĞ Ğ¡Ğ˜Ğœ CALLBACK DATA
    vehicle_type = callback.data.replace("vehicle_", "")

    # ğŸ“¦ Ğ¡Ğ›ĞĞ’ĞĞ Ğ¬ ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞ«Ğ¥ ĞĞĞ—Ğ’ĞĞĞ˜Ğ™ Ğ¢Ğ ĞĞĞ¡ĞŸĞĞ Ğ¢Ğ
    vehicles_display = {
        "railway": "ğŸš‚ Ğ–Ğ”",
        "grain": "ğŸšš Ğ—ĞµÑ€Ğ½Ğ¾Ğ²Ğ¾Ğ·",
        "truck": "ğŸš› Ğ¤ÑƒÑ€Ğ°",
    }

    # ğŸ¯ ĞŸĞĞ›Ğ£Ğ§ĞĞ•Ğœ ĞšĞ ĞĞ¡Ğ˜Ğ’ĞĞ• ĞĞĞ—Ğ’ĞĞĞ˜Ğ•
    transport_display = vehicles_display.get(vehicle_type, "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ñ‹Ğ¹ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚")

    # ğŸ’¾ Ğ¡ĞĞ¥Ğ ĞĞĞ¯Ğ•Ğœ Ğ’ STATE
    await state.update_data(vehicle_type=vehicle_type)

    # ğŸ“‹ ĞŸĞĞ›Ğ£Ğ§ĞĞ•Ğœ Ğ”ĞĞĞĞ«Ğ• Ğ—ĞĞ¯Ğ’ĞšĞ˜
    data = await state.get_data()
    request_id = data.get("request_id")
    request = shipping_requests.get(request_id, {})
    volume = request.get("volume", 0)

    # ğŸ“ Ğ¤ĞĞ ĞœĞ˜Ğ Ğ£Ğ•Ğœ Ğ¢Ğ•ĞšĞ¡Ğ¢
    text = f"""âœ… <b>Ğ¡ĞĞ—Ğ”ĞĞĞ˜Ğ• ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯</b>

âœ“ Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚: <b>{transport_display}</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

<b>Ğ¨Ğ°Ğ³ 2/4: Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ ÑÑ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸</b>

ĞĞ±ÑŠÑ‘Ğ¼ Ğ³Ñ€ÑƒĞ·Ğ°: <b>{volume:.1f} Ñ‚</b>

Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ÑÑ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸ Ğ² Ñ€ÑƒĞ±Ğ»ÑÑ…:
<i>(Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: 50000)</i>"""

    # âŒ¨ï¸ ĞšĞ›ĞĞ’Ğ˜ĞĞ¢Ğ£Ğ Ğ
    keyboard = InlineKeyboardMarkup()
    keyboard.add(InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="cancel_offer"))

    # ğŸ”„ ĞĞ‘ĞĞĞ’Ğ›Ğ¯Ğ•Ğœ Ğ¡ĞĞĞ‘Ğ©Ğ•ĞĞ˜Ğ• Ğ˜ ĞŸĞ•Ğ Ğ•Ğ¥ĞĞ”Ğ˜Ğœ ĞĞ Ğ¨ĞĞ“ 2
    try:
        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
        logging.info(f"âœ… VEHICLE SELECTED: {vehicle_type}")
    except Exception as e:
        logging.error(f"âŒ EDIT ERROR: {e}")
        await callback.message.answer(text, reply_markup=keyboard, parse_mode="HTML")

    # âœ… ĞŸĞ•Ğ Ğ•Ğ¥ĞĞ”Ğ˜Ğœ ĞĞ Ğ¨ĞĞ“ Ğ’Ğ’ĞĞ”Ğ Ğ¦Ğ•ĞĞ«
    await LogisticOfferStatesGroup.price.set()
    await callback.answer()


@dp.message_handler(state=LogisticOfferStatesGroup.price)
async def offer_price_entered(message: types.Message, state: FSMContext):
    """Ğ’Ğ²Ğ¾Ğ´ Ñ†ĞµĞ½Ñ‹"""
    user_id = message.from_user.id

    try:
        price_str = (
            message.text.strip().replace(" ", "").replace(",", "").replace("â‚½", "")
        )
        price = float(price_str)

        if price <= 0:
            await message.answer(
                "âŒ Ğ¦ĞµĞ½Ğ° Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ½ÑƒĞ»Ñ!\n\n" "ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·:"
            )
            return

        if price > 10000000:
            await message.answer(
                "âŒ Ğ¦ĞµĞ½Ğ° ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ±Ğ¾Ğ»ÑŒÑˆĞ°Ñ (Ğ¼Ğ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ 10 Ğ¼Ğ»Ğ½ â‚½)!\n\n" "ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·:"
            )
            return

    except ValueError:
        await message.answer(
            "âŒ ĞĞµĞ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ñ†ĞµĞ½Ñ‹!\n\n" "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: 50000):"
        )
        return

    await state.update_data(price=price)

    # ğŸ“‹ ĞŸĞĞ›Ğ£Ğ§ĞĞ•Ğœ Ğ”ĞĞĞĞ«Ğ•
    data = await state.get_data()
    vehicle_type = data.get("vehicle_type")

    # ğŸ“¦ Ğ¡Ğ›ĞĞ’ĞĞ Ğ¬ ĞĞĞ—Ğ’ĞĞĞ˜Ğ™ Ğ¢Ğ ĞĞĞ¡ĞŸĞĞ Ğ¢Ğ
    vehicles_display = {
        "railway": "ğŸš‚ Ğ–Ğ”",
        "grain": "ğŸšš Ğ—ĞµÑ€Ğ½Ğ¾Ğ²Ğ¾Ğ·",
        "truck": "ğŸš› Ğ¤ÑƒÑ€Ğ°",
    }

    # ğŸ¯ ĞŸĞĞ›Ğ£Ğ§ĞĞ•Ğœ ĞĞĞ—Ğ’ĞĞĞ˜Ğ• Ğ¢Ğ ĞĞĞ¡ĞŸĞĞ Ğ¢Ğ
    transport = vehicles_display.get(vehicle_type, "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ñ‹Ğ¹ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚")

    # ğŸ“ Ğ¤ĞĞ ĞœĞ˜Ğ Ğ£Ğ•Ğœ Ğ¢Ğ•ĞšĞ¡Ğ¢
    text = f"""âœ… <b>Ğ¡ĞĞ—Ğ”ĞĞĞ˜Ğ• ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯</b>

âœ“ Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚: <b>{transport}</b>
âœ“ Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ: <b>{price:,.0f} â‚½</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

<b>Ğ¨Ğ°Ğ³ 3/4: Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ğ´Ğ°Ñ‚Ñƒ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸</b>

Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ´Ğ°Ñ‚Ñƒ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸ Ğ² Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğµ Ğ”Ğ”.ĞœĞœ.Ğ“Ğ“Ğ“Ğ“:
<i>(Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: 15.11.2025)</i>"""

    keyboard = InlineKeyboardMarkup()
    keyboard.add(InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="cancel_offer"))

    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")
    await LogisticOfferStatesGroup.delivery_date.set()


@dp.message_handler(state=LogisticOfferStatesGroup.delivery_date)
async def offer_date_entered(message: types.Message, state: FSMContext):
    """Ğ’Ğ²Ğ¾Ğ´ Ğ´Ğ°Ñ‚Ñ‹ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸"""
    date_str = message.text.strip()

    # ğŸ” Ğ’ĞĞ›Ğ˜Ğ”ĞĞ¦Ğ˜Ğ¯ Ğ”ĞĞ¢Ğ«
    try:
        delivery_date = datetime.strptime(date_str, "%d.%m.%Y")

        # ĞŸĞ ĞĞ’Ğ•Ğ ĞšĞ, Ğ§Ğ¢Ğ Ğ”ĞĞ¢Ğ ĞĞ• Ğ’ ĞŸĞ ĞĞ¨Ğ›ĞĞœ
        today = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        if delivery_date < today:
            await message.answer(
                "âŒ Ğ”Ğ°Ñ‚Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸ Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ Ğ² Ğ¿Ñ€Ğ¾ÑˆĞ»Ğ¾Ğ¼!\n\n"
                "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ´Ğ°Ñ‚Ñƒ Ğ½Ğµ Ñ€Ğ°Ğ½ĞµĞµ ÑĞµĞ³Ğ¾Ğ´Ğ½ÑÑˆĞ½ĞµĞ³Ğ¾ Ğ´Ğ½Ñ:"
            )
            return

        # ĞŸĞ ĞĞ’Ğ•Ğ ĞšĞ, Ğ§Ğ¢Ğ Ğ”ĞĞ¢Ğ ĞĞ• Ğ¡Ğ›Ğ˜Ğ¨ĞšĞĞœ Ğ”ĞĞ›Ğ•ĞšĞ
        max_date = today + timedelta(days=365)
        if delivery_date > max_date:
            await message.answer(
                "âŒ Ğ”Ğ°Ñ‚Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸ ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ´Ğ°Ğ»ĞµĞºĞ¾ (Ğ¼Ğ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ 1 Ğ³Ğ¾Ğ´)!\n\n"
                "ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·:"
            )
            return

    except ValueError:
        await message.answer(
            "âŒ ĞĞµĞ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ğ´Ğ°Ñ‚Ñ‹!\n\n"
            "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ğ”Ğ”.ĞœĞœ.Ğ“Ğ“Ğ“Ğ“ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: 15.11.2025):"
        )
        return

    # âœ… Ğ¡ĞĞ¥Ğ ĞĞĞ¯Ğ•Ğœ Ğ”ĞĞ¢Ğ£
    await state.update_data(delivery_date=date_str)

    # ğŸ“‹ ĞŸĞ•Ğ Ğ•Ğ¥ĞĞ”Ğ˜Ğœ Ğš ĞŸĞĞ”Ğ¢Ğ’Ğ•Ğ Ğ–Ğ”Ğ•ĞĞ˜Ğ®
    try:
        await show_offer_confirmation(message, state, user_id=message.from_user.id)
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ² show_offer_confirmation: {e}")
        await message.answer("âŒ ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·.")


@dp.callback_query_handler(
    lambda c: c.data == "skip_additional_info",
    state=LogisticOfferStatesGroup.additional_info,
)
async def offer_skip_additional_info(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞº Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğ¹ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸"""
    await state.update_data(additional_info="")
    await show_offer_confirmation(
        callback.message, state, user_id=callback.from_user.id, is_callback=True
    )
    await callback.answer()


@dp.message_handler(state=LogisticOfferStatesGroup.additional_info)
async def offer_additional_info_entered(message: types.Message, state: FSMContext):
    """Ğ’Ğ²Ğ¾Ğ´ Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğ¹ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸"""
    additional_info = message.text.strip()

    if len(additional_info) > 500:
        await message.answer(
            "âŒ Ğ¡Ğ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ´Ğ»Ğ¸Ğ½Ğ½Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ (Ğ¼Ğ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ 500 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²)!\n\n"
            "Ğ¡Ğ¾ĞºÑ€Ğ°Ñ‚Ğ¸Ñ‚Ğµ Ñ‚ĞµĞºÑÑ‚:"
        )
        return

    await state.update_data(additional_info=additional_info)
    await show_offer_confirmation(message, state, user_id=message.from_user.id)


async def show_offer_confirmation(
    message_or_callback, state: FSMContext, user_id: int, is_callback: bool = False
):
    """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ"""
    data = await state.get_data()

    request_id = data.get("request_id")
    request = shipping_requests.get(request_id, {})
    pull_id = request.get("pull_id")
    pull_info = pulls.get(pull_id, {})

    vehicle_type = data.get("vehicle_type")
    price = data.get("price")
    delivery_date = data.get("delivery_date")
    additional_info = data.get("additional_info", "")

    # ğŸ“¦ Ğ¡Ğ›ĞĞ’ĞĞ Ğ¬ ĞĞĞ—Ğ’ĞĞĞ˜Ğ™ Ğ¢Ğ ĞĞĞ¡ĞŸĞĞ Ğ¢Ğ
    vehicles_display = {
        "fura": "ğŸš› Ğ¤ÑƒÑ€Ğ°",
        "railway": "ğŸš‚ Ğ–/Ğ´ Ğ²Ğ°Ğ³Ğ¾Ğ½",
        "grain": "ğŸšš Ğ—ĞµÑ€Ğ½Ğ¾Ğ²Ğ¾Ğ·",
    }

    # ğŸ¯ ĞŸĞĞ›Ğ£Ğ§ĞĞ•Ğœ ĞĞĞ—Ğ’ĞĞĞ˜Ğ• Ğ¢Ğ ĞĞĞ¡ĞŸĞĞ Ğ¢Ğ
    transport = vehicles_display.get(vehicle_type, "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ñ‹Ğ¹ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚")

    # ğŸ“ Ğ¤ĞĞ ĞœĞ˜Ğ Ğ£Ğ•Ğœ Ğ¢Ğ•ĞšĞ¡Ğ¢
    text = f"""ğŸ“‹ <b>ĞŸĞĞ”Ğ¢Ğ’Ğ•Ğ Ğ–Ğ”Ğ•ĞĞ˜Ğ• ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯</b>

ğŸ“¦ <b>Ğ—ĞĞ¯Ğ’ĞšĞ #{request_id}</b>
ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {pull_info.get('culture', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}
ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: {request.get('volume', 0):.1f} Ñ‚
ğŸ“ ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚: {request.get('route_from', '')} â†’ {request.get('route_to', '')}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

<b>Ğ’ĞĞ¨Ğ• ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ•:</b>

ğŸš› Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚: <b>{transport}</b>
ğŸ’° Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ: <b>{price:,.0f} â‚½</b>
ğŸ“… Ğ”Ğ°Ñ‚Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸: <b>{delivery_date}</b>"""

    if additional_info:
        text += f"\n\nâ„¹ï¸ Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾:\n{additional_info}"

    text += "\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nâœ… ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ğ¸Ñ‚Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºÑƒ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ"

    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("âœ… ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ", callback_data="confirm_offer"),
        InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="cancel_offer"),
    )

    if is_callback:
        await message_or_callback.edit_text(
            text, reply_markup=keyboard, parse_mode="HTML"
        )
    else:
        await message_or_callback.answer(text, reply_markup=keyboard, parse_mode="HTML")

    await LogisticOfferStatesGroup.confirm.set()


@dp.callback_query_handler(
    lambda c: c.data == "confirm_offer", state=LogisticOfferStatesGroup.confirm
)
async def offer_confirmed(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ"""
    try:
        user_id = callback.from_user.id
        data = await state.get_data()

        # ğŸ“‹ Ğ˜Ğ—Ğ’Ğ›Ğ•ĞšĞĞ•Ğœ Ğ”ĞĞĞĞ«Ğ• Ğ˜Ğ— Ğ¡ĞĞ¡Ğ¢ĞĞ¯ĞĞ˜Ğ¯
        request_id = data.get("request_id")
        vehicle_type = data.get("vehicle_type")
        price = data.get("price")
        delivery_date = data.get("delivery_date")
        additional_info = data.get("additional_info", "")

        # âœ… ĞŸĞ ĞĞ’Ğ•Ğ ĞšĞ ĞĞ‘Ğ¯Ğ—ĞĞ¢Ğ•Ğ›Ğ¬ĞĞ«Ğ¥ Ğ”ĞĞĞĞ«Ğ¥
        if not all([request_id, vehicle_type, price, delivery_date]):
            await callback.answer(
                "âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒÑÑ‚ Ğ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ", show_alert=True
            )
            return

        # ğŸ“¦ Ğ¡Ğ›ĞĞ’ĞĞ Ğ¬ ĞĞĞ—Ğ’ĞĞĞ˜Ğ™ Ğ¢Ğ ĞĞĞ¡ĞŸĞĞ Ğ¢Ğ
        vehicles_display = {
            "fura": "ğŸš› Ğ¤ÑƒÑ€Ğ°",
            "railway": "ğŸš‚ Ğ–/Ğ´ Ğ²Ğ°Ğ³Ğ¾Ğ½",
            "grain": "ğŸšš Ğ—ĞµÑ€Ğ½Ğ¾Ğ²Ğ¾Ğ·",
        }

        # ğŸ¯ ĞŸĞĞ›Ğ£Ğ§ĞĞ•Ğœ ĞĞĞ—Ğ’ĞĞĞ˜Ğ• Ğ¢Ğ ĞĞĞ¡ĞŸĞĞ Ğ¢Ğ
        transport = vehicles_display.get(vehicle_type, "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ñ‹Ğ¹ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚")

        # ğŸ’¾ Ğ“Ğ•ĞĞ•Ğ Ğ˜Ğ Ğ£Ğ•Ğœ ID ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯
        global logistic_offers
        offer_id = max(logistic_offers.keys()) + 1 if logistic_offers else 1

        # ğŸ“‹ Ğ¡ĞĞ—Ğ”ĞĞĞœ ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ•
        offer = {
            "id": offer_id,
            "request_id": request_id,
            "logist_id": user_id,
            "vehicle_type": vehicle_type,
            "price": price,
            "delivery_date": delivery_date,
            "additional_info": additional_info,
            "status": "pending",
            "created_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        }

        logistic_offers[offer_id] = offer
        logging.info(f"âœ… ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ #{offer_id} ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¾ Ğ² Ğ‘Ğ”")

        # ğŸ‘¤ ĞŸĞĞ›Ğ£Ğ§ĞĞ•Ğœ Ğ˜ĞĞ¤ĞĞ ĞœĞĞ¦Ğ˜Ğ®
        request = shipping_requests.get(request_id, {})
        exporter_id = request.get("exporter_id")
        logist_name = users.get(user_id, {}).get(
            "company_name", "Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ ĞºĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ"
        )

        # ğŸ“¨ Ğ£Ğ’Ğ•Ğ”ĞĞœĞ›Ğ¯Ğ•Ğœ Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢Ğ
        text = f"""âœ… <b>ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ• ĞĞ¢ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ!</b>


ğŸ“¦ Ğ—Ğ°ÑĞ²ĞºĞ° #{request_id}
ğŸš› Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚: <b>{transport}</b>
ğŸ’° Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ: <b>{price:,.0f} â‚½</b>
ğŸ“… Ğ”Ğ°Ñ‚Ğ°: <b>{delivery_date}</b>


Ğ’Ğ°ÑˆĞµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ #{offer_id} Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ñƒ.
Ğ’Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚Ğµ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ, ĞºĞ¾Ğ³Ğ´Ğ° Ğ¾Ğ½ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ‚ Ñ€ĞµÑˆĞµĞ½Ğ¸Ğµ."""

        keyboard = InlineKeyboardMarkup(row_width=1)
        keyboard.add(
            InlineKeyboardButton("ğŸ’¼ ĞœĞ¾Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ", callback_data="my_offers"),
            InlineKeyboardButton("ğŸ”™ Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main"),
        )

        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")

        # ğŸ”” Ğ£Ğ’Ğ•Ğ”ĞĞœĞ›Ğ¯Ğ•Ğœ Ğ­ĞšĞ¡ĞŸĞĞ Ğ¢ĞĞ Ğ
        print(
            f"ğŸ” DEBUG: ĞĞ°Ñ‡Ğ°Ğ»Ğ¾ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ. exporter_id={exporter_id}, offer_id={offer_id}"
        )

        if exporter_id:
            try:
                print(f"ğŸ” DEBUG: exporter_id Ğ½Ğ°Ğ¹Ğ´ĞµĞ½: {exporter_id}, ÑĞ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ")

                exporter_text = f"""ğŸ”” <b>ĞĞĞ’ĞĞ• ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ• ĞŸĞ Ğ’ĞĞ¨Ğ•Ğ™ Ğ—ĞĞ¯Ğ’ĞšĞ•!</b>


ğŸ“¦ <b>Ğ—Ğ°ÑĞ²ĞºĞ° #{request_id}</b>
ğŸ‘¤ ĞÑ‚: <b>{logist_name}</b>
ğŸš› Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚: <b>{transport}</b>
ğŸ’° Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ: <b>{price:,.0f} â‚½</b>
ğŸ“… Ğ”Ğ°Ñ‚Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸: <b>{delivery_date}</b>"""

                if additional_info:
                    exporter_text += f"\n\nâ„¹ï¸ Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾:\n{additional_info}"

                print(f"ğŸ” DEBUG: Ğ¡Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ ÑĞ¾ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ğ¾, ÑĞ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ ĞºĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ñƒ Ñ ĞºĞ½Ğ¾Ğ¿ĞºĞ¾Ğ¹")

                exporter_keyboard = InlineKeyboardMarkup()
                exporter_keyboard.add(
                    InlineKeyboardButton(
                        "ğŸ‘ ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ", callback_data=f"view_offer_details_{offer_id}"
                    )
                )

                print(
                    f"ğŸ” DEBUG: ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ñƒ {exporter_id} Ñ ĞºĞ½Ğ¾Ğ¿ĞºĞ¾Ğ¹ view_offer_details_{offer_id}"
                )

                await bot.send_message(
                    exporter_id,
                    exporter_text,
                    reply_markup=exporter_keyboard,
                    parse_mode="HTML",
                )

                print(f"âœ… DEBUG: ĞšĞ½Ğ¾Ğ¿ĞºĞ° ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ° ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ñƒ {exporter_id}")
                logging.info(f"ğŸ“§ Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ñƒ {exporter_id}")

            except Exception as e:
                print(f"âŒ DEBUG ĞĞ¨Ğ˜Ğ‘ĞšĞ: {type(e).__name__}: {str(e)}")
                logging.error(
                    f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ñƒ {exporter_id}: {e}",
                    exc_info=True,
                )
        else:
            print(
                f"âš ï¸ DEBUG: exporter_id=None Ğ¸Ğ»Ğ¸ Ğ¿ÑƒÑÑ‚Ğ¾! request_id={request_id}, request={request}"
            )
            logging.warning(f"âš ï¸ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ Ğ´Ğ»Ñ Ğ·Ğ°ÑĞ²ĞºĞ¸ #{request_id}")

        await state.finish()
        await callback.answer("âœ… ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾!")

        logging.info(
            f"âœ… Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ {user_id} ÑĞ¾Ğ·Ğ´Ğ°Ğ» Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ #{offer_id} Ğ´Ğ»Ñ Ğ·Ğ°ÑĞ²ĞºĞ¸ #{request_id}"
        )

    except Exception as e:
        print(f"âŒ DEBUG ĞšĞ Ğ˜Ğ¢Ğ˜Ğ§Ğ•Ğ¡ĞšĞĞ¯ ĞĞ¨Ğ˜Ğ‘ĞšĞ: {type(e).__name__}: {str(e)}")
        logging.error(f"âŒ ĞšÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¾ÑˆĞ¸Ğ±ĞºĞ° Ğ² offer_confirmed: {e}", exc_info=True)
        await callback.answer(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)}", show_alert=True)
        await callback.message.answer(
            "âŒ <b>ĞĞ¨Ğ˜Ğ‘ĞšĞ ĞŸĞ Ğ˜ Ğ¡ĞĞ—Ğ”ĞĞĞ˜Ğ˜ ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯</b>\n\n"
            "ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ· Ğ¸Ğ»Ğ¸ ÑĞ²ÑĞ¶Ğ¸Ñ‚ĞµÑÑŒ Ñ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ¾Ğ¹.",
            parse_mode="HTML",
        )


@dp.callback_query_handler(text="cancel_offer", state="*")
async def offer_cancelled(callback: types.CallbackQuery, state: FSMContext):
    """ĞÑ‚Ğ¼ĞµĞ½Ğ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ"""
    user_id = callback.from_user.id

    # ğŸ“‹ ĞŸĞĞ›Ğ£Ğ§ĞĞ•Ğœ Ğ”ĞĞĞĞ«Ğ• ĞŸĞ•Ğ Ğ•Ğ” Ğ—ĞĞ’Ğ•Ğ Ğ¨Ğ•ĞĞ˜Ğ•Ğœ Ğ¡ĞĞ¡Ğ¢ĞĞ¯ĞĞ˜Ğ¯
    data = await state.get_data()
    request_id = data.get("request_id")

    # ğŸ”š Ğ—ĞĞ’Ğ•Ğ Ğ¨ĞĞ•Ğœ Ğ¡ĞĞ¡Ğ¢ĞĞ¯ĞĞ˜Ğ•
    await state.finish()

    # ğŸ“ Ğ¤ĞĞ ĞœĞ˜Ğ Ğ£Ğ•Ğœ Ğ¢Ğ•ĞšĞ¡Ğ¢
    text = """âŒ <b>Ğ¡ĞĞ—Ğ”ĞĞĞ˜Ğ• ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯ ĞĞ¢ĞœĞ•ĞĞ•ĞĞ</b>

Ğ’Ñ‹ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ğ»Ğ¸ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ.
Ğ’ĞµÑ€Ğ½Ğ¸Ñ‚ĞµÑÑŒ Ğ½Ğ° Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ¸Ñ‚ÑŒ."""

    # ğŸ¨ ĞšĞ›ĞĞ’Ğ˜ĞĞ¢Ğ£Ğ Ğ
    keyboard = InlineKeyboardMarkup(row_width=1)
    keyboard.add(InlineKeyboardButton("ğŸ”™ Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main"))

    # ğŸ“¤ ĞĞ¢ĞŸĞ ĞĞ’Ğ›Ğ¯Ğ•Ğœ Ğ¡ĞĞĞ‘Ğ©Ğ•ĞĞ˜Ğ•
    try:
        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    except Exception as e:
        logging.warning(f"âš ï¸ ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¾Ñ‚Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ: {e}")
        try:
            await callback.message.answer(
                text, reply_markup=keyboard, parse_mode="HTML"
            )
        except Exception as e:
            logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ¾Ğ± Ğ¾Ñ‚Ğ¼ĞµĞ½Ğµ: {e}")

    await callback.answer("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ° Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ°", show_alert=False)

    logging.info(
        f"â„¹ï¸ Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ {user_id} Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ğ» ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ´Ğ»Ñ Ğ·Ğ°ÑĞ²ĞºĞ¸ #{request_id}"
    )


# ============================================================================
# Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢: Ğ£ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ• ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯ĞœĞ˜
# ============================================================================
@dp.message_handler(lambda m: m.text == "ğŸ’¼ ĞœĞ¾Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ", state="*")
async def logistic_my_offers_text_button(message: types.Message, state: FSMContext):
    """Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ Ğ½Ğ°Ğ¶Ğ°Ğ» Ğ½Ğ° Ğ¢Ğ•ĞšĞ¡Ğ¢ĞĞ’Ğ£Ğ® ĞºĞ½Ğ¾Ğ¿ĞºÑƒ 'ğŸ’¼ ĞœĞ¾Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ'"""

    logger.info(
        f"âœ… Ğ¢Ğ•ĞšĞ¡Ğ¢ĞĞ’ĞĞ¯ ĞšĞĞĞŸĞšĞ: ğŸ’¼ ĞœĞ¾Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ | User: {message.from_user.id}"
    )

    user_id = message.from_user.id

    try:
        await state.finish()

        my_offers = [
            (offer_id, offer)
            for offer_id, offer in logistic_offers.items()
            if offer.get("logist_id") == user_id
        ]

        logger.info(f"[{user_id}] ğŸ“¦ ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹: {len(my_offers)}")

        if not my_offers:
            text = "ğŸ“‹ <b>ĞœĞĞ˜ ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯</b>\n\nâŒ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹"
            keyboard = InlineKeyboardMarkup()
            keyboard.add(
                InlineKeyboardButton(
                    "ğŸ“¦ Ğš Ğ·Ğ°ÑĞ²ĞºĞ°Ğ¼", callback_data="logistic_requests_list"
                )
            )
            keyboard.add(InlineKeyboardButton("ğŸ”™ ĞœĞµĞ½Ñ", callback_data="back_to_main"))

            await message.answer(text, reply_markup=keyboard, parse_mode="HTML")
            return

        # âœ… Ğ›ĞĞ“Ğ˜Ğ Ğ£Ğ•Ğœ Ğ Ğ•ĞĞ›Ğ¬ĞĞ«Ğ• Ğ¡Ğ¢ĞĞ¢Ğ£Ğ¡Ğ«
        by_status = {}
        for offer_id, offer in my_offers:
            status = offer.get("status", "pending")
            logger.info(
                f"[{user_id}] ğŸ“Œ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ #{offer_id}: ÑÑ‚Ğ°Ñ‚ÑƒÑ = '{status}'"
            )  # ğŸ” Ğ›ĞĞ“Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ•
            if status not in by_status:
                by_status[status] = []
            by_status[status].append((offer_id, offer))

        logger.info(
            f"[{user_id}] ğŸ“Š Ğ’ÑĞµ ÑÑ‚Ğ°Ñ‚ÑƒÑÑ‹: {dict((k, len(v)) for k, v in by_status.items())}"
        )

        text = f"ğŸ“‹ <b>ĞœĞĞ˜ ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯</b> ({len(my_offers)} ÑˆÑ‚)\n\n"
        text += f"ğŸ• ĞĞ¶Ğ¸Ğ´Ğ°ÑÑ‚: {len(by_status.get('pending', []))}\n"
        text += f"âœ… ĞŸÑ€Ğ¸Ğ½ÑÑ‚Ñ‹: {len(by_status.get('accepted', []))}\n"
        text += f"âŒ ĞÑ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ñ‹: {len(by_status.get('rejected', []))}\n"
        text += f"â›” ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½Ñ‹: {len(by_status.get('cancelled', []))}\n\n"

        keyboard = InlineKeyboardMarkup(row_width=1)
        button_count = 0

        for status_key, emoji in [
            ("pending", "ğŸ•"),
            ("accepted", "âœ…"),
            ("rejected", "âŒ"),
            ("cancelled", "â›”"),
        ]:
            for offer_id, offer in by_status.get(status_key, [])[:5]:
                if button_count >= 10:
                    break
                price = offer.get("price", 0)
                button_text = f"{emoji} #{offer_id} | {price:,.0f}â‚½"
                keyboard.add(
                    InlineKeyboardButton(
                        button_text, callback_data=f"view_my_offer_{offer_id}"
                    )
                )
                button_count += 1

        keyboard.add(InlineKeyboardButton("ğŸ”™ ĞœĞµĞ½Ñ", callback_data="back_to_main"))

        await message.answer(text, reply_markup=keyboard, parse_mode="HTML")
        logger.info(f"[{user_id}] âœ… Ğ£Ğ¡ĞŸĞ•Ğ¥! ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¾ {button_count} ĞºĞ½Ğ¾Ğ¿Ğ¾Ğº")

    except Exception as e:
        logger.error(f"[{user_id}] âŒ ĞĞ¨Ğ˜Ğ‘ĞšĞ: {e}", exc_info=True)
        await message.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸", parse_mode="HTML")


@dp.callback_query_handler(lambda c: c.data == "my_offers")
async def show_my_offers(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¼Ğ¾Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ"""

    user_id = callback.from_user.id
    username = callback.from_user.username or "NoUsername"

    logger.info(f"âœ… ĞšĞ›Ğ˜Ğš ĞŸĞ 'ĞœĞĞ˜ ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯' | User: {user_id} | @{username}")

    try:
        try:
            await state.finish()
            logger.debug(f"[{user_id}] FSM state Ğ·Ğ°Ğ²ĞµÑ€ÑˆÑ‘Ğ½")
        except:
            logger.debug(f"[{user_id}] State Ğ±Ñ‹Ğ» Ğ¿ÑƒÑÑ‚")

        my_offers = [
            (offer_id, offer)
            for offer_id, offer in logistic_offers.items()
            if offer.get("logist_id") == user_id
        ]

        logger.info(f"[{user_id}] ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹: {len(my_offers)}")

        if not my_offers:
            text = "ğŸ“‹ <b>ĞœĞĞ˜ ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯</b>\n\nâŒ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹"
            keyboard = InlineKeyboardMarkup()
            keyboard.add(
                InlineKeyboardButton(
                    "ğŸ“¦ Ğš Ğ·Ğ°ÑĞ²ĞºĞ°Ğ¼", callback_data="logistic_requests_list"
                )
            )
            keyboard.add(InlineKeyboardButton("ğŸ”™ ĞœĞµĞ½Ñ", callback_data="back_to_main"))

            await callback.message.edit_text(
                text, reply_markup=keyboard, parse_mode="HTML"
            )
            await callback.answer()
            return

        # âœ… ĞĞ• Ğ¡ĞĞ—Ğ”ĞĞĞœ ĞŸĞ£Ğ¡Ğ¢ĞĞ™ Ğ¡Ğ›ĞĞ’ĞĞ Ğ¬! Ğ¡ĞĞ‘Ğ˜Ğ ĞĞ•Ğœ Ğ’Ğ¡Ğ• Ğ¡Ğ¢ĞĞ¢Ğ£Ğ¡Ğ«
        by_status = {}
        for offer_id, offer in my_offers:
            status = offer.get("status", "pending")
            logger.info(f"[{user_id}] ğŸ“Œ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ #{offer_id}: ÑÑ‚Ğ°Ñ‚ÑƒÑ = '{status}'")
            if status not in by_status:
                by_status[status] = []
            by_status[status].append((offer_id, offer))

        logger.info(
            f"[{user_id}] ğŸ“Š Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ¸Ñ€Ğ¾Ğ²ĞºĞ°: {dict((k, len(v)) for k, v in by_status.items())}"
        )

        text = f"ğŸ“‹ <b>ĞœĞĞ˜ ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯</b> ({len(my_offers)} ÑˆÑ‚)\n\n"
        text += f"ğŸ• ĞĞ¶Ğ¸Ğ´Ğ°ÑÑ‚: {len(by_status.get('pending', []))}\n"
        text += f"âœ… ĞŸÑ€Ğ¸Ğ½ÑÑ‚Ñ‹: {len(by_status.get('accepted', []))}\n"
        text += f"âŒ ĞÑ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ñ‹: {len(by_status.get('rejected', []))}\n"
        text += f"â›” ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½Ñ‹: {len(by_status.get('cancelled', []))}\n\n"

        keyboard = InlineKeyboardMarkup(row_width=1)
        button_count = 0

        # âœ… Ğ”ĞĞ‘ĞĞ’Ğ›Ğ¯Ğ•Ğœ Ğ’Ğ¡Ğ• Ğ¡Ğ¢ĞĞ¢Ğ£Ğ¡Ğ«
        for status_key, emoji in [
            ("pending", "ğŸ•"),
            ("accepted", "âœ…"),
            ("rejected", "âŒ"),
            ("cancelled", "â›”"),
        ]:
            for offer_id, offer in by_status.get(status_key, [])[:5]:
                if button_count >= 10:
                    break
                price = offer.get("price", 0)
                button_text = f"{emoji} #{offer_id} | {price:,.0f}â‚½"
                keyboard.add(
                    InlineKeyboardButton(
                        button_text, callback_data=f"view_my_offer_{offer_id}"
                    )
                )
                button_count += 1

        keyboard.add(InlineKeyboardButton("ğŸ”™ ĞœĞµĞ½Ñ", callback_data="back_to_main"))

        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
        await callback.answer()

        logger.info(f"[{user_id}] âœ… Ğ£Ğ¡ĞŸĞ•Ğ¥! ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¾ {button_count} ĞºĞ½Ğ¾Ğ¿Ğ¾Ğº")

    except Exception as e:
        logger.error(f"[{user_id}] âŒ ĞĞ¨Ğ˜Ğ‘ĞšĞ: {e}", exc_info=True)
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸", show_alert=True)


@dp.callback_query_handler(lambda c: c.data.startswith("view_my_offer_"), state="*")
async def view_my_offer_details(callback: types.CallbackQuery, state: FSMContext):
    """Ğ”ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ ÑĞ²Ğ¾ĞµĞ³Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ"""
    await state.finish()
    try:
        offer_id = int(callback.data.split("_")[-1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ ID Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ", show_alert=True)
        return

    if offer_id not in logistic_offers:
        await callback.answer("âŒ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾", show_alert=True)
        return

    offer = logistic_offers[offer_id]
    user_id = callback.from_user.id
    if offer.get("logist_id") != user_id:
        await callback.answer("âŒ Ğ­Ñ‚Ğ¾ Ğ½Ğµ Ğ²Ğ°ÑˆĞµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ", show_alert=True)
        return

    request_id = offer.get("request_id")
    request = shipping_requests.get(request_id, {})
    pull_id = request.get("pull_id")
    pull_info = pulls.get(pull_id, {})
    exporter_id = request.get("exporter_id")
    exporter_info = users.get(exporter_id, {})
    exporter_company = exporter_info.get("company_name", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°")
    vehicles_display = {
        "fura": "ğŸš› Ğ¤ÑƒÑ€Ğ°",
        "railway": "ğŸš‚ Ğ–/Ğ´ Ğ²Ğ°Ğ³Ğ¾Ğ½",
        "grain": "ğŸšš Ğ—ĞµÑ€Ğ½Ğ¾Ğ²Ğ¾Ğ·",
    }

    text = f"ğŸ“‹ <b>ĞœĞĞ ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ• #{offer_id}</b>\n\n"
    text += f"ğŸ“¦ <b>Ğ—ĞĞ¯Ğ’ĞšĞ #{request_id}</b>\n"
    text += f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {pull_info.get('culture', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}\n"
    text += f"ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: {request.get('volume', 0):.1f} Ñ‚\n"
    text += (
        f"ğŸ“ ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚: {request.get('route_from', '')} â†’ {request.get('route_to', '')}\n"
    )
    text += f"ğŸ‘¤ Ğ—Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸Ğº: {exporter_company}\n\n"
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    text += f"<b>Ğ’ĞĞ¨Ğ• ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ•:</b>\n\n"
    transport = vehicles_display.get(offer.get("vehicle_type"), "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
    text += f"ğŸš› Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚: <b>{transport}</b>\n"
    text += f"ğŸ’° Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ: <b>{offer.get('price', 0):,.0f} â‚½</b>\n"
    text += f"ğŸ“… Ğ”Ğ°Ñ‚Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸: <b>{offer.get('delivery_date', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}</b>\n"
    if offer.get("additional_info"):
        text += f"\nâ„¹ï¸ Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾:\n{offer.get('additional_info')}\n"
    text += f"\nğŸ“… Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¾: {offer.get('created_at', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n"
    if offer.get("updated_at"):
        text += f"âœï¸ Ğ˜Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¾: {offer.get('updated_at')}\n"
    text += "\n"
    status = offer.get("status", "pending")
    status_icon = status_map.get(status, "âšª").split()[0]
    status_name = get_status_name(status)

    text += f"ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: <b>{status_icon} {status_name}</b>\n"
    if status == "accepted":
        text += f"\nâœ… <b>Ğ’Ğ°ÑˆĞµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¾!</b>\n"
        text += f"<i>ĞĞ¶Ğ¸Ğ´Ğ°Ğ¹Ñ‚Ğµ Ğ´Ğ°Ğ»ÑŒĞ½ĞµĞ¹ÑˆĞ¸Ñ… Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞºÑ†Ğ¸Ğ¹ Ğ¾Ñ‚ Ğ·Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸ĞºĞ°</i>"
    elif status == "rejected":
        text += f"\nâŒ <b>ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¾</b>\n"
        if offer.get("rejection_reason"):
            text += f"<i>ĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ°: {offer.get('rejection_reason')}</i>"
    elif status == "cancelled":
        text += f"\nğŸš« <b>ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾ Ğ²Ğ°Ğ¼Ğ¸</b>"
        if offer.get("cancelled_at"):
            text += f"\n<i>ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾: {offer.get('cancelled_at')}</i>"

    keyboard = InlineKeyboardMarkup(row_width=2)
    if status == "pending":
        keyboard.add(
            InlineKeyboardButton(
                "âœï¸ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ†ĞµĞ½Ñƒ", callback_data=f"edit_price_{offer_id}"
            ),
            InlineKeyboardButton(
                "âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ", callback_data=f"cancel_my_offer_{offer_id}"
            ),
        )
    keyboard.add(
        InlineKeyboardButton("ğŸ”™ Ğš Ğ¼Ğ¾Ğ¸Ğ¼ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸ÑĞ¼", callback_data="my_offers")
    )
    keyboard.add(InlineKeyboardButton("ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main"))

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("cancel_my_offer_"), state="*")
async def cancel_my_offer_confirm(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‹ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ"""
    await state.finish()

    try:
        offer_id = int(callback.data.split("_")[-1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ ID", show_alert=True)
        return

    if offer_id not in logistic_offers:
        await callback.answer("âŒ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾", show_alert=True)
        return

    offer = logistic_offers[offer_id]

    if offer.get("logist_id") != callback.from_user.id:
        await callback.answer("âŒ Ğ­Ñ‚Ğ¾ Ğ½Ğµ Ğ²Ğ°ÑˆĞµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ", show_alert=True)
        return

    if offer.get("status") != "pending":
        await callback.answer(
            "âŒ ĞœĞ¾Ğ¶Ğ½Ğ¾ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¾Ğ¶Ğ¸Ğ´Ğ°ÑÑ‰Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ", show_alert=True
        )
        return

    vehicles_display = {
        "fura": "ğŸš› Ğ¤ÑƒÑ€Ğ°",
        "railway": "ğŸš‚ Ğ–/Ğ´ Ğ²Ğ°Ğ³Ğ¾Ğ½",
        "grain": "ğŸšš Ğ—ĞµÑ€Ğ½Ğ¾Ğ²Ğ¾Ğ·",
    }

    transport = vehicles_display.get(offer.get("vehicle_type"), "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ñ‹Ğ¹")

    text = f"â“ <b>ĞĞ¢ĞœĞ•ĞĞ ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯ #{offer_id}</b>\n\n"
    text += f"Ğ’Ñ‹ ÑƒĞ²ĞµÑ€ĞµĞ½Ñ‹, Ñ‡Ñ‚Ğ¾ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ÑÑ‚Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ?\n\n"
    text += f"ğŸš› Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚: {transport}\n"
    text += f"ğŸ’° Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ: {offer.get('price', 0):,.0f} â‚½\n\n"
    text += f"<i>Ğ­Ñ‚Ğ¾ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ½ĞµĞ»ÑŒĞ·Ñ Ğ±ÑƒĞ´ĞµÑ‚ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ</i>"

    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton(
            "âœ… Ğ”Ğ°, Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ", callback_data=f"confirm_cancel_offer_{offer_id}"
        ),
        InlineKeyboardButton("âŒ ĞĞµÑ‚", callback_data=f"view_my_offer_{offer_id}"),
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("confirm_cancel_offer_"), state="*"
)
async def cancel_my_offer_confirmed(callback: types.CallbackQuery, state: FSMContext):
    """ĞÑ‚Ğ¼ĞµĞ½Ğ° Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ°"""
    await state.finish()

    try:
        offer_id = int(callback.data.split("_")[-1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ ID", show_alert=True)
        return

    if offer_id not in logistic_offers:
        await callback.answer("âŒ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾", show_alert=True)
        return

    offer = logistic_offers[offer_id]

    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ
    offer["status"] = "cancelled"
    offer["cancelled_at"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°
    request_id = offer.get("request_id")
    request = shipping_requests.get(request_id, {})
    exporter_id = request.get("exporter_id")
    logist_name = users.get(callback.from_user.id, {}).get("company_name", "Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚")

    if exporter_id:
        try:
            await bot.send_message(
                exporter_id,
                f"ğŸ”” <b>ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ #{offer_id} Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾</b>\n\n"
                f"ğŸ“¦ Ğ—Ğ°ÑĞ²ĞºĞ° #{request_id}\n"
                f"ğŸ‘¤ Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚: {logist_name}\n"
                f"Ğš ÑĞ¾Ğ¶Ğ°Ğ»ĞµĞ½Ğ¸Ñ, Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ğ» ÑĞ²Ğ¾Ñ‘ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ.",
                parse_mode="HTML",
            )
        except Exception as e:
            logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°: {e}")

    text = f"âœ… <b>ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ• #{offer_id} ĞĞ¢ĞœĞ•ĞĞ•ĞĞ</b>\n\n"
    text += f"Ğ’Ğ°ÑˆĞµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾.\n"
    text += f"Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ğ» ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ğ± ÑÑ‚Ğ¾Ğ¼."

    keyboard = InlineKeyboardMarkup()
    keyboard.add(InlineKeyboardButton("ğŸ’¼ ĞœĞ¾Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ", callback_data="my_offers"))
    keyboard.add(InlineKeyboardButton("ğŸ”™ Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main"))

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer("âœ… ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾")

    logging.info(f"âŒ Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ {callback.from_user.id} Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ğ» Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ #{offer_id}")


@dp.callback_query_handler(lambda c: c.data.startswith("edit_offer_"), state="*")
async def edit_offer_start(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ğ»Ğ¾ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ"""
    await state.finish()

    try:
        offer_id = int(callback.data.split("_")[-1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ ID", show_alert=True)
        return

    if offer_id not in logistic_offers:
        await callback.answer("âŒ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾", show_alert=True)
        return

    offer = logistic_offers[offer_id]

    if offer.get("logist_id") != callback.from_user.id:
        await callback.answer("âŒ Ğ­Ñ‚Ğ¾ Ğ½Ğµ Ğ²Ğ°ÑˆĞµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ", show_alert=True)
        return

    if offer.get("status") != "pending":
        await callback.answer(
            "âŒ ĞœĞ¾Ğ¶Ğ½Ğ¾ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¾Ğ¶Ğ¸Ğ´Ğ°ÑÑ‰Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ", show_alert=True
        )
        return

    text = f"âœï¸ <b>Ğ Ğ•Ğ”ĞĞšĞ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ• ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯ #{offer_id}</b>\n\n"
    text += f"Ğ¢ĞµĞºÑƒÑ‰Ğ¸Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ:\n\n"
    text += f"ğŸš› Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚: {offer.get('vehicle_type')}\n"
    text += f"ğŸ’° Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ: {offer.get('price', 0):,.0f} â‚½\n"
    text += f"ğŸ“… Ğ”Ğ°Ñ‚Ğ°: {offer.get('delivery_date')}\n\n"
    text += f"Ğ§Ñ‚Ğ¾ Ğ²Ñ‹ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ?"

    keyboard = InlineKeyboardMarkup(row_width=1)
    keyboard.add(
        InlineKeyboardButton(
            "ğŸš› Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚", callback_data=f"edit_vehicle_{offer_id}"
        ),
        InlineKeyboardButton(
            "ğŸ’° Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ†ĞµĞ½Ñƒ", callback_data=f"edit_price_{offer_id}"
        ),
        InlineKeyboardButton("ğŸ“… Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ´Ğ°Ñ‚Ñƒ", callback_data=f"edit_date_{offer_id}"),
        InlineKeyboardButton(
            "â„¹ï¸ Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ´Ğ¾Ğ¿. Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ", callback_data=f"edit_info_{offer_id}"
        ),
    )
    keyboard.add(
        InlineKeyboardButton("ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´", callback_data=f"view_my_offer_{offer_id}")
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


# Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ğ¼ FSM states Ğ´Ğ»Ñ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
class EditOfferStatesGroup(StatesGroup):
    """FSM Ğ´Ğ»Ñ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ"""

    offer_id = State()
    field = State()
    value = State()


@dp.callback_query_handler(lambda c: c.data.startswith("edit_price_"), state="*")
async def edit_offer_price(callback: types.CallbackQuery, state: FSMContext):
    """Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ†ĞµĞ½Ñ‹"""
    await state.finish()

    try:
        offer_id = int(callback.data.split("_")[-1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    offer = logistic_offers.get(offer_id)
    if not offer:
        await callback.answer("âŒ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾", show_alert=True)
        return

    if offer.get("logist_id") != callback.from_user.id:
        await callback.answer("âŒ Ğ­Ñ‚Ğ¾ Ğ½Ğµ Ğ²Ğ°ÑˆĞµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ", show_alert=True)
        return

    if offer.get("status") != "pending":
        await callback.answer(
            "âŒ ĞĞµĞ»ÑŒĞ·Ñ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ", show_alert=True
        )
        return

    await state.update_data(offer_id=offer_id, field="price")

    text = f"ğŸ’° <b>Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ• Ğ¦Ğ•ĞĞ«</b>\n\n"
    text += f"Ğ—Ğ°ÑĞ²ĞºĞ° #{offer.get('request_id')}\n\n"
    text += f"Ğ¢ĞµĞºÑƒÑ‰Ğ°Ñ Ñ†ĞµĞ½Ğ°: <b>{offer.get('price', 0):,.0f} â‚½</b>\n\n"
    text += f"Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²ÑƒÑ Ñ†ĞµĞ½Ñƒ Ğ² Ñ€ÑƒĞ±Ğ»ÑÑ…:"

    keyboard = InlineKeyboardMarkup()
    keyboard.add(
        InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data=f"view_my_offer_{offer_id}")
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await EditOfferStatesGroup.value.set()
    await callback.answer()


@dp.message_handler(state=EditOfferStatesGroup.value)
async def edit_offer_value_entered(message: types.Message, state: FSMContext):
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½Ñ‘Ğ½Ğ½Ğ¾Ğ³Ğ¾ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ"""
    data = await state.get_data()
    offer_id = data.get("offer_id")
    field = data.get("field")

    offer = logistic_offers.get(offer_id)
    if not offer:
        await message.answer("âŒ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾")
        await state.finish()
        return

    # Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ
    if field == "price":
        try:
            new_price = float(
                message.text.strip().replace(" ", "").replace(",", "").replace("â‚½", "")
            )
            if new_price <= 0 or new_price > 10000000:
                await message.answer(
                    "âŒ ĞĞµĞ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ°Ñ Ñ†ĞµĞ½Ğ°! Ğ”Ğ¸Ğ°Ğ¿Ğ°Ğ·Ğ¾Ğ½: 1 - 10 Ğ¼Ğ»Ğ½ â‚½\n\nĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·:"
                )
                return

            old_price = offer.get("price")
            offer["price"] = new_price
            offer["updated_at"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

            text = f"âœ… <b>Ğ¦Ğ•ĞĞ Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ!</b>\n\n"
            text += f"Ğ‘Ñ‹Ğ»Ğ¾: {old_price:,.0f} â‚½\n"
            text += f"Ğ¡Ñ‚Ğ°Ğ»Ğ¾: <b>{new_price:,.0f} â‚½</b>\n\n"
            text += f"Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ğ± Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¸"

            # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°
            request_id = offer.get("request_id")
            request = shipping_requests.get(request_id, {})
            exporter_id = request.get("exporter_id")
            logist_name = users.get(message.from_user.id, {}).get(
                "company_name", "Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚"
            )

            if exporter_id:
                try:
                    await bot.send_message(
                        exporter_id,
                        f"ğŸ”” <b>ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ #{offer_id} Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¾</b>\n\n"
                        f"ğŸ“¦ Ğ—Ğ°ÑĞ²ĞºĞ° #{request_id}\n"
                        f"ğŸ‘¤ Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚: {logist_name}\n"
                        f"ğŸ’° ĞĞ¾Ğ²Ğ°Ñ Ñ†ĞµĞ½Ğ°: <b>{new_price:,.0f} â‚½</b>",
                        parse_mode="HTML",
                    )
                except Exception as e:
                    logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ: {e}")

        except ValueError:
            await message.answer(
                "âŒ ĞĞµĞ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚! Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ (Ğ±ĞµĞ· ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²)\n\nĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·:"
            )
            return

    keyboard = InlineKeyboardMarkup()
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ‘ ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ", callback_data=f"view_my_offer_{offer_id}"
        )
    )
    keyboard.add(InlineKeyboardButton("ğŸ’¼ ĞœĞ¾Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ", callback_data="my_offers"))

    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")
    await state.finish()

    logging.info(
        f"âœï¸ Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ {message.from_user.id} Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ğ» Ñ†ĞµĞ½Ñƒ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ #{offer_id}"
    )


# ============================================================================
# Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢: Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ Ğ£Ğ’Ğ•Ğ”ĞĞœĞ›Ğ•ĞĞ˜Ğ™
# ============================================================================


async def notify_logistic_offer_accepted(offer_id: int, exporter_id: int):
    """Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° Ğ¾ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¸Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ"""
    try:
        if offer_id not in logistic_offers:
            return

        offer = logistic_offers[offer_id]
        logist_id = offer.get("logist_id")

        if not logist_id:
            return

        request_id = offer.get("request_id")
        request = shipping_requests.get(request_id, {})
        exporter_info = users.get(exporter_id, {})
        exporter_company = exporter_info.get("company_name", "ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ")

        text = f"ğŸ‰ <b>Ğ’ĞĞ¨Ğ• ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ• ĞŸĞ Ğ˜ĞĞ¯Ğ¢Ğ!</b>\n\n"
        text += f"ğŸ“‹ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ #{offer_id}\n"
        text += f"ğŸ“¦ Ğ—Ğ°ÑĞ²ĞºĞ° #{request_id}\n"
        text += f"ğŸ‘¤ Ğ—Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸Ğº: {exporter_company}\n\n"
        text += f"ğŸš› Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚: {offer.get('vehicle_type')}\n"
        text += f"ğŸ’° Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ: {offer.get('price', 0):,.0f} â‚½\n"
        text += f"ğŸ“… Ğ”Ğ°Ñ‚Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸: {offer.get('delivery_date')}\n\n"
        text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        text += f"âœ… <b>Ğ¡Ğ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğµ ÑˆĞ°Ğ³Ğ¸:</b>\n"
        text += f"1. Ğ¡Ğ²ÑĞ¶Ğ¸Ñ‚ĞµÑÑŒ Ñ Ğ·Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸ĞºĞ¾Ğ¼\n"
        text += f"2. Ğ£Ñ‚Ğ¾Ñ‡Ğ½Ğ¸Ñ‚Ğµ Ğ´ĞµÑ‚Ğ°Ğ»Ğ¸ Ğ¿Ğ¾Ğ³Ñ€ÑƒĞ·ĞºĞ¸\n"
        text += f"3. ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ÑŒÑ‚Ğµ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚\n\n"

        if exporter_info.get("phone"):
            text += f"ğŸ“ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½ Ğ·Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸ĞºĞ°: {exporter_info.get('phone')}\n"

        keyboard = InlineKeyboardMarkup()
        keyboard.add(
            InlineKeyboardButton(
                "ğŸ“‹ Ğ”ĞµÑ‚Ğ°Ğ»Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ", callback_data=f"view_my_offer_{offer_id}"
            )
        )
        keyboard.add(
            InlineKeyboardButton("ğŸš› ĞœĞ¾Ğ¸ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸", callback_data="my_deliveries")
        )

        await bot.send_message(
            logist_id, text, reply_markup=keyboard, parse_mode="HTML"
        )

        logging.info(f"âœ… Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¸Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ñƒ {logist_id}")

    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° Ğ¾ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¸Ğ¸: {e}")


async def notify_logistic_offer_rejected(
    offer_id: int, exporter_id: int, reason: str = None
):
    """Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° Ğ¾Ğ± Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ"""
    try:
        if offer_id not in logistic_offers:
            return

        offer = logistic_offers[offer_id]
        logist_id = offer.get("logist_id")

        if not logist_id:
            return

        request_id = offer.get("request_id")
        exporter_info = users.get(exporter_id, {})
        exporter_company = exporter_info.get("company_name", "ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ")

        text = f"âŒ <b>ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ• ĞĞ¢ĞšĞ›ĞĞĞ•ĞĞ</b>\n\n"
        text += f"ğŸ“‹ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ #{offer_id}\n"
        text += f"ğŸ“¦ Ğ—Ğ°ÑĞ²ĞºĞ° #{request_id}\n"
        text += f"ğŸ‘¤ Ğ—Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸Ğº: {exporter_company}\n\n"
        text += f"Ğš ÑĞ¾Ğ¶Ğ°Ğ»ĞµĞ½Ğ¸Ñ, Ğ²Ğ°ÑˆĞµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ½Ğµ Ğ±Ñ‹Ğ»Ğ¾ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¾.\n\n"

        if reason:
            text += f"ğŸ’¬ <b>ĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ°:</b>\n{reason}\n\n"

        text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        text += f"ğŸ’¡ <b>Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ğ¸Ğ¸:</b>\n"
        text += f"â€¢ ĞŸĞµÑ€ĞµÑĞ¼Ğ¾Ñ‚Ñ€Ğ¸Ñ‚Ğµ ÑĞ²Ğ¾Ñ Ñ†ĞµĞ½Ğ¾Ğ²ÑƒÑ Ğ¿Ğ¾Ğ»Ğ¸Ñ‚Ğ¸ĞºÑƒ\n"
        text += f"â€¢ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶Ğ¸Ñ‚Ğµ Ğ±Ğ¾Ğ»ĞµĞµ Ğ³Ğ¸Ğ±ĞºĞ¸Ğµ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ñ\n"
        text += f"â€¢ Ğ˜Ñ‰Ğ¸Ñ‚Ğµ Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸\n"

        keyboard = InlineKeyboardMarkup()
        keyboard.add(
            InlineKeyboardButton(
                "ğŸ“¦ ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸", callback_data="logistic_requests_list"
            )
        )
        keyboard.add(
            InlineKeyboardButton("ğŸ’¼ ĞœĞ¾Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ", callback_data="my_offers")
        )

        await bot.send_message(
            logist_id, text, reply_markup=keyboard, parse_mode="HTML"
        )

        logging.info(f"âŒ Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ğ± Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ñƒ {logist_id}")

    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° Ğ¾Ğ± Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ğ¸: {e}")


async def notify_logistic_new_request(request_id: int):
    """Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ Ğ²ÑĞµÑ… Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ² Ğ¾ Ğ½Ğ¾Ğ²Ğ¾Ğ¹ Ğ·Ğ°ÑĞ²ĞºĞµ"""
    try:
        if request_id not in shipping_requests:
            return

        request = shipping_requests[request_id]
        pull_id = request.get("pull_id")
        pull_info = pulls.get(pull_id, {})

        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ²ÑĞµÑ… Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²
        logistics = [
            uid for uid, user in users.items() if user.get("role") == "logistic"
        ]

        if not logistics:
            return

        text = f"ğŸ”” <b>ĞĞĞ’ĞĞ¯ Ğ—ĞĞ¯Ğ’ĞšĞ ĞĞ Ğ”ĞĞ¡Ğ¢ĞĞ’ĞšĞ£!</b>\n\n"
        text += f"ğŸ“¦ Ğ—Ğ°ÑĞ²ĞºĞ° #{request_id}\n"
        text += f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {pull_info.get('culture', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}\n"
        text += f"ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: {request.get('volume', 0):.1f} Ñ‚\n"
        text += f"ğŸ“ ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚: {request.get('route_from', '')} â†’ {request.get('route_to', '')}\n"

        if request.get("desired_date"):
            text += f"ğŸ“… Ğ–ĞµĞ»Ğ°ĞµĞ¼Ğ°Ñ Ğ´Ğ°Ñ‚Ğ°: {request.get('desired_date')}\n"

        if request.get("budget"):
            text += f"ğŸ’° Ğ‘ÑĞ´Ğ¶ĞµÑ‚: {request.get('budget'):,.0f} â‚½\n"

        text += f"\n<i>Ğ¢Ğ¾Ñ€Ğ¾Ğ¿Ğ¸Ñ‚ĞµÑÑŒ! ĞšĞ¾Ğ½ĞºÑƒÑ€ĞµĞ½Ñ‚Ñ‹ ÑƒĞ¶Ğµ ÑĞ¼Ğ¾Ñ‚Ñ€ÑÑ‚ ÑÑ‚Ñƒ Ğ·Ğ°ÑĞ²ĞºÑƒ</i>"

        keyboard = InlineKeyboardMarkup()
        keyboard.add(
            InlineKeyboardButton(
                "ğŸ‘€ ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ğ·Ğ°ÑĞ²ĞºÑƒ",
                callback_data=f"view_shipping_request_{request_id}",
            )
        )
        keyboard.add(
            InlineKeyboardButton(
                "ğŸ“¦ Ğ’ÑĞµ Ğ·Ğ°ÑĞ²ĞºĞ¸", callback_data="logistic_requests_list"
            )
        )

        # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ¼Ñƒ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ñƒ
        sent_count = 0
        for logist_id in logistics:
            try:
                await bot.send_message(
                    logist_id, text, reply_markup=keyboard, parse_mode="HTML"
                )
                sent_count += 1
                await asyncio.sleep(0.1)  # ĞĞµĞ±Ğ¾Ğ»ÑŒÑˆĞ°Ñ Ğ·Ğ°Ğ´ĞµÑ€Ğ¶ĞºĞ° Ğ¼ĞµĞ¶Ğ´Ñƒ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ°Ğ¼Ğ¸
            except Exception as e:
                logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ñƒ {logist_id}: {e}")

        logging.info(
            f"ğŸ”” Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾ Ğ½Ğ¾Ğ²Ğ¾Ğ¹ Ğ·Ğ°ÑĞ²ĞºĞµ #{request_id} Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ {sent_count} Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°Ğ¼"
        )

    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¼Ğ°ÑÑĞ¾Ğ²Ğ¾Ğ³Ğ¾ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²: {e}")


async def notify_logistic_delivery_started(delivery_id: int):
    """Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° Ğ¾ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğµ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸"""
    try:
        if delivery_id not in deliveries:
            return

        delivery = deliveries[delivery_id]
        logist_id = delivery.get("logist_id")

        if not logist_id:
            return

        request_id = delivery.get("request_id")

        text = f"ğŸšš <b>Ğ”ĞĞ¡Ğ¢ĞĞ’ĞšĞ ĞĞĞ§ĞĞ›ĞĞ¡Ğ¬!</b>\n\n"
        text += f"ğŸ“¦ Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° #{delivery_id}\n"
        text += f"ğŸ“‹ Ğ—Ğ°ÑĞ²ĞºĞ° #{request_id}\n\n"
        text += f"âœ… Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ Ğ¸Ğ·Ğ¼ĞµĞ½Ñ‘Ğ½ Ğ½Ğ°: <b>Ğ’ Ğ¿ÑƒÑ‚Ğ¸</b>\n\n"
        text += f"ğŸ“ ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚: {delivery.get('route_from', '')} â†’ {delivery.get('route_to', '')}\n"
        text += f"ğŸ“… ĞŸĞ»Ğ°Ğ½Ğ¾Ğ²Ğ°Ñ Ğ´Ğ°Ñ‚Ğ°: {delivery.get('delivery_date', '')}\n\n"
        text += f"<i>ĞĞµ Ğ·Ğ°Ğ±ÑƒĞ´ÑŒÑ‚Ğµ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ¿Ğ¾ Ğ¿Ñ€Ğ¸Ğ±Ñ‹Ñ‚Ğ¸Ğ¸!</i>"

        keyboard = InlineKeyboardMarkup()
        keyboard.add(
            InlineKeyboardButton(
                "ğŸ“‹ Ğ”ĞµÑ‚Ğ°Ğ»Ğ¸ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸", callback_data=f"view_delivery_{delivery_id}"
            )
        )

        await bot.send_message(
            logist_id, text, reply_markup=keyboard, parse_mode="HTML"
        )

        logging.info(f"ğŸšš Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğµ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ñƒ {logist_id}")

    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ¾ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğµ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸: {e}")


async def notify_logistic_delivery_completed(delivery_id: int):
    """Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° Ğ¾ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğ¸ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸"""
    try:
        if delivery_id not in deliveries:
            return

        delivery = deliveries[delivery_id]
        logist_id = delivery.get("logist_id")

        if not logist_id:
            return

        offer_id = delivery.get("offer_id")
        offer = logistic_offers.get(offer_id, {})
        price = offer.get("price", 0)

        text = f"âœ… <b>Ğ”ĞĞ¡Ğ¢ĞĞ’ĞšĞ Ğ—ĞĞ’Ğ•Ğ Ğ¨Ğ•ĞĞ!</b>\n\n"
        text += f"ğŸ“¦ Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° #{delivery_id}\n"
        text += f"ğŸ’° Ğ¡ÑƒĞ¼Ğ¼Ğ°: <b>{price:,.0f} â‚½</b>\n\n"
        text += f"ğŸ‰ ĞŸĞ¾Ğ·Ğ´Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ ÑƒÑĞ¿ĞµÑˆĞ½Ñ‹Ğ¼ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸ĞµĞ¼ Ğ·Ğ°ĞºĞ°Ğ·Ğ°!\n\n"
        text += f"ğŸ“Š <b>Ğ¡Ğ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğµ ÑˆĞ°Ğ³Ğ¸:</b>\n"
        text += f"â€¢ ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚Ğµ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñƒ Ğ¾Ñ‚ Ğ·Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸ĞºĞ°\n"
        text += f"â€¢ Ğ—Ğ°ĞºÑ€Ğ¾Ğ¹Ñ‚Ğµ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ñ‹\n"
        text += f"â€¢ ĞÑÑ‚Ğ°Ğ²ÑŒÑ‚Ğµ Ğ¾Ñ‚Ğ·Ñ‹Ğ² Ğ¾ ÑĞ¾Ñ‚Ñ€ÑƒĞ´Ğ½Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğµ"

        keyboard = InlineKeyboardMarkup()
        keyboard.add(
            InlineKeyboardButton(
                "ğŸ“‹ Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº", callback_data="delivery_history"
            )
        )
        keyboard.add(
            InlineKeyboardButton("ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°", callback_data="logistic_statistics")
        )

        await bot.send_message(
            logist_id, text, reply_markup=keyboard, parse_mode="HTML"
        )

        logging.info(
            f"âœ… Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğ¸ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ñƒ {logist_id}"
        )

    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ¾ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğ¸ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸: {e}")


async def notify_logistic_request_cancelled(request_id: int, reason: str = None):
    """Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ² Ğ¾Ğ± Ğ¾Ñ‚Ğ¼ĞµĞ½Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸"""
    try:
        if request_id not in shipping_requests:
            return

        # ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ğ²ÑĞµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾ ÑÑ‚Ğ¾Ğ¹ Ğ·Ğ°ÑĞ²ĞºĞµ
        related_offers = [
            (offer_id, offer)
            for offer_id, offer in logistic_offers.items()
            if offer.get("request_id") == request_id
            and offer.get("status") == "pending"
        ]

        if not related_offers:
            return

        text = f"âŒ <b>Ğ—ĞĞ¯Ğ’ĞšĞ ĞĞ¢ĞœĞ•ĞĞ•ĞĞ</b>\n\n"
        text += f"ğŸ“¦ Ğ—Ğ°ÑĞ²ĞºĞ° #{request_id} Ğ±Ñ‹Ğ»Ğ° Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ° Ğ·Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸ĞºĞ¾Ğ¼.\n\n"

        if reason:
            text += f"ğŸ’¬ ĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ°: {reason}\n\n"

        text += f"Ğ’Ğ°ÑˆĞµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾."

        keyboard = InlineKeyboardMarkup()
        keyboard.add(
            InlineKeyboardButton(
                "ğŸ“¦ Ğ”Ñ€ÑƒĞ³Ğ¸Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸", callback_data="logistic_requests_list"
            )
        )

        # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°
        for offer_id, offer in related_offers:
            logist_id = offer.get("logist_id")
            if logist_id:
                try:
                    await bot.send_message(
                        logist_id, text, reply_markup=keyboard, parse_mode="HTML"
                    )
                    # ĞÑ‚Ğ¼ĞµĞ½ÑĞµĞ¼ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ
                    offer["status"] = "cancelled"
                    await asyncio.sleep(0.1)
                except Exception as e:
                    logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° {logist_id}: {e}")

        logging.info(f"âŒ Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ¾Ğ± Ğ¾Ñ‚Ğ¼ĞµĞ½Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸ #{request_id} Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ñ‹")

    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ¾Ğ± Ğ¾Ñ‚Ğ¼ĞµĞ½Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸: {e}")


# ============================================================================
# Ğ”ĞĞŸĞĞ›ĞĞ˜Ğ¢Ğ•Ğ›Ğ¬ĞĞ«Ğ• Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ˜ Ğ”Ğ›Ğ¯ Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢Ğ
# ============================================================================


@dp.callback_query_handler(lambda c: c.data == "my_deliveries", state="*")
async def show_my_deliveries(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¼Ğ¾Ğ¸ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸"""
    await state.finish()

    user_id = callback.from_user.id

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°
    my_deliveries = [
        (deliv_id, deliv)
        for deliv_id, deliv in deliveries.items()
        if deliv.get("logist_id") == user_id
    ]

    if not my_deliveries:
        text = "ğŸšš <b>ĞœĞĞ˜ Ğ”ĞĞ¡Ğ¢ĞĞ’ĞšĞ˜</b>\n\n"
        text += "âŒ Ğ£ Ğ²Ğ°Ñ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº\n\n"
        text += "<i>Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸ Ğ¿Ğ¾ÑĞ²ÑÑ‚ÑÑ Ğ¿Ğ¾ÑĞ»Ğµ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¸Ñ Ğ²Ğ°ÑˆĞ¸Ñ… Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹</i>"

        keyboard = InlineKeyboardMarkup()
        keyboard.add(
            InlineKeyboardButton("ğŸ’¼ ĞœĞ¾Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ", callback_data="my_offers")
        )
        keyboard.add(
            InlineKeyboardButton("ğŸ”™ Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main")
        )

        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
        await callback.answer()
        return

    # Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°Ğ¼
    by_status = {"pending": [], "in_progress": [], "completed": [], "cancelled": []}

    for deliv_id, deliv in my_deliveries:
        status = deliv.get("status", "pending")
        by_status[status].append((deliv_id, deliv))

    text = f"ğŸšš <b>ĞœĞĞ˜ Ğ”ĞĞ¡Ğ¢ĞĞ’ĞšĞ˜</b>\n\n"
    text += f"Ğ’ÑĞµĞ³Ğ¾ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº: <b>{len(my_deliveries)}</b>\n\n"

    active = len(by_status["pending"]) + len(by_status["in_progress"])
    completed = len(by_status["completed"])

    text += f"ğŸŸ¢ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ: <b>{active}</b>\n"
    text += f"âœ… Ğ—Ğ°Ğ²ĞµÑ€ÑˆÑ‘Ğ½Ğ½Ñ‹Ğµ: <b>{completed}</b>\n\n"
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    text += "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ:"

    keyboard = InlineKeyboardMarkup(row_width=1)

    # ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸
    for status_key, status_name, emoji in [
        ("pending", "ĞĞ¶Ğ¸Ğ´Ğ°ÑÑ‚", "ğŸ•"),
        ("in_progress", "Ğ’ Ğ¿ÑƒÑ‚Ğ¸", "ğŸšš"),
        ("completed", "Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ñ‹", "âœ…"),
    ]:
        delivs = by_status[status_key]
        if delivs:
            for deliv_id, deliv in delivs[:5]:
                request_id = deliv.get("request_id")
                request = shipping_requests.get(request_id, {})

                route = (
                    f"{request.get('route_from', '')} â†’ {request.get('route_to', '')}"
                )

                button_text = f"{emoji} #{deliv_id} | {route}"

                keyboard.add(
                    InlineKeyboardButton(
                        button_text, callback_data=f"view_delivery_{deliv_id}"
                    )
                )

    keyboard.add(InlineKeyboardButton("ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="my_deliveries"))
    keyboard.add(InlineKeyboardButton("ğŸ”™ Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main"))

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data == "logistic_statistics", state="*")
async def show_logistic_statistics(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºÑƒ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°"""
    await state.finish()

    user_id = callback.from_user.id

    # Ğ¡Ğ¾Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºÑƒ
    my_offers = [o for o in logistic_offers.values() if o.get("logist_id") == user_id]
    my_deliveries = [d for d in deliveries.values() if d.get("logist_id") == user_id]

    total_offers = len(my_offers)
    accepted_offers = len([o for o in my_offers if o.get("status") == "accepted"])
    rejected_offers = len([o for o in my_offers if o.get("status") == "rejected"])
    pending_offers = len([o for o in my_offers if o.get("status") == "pending"])

    completed_deliveries = len(
        [d for d in my_deliveries if d.get("status") == "completed"]
    )
    active_deliveries = len(
        [d for d in my_deliveries if d.get("status") in ["pending", "in_progress"]]
    )

    # ĞŸĞ¾Ğ´ÑÑ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¾Ğ±Ñ‰Ğ¸Ğ¹ Ğ·Ğ°Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ¾Ğº
    total_earnings = sum(
        logistic_offers.get(d.get("offer_id"), {}).get("price", 0)
        for d in my_deliveries
        if d.get("status") == "completed"
    )

    # ĞšĞ¾Ğ½Ğ²ĞµÑ€ÑĞ¸Ñ
    conversion = (accepted_offers / total_offers * 100) if total_offers > 0 else 0

    text = f"ğŸ“Š <b>Ğ¡Ğ¢ĞĞ¢Ğ˜Ğ¡Ğ¢Ğ˜ĞšĞ Ğ ĞĞ‘ĞĞ¢Ğ«</b>\n\n"
    text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"

    text += f"<b>ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯:</b>\n"
    text += f"ğŸ“‹ Ğ’ÑĞµĞ³Ğ¾ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾: <b>{total_offers}</b>\n"
    text += f"âœ… ĞŸÑ€Ğ¸Ğ½ÑÑ‚Ğ¾: <b>{accepted_offers}</b>\n"
    text += f"âŒ ĞÑ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¾: <b>{rejected_offers}</b>\n"
    text += f"ğŸ• ĞĞ¶Ğ¸Ğ´Ğ°ÑÑ‚ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ°: <b>{pending_offers}</b>\n"
    text += f"ğŸ“ˆ ĞšĞ¾Ğ½Ğ²ĞµÑ€ÑĞ¸Ñ: <b>{conversion:.1f}%</b>\n\n"

    text += f"<b>Ğ”ĞĞ¡Ğ¢ĞĞ’ĞšĞ˜:</b>\n"
    text += f"ğŸšš ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ: <b>{active_deliveries}</b>\n"
    text += f"âœ… Ğ—Ğ°Ğ²ĞµÑ€ÑˆÑ‘Ğ½Ğ½Ñ‹Ğµ: <b>{completed_deliveries}</b>\n\n"

    text += f"<b>Ğ¤Ğ˜ĞĞĞĞ¡Ğ«:</b>\n"
    text += f"ğŸ’° ĞĞ±Ñ‰Ğ¸Ğ¹ Ğ·Ğ°Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ¾Ğº: <b>{total_earnings:,.0f} â‚½</b>\n"
    if completed_deliveries > 0:
        avg_earning = total_earnings / completed_deliveries
        text += f"ğŸ“Š Ğ¡Ñ€ĞµĞ´Ğ½ÑÑ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ°: <b>{avg_earning:,.0f} â‚½</b>\n"

    keyboard = InlineKeyboardMarkup()
    keyboard.add(InlineKeyboardButton("ğŸ’¼ ĞœĞ¾Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ", callback_data="my_offers"))
    keyboard.add(InlineKeyboardButton("ğŸš› ĞœĞ¾Ğ¸ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸", callback_data="my_deliveries"))
    keyboard.add(InlineKeyboardButton("ğŸ”™ Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main"))

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


# ==================== ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜ĞšĞ˜ Ğ”Ğ›Ğ¯ Ğ­ĞšĞ¡ĞŸĞ•Ğ”Ğ˜Ğ¢ĞĞ ĞĞ’ ====================


@dp.message_handler(lambda m: m.text == "â• Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ ÑƒÑĞ»ÑƒĞ³", state="*")
async def create_expeditor_offer_start(message: types.Message, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ğ»Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°"""
    user_id = message.from_user.id

    if user_id not in users or users[user_id].get("role") != "expeditor":
        await message.answer("âŒ Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°Ğ¼")
        return

    await message.answer(
        "ğŸš› <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑƒÑĞ»ÑƒĞ³</b>\n\n"
        "Ğ¨Ğ°Ğ³ 1/5: Ğ¢Ğ¸Ğ¿ ÑƒÑĞ»ÑƒĞ³Ğ¸\n\n"
        "Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ñ‚Ğ¸Ğ¿ ÑƒÑĞ»ÑƒĞ³Ğ¸ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: ĞÑ„Ğ¾Ñ€Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ”Ğ¢, Ğ¢Ğ°Ğ¼Ğ¾Ğ¶ĞµĞ½Ğ½Ğ¾Ğµ Ğ¾Ñ„Ğ¾Ñ€Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ):",
        parse_mode="HTML",
    )
    await ExcavatorStatesGroup.service_type.set()


@dp.message_handler(state=ExcavatorStatesGroup.service_type)
async def expeditor_service_type(message: types.Message, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ñ‚Ğ¸Ğ¿Ğ° ÑƒÑĞ»ÑƒĞ³Ğ¸"""
    service_type = message.text.strip()

    await state.update_data(service_type=service_type)

    await message.answer(
        "ğŸš› <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑƒÑĞ»ÑƒĞ³</b>\n\n"
        "Ğ¨Ğ°Ğ³ 2/5: Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ\n\n"
        "Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ ÑÑ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ ÑƒÑĞ»ÑƒĞ³Ğ¸ (â‚½):",
        parse_mode="HTML",
    )
    await ExcavatorStatesGroup.price.set()


@dp.message_handler(state=ExcavatorStatesGroup.price)
async def expeditor_price(message: types.Message, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ÑÑ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸"""
    try:
        price = float(message.text.replace(",", ".").replace(" ", ""))
        if price <= 0:
            raise ValueError

        await state.update_data(price=price)

        await message.answer(
            "ğŸš› <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑƒÑĞ»ÑƒĞ³</b>\n\n"
            "Ğ¨Ğ°Ğ³ 3/5: Ğ¡Ñ€Ğ¾ĞºĞ¸ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ\n\n"
            "Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ ÑÑ€Ğ¾ĞºĞ¸ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: 3-5 Ğ´Ğ½ĞµĞ¹):",
            parse_mode="HTML",
        )
        await ExcavatorStatesGroup.terms.set()

    except Exception as e:
        await message.answer("âŒ ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚. Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: 15000)")


@dp.message_handler(state=ExcavatorStatesGroup.terms)
async def expeditor_terms(message: types.Message, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ÑÑ€Ğ¾ĞºĞ¾Ğ²"""
    terms = message.text.strip()

    await state.update_data(terms=terms)

    await message.answer(
        "ğŸš› <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑƒÑĞ»ÑƒĞ³</b>\n\n"
        "Ğ¨Ğ°Ğ³ 4/5: ĞŸĞ¾Ñ€Ñ‚Ñ‹\n\n"
        "Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ñ€Ñ‚Ñ‹, Ğ² ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ñ… Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚Ğµ (Ñ‡ĞµÑ€ĞµĞ· Ğ·Ğ°Ğ¿ÑÑ‚ÑƒÑ):",
        parse_mode="HTML",
    )
    await ExcavatorStatesGroup.ports.set()


@dp.message_handler(state=ExcavatorStatesGroup.ports)
async def expeditor_ports(message: types.Message, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¿Ğ¾Ñ€Ñ‚Ğ¾Ğ²"""
    ports = message.text.strip()

    await state.update_data(ports=ports)

    await message.answer(
        "ğŸš› <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑƒÑĞ»ÑƒĞ³</b>\n\n"
        "Ğ¨Ğ°Ğ³ 5/5: ĞŸÑ€Ğ¸Ğ¼ĞµÑ‡Ğ°Ğ½Ğ¸Ñ (Ğ½ĞµĞ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾)\n\n"
        "Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ°Ñ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¸Ğ»Ğ¸ /skip Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ°:",
        parse_mode="HTML",
    )
    await ExcavatorStatesGroup.notes.set()


@dp.message_handler(lambda m: m.text == "/skip", state=ExcavatorStatesGroup.notes)
@dp.message_handler(state=ExcavatorStatesGroup.notes)
async def expeditor_notes(message: types.Message, state: FSMContext):
    """Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğµ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸"""
    user_id = message.from_user.id

    notes = "" if message.text == "/skip" else message.text.strip()
    await state.update_data(notes=notes)

    data = await state.get_data()

    # Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµĞ¼ ID Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
    global expeditor_offers
    offer_id = len(expeditor_offers) + 1

    # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ
    offer = {
        "id": offer_id,
        "expeditor_id": user_id,
        "service_type": data["service_type"],
        "price": data["price"],
        "terms": data["terms"],
        "ports": data["ports"],
        "notes": notes,
        "status": "active",
        "created_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
    }

    expeditor_offers[offer_id] = offer

    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ
    expeditor_name = users[user_id].get("name", "Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€")

    text = f"âœ… <b>ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° ÑƒÑĞ»ÑƒĞ³ #{offer_id} ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ°!</b>\n\n"
    text += f"ğŸ“‹ Ğ£ÑĞ»ÑƒĞ³Ğ°: {data['service_type']}\n"
    text += f"ğŸ’° Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ: {data['price']:,.0f} â‚½\n"
    text += f"â± Ğ¡Ñ€Ğ¾ĞºĞ¸: {data['terms']}\n"
    text += f"ğŸš¢ ĞŸĞ¾Ñ€Ñ‚Ñ‹: {data['ports']}\n"
    if notes:
        text += f"ğŸ“ ĞŸÑ€Ğ¸Ğ¼ĞµÑ‡Ğ°Ğ½Ğ¸Ñ: {notes}\n"
    text += f"\nğŸ‘¤ ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚: {expeditor_name}\n"
    text += f"ğŸ“ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: {users[user_id].get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}"

    await message.answer(text, parse_mode="HTML", reply_markup=expeditor_keyboard())

    await state.finish()

    logging.info(f"âœ… Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€ {user_id} ÑĞ¾Ğ·Ğ´Ğ°Ğ» ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ ÑƒÑĞ»ÑƒĞ³ #{offer_id}")


# ==================== Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ˜ Ğ¡ĞĞ¥Ğ ĞĞĞ•ĞĞ˜Ğ¯ ====================


def save_shipping_requests():
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ·Ğ°ÑĞ²Ğ¾Ğº Ğ½Ğ° Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºÑƒ"""
    try:
        with open("data/shipping_requests.pkl", "wb") as f:
            pickle.dump(shipping_requests, f)
    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ shipping_requests: {e}")


def load_shipping_requests():
    """Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ğ·Ğ°ÑĞ²Ğ¾Ğº Ğ½Ğ° Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºÑƒ"""
    global shipping_requests
    try:
        if False:  # Pickle disabled
            with open("data/shipping_requests.pkl", "rb") as f:
                shipping_requests = pickle.load(f)
                logging.info(
                    f"âœ… Ğ—Ğ°ÑĞ²ĞºĞ¸ Ğ½Ğ° Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºÑƒ Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ñ‹: {len(shipping_requests)}"
                )
    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸ shipping_requests: {e}")
        shipping_requests = {}


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ¡ĞĞ—Ğ”ĞĞĞ˜Ğ• Ğ—ĞĞ¯Ğ’ĞšĞ˜ ĞĞ Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢Ğ˜ĞšĞ£ (ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜ĞšĞ˜)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


# ===== Ğ¨ĞĞ“ 1: ĞŸÑƒĞ½ĞºÑ‚ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ =====
# ===== Ğ¨ĞĞ“ 1: ĞŸÑƒĞ½ĞºÑ‚ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ =====
@dp.message_handler(state=ShippingRequestStatesGroup.route_from)
async def shipping_route_from(message: types.Message, state: FSMContext):
    """Ğ¨Ğ°Ğ³ 1: ĞŸÑƒĞ½ĞºÑ‚ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸"""
    route_from = message.text.strip()

    if not route_from or len(route_from) < 2:
        await message.answer("âŒ Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ°/Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ°")
        return

    await state.update_data(route_from=route_from)

    await message.answer(
        f"ğŸ“ ĞŸÑƒĞ½ĞºÑ‚ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸: <b>{route_from}</b>\n\n"
        "<b>Ğ¨Ğ°Ğ³ 2 Ğ¸Ğ· 7</b>\n\n"
        "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¿ÑƒĞ½ĞºÑ‚ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ (Ğ³Ğ¾Ñ€Ğ¾Ğ´/Ğ¿Ğ¾Ñ€Ñ‚):",
        parse_mode="HTML",
    )

    await ShippingRequestStatesGroup.route_to.set()


# ===== Ğ¨ĞĞ“ 2: ĞŸÑƒĞ½ĞºÑ‚ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ =====
@dp.message_handler(state=ShippingRequestStatesGroup.route_to)
async def shipping_route_to(message: types.Message, state: FSMContext):
    """Ğ¨Ğ°Ğ³ 2: ĞŸÑƒĞ½ĞºÑ‚ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ"""
    route_to = message.text.strip()

    if not route_to or len(route_to) < 2:
        await message.answer("âŒ Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿ÑƒĞ½ĞºÑ‚Ğ° Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ")
        return

    await state.update_data(route_to=route_to)
    data = await state.get_data()
    pull_id = data.get("pull_id")

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿ÑƒĞ» Ğ¸Ğ· Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑÑ‚Ğ°
    all_pulls = pulls.get("pulls", {})
    pull = all_pulls.get(pull_id) or all_pulls.get(str(pull_id))

    if not pull:
        await message.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½")
        await state.finish()
        return

    total_volume = pull.get("target_volume", 0)

    await message.answer(
        f"ğŸ“ ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚: <b>{data['route_from']}</b> â†’ <b>{route_to}</b>\n\n"
        "<b>Ğ¨Ğ°Ğ³ 3 Ğ¸Ğ· 7</b>\n\n"
        f"Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¾Ğ±ÑŠÑ‘Ğ¼ Ğ³Ñ€ÑƒĞ·Ğ° Ğ´Ğ»Ñ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºĞ¸ (Ñ‚Ğ¾Ğ½Ğ½)\n"
        f"ĞĞ±ÑŠÑ‘Ğ¼ Ğ¿ÑƒĞ»Ğ°: {total_volume:.0f} Ñ‚",
        parse_mode="HTML",
    )

    await ShippingRequestStatesGroup.volume.set()


# ===== Ğ¨ĞĞ“ 3: ĞĞ±ÑŠÑ‘Ğ¼ =====
@dp.message_handler(state=ShippingRequestStatesGroup.volume)
async def shipping_volume(message: types.Message, state: FSMContext):
    """Ğ¨Ğ°Ğ³ 3: ĞĞ±ÑŠÑ‘Ğ¼"""
    try:
        volume = float(message.text.replace(",", ".").replace(" ", ""))

        if volume <= 0:
            await message.answer("âŒ ĞĞ±ÑŠÑ‘Ğ¼ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ±Ñ‹Ñ‚ÑŒ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ½ÑƒĞ»Ñ")
            return

        data = await state.get_data()
        pull_id = data.get("pull_id")

        # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿ÑƒĞ»Ñ‹ Ğ¸Ğ· Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑÑ‚Ğ°
        all_pulls = pulls.get("pulls", {})
        pull = all_pulls.get(pull_id) or all_pulls.get(str(pull_id))

        if not pull:
            await message.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½")
            await state.finish()
            return

        target_volume = pull.get("target_volume", 0)

        if volume > target_volume:
            await message.answer(
                f"âŒ Ğ£ĞºĞ°Ğ·Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ğ¾Ğ±ÑŠÑ‘Ğ¼ Ğ¿Ñ€ĞµĞ²Ñ‹ÑˆĞ°ĞµÑ‚ Ğ¾Ğ±ÑŠÑ‘Ğ¼ Ğ¿ÑƒĞ»Ğ°!\n"
                f"ĞœĞ°ĞºÑĞ¸Ğ¼ÑƒĞ¼: {target_volume:.0f} Ñ‚"
            )
            return

        await state.update_data(volume=volume)

        await message.answer(
            f"ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºĞ¸: <b>{volume:.0f} Ñ‚</b>\n\n"
            "<b>Ğ¨Ğ°Ğ³ 4 Ğ¸Ğ· 7</b>\n\n"
            "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñƒ:",
            parse_mode="HTML",
        )

        await ShippingRequestStatesGroup.culture.set()

    except ValueError:
        await message.answer(
            "âŒ ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ²Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾\nĞŸÑ€Ğ¸Ğ¼ĞµÑ€: 100 Ğ¸Ğ»Ğ¸ 150.5"
        )


# ===== Ğ¨ĞĞ“ 4: ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ° =====
@dp.message_handler(state=ShippingRequestStatesGroup.culture)
async def shipping_culture(message: types.Message, state: FSMContext):
    """Ğ¨Ğ°Ğ³ 4: ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°"""
    culture = message.text.strip()

    if not culture or len(culture) < 2:
        await message.answer("âŒ Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñ‹")
        return

    await state.update_data(culture=culture)

    await message.answer(
        f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: <b>{culture}</b>\n\n"
        "<b>Ğ¨Ğ°Ğ³ 5 Ğ¸Ğ· 7</b>\n\n"
        "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ†ĞµĞ½Ñƒ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºĞ¸ Ğ·Ğ° Ñ‚Ğ¾Ğ½Ğ½Ñƒ Ğ² Ñ€ÑƒĞ±Ğ»ÑÑ…\n"
        "ĞŸÑ€Ğ¸Ğ¼ĞµÑ€: 5500",
        parse_mode="HTML",
    )

    await ShippingRequestStatesGroup.price_rub.set()


# ===== Ğ¨ĞĞ“ 5: Ğ¦ĞµĞ½Ğ° Ğ² Ñ€ÑƒĞ±Ğ»ÑÑ… =====
@dp.message_handler(state=ShippingRequestStatesGroup.price_rub)
async def shipping_price_rub(message: types.Message, state: FSMContext):
    """Ğ¨Ğ°Ğ³ 5: Ğ¦ĞµĞ½Ğ° Ğ² Ñ€ÑƒĞ±Ğ»ÑÑ… Ğ·Ğ° Ñ‚Ğ¾Ğ½Ğ½Ñƒ"""

    price_text = message.text.strip()

    try:
        price_rub = float(price_text)
        if price_rub <= 0:
            await message.answer("âŒ Ğ¦ĞµĞ½Ğ° Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ½ÑƒĞ»Ñ!")
            return
        if price_rub > 1000000:
            await message.answer("âŒ Ğ¦ĞµĞ½Ğ° ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ²Ñ‹ÑĞ¾ĞºĞ°Ñ! (Ğ¼Ğ°ĞºÑ 1 Ğ¼Ğ»Ğ½ â‚½/Ñ‚)")
            return

        price_rub = int(price_rub)
        await state.update_data(price_rub=price_rub)

        await message.answer(
            f"ğŸ’° <b>Ğ¦ĞµĞ½Ğ° ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°:</b> <code>{price_rub:,} â‚½/Ñ‚</code>\n\n"
            "<b>Ğ¨Ğ°Ğ³ 6 Ğ¸Ğ· 7</b>\n\n"
            "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¶ĞµĞ»Ğ°ĞµĞ¼ÑƒÑ Ğ´Ğ°Ñ‚Ñƒ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ (Ğ”Ğ”.ĞœĞœ.Ğ“Ğ“Ğ“Ğ“)\n"
            "Ğ˜Ğ»Ğ¸ Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ /skip Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ:",
            parse_mode="HTML",
        )
        await ShippingRequestStatesGroup.desired_date.set()

    except ValueError:
        await message.answer("âŒ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾\nĞŸÑ€Ğ¸Ğ¼ĞµÑ€: 5500")


# ===== Ğ¨ĞĞ“ 6: Ğ”Ğ°Ñ‚Ğ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ =====
@dp.message_handler(
    lambda m: m.text == "/skip", state=ShippingRequestStatesGroup.desired_date
)
async def shipping_desired_date_skip(message: types.Message, state: FSMContext):
    """Ğ¨Ğ°Ğ³ 6: ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞº Ğ´Ğ°Ñ‚Ñ‹"""
    await state.update_data(desired_date="ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°")
    await shipping_final_confirmation(message, state)


@dp.message_handler(state=ShippingRequestStatesGroup.desired_date)
async def shipping_desired_date(message: types.Message, state: FSMContext):
    """Ğ¨Ğ°Ğ³ 6: Ğ–ĞµĞ»Ğ°ĞµĞ¼Ğ°Ñ Ğ´Ğ°Ñ‚Ğ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸"""
    desired_date = message.text.strip()

    if not re.match(r"^\d{2}\.\d{2}\.\d{4}$", desired_date):
        await message.answer(
            "âŒ ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ğ´Ğ°Ñ‚Ñ‹!\n"
            "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ: Ğ”Ğ”.ĞœĞœ.Ğ“Ğ“Ğ“Ğ“ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, 15.11.2025)"
        )
        return

    try:
        datetime.strptime(desired_date, "%d.%m.%Y")
    except ValueError:
        await message.answer("âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ°Ñ Ğ´Ğ°Ñ‚Ğ°! ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ Ğ¸ Ğ¼ĞµÑÑÑ†")
        return

    await state.update_data(desired_date=desired_date)
    await shipping_final_confirmation(message, state)


# ===== Ğ¨ĞĞ“ 7: Ğ¤Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸ =====
async def shipping_final_confirmation(message: types.Message, state: FSMContext):
    """Ğ¨Ğ°Ğ³ 7: Ğ¤Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸"""

    data = await state.get_data()
    user_id = message.from_user.id
    pull_id = data.get("pull_id")

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿ÑƒĞ» Ğ¸Ğ· Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑÑ‚Ğ°
    all_pulls = pulls.get("pulls", {})
    pull = all_pulls.get(pull_id) or all_pulls.get(str(pull_id))

    if not pull:
        await message.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½. ĞĞ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ°.")
        await state.finish()
        return

    # Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµĞ¼ ID
    request_id = max(shipping_requests.keys(), default=0) + 1

    # Ğ‘ĞµÑ€Ñ‘Ğ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€Ğ° Ğ¸Ğ· Ğ¿ÑƒĞ»Ğ°
    exporter_id = pull.get("exporter_id")
    if not exporter_id:
        await message.answer("âŒ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½. ĞĞ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ°.")
        await state.finish()
        return

    exporter = users.get(exporter_id, {})

    # âœ… Ğ¡ĞĞ—Ğ”ĞĞĞœ Ğ—ĞĞ¯Ğ’ĞšĞ£
    request = {
        "id": request_id,
        "pull_id": pull_id,
        "exporter_id": exporter_id,
        "route_from": data.get("route_from", ""),
        "route_to": data.get("route_to", ""),
        "volume": data.get("volume", 0),
        "culture": data.get("culture", ""),
        "price_rub": data.get("price_rub", 0),
        "desired_date": data.get("desired_date", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°"),
        "status": "active",
        "created_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "logist_id": None,
    }

    shipping_requests[request_id] = request
    save_shipping_requests()

    await state.finish()

    # âœ… Ğ¤Ğ˜ĞĞĞ›Ğ¬ĞĞĞ• Ğ¡ĞĞĞ‘Ğ©Ğ•ĞĞ˜Ğ•
    summary = (
        f"âœ… <b>Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ #{request_id} ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ°!</b>\n\n"
        f"ğŸ“¦ ĞŸÑƒĞ»: #{pull_id}\n"
        f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {data.get('culture', '')}\n"
        f"ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: {data.get('volume', 0):.0f} Ñ‚\n"
        f"ğŸ’° <b>Ğ¦ĞµĞ½Ğ°: {data.get('price_rub', 0):,} â‚½/Ñ‚</b>\n"
        f"ğŸ“ ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚: {data.get('route_from', '')} â†’ {data.get('route_to', '')}\n"
        f"ğŸ“… Ğ”Ğ°Ñ‚Ğ°: {data.get('desired_date', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}\n\n"
        f"ğŸ‘¤ ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚: {exporter.get('name', 'N/A')}\n"
        f"ğŸ“‹ Ğ˜ĞĞ: <code>{exporter.get('inn', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>\n"
        f"ğŸ“‹ ĞĞ“Ğ Ğ: <code>{exporter.get('ogrn', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>\n"
        f"ğŸ“ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <code>{exporter.get('phone', 'N/A')}</code>\n"
        f"ğŸ“§ Email: <code>{exporter.get('email', 'N/A')}</code>\n\n"
        f"ğŸ”” Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°Ñ‚ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾ Ğ²Ğ°ÑˆĞµĞ¹ Ğ·Ğ°ÑĞ²ĞºĞµ"
    )

    await message.answer(summary, parse_mode="HTML", reply_markup=exporter_keyboard())

    # âœ… ĞĞ¢ĞŸĞ ĞĞ’Ğ›Ğ¯Ğ•Ğœ Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢ĞĞœ
    logistics_users = [
        uid for uid, user in users.items() if user.get("role") == "logistic"
    ]

    for logist_id in logistics_users:
        try:
            await bot.send_message(logist_id, summary, parse_mode="HTML")
            logging.info(f"âœ… Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ñƒ {logist_id} Ğ¾ Ğ·Ğ°ÑĞ²ĞºĞµ #{request_id}")
        except Exception as e:
            logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ñƒ {logist_id}: {e}")

    logging.info(
        f"âœ… Ğ—Ğ°ÑĞ²ĞºĞ° #{request_id} ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ°\n"
        f"Ğ¦ĞµĞ½Ğ°: {data.get('price_rub', 0)} â‚½/Ñ‚\n"
        f"ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚: {data.get('route_from')} â†’ {data.get('route_to')}"
    )


# ==================== ĞĞ’Ğ¢ĞĞœĞĞ¢Ğ˜Ğ§Ğ•Ğ¡ĞšĞĞ• ĞŸĞ Ğ˜ĞšĞ Ğ•ĞŸĞ›Ğ•ĞĞ˜Ğ• ĞŸĞĞ”Ğ Ğ¯Ğ”Ğ§Ğ˜ĞšĞĞ’ ====================


async def attach_contractors_to_pull(pull_id):
    """
    ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¾Ğµ Ğ¿Ñ€Ğ¸ĞºÑ€ĞµĞ¿Ğ»ĞµĞ½Ğ¸Ğµ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ² Ğ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ² Ğº Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¾Ğ¼Ñƒ Ğ¿ÑƒĞ»Ğ»Ñƒ
    Ğ’Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ÑÑ ĞºĞ¾Ğ³Ğ´Ğ° Ğ¿ÑƒĞ»Ğ» Ğ´Ğ¾ÑÑ‚Ğ¸Ğ³Ğ°ĞµÑ‚ Ğ½ÑƒĞ¶Ğ½Ğ¾Ğ³Ğ¾ Ñ‚Ğ¾Ğ½Ğ½Ğ°Ğ¶Ğ°
    """
    if pull_id not in pulls.get("pulls", {}):
        return

    pull = pulls["pulls"][pull_id]
    exporter_id = pull.get("exporter_id")
    pull_port = pull.get("port", "")
    pull_region = pull.get("region", "")

    # ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´ÑÑ‰Ğ¸Ñ… Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²
    suitable_logistics = []
    for req_id, request in shipping_requests.items():
        if request.get("status") != "active":
            continue

        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñƒ/Ğ¿Ğ¾Ñ€Ñ‚Ñƒ
        req_to = request.get("to", "").lower()
        if pull_port.lower() in req_to or pull_region.lower() in req_to:
            logist_id = request.get("logist_id")
            if logist_id in users:
                suitable_logistics.append(
                    {
                        "request_id": req_id,
                        "logist_id": logist_id,
                        "logist_name": users[logist_id].get("name", "Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚"),
                        "phone": users[logist_id].get("phone", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"),
                        "route": f"{request['from']} â†’ {request['to']}",
                        "price": request["price"],
                        "volume": request["volume"],
                        "vehicle": request.get("vehicle_type", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"),
                    }
                )

    # ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´ÑÑ‰Ğ¸Ñ… ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²
    suitable_expeditors = []
    for offer_id, offer in expeditor_offers.items():
        if offer.get("status") != "active":
            continue

        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ Ğ¿Ğ¾Ñ€Ñ‚Ñƒ
        offer_ports = offer.get("ports", "").lower()
        if pull_port.lower() in offer_ports:
            expeditor_id = offer.get("expeditor_id")
            if expeditor_id in users:
                suitable_expeditors.append(
                    {
                        "offer_id": offer_id,
                        "expeditor_id": expeditor_id,
                        "expeditor_name": users[expeditor_id].get("name", "Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€"),
                        "phone": users[expeditor_id].get("phone", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"),
                        "service": offer["service_type"],
                        "price": offer["price"],
                        "terms": offer["terms"],
                        "ports": offer["ports"],
                    }
                )

    # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€Ñƒ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ğ¿Ğ¾Ğ´Ñ€ÑĞ´Ñ‡Ğ¸ĞºĞ¾Ğ²
    if exporter_id and (suitable_logistics or suitable_expeditors):
        text = f"ğŸ‰ <b>ĞŸÑƒĞ»Ğ» #{pull_id} ÑĞ¾Ğ±Ñ€Ğ°Ğ½!</b>\n\n"
        text += f"ğŸ“¦ {pull['culture']}, {pull['volume']} Ñ‚\n"
        text += f"ğŸš¢ ĞŸĞ¾Ñ€Ñ‚: {pull_port}\n\n"

        if suitable_logistics:
            text += f"ğŸšš <b>Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ñ‹ ({len(suitable_logistics)}):</b>\n\n"
            for idx, logist in enumerate(suitable_logistics[:5], 1):
                text += f"{idx}. {logist['logist_name']}\n"
                text += f"   â€¢ {logist['route']}\n"
                text += f"   â€¢ {logist['price']:,.0f} â‚½/Ñ‚, Ğ´Ğ¾ {logist['volume']} Ñ‚\n"
                text += f"   â€¢ {logist['vehicle']}\n"
                text += f"   â€¢ ğŸ“ {logist['phone']}\n\n"

            if len(suitable_logistics) > 5:
                text += f"<i>... Ğ¸ ĞµÑ‰Ñ‘ {len(suitable_logistics) - 5} Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²</i>\n\n"

        if suitable_expeditors:
            text += f"ğŸš› <b>Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ñ‹ ({len(suitable_expeditors)}):</b>\n\n"
            for idx, exp in enumerate(suitable_expeditors[:5], 1):
                text += f"{idx}. {exp['expeditor_name']}\n"
                text += f"   â€¢ {exp['service']}\n"
                text += f"   â€¢ {exp['price']:,.0f} â‚½, ÑÑ€Ğ¾Ğº: {exp['terms']}\n"
                text += f"   â€¢ ĞŸĞ¾Ñ€Ñ‚Ñ‹: {exp['ports']}\n"
                text += f"   â€¢ ğŸ“ {exp['phone']}\n\n"

            if len(suitable_expeditors) > 5:
                text += (
                    f"<i>... Ğ¸ ĞµÑ‰Ñ‘ {len(suitable_expeditors) - 5} ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²</i>\n\n"
                )

        text += "ğŸ’¡ <b>Ğ¡Ğ²ÑĞ¶Ğ¸Ñ‚ĞµÑÑŒ Ñ Ğ¿Ğ¾Ğ´Ñ€ÑĞ´Ñ‡Ğ¸ĞºĞ°Ğ¼Ğ¸ Ğ´Ğ»Ñ Ğ¾Ğ±ÑÑƒĞ¶Ğ´ĞµĞ½Ğ¸Ñ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ğ¹.</b>"

        try:
            await bot.send_message(exporter_id, text, parse_mode="HTML")
            logging.info(
                f"âœ… Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€Ñƒ {exporter_id} Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ñ‹ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ğ¿Ğ¾Ğ´Ñ€ÑĞ´Ñ‡Ğ¸ĞºĞ¾Ğ² Ğ´Ğ»Ñ Ğ¿ÑƒĞ»Ğ»Ğ° #{pull_id}"
            )
        except Exception as e:
            logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞµĞº Ğ¿Ğ¾Ğ´Ñ€ÑĞ´Ñ‡Ğ¸ĞºĞ¾Ğ²: {e}")

    # â† Ğ”ĞĞ‘ĞĞ’Ğ˜Ğ¢Ğ¬: Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ² Ğ¸Ğ· Ğ¿ÑƒĞ»Ğ»Ğ°
    if pull_id in pullparticipants:
        participants = pullparticipants[pull_id]
        for participant in participants:
            farmer_id = participant.get("farmer_id")
            if farmer_id and farmer_id in users:
                try:
                    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°
                    farmer_text = f"ğŸ‰ <b>ĞŸÑƒĞ»Ğ» #{pull_id} ÑĞ¾Ğ±Ñ€Ğ°Ğ½!</b>\n\n"
                    farmer_text += (
                        f"ğŸ“¦ {pull['culture']}, {pull.get('target_volume', 0)} Ñ‚\n"
                    )
                    farmer_text += f"ğŸš¢ ĞŸĞ¾Ñ€Ñ‚: {pull_port}\n\n"

                    # ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¿ĞµÑ€Ğ²Ğ¾Ğ³Ğ¾ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° (ĞµÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ)
                    if suitable_logistics:
                        logist = suitable_logistics[0]
                        farmer_text += "ğŸšš <b>Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğ¹ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚:</b>\n"
                        farmer_text += f"â€¢ {logist['logist_name']}\n"
                        farmer_text += f"â€¢ {logist['route']}\n"
                        farmer_text += f"â€¢ {logist['price']:,.0f} â‚½/Ñ‚\n"
                        farmer_text += f"â€¢ ğŸ“ {logist['phone']}\n\n"

                        if len(suitable_logistics) > 1:
                            farmer_text += f"<i>...Ğ¸ ĞµÑ‰Ñ‘ {len(suitable_logistics) - 1} Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²</i>\n\n"

                    # ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¿ĞµÑ€Ğ²Ğ¾Ğ³Ğ¾ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ° (ĞµÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ)
                    if suitable_expeditors:
                        exp = suitable_expeditors[0]
                        farmer_text += "ğŸš› <b>Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğ¹ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€:</b>\n"
                        farmer_text += f"â€¢ {exp['expeditor_name']}\n"
                        farmer_text += f"â€¢ {exp['service']}\n"
                        farmer_text += f"â€¢ ğŸ“ {exp['phone']}\n\n"

                        if len(suitable_expeditors) > 1:
                            farmer_text += f"<i>...Ğ¸ ĞµÑ‰Ñ‘ {len(suitable_expeditors) - 1} ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²</i>\n\n"

                    farmer_text += "ğŸ’¡ <b>Ğ’Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ ÑĞ²ÑĞ·Ğ°Ñ‚ÑŒÑÑ Ñ Ğ¿Ğ¾Ğ´Ñ€ÑĞ´Ñ‡Ğ¸ĞºĞ°Ğ¼Ğ¸ Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ÑƒÑ Ğ¸Ğ»Ğ¸ Ñ‡ĞµÑ€ĞµĞ· ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°.</b>"

                    await bot.send_message(
                        farmer_id,
                        f"âœ… Ğ’Ñ‹ ÑƒÑ‡Ğ°ÑÑ‚Ğ²ÑƒĞµÑ‚Ğµ Ğ² Ğ¿ÑƒĞ»Ğ»Ğµ Ğ½Ğ° {target_volume:.1f} Ñ‚!\n"
                        f"Ğ’Ğ°ÑˆĞ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ {batch['volume']:.1f} Ñ‚ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ° Ğ² Ğ¿ÑƒĞ»Ğ» #{pull_id}",
                    )
                    logging.info(
                        f"âœ… Ğ¤ĞµÑ€Ğ¼ĞµÑ€Ñƒ {farmer_id} Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾ ÑĞ±Ğ¾Ñ€Ğµ Ğ¿ÑƒĞ»Ğ»Ğ° #{pull_id}"
                    )
                except Exception as e:
                    logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ° {farmer_id}: {e}")

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²
    for logist in suitable_logistics:
        try:
            text = "ğŸ“¢ <b>Ğ’Ğ°Ñˆ Ñ‚Ğ°Ñ€Ğ¸Ñ„ Ğ¿ĞµÑ€ĞµĞ´Ğ°Ğ½ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€Ñƒ!</b>\n\n"
            text += f"ĞŸÑƒĞ»Ğ» #{pull_id}\n"
            text += f"ğŸ“¦ {pull['culture']}, {pull['volume']} Ñ‚\n"
            text += f"ğŸš¢ ĞŸĞ¾Ñ€Ñ‚: {pull_port}\n\n"
            text += "Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€ Ğ¼Ğ¾Ğ¶ĞµÑ‚ ÑĞ²ÑĞ·Ğ°Ñ‚ÑŒÑÑ Ñ Ğ²Ğ°Ğ¼Ğ¸ Ğ´Ğ»Ñ Ğ¾Ğ±ÑÑƒĞ¶Ğ´ĞµĞ½Ğ¸Ñ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ğ¹ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºĞ¸."

            await bot.send_message(logist["logist_id"], text, parse_mode="HTML")
            logging.info(
                f"âœ… Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚Ñƒ {logist['logist_id']} Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾ Ğ¿ÑƒĞ»Ğ»Ğµ #{pull_id}"
            )
        except Exception as e:
            logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°: {e}")

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²
    for exp in suitable_expeditors:
        try:
            text = "ğŸ“¢ <b>Ğ’Ğ°ÑˆĞ¸ ÑƒÑĞ»ÑƒĞ³Ğ¸ Ğ¿ĞµÑ€ĞµĞ´Ğ°Ğ½Ñ‹ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€Ñƒ!</b>\n\n"
            text += f"ĞŸÑƒĞ»Ğ» #{pull_id}\n"
            text += f"ğŸ“¦ {pull['culture']}, {pull['volume']} Ñ‚\n"
            text += f"ğŸš¢ ĞŸĞ¾Ñ€Ñ‚: {pull_port}\n\n"
            text += "Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€ Ğ¼Ğ¾Ğ¶ĞµÑ‚ ÑĞ²ÑĞ·Ğ°Ñ‚ÑŒÑÑ Ñ Ğ²Ğ°Ğ¼Ğ¸ Ğ´Ğ»Ñ Ğ¾Ñ„Ğ¾Ñ€Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²."

            await bot.send_message(exp["expeditor_id"], text, parse_mode="HTML")
            logging.info(
                f"âœ… Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ñƒ {exp['expeditor_id']} Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾ Ğ¿ÑƒĞ»Ğ»Ğµ #{pull_id}"
            )
        except Exception as e:
            logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°: {e}")


async def on_startup(dp):
    logging.info("ğŸš€ Ğ‘Ğ¾Ñ‚ Exportum Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½")

    # Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¸Ğ· Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²
    load_data()
    load_users_from_json()
    load_users_from_pickle()
    load_pulls_from_pickle()
    load_batches_from_pickle()
    load_logistic_offers()
    load_deliveries()
    load_expeditor_offers()
    load_logistic_ratings()
    load_expeditor_cards()

    # âœ… Ğ—ĞĞ“Ğ Ğ£Ğ—ĞšĞ Ğ—ĞĞ¯Ğ’ĞĞš ĞŸĞ Ğ˜ Ğ¡Ğ¢ĞĞ Ğ¢Ğ•
    await load_requests_from_file()

    migrate_all_existing_pulls()
    os.makedirs(LOGS_DIR, exist_ok=True)
    os.makedirs(DATA_DIR, exist_ok=True)

    # âœ… ĞœĞ˜Ğ“Ğ ĞĞ¦Ğ˜Ğ¯ Ğ¡Ğ¢ĞĞ Ğ«Ğ¥ ĞŸĞ£Ğ›ĞĞ’
    logging.info("ğŸ”„ ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¸ Ğ¼Ğ¸Ğ³Ñ€Ğ°Ñ†Ğ¸Ñ ÑÑ‚Ğ°Ñ€Ñ‹Ñ… Ğ¿ÑƒĞ»Ğ¾Ğ²...")
    try:
        migrate_old_pulls()
        logging.info("âœ… ĞœĞ¸Ğ³Ñ€Ğ°Ñ†Ğ¸Ñ Ğ¿ÑƒĞ»Ğ¾Ğ² Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¼Ğ¸Ğ³Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ğ¿ÑƒĞ»Ğ¾Ğ²: {e}")

    # ============================================================
    # ğŸ” Ğ”ĞĞ‘ĞĞ’Ğ˜Ğ¢Ğ¬ Ğ”Ğ˜ĞĞ“ĞĞĞ¡Ğ¢Ğ˜ĞšĞ£ Ğ—Ğ”Ğ•Ğ¡Ğ¬ - ĞŸĞ Ğ¯ĞœĞ ĞŸĞ•Ğ Ğ•Ğ” ĞŸĞ›ĞĞĞ˜Ğ ĞĞ’Ğ©Ğ˜ĞšĞĞœ
    # ============================================================
    logging.info("=" * 70)
    logging.info("ğŸ” Ğ”Ğ˜ĞĞ“ĞĞĞ¡Ğ¢Ğ˜ĞšĞ Ğ”ĞĞĞĞ«Ğ¥ ĞŸĞ£Ğ›ĞĞ’")
    logging.info("=" * 70)

    logging.info(f"ğŸ“Š Ğ¢Ğ¸Ğ¿ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… pulls: {type(pulls)}")
    logging.info(f"ğŸ“Š ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¿ÑƒĞ»Ğ¾Ğ²: {len(pulls)}")

    if isinstance(pulls, dict):
        logging.info(f"ğŸ“Š ĞšĞ»ÑÑ‡Ğ¸ Ğ¿ÑƒĞ»Ğ¾Ğ²: {list(pulls.keys())}")
        logging.info(
            f"ğŸ“Š Ğ¢Ğ¸Ğ¿ ĞºĞ»ÑÑ‡ĞµĞ¹: {type(list(pulls.keys())[0]) if pulls else 'Ğ½ĞµÑ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…'}"
        )
    else:
        logging.info(f"ğŸ“Š pulls ÑĞ²Ğ»ÑĞµÑ‚ÑÑ List, ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²: {len(pulls)}")

    # ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¹ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚
    try:
        if isinstance(pulls, dict):
            first_key = list(pulls.keys())[0]
            first_pull = pulls[first_key]
        else:
            first_key = 0
            first_pull = pulls[0]

        logging.info(f"\nğŸ“Œ ĞŸĞ•Ğ Ğ’Ğ«Ğ™ Ğ­Ğ›Ğ•ĞœĞ•ĞĞ¢ (ĞºĞ»ÑÑ‡={first_key}):")
        logging.info(f"   Ğ¢Ğ¸Ğ¿: {type(first_pull)}")
        logging.info(
            f"   'id' Ğ² Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…: {'id' in first_pull if isinstance(first_pull, dict) else 'N/A'}"
        )
        logging.info(
            f"   ĞšĞ»ÑÑ‡Ğ¸: {list(first_pull.keys()) if isinstance(first_pull, dict) else 'N/A'}"
        )
        logging.info(f"   Ğ¡Ğ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ğ¼Ğ¾Ğµ: {first_pull}")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğµ Ğ¿ĞµÑ€Ğ²Ğ¾Ğ³Ğ¾ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ°: {e}")

    logging.info("=" * 70 + "\n")
    # ============================================================

    # ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸ĞºĞ° Ğ¸ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ĞºÑÑˆĞµĞ¹
    await setup_scheduler()

    try:
        await update_prices_cache()
        await update_news_cache()
        await schedule_weekly_reports()
        logging.info("âœ… Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ñ‹ Ğ¿Ñ€Ğ¸ Ğ·Ğ°Ğ¿ÑƒÑĞºĞµ")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…: {e}")

    # ĞĞ²Ñ‚Ğ¾Ğ¿Ğ¾Ğ¸ÑĞº ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğ¹
    try:
        matches_found = await auto_match_batches_and_pulls()
        logging.info(f"âœ… ĞĞ²Ñ‚Ğ¾Ğ¿Ğ¾Ğ¸ÑĞº Ğ¿Ñ€Ğ¸ Ğ·Ğ°Ğ¿ÑƒÑĞºĞµ: Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾ {matches_found} ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğ¹")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ°Ğ²Ñ‚Ğ¾Ğ¿Ğ¾Ğ¸ÑĞºĞ°: {e}")


def validate_integration():
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ñ‚Ñ‹ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ğ¸"""
    required_functions = [
        "load_users_from_json",
        "save_users_to_json",
        "load_batches_from_pickle",
        "save_batches_to_pickle",
        "load_pulls_from_pickle",
        "save_pulls_to_pickle",
        "update_prices_cache",
        "update_news_cache",
        "auto_match_batches_and_pulls",
        "find_matching_batches",
        "find_matching_exporters",
        "notify_match",
    ]

    missing = []
    for func in required_functions:
        if not globals().get(func):
            missing.append(func)

    if missing:
        logging.warning(f"âš ï¸ ĞÑ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒÑÑ‚ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸: {', '.join(missing)}")
    else:
        logging.info("âœ… Ğ’ÑĞµ Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ Ğ¿Ñ€Ğ¸ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒÑÑ‚")


validate_integration()

logging.info("ğŸ‰ Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Exportum Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°!")
logging.info("ğŸ“‹ Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸:")
logging.info("   âœ… Ğ Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ½Ğ°Ñ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ñ Ğ˜ĞĞ Ğ¸ Ñ€ĞµĞºĞ²Ğ¸Ğ·Ğ¸Ñ‚Ğ°Ğ¼Ğ¸")
logging.info("   âœ… Ğ Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ½Ñ‹Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ñ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ¾Ğ¼ Ğ¸ Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸ĞµĞ¼")
logging.info("   âœ… ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ¼Ğ°Ñ‚Ñ‡Ğ¸Ğ½Ğ³ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ¸ Ğ¿ÑƒĞ»Ğ¾Ğ²")
logging.info("   âœ… Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ¾ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸ÑÑ…")
logging.info("   âœ… Ğ Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ¸ÑĞº Ğ¿Ğ¾ ĞºÑ€Ğ¸Ñ‚ĞµÑ€Ğ¸ÑĞ¼")
logging.info("   âœ… Ğ—Ğ°ÑĞ²ĞºĞ¸ Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ")
logging.info("   âœ… Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ° Ñ Ñ„Ğ°Ğ¹Ğ»Ğ°Ğ¼Ğ¸ Ğ¸ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°Ğ¼Ğ¸")
logging.info("   âœ… Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ÑĞ´ĞµĞ»ĞºĞ°Ğ¼Ğ¸")
logging.info("   âœ… Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¸ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ")
logging.info("   âœ… Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ Google Sheets")
logging.info("   âœ… ĞŸĞ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸Ğº Ğ·Ğ°Ğ´Ğ°Ñ‡")


@dp.message_handler(lambda m: m.text == "ğŸ“¦ Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸", state="*")
async def show_available_batches_exporter(message: types.Message, state: FSMContext):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ´Ğ»Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€Ğ°"""
    await state.finish()

    user_id = message.from_user.id

    logging.info(f"ğŸ“¦ ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº 'Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸' Ğ²Ñ‹Ğ·Ğ²Ğ°Ğ½ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¼ {user_id}")

    # âœ… ĞŸĞ ĞĞ’Ğ•Ğ ĞšĞ Ğ ĞĞ›Ğ˜
    if user_id not in users or users[user_id].get("role") != "exporter":
        logging.warning(f"âŒ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ {user_id} Ğ½Ğµ ÑĞ²Ğ»ÑĞµÑ‚ÑÑ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ¼")
        await message.answer("âš ï¸ Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°Ğ¼.")
        return

    # âœ… ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞ«Ğ™ Ğ¡Ğ‘ĞĞ  Ğ”ĞĞ¡Ğ¢Ğ£ĞŸĞĞ«Ğ¥ ĞŸĞĞ Ğ¢Ğ˜Ğ™
    available = []
    for farmer_id, farmer_batches in batches.items():  # â† ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞĞ• Ğ˜ĞœĞ¯ ĞŸĞ•Ğ Ğ•ĞœĞ•ĞĞĞĞ™
        for batch in farmer_batches:  # â† ĞŸĞ•Ğ Ğ•Ğ‘Ğ˜Ğ ĞĞ•Ğœ farmer_batches, ĞĞ• user_batches
            # âœ… ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸
            if batch.get("status") in ["active", "ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ°", "available", "Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ°"]:
                farmer_name = users.get(farmer_id, {}).get("name", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")
                available.append(
                    {"batch": batch, "farmer_id": farmer_id, "farmer_name": farmer_name}
                )

    logging.info(f"ğŸ“¦ ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹: {len(available)}")

    # âœ… Ğ•Ğ¡Ğ›Ğ˜ ĞĞ• ĞĞĞ™Ğ”Ğ•ĞĞ ĞŸĞĞ Ğ¢Ğ˜Ğ™
    if not available:
        await message.answer(
            "ğŸ“¦ <b>Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸</b>\n\n"
            "âŒ ĞĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ğ¼Ğ¾Ğ¼ĞµĞ½Ñ‚ Ğ½ĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ¾Ñ‚ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ².\n\n"
            "ğŸ’¡ ĞŸĞ¾Ğ´Ğ¾Ğ¶Ğ´Ğ¸Ñ‚Ğµ, Ğ¿Ğ¾ĞºĞ° Ñ„ĞµÑ€Ğ¼ĞµÑ€Ñ‹ Ğ´Ğ¾Ğ±Ğ°Ğ²ÑÑ‚ ÑĞ²Ğ¾Ğ¸ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸.",
            parse_mode="HTML",
        )
        return

    # âœ… Ğ¤ĞĞ ĞœĞ˜Ğ Ğ£Ğ•Ğœ Ğ¡ĞĞĞ‘Ğ©Ğ•ĞĞ˜Ğ•
    text = "ğŸ“¦ <b>Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ¾Ñ‚ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ²</b>\n\n"
    text += f"Ğ’ÑĞµĞ³Ğ¾: {len(available)} Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹\n\n"

    keyboard = InlineKeyboardMarkup(row_width=1)

    # âœ… ĞŸĞĞšĞĞ—Ğ«Ğ’ĞĞ•Ğœ ĞŸĞ•Ğ Ğ’Ğ«Ğ• 10 ĞŸĞĞ Ğ¢Ğ˜Ğ™
    for i, item in enumerate(available[:10], 1):
        batch = item["batch"]
        farmer_name = item["farmer_name"]

        text += f"{i}. <b>{batch['culture']}</b> - {batch['volume']} Ñ‚\n"
        text += (
            f"   ğŸ’° {batch['price']:,.0f} â‚½/Ñ‚ | ğŸ“ {batch.get('region', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
        )
        text += f"   ğŸ‘¤ {farmer_name}\n\n"

        keyboard.add(
            InlineKeyboardButton(
                f"ğŸŒ¾ {batch['culture']} - {batch['volume']} Ñ‚",
                callback_data=f"view_batch:{batch['id']}",
            )
        )

    # âœ… Ğ•Ğ¡Ğ›Ğ˜ Ğ•Ğ©Ğ• Ğ•Ğ¡Ğ¢Ğ¬ ĞŸĞĞ Ğ¢Ğ˜Ğ˜
    if len(available) > 10:
        text += f"... Ğ¸ ĞµÑ‰Ñ‘ {len(available) - 10} Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹\n\n"
        text += "ğŸ’¡ Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ 'ğŸ” Ğ Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ¸ÑĞº' Ğ´Ğ»Ñ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸"

    keyboard.add(
        InlineKeyboardButton(
            "ğŸ” Ğ Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ¸ÑĞº", callback_data="advanced_batch_search"
        )
    )
    keyboard.add(InlineKeyboardButton("â—€ï¸ ĞœĞµĞ½Ñ", callback_data="back_to_exporter_menu"))

    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")


async def on_shutdown(dp):
    """Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğµ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ğ±Ğ¾Ñ‚Ğ°"""
    logging.info("â¹ Ğ‘Ğ¾Ñ‚ Exportum Ğ¾ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµÑ‚ÑÑ...")

    # âœ… Ğ¡ĞĞ¥Ğ ĞĞĞ¯Ğ•Ğœ Ğ’Ğ¡Ğ• Ğ”ĞĞĞĞ«Ğ•
    save_users_to_json()
    save_users_to_pickle()
    save_pulls_to_pickle()  # âœ… Ğ¡ĞĞ¥Ğ ĞĞĞ¯Ğ•Ğœ ĞĞ”Ğ˜Ğ Ğ ĞĞ—!
    save_shipping_requests()
    save_batches_to_pickle()
    save_logistic_offers()
    save_deliveries()
    save_expeditor_offers()

    # âœ… Ğ”ĞĞ‘ĞĞ’Ğ˜Ğ¢Ğ¬ Ğ­Ğ¢Ğ£ Ğ¡Ğ¢Ğ ĞĞšĞ£ - Ğ¡ĞĞ¥Ğ ĞĞĞ•ĞĞ˜Ğ• Ğ—ĞĞ¯Ğ’ĞĞš:
    save_requests_to_file()

    logging.info("âœ… Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ñ‹")

    await bot.close()
    await dp.storage.close()
    await dp.storage.wait_closed()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ĞŸĞ ĞĞ¡ĞœĞĞ¢Ğ  Ğ”Ğ•Ğ¢ĞĞ›Ğ•Ğ™ Ğ”ĞĞ¡Ğ¢ĞĞ’ĞšĞ˜
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


@dp.callback_query_handler(lambda c: c.data.startswith("view_delivery:"), state="*")
async def view_delivery_details(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸"""
    await state.finish()

    try:
        offer_id = int(callback.data.split(":")[1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
        return

    if offer_id not in logistic_offers:
        await callback.answer("âŒ Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    offer = logistic_offers[offer_id]
    request_id = offer.get("request_id")
    request = shipping_requests.get(request_id, {})
    exporter_id = request.get("exporter_id")
    exporter = users.get(exporter_id, {})

    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‚ĞµĞºÑÑ‚
    text = (
        f"ğŸš› <b>Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° #{offer_id}</b>\n\n"
        f"<b>ğŸ“¦ Ğ“Ñ€ÑƒĞ·:</b>\n"
        f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {request.get('culture', 'Ğ/Ğ”')}\n"
        f"âš–ï¸ ĞĞ±ÑŠÑ‘Ğ¼: {request.get('volume', 0):.0f} Ñ‚\n"
        f"ğŸ“ ĞÑ‚ĞºÑƒĞ´Ğ°: {request.get('route_from', '?')}\n"
        f"ğŸ“ ĞšÑƒĞ´Ğ°: {request.get('route_to', '?')}\n"
        f"ğŸ“… Ğ–ĞµĞ»Ğ°ĞµĞ¼Ğ°Ñ Ğ´Ğ°Ñ‚Ğ°: {request.get('desired_date', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}\n\n"
        f"<b>ğŸš› Ğ£ÑĞ»Ğ¾Ğ²Ğ¸Ñ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸:</b>\n"
        f"ğŸšš Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚: {offer.get('vehicle_type', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
        f"ğŸ’° Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ: {offer.get('price', 0):,} â‚½\n"
        f"ğŸ“… Ğ”Ğ°Ñ‚Ğ°: {offer.get('delivery_date', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}\n\n"
        f"<b>ğŸ‘¤ Ğ—Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸Ğº:</b>\n"
        f"ğŸ¢ {exporter.get('company_name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}\n"
        f"ğŸ‘¤ {exporter.get('name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n"
        f"ğŸ“ <code>{exporter.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>\n"
        f"ğŸ“§ {exporter.get('email', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n\n"
        f"<b>ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ:</b> {get_offer_status_display(offer.get('status', 'pending'))}"
    )

    if offer.get("completed_at"):
        text += f"\nâœ… <b>Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°:</b> {offer.get('completed_at')}"

    keyboard = InlineKeyboardMarkup(row_width=1)
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ“ Ğ¡Ğ²ÑĞ·Ğ°Ñ‚ÑŒÑÑ Ñ Ğ·Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸ĞºĞ¾Ğ¼", url=f"tg://user?id={exporter_id}"
        )
    )

    # Ğ•ÑĞ»Ğ¸ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° Ğ² Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑĞµ - Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚ÑŒ
    if offer.get("status") in ["accepted", "in_progress"]:
        keyboard.add(
            InlineKeyboardButton(
                "âœ… Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚ÑŒ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ", callback_data=f"complete_delivery:{offer_id}"
            )
        )

    keyboard.add(
        InlineKeyboardButton("ğŸ”™ Ğš ÑĞ¿Ğ¸ÑĞºÑƒ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº", callback_data="back_to_deliveries")
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("complete_delivery:"), state="*")
async def complete_delivery(callback: types.CallbackQuery):
    """Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğµ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸"""
    try:
        offer_id = int(callback.data.split(":")[1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
        return

    if offer_id not in logistic_offers:
        await callback.answer("âŒ Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ
    logistic_offers[offer_id]["status"] = "completed"
    logistic_offers[offer_id]["completed_at"] = datetime.now().strftime(
        "%d.%m.%Y %H:%M"
    )

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°
    request_id = logistic_offers[offer_id].get("request_id")
    request = shipping_requests.get(request_id, {})
    exporter_id = request.get("exporter_id")

    if exporter_id:
        try:
            await bot.send_message(
                exporter_id,
                f"âœ… <b>Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°!</b>\n\n"
                f"Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ğ» Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ Ğ¿Ğ¾ Ğ·Ğ°ÑĞ²ĞºĞµ #{request_id}.\n"
                f"Ğ“Ñ€ÑƒĞ· Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½: {request.get('route_to', 'Ğ¿ÑƒĞ½ĞºÑ‚ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ')}.",
                parse_mode="HTML",
            )
            logging.info(
                f"âœ… Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ñƒ {exporter_id} Ğ¾ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğ¸ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸ #{offer_id}"
            )
        except Exception as e:
            logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°: {e}")

    await callback.answer("âœ… Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°!", show_alert=True)

    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ
    text = (
        f"âœ… <b>Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° #{offer_id} Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°!</b>\n\n"
        f"Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾ Ğ·Ğ° Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñƒ! \n"
        f"Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° Ğ¾Ñ‚Ğ¼ĞµÑ‡ĞµĞ½Ğ° ĞºĞ°Ğº Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ½Ğ°Ñ.\n\n"
        f"ğŸ’° Ğ—Ğ°Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½Ğ¾: {logistic_offers[offer_id].get('price', 0):,} â‚½"
    )

    keyboard = InlineKeyboardMarkup(row_width=1)
    keyboard.add(
        InlineKeyboardButton("ğŸ”™ Ğš ÑĞ¿Ğ¸ÑĞºÑƒ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº", callback_data="back_to_deliveries")
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")


@dp.callback_query_handler(
    lambda c: c.data in ["back_to_deliveries", "refresh_deliveries"], state="*"
)
async def back_to_deliveries_handler(callback: types.CallbackQuery, state: FSMContext):
    """Ğ’ĞµÑ€Ğ½ÑƒÑ‚ÑŒÑÑ Ğº ÑĞ¿Ğ¸ÑĞºÑƒ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº"""
    await logistics_my_deliveries_handler(callback.message, state)
    await callback.answer()


@dp.message_handler(
    lambda m: m.text in ["ğŸ’¼ ĞœĞ¾Ğ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… ÑƒÑĞ»ÑƒĞ³Ğ¸", "ğŸ’¼ ĞœĞ¾Ğ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… ÑƒÑĞ»ÑƒĞ³"],
    state="*",
)
async def logistics_services_stats_handler(message: types.Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id

    if user_id not in users or users[user_id].get("role") != "logistic":
        await message.answer("âŒ Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²")
        return

    await message.answer(
        "ğŸ’¼ <b>Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° ÑƒÑĞ»ÑƒĞ³</b>\n\n"
        "ğŸ“Š <b>ĞŸĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºĞ¸:</b> 0\n"
        "ğŸ’° <b>Ğ—Ğ°Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½Ğ¾:</b> 0 â‚½\n"
        "â­ <b>Ğ ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³:</b> Ğ½ĞµÑ‚ Ğ¾Ñ‚Ğ·Ñ‹Ğ²Ğ¾Ğ²\n\n"
        "Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ÑÑÑ‚ÑÑ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸",
        parse_mode="HTML",
    )


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜ĞšĞ˜: ĞĞĞ’ĞĞ¡Ğ¢Ğ˜, Ğ¦Ğ•ĞĞ« Ğ˜ ĞŸĞĞ˜Ğ¡Ğš
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


@dp.message_handler(lambda message: message.text == "ğŸ“Š ĞĞ¾Ğ²Ğ¾ÑÑ‚Ğ¸ Ğ¸ Ñ†ĞµĞ½Ñ‹", state="*")
async def show_news_and_prices(message: types.Message, state: FSMContext):
    """ĞÑ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ Ğ½Ğ¾Ğ²Ğ¾ÑÑ‚ĞµĞ¹ Ğ¸ Ñ†ĞµĞ½"""
    user_id = message.from_user.id
    if user_id not in users:
        await message.answer("âš ï¸ Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚Ğµ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ.")
        return

    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("ğŸ“ˆ Ğ¦ĞµĞ½Ñ‹", callback_data="show_prices"),
        InlineKeyboardButton("ğŸ“° ĞĞ¾Ğ²Ğ¾ÑÑ‚Ğ¸", callback_data="show_news"),
    )
    keyboard.add(InlineKeyboardButton("ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_menu"))

    await message.answer(
        "ğŸ“Š <b>ĞĞ¾Ğ²Ğ¾ÑÑ‚Ğ¸ Ğ¸ Ñ†ĞµĞ½Ñ‹ Ğ·ĞµÑ€Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ñ€Ñ‹Ğ½ĞºĞ°</b>\n\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ€Ğ°Ğ·Ğ´ĞµĞ»:",
        reply_markup=keyboard,
        parse_mode="HTML",
    )


@dp.callback_query_handler(lambda c: c.data == "show_prices", state="*")
async def callback_show_prices(callback_query: types.CallbackQuery):
    """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ñ†ĞµĞ½Ñ‹"""
    await bot.answer_callback_query(callback_query.id)
    try:
        regional_prices = parse_russia_regional_prices()
        fob_prices = parse_fob_black_sea()
        cbot_prices = parse_cbot_futures()
        message_text = format_prices_message(regional_prices, fob_prices, cbot_prices)

        keyboard = InlineKeyboardMarkup()
        keyboard.add(InlineKeyboardButton("ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="show_prices"))
        keyboard.add(
            InlineKeyboardButton("ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_news_menu")
        )

        await bot.edit_message_text(
            message_text,
            callback_query.from_user.id,
            callback_query.message.message_id,
            reply_markup=keyboard,
            parse_mode="Markdown",
        )
    except MessageNotModified:
        pass
    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾ĞºĞ°Ğ·Ğ° Ñ†ĞµĞ½: {e}")


@dp.callback_query_handler(lambda c: c.data == "show_news", state="*")
async def callback_show_news(callback_query: types.CallbackQuery):
    """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ğ¾ÑÑ‚Ğ¸"""
    await bot.answer_callback_query(callback_query.id)
    try:
        news_list = parse_grain_news()
        message_text = format_news_message(news_list)

        keyboard = InlineKeyboardMarkup()
        keyboard.add(InlineKeyboardButton("ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="show_news"))
        keyboard.add(
            InlineKeyboardButton("ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_news_menu")
        )

        await bot.edit_message_text(
            message_text,
            callback_query.from_user.id,
            callback_query.message.message_id,
            reply_markup=keyboard,
            parse_mode="Markdown",
        )
    except MessageNotModified:
        pass
    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾ĞºĞ°Ğ·Ğ° Ğ½Ğ¾Ğ²Ğ¾ÑÑ‚ĞµĞ¹: {e}")


@dp.callback_query_handler(lambda c: c.data == "back_to_news_menu", state="*")
async def callback_back_to_news_menu(callback_query: types.CallbackQuery):
    """Ğ’ĞµÑ€Ğ½ÑƒÑ‚ÑŒÑÑ Ğ² Ğ¼ĞµĞ½Ñ Ğ½Ğ¾Ğ²Ğ¾ÑÑ‚ĞµĞ¹"""
    await bot.answer_callback_query(callback_query.id)

    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("ğŸ“ˆ Ğ¦ĞµĞ½Ñ‹", callback_data="show_prices"),
        InlineKeyboardButton("ğŸ“° ĞĞ¾Ğ²Ğ¾ÑÑ‚Ğ¸", callback_data="show_news"),
    )
    keyboard.add(InlineKeyboardButton("ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_menu"))

    try:
        await bot.edit_message_text(
            "ğŸ“Š <b>ĞĞ¾Ğ²Ğ¾ÑÑ‚Ğ¸ Ğ¸ Ñ†ĞµĞ½Ñ‹ Ğ·ĞµÑ€Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ñ€Ñ‹Ğ½ĞºĞ°</b>\n\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ€Ğ°Ğ·Ğ´ĞµĞ»:",
            callback_query.from_user.id,
            callback_query.message.message_id,
            reply_markup=keyboard,
            parse_mode="HTML",
        )
    except MessageNotModified:
        pass


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ĞŸĞ ĞĞ¡ĞœĞĞ¢Ğ  Ğ”Ğ•Ğ¢ĞĞ›Ğ•Ğ™ ĞŸĞĞ Ğ¢Ğ˜Ğ˜ (CALLBACK)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


async def view_batch_details_direct(
    message: types.Message, batch_id: str, user_id: int
):
    """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ´ĞµÑ‚Ğ°Ğ»Ğ¸ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""
    logging.info(f"ğŸ” Ğ˜Ñ‰ĞµĞ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ batch_id={batch_id}, user_id={user_id}")

    # âœ… ĞŸĞ ĞĞ’Ğ•Ğ ĞšĞ Ğ¢Ğ˜ĞŸĞ Ğ”ĞĞĞĞ«Ğ¥
    if not isinstance(batches, dict):
        logging.error(f"âŒ batches Ğ¸Ğ¼ĞµĞµÑ‚ Ğ½ĞµĞ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ‚Ğ¸Ğ¿: {type(batches)}")
        await message.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹")
        return

    batch = None

    # âœ… ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞ«Ğ™ ĞŸĞĞ˜Ğ¡Ğš ĞŸĞĞ Ğ¢Ğ˜Ğ˜
    user_batches = batches.get(user_id, [])
    for b in user_batches:
        if str(b.get("id")) == str(batch_id):
            batch = b
            break

    if not batch:
        await message.answer("âŒ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°")
        return

    active_matches = [
        m
        for m in matches.values()
        if m["batch_id"] == batch_id and m["status"] == "active"
    ]

    text = f"""
ğŸ“¦ <b>ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ #{batch['id']}</b>

ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {batch['culture']}
ğŸ“ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½: {batch.get('region', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}
ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: {batch['volume']} Ñ‚
ğŸ’° Ğ¦ĞµĞ½Ğ°: {batch['price']:,.0f} â‚½/Ñ‚
ğŸ’§ Ğ’Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ: {batch.get('humidity', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}%
ğŸŒ¾ Ğ¡Ğ¾Ñ€Ğ½Ğ¾ÑÑ‚ÑŒ: {batch.get('impurity', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}%
â­ ĞšĞ»Ğ°ÑÑ: {batch.get('quality_class', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}
ğŸ­ Ğ¥Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ: {batch.get('storage_type', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}
ğŸ“… Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ½Ğ¾ÑÑ‚ÑŒ: {batch.get('readiness_date', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}
ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: {batch.get('status', 'ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ°')}
ğŸ“… Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¾: {batch.get('created_at', 'ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾')}
"""

    if active_matches:
        text += f"\nğŸ¯ <b>ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğ¹: {len(active_matches)}</b>"

    if batch.get("files"):
        text += f"\nğŸ“ ĞŸÑ€Ğ¸ĞºÑ€ĞµĞ¿Ğ»ĞµĞ½Ğ¾ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²: {len(batch['files'])}"

    keyboard = batch_actions_keyboard(batch_id)

    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")


@dp.callback_query_handler(lambda c: c.data == "back_to_my_batches", state="*")
async def back_to_my_batches(callback: types.CallbackQuery, state: FSMContext):
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğº ÑĞ¿Ğ¸ÑĞºÑƒ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ñ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸ĞµĞ¹ Ğ¿Ğ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°Ğ¼"""
    await state.finish()

    user_id = callback.from_user.id

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ€Ğ¾Ğ»Ğ¸
    if user_id not in users or users[user_id].get("role") != "farmer":
        await callback.answer(
            "âŒ Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°Ğ¼", show_alert=True
        )
        return

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    user_batches = batches.get(user_id, [])

    if not user_batches:
        keyboard = InlineKeyboardMarkup().add(
            InlineKeyboardButton("ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main")
        )
        await callback.message.edit_text(
            "ğŸ“¦ Ğ£ Ğ²Ğ°Ñ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ñ… Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹.\n\n"
            "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ 'â• Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ' Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ½Ğ¾Ğ²Ğ¾Ğ¹.",
            reply_markup=keyboard,
            parse_mode="HTML",
        )
        await callback.answer()
        return

    # Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ÑƒĞµĞ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ¿Ğ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°Ğ¼
    active_batches = [
        b for b in user_batches if b.get("status") in ["ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ°", "active", "Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ°"]
    ]
    reserved_batches = [
        b for b in user_batches if b.get("status") in ["Ğ—Ğ°Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ°", "reserved"]
    ]
    sold_batches = [b for b in user_batches if b.get("status") in ["ĞŸÑ€Ğ¾Ğ´Ğ°Ğ½Ğ°", "sold"]]
    withdrawn_batches = [
        b for b in user_batches if b.get("status") in ["Ğ¡Ğ½ÑÑ‚Ğ°", "withdrawn", "Ğ¡Ğ½ÑÑ‚Ğ¾"]
    ]

    # Ğ¡Ñ‡Ğ¸Ñ‚Ğ°ĞµĞ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ñ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸ÑĞ¼Ğ¸
    matched_batches = [
        b
        for b in active_batches
        if any(
            m.get("batch_id") == b.get("id") and m.get("status") == "active"
            for m in matches.values()
        )
    ]

    # Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ ÑĞ¾ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¾Ğ¹ Ğ¸ ĞºĞ½Ğ¾Ğ¿ĞºĞ°Ğ¼Ğ¸ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ¾Ğ²
    keyboard = InlineKeyboardMarkup(row_width=1)

    keyboard.add(
        InlineKeyboardButton(
            f"âœ… ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ ({len(active_batches)})",
            callback_data="filter_batches:active",
        ),
        InlineKeyboardButton(
            f"ğŸ”’ Ğ—Ğ°Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ ({len(reserved_batches)})",
            callback_data="filter_batches:reserved",
        ),
        InlineKeyboardButton(
            f"ğŸ’° ĞŸÑ€Ğ¾Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ ({len(sold_batches)})", callback_data="filter_batches:sold"
        ),
        InlineKeyboardButton(
            f"âŒ Ğ¡Ğ½ÑÑ‚Ñ‹Ğµ ({len(withdrawn_batches)})",
            callback_data="filter_batches:withdrawn",
        ),
    )

    keyboard.add(InlineKeyboardButton("ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main"))

    message_text = (
        f"ğŸ“¦ <b>Ğ’Ğ°ÑˆĞ¸ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸</b> ({len(user_batches)} ÑˆÑ‚.)\n\n"
        f"âœ… ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ: {len(active_batches)}\n"
        f"ğŸ”’ Ğ—Ğ°Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ: {len(reserved_batches)}\n"
        f"ğŸ’° ĞŸÑ€Ğ¾Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ: {len(sold_batches)}\n"
        f"âŒ Ğ¡Ğ½ÑÑ‚Ñ‹Ğµ Ñ Ğ¿Ñ€Ğ¾Ğ´Ğ°Ğ¶Ğ¸: {len(withdrawn_batches)}\n"
        f"ğŸ¯ Ğ¡ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸ÑĞ¼Ğ¸: {len(matched_batches)}\n\n"
        "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹:"
    )

    try:
        await callback.message.edit_text(
            message_text, reply_markup=keyboard, parse_mode="HTML"
        )
    except MessageNotModified:
        pass

    await callback.answer()


# ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ¿Ğ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°Ğ¼
@dp.callback_query_handler(lambda c: c.data.startswith("filter_batches:"), state="*")
async def filter_batches(callback: types.CallbackQuery, state: FSMContext):
    """Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ¸ Ğ¿Ğ¾ĞºĞ°Ğ· Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ¿Ğ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°Ğ¼"""
    await state.finish()

    user_id = callback.from_user.id
    status_filter = callback.data.split(":")[1]

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    user_batches = batches.get(user_id, [])

    # ĞœĞ°Ğ¿Ğ¿Ğ¸Ğ½Ğ³ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ¾Ğ²
    status_map = {
        "active": (["ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ°", "active", "Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ°"], "âœ… ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ"),
        "reserved": (["Ğ—Ğ°Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ°", "reserved"], "ğŸ”’ Ğ—Ğ°Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ"),
        "sold": (["ĞŸÑ€Ğ¾Ğ´Ğ°Ğ½Ğ°", "sold"], "ğŸ’° ĞŸÑ€Ğ¾Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ"),
        "withdrawn": (["Ğ¡Ğ½ÑÑ‚Ğ°", "withdrawn", "Ğ¡Ğ½ÑÑ‚Ğ¾"], "âŒ Ğ¡Ğ½ÑÑ‚Ñ‹Ğµ Ñ Ğ¿Ñ€Ğ¾Ğ´Ğ°Ğ¶Ğ¸"),
    }

    status_list, title = status_map.get(status_filter, ([], ""))
    filtered_batches = [b for b in user_batches if b.get("status") in status_list]

    keyboard = InlineKeyboardMarkup(row_width=1)

    if filtered_batches:
        # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹
        for batch in filtered_batches:
            culture = batch.get("culture", "?")
            volume = batch.get("volume", 0)
            price = batch.get("price", 0)
            batch_id = batch.get("id", "unknown")
            button_text = (
                f"{title.split()[0]} {culture} - {volume} Ñ‚ ({price:,.0f} â‚½/Ñ‚)"
            )
            keyboard.add(
                InlineKeyboardButton(
                    button_text, callback_data=f"view_batch:{batch_id}"
                )
            )
    else:
        await callback.message.edit_text(
            f"ğŸ“¦ {title}\n\nĞ› Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾",
            reply_markup=InlineKeyboardMarkup().add(
                InlineKeyboardButton("â† ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_my_batches")
            ),
            parse_mode="HTML",
        )
        await callback.answer()
        return

    # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚Ğ°
    keyboard.add(InlineKeyboardButton("â† ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_my_batches"))

    message_text = f"ğŸ“¦ <b>{title}</b> ({len(filtered_batches)} ÑˆÑ‚.)\n\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ°:"

    try:
        await callback.message.edit_text(
            message_text, reply_markup=keyboard, parse_mode="HTML"
        )
    except MessageNotModified:
        pass

    await callback.answer()


@dp.callback_query_handler(text="back_to_requests", state="*")
async def back_to_requests(callback: types.CallbackQuery, state: FSMContext):
    """Ğ’ĞµÑ€Ğ½ÑƒÑ‚ÑŒÑÑ Ğº ĞŸĞĞ›ĞĞĞœĞ£ ÑĞ¿Ğ¸ÑĞºÑƒ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ·Ğ°ÑĞ²Ğ¾Ğº (ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ñ‹ + Ñ„ĞµÑ€Ğ¼ĞµÑ€Ñ‹)"""
    await state.finish()

    try:
        await callback.answer()
    except Exception as e:
        logging.warning(f"Callback answer error: {e}")

    # ğŸ”„ Ğ¡ĞĞ‘Ğ˜Ğ ĞĞ•Ğœ Ğ’Ğ¡Ğ• ĞĞšĞ¢Ğ˜Ğ’ĞĞ«Ğ• Ğ—ĞĞ¯Ğ’ĞšĞ˜
    all_requests = []

    # ğŸ“Š DEBUG: ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ ĞµÑÑ‚ÑŒ Ğ² Ñ…Ñ€Ğ°Ğ½Ğ¸Ğ»Ğ¸Ñ‰Ğ°Ñ…
    logging.info(f"ğŸ” DEBUG: shipping_requests ({len(shipping_requests)} Ğ²ÑĞµĞ³Ğ¾)")
    for req_id, req in shipping_requests.items():
        status = req.get("status")
        logging.info(f"   - ID {req_id}: status='{status}'")
        if status == "active":
            all_requests.append(
                {
                    "id": req_id,
                    "source": "exporter",
                    "culture": req.get("culture", "â€”"),
                    "volume": req.get("volume", 0),
                    "created": req.get("created_at", "â€”"),
                }
            )

    logging.info(
        f"ğŸ” DEBUG: farmer_logistics_requests ({len(farmer_logistics_requests)} Ğ²ÑĞµĞ³Ğ¾)"
    )
    for req_id, req in farmer_logistics_requests.items():
        status = req.get("status")
        logging.info(f"   - ID {req_id}: status='{status}'")
        if status == "active":
            all_requests.append(
                {
                    "id": req_id,
                    "source": "farmer",
                    "culture": req.get("culture", "â€”"),
                    "volume": req.get("volume", 0),
                    "created": req.get("created_at", "â€”"),
                }
            )

    logging.info(f"âœ… Ğ˜Ğ¢ĞĞ“Ğ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ·Ğ°ÑĞ²Ğ¾Ğº: {len(all_requests)}")
    for req in all_requests:
        logging.info(f"   - {req['source'].upper()}: #{req['id']} ({req['culture']})")

    # ğŸ“Š Ğ¤ĞĞ ĞœĞ˜Ğ Ğ£Ğ•Ğœ Ğ¢Ğ•ĞšĞ¡Ğ¢
    text = f"""ğŸšš <b>ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸</b>


ğŸ“‹ Ğ’ÑĞµĞ³Ğ¾ Ğ·Ğ°ÑĞ²Ğ¾Ğº: {len(all_requests)}
ğŸš› ĞÑ‚ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ² | ğŸŒ¾ ĞÑ‚ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ²


Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ·Ğ°ÑĞ²ĞºÑƒ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ° Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹ Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ:
"""

    # ğŸ¯ ĞšĞĞĞŸĞšĞ˜ Ğ¡ Ğ—ĞĞ¯Ğ’ĞšĞĞœĞ˜
    keyboard = InlineKeyboardMarkup(row_width=1)

    if not all_requests:
        text += "\n\nâŒ <b>ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ·Ğ°ÑĞ²Ğ¾Ğº Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾</b>"
    else:
        for req in all_requests:
            if req["source"] == "exporter":
                emoji = "ğŸš›"
            else:
                emoji = "ğŸŒ¾"

            label = f"{emoji} {req['culture']} â€¢ {req['volume']:.0f}Ñ‚"
            keyboard.add(
                InlineKeyboardButton(
                    label, callback_data=f"view_request:{req['source']}:{req['id']}"
                )
            )
    try:
        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    except Exception as e:
        logging.error(f"Error editing message in back_to_requests: {e}")
        try:
            await callback.message.answer(
                text, reply_markup=keyboard, parse_mode="HTML"
            )
        except Exception as e2:
            logging.error(f"Error sending new message: {e2}")


@dp.callback_query_handler(lambda c: c.data == "back_to_exporter_menu", state="*")
async def back_to_exporter_menu(callback: types.CallbackQuery, state: FSMContext):
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğ² Ğ¼ĞµĞ½Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°"""
    await state.finish()

    user_id = callback.from_user.id

    if user_id not in users:
        await callback.answer("âŒ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    user = users[user_id]
    name = user.get("name", "Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€")

    try:
        await callback.message.delete()
    except Exception as e:
        print(f"ĞÑˆĞ¸Ğ±ĞºĞ°: {e}")
        pass

    keyboard = exporter_keyboard()

    await callback.message.answer(
        f"ğŸ‘‹ Ğ¡ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰ĞµĞ½Ğ¸ĞµĞ¼, {name}!\n\nğŸ“¦ <b>ĞœĞµĞ½Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°</b>",
        reply_markup=keyboard,
        parse_mode="HTML",
    )

    await callback.answer()


@dp.callback_query_handler(lambda c: c.data == "advanced_batch_search", state="*")
async def advanced_batch_search_handler(
    callback: types.CallbackQuery, state: FSMContext
):
    """Ğ Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ¸ÑĞº Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹"""
    await callback.message.edit_text(
        "ğŸ” <b>Ğ Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ¸ÑĞº Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹</b>\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºÑ€Ğ¸Ñ‚ĞµÑ€Ğ¸Ğ¹ Ğ¿Ğ¾Ğ¸ÑĞºĞ°:",
        reply_markup=search_criteria_keyboard(),
        parse_mode="HTML",
    )
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("contact_farmer_"), state="*")
async def contact_farmer_handler(callback: types.CallbackQuery, state: FSMContext):
    """ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚ Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ¼"""
    try:
        parts = callback.data.split("_")
        farmer_id = int(parts[2])
        batch_id = int(parts[3])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
        return

    farmer = users.get(farmer_id)
    if not farmer:
        await callback.answer("âŒ Ğ¤ĞµÑ€Ğ¼ĞµÑ€ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    farmer_name = farmer.get("name", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")
    farmer_phone = farmer.get("phone", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")

    await callback.answer(
        f"ğŸ‘¤ Ğ¤ĞµÑ€Ğ¼ĞµÑ€: {farmer_name}\n" f"ğŸ“ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: {farmer_phone}", show_alert=True
    )

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ° Ğ¾ Ğ·Ğ°Ğ¸Ğ½Ñ‚ĞµÑ€ĞµÑĞ¾Ğ²Ğ°Ğ½Ğ½Ğ¾ÑÑ‚Ğ¸
    try:
        exporter_name = users[callback.from_user.id].get("name", "Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€")
        await bot.send_message(
            farmer_id,
            f"âœ… <b>Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€ Ğ¿Ñ€Ğ¾ÑĞ²Ğ¸Ğ» Ğ¸Ğ½Ñ‚ĞµÑ€ĞµÑ!</b>\n\n"
            f"ğŸ‘¤ {exporter_name} Ğ·Ğ°Ğ¸Ğ½Ñ‚ĞµÑ€ĞµÑĞ¾Ğ²Ğ°Ğ»ÑÑ Ğ²Ğ°ÑˆĞµĞ¹ Ğ¿Ğ°Ñ€Ñ‚Ğ¸ĞµĞ¹ #{batch_id}\n\n"
            f"ĞĞ¶Ğ¸Ğ´Ğ°Ğ¹Ñ‚Ğµ Ğ·Ğ²Ğ¾Ğ½ĞºĞ°!",
            parse_mode="HTML",
        )
    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°: {e}")


@dp.message_handler(lambda message: message.text == "ğŸ” ĞŸĞ¾Ğ¸ÑĞº", state="*")
async def start_search(message: types.Message, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ¸ÑĞº Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹"""
    user_id = message.from_user.id
    if user_id not in users:
        await message.answer("âš ï¸ Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚Ğµ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ.")
        return

    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("ğŸŒ¾ ĞŸĞ¾ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğµ", callback_data="search_by_culture"),
        InlineKeyboardButton("ğŸ“ ĞŸĞ¾ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñƒ", callback_data="search_by_region"),
    )
    keyboard.add(
        InlineKeyboardButton("ğŸ’° ĞŸĞ¾ Ñ†ĞµĞ½Ğµ", callback_data="search_by_price"),
        InlineKeyboardButton("ğŸ“¦ ĞŸĞ¾ Ğ¾Ğ±ÑŠĞµĞ¼Ñƒ", callback_data="search_by_volume"),
    )
    keyboard.add(InlineKeyboardButton("ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_menu"))

    await message.answer(
        "ğŸ” <b>ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ·ĞµÑ€Ğ½Ğ°</b>\n\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºÑ€Ğ¸Ñ‚ĞµÑ€Ğ¸Ğ¹ Ğ¿Ğ¾Ğ¸ÑĞºĞ°:",
        reply_markup=keyboard,
        parse_mode="HTML",
    )


@dp.callback_query_handler(lambda c: c.data == "search_by_culture")
async def callback_search_by_culture(
    callback_query: types.CallbackQuery, state: FSMContext
):
    """ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğµ"""  # â† DOCSTRING ĞĞ ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞĞœ ĞœĞ•Ğ¡Ğ¢Ğ•

    # Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ state ĞĞ”Ğ˜Ğ Ğ ĞĞ—
    await SearchByCulture.waiting_culture.set()

    # ĞÑ‚Ğ²ĞµÑ‡Ğ°ĞµĞ¼ Ğ½Ğ° callback
    await bot.answer_callback_query(callback_query.id)

    # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ ĞºĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ñƒ
    keyboard = culture_keyboard()

    try:
        await bot.edit_message_text(
            "ğŸŒ¾ <b>Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñƒ:</b>",
            callback_query.from_user.id,
            callback_query.message.message_id,
            reply_markup=keyboard,
            parse_mode="HTML",
        )
    except MessageNotModified:
        pass


@dp.callback_query_handler(lambda c: c.data == "search_by_region", state="*")
async def callback_search_by_region(callback_query: types.CallbackQuery):
    """ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñƒ"""
    await bot.answer_callback_query(callback_query.id)
    await SearchBatchesStatesGroup.region.set()
    keyboard = region_keyboard()
    try:
        await bot.edit_message_text(
            "ğŸ“ <b>Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½:</b>",
            callback_query.from_user.id,
            callback_query.message.message_id,
            reply_markup=keyboard,
            parse_mode="HTML",
        )
    except MessageNotModified:
        pass


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ˜ ĞŸĞ£Ğ‘Ğ›Ğ˜ĞšĞĞ¦Ğ˜Ğ˜ Ğ’ ĞšĞĞĞĞ› Ğ˜ ĞĞ¢Ğ§Ğ•Ğ¢Ğ«
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


async def publish_pull_to_channel(pull_data):
    """ĞŸÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ğ¿ÑƒĞ»Ğ»Ğ° Ğ² Telegram ĞºĞ°Ğ½Ğ°Ğ»"""
    try:
        message_text = f"""ğŸŒ <b>ĞĞĞ’Ğ«Ğ™ ĞŸĞ£Ğ›Ğ›</b>

ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {pull_data.get('culture', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}
ğŸ“¦ ĞĞ±ÑŠĞµĞ¼: {pull_data.get('target_volume', 0):,.0f} Ñ‚Ğ¾Ğ½Ğ½
ğŸ’° Ğ¦ĞµĞ½Ğ°: {pull_data.get('price', 0):,.0f} â‚½/Ñ‚
ğŸš¢ ĞŸĞ¾Ñ€Ñ‚: {pull_data.get('port', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}

ğŸ“Š Ğ¢Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğº ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ñƒ:
â€¢ Ğ’Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ: Ğ´Ğ¾ {pull_data.get('moisture', 0)}%
â€¢ ĞĞ°Ñ‚ÑƒÑ€Ğ°: Ğ¾Ñ‚ {pull_data.get('nature', 0)} Ğ³/Ğ»
â€¢ ĞŸÑ€Ğ¸Ğ¼ĞµÑÑŒ: Ğ´Ğ¾ {pull_data.get('impurity', 0)}%

ğŸ†” ID Ğ¿ÑƒĞ»Ğ»Ğ°: {pull_data.get('id', 'N/A')}
ğŸ“… Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½: {pull_data.get('created_at', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}

ğŸ’¬ Ğ”Ğ»Ñ ÑƒÑ‡Ğ°ÑÑ‚Ğ¸Ñ Ğ½Ğ°Ğ¿Ğ¸ÑˆĞ¸Ñ‚Ğµ Ğ±Ğ¾Ñ‚Ñƒ
"""
        await bot.send_message(CHANNEL_ID, message_text, parse_mode="HTML")
        logging.info(f'âœ… ĞŸÑƒĞ»Ğ» {pull_data.get("id")} Ğ¾Ğ¿ÑƒĞ±Ğ»Ğ¸ĞºĞ¾Ğ²Ğ°Ğ½ Ğ² ĞºĞ°Ğ½Ğ°Ğ»')
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸ Ğ¿ÑƒĞ»Ğ»Ğ° Ğ² ĞºĞ°Ğ½Ğ°Ğ»: {e}")


async def publish_batch_to_channel(batch_data, farmer_name):
    """ĞŸÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ² Telegram ĞºĞ°Ğ½Ğ°Ğ»"""
    try:
        message_text = f"""ğŸ“¦ <b>ĞĞĞ’ĞĞ¯ ĞŸĞĞ Ğ¢Ğ˜Ğ¯</b>

ğŸ‘¤ Ğ¤ĞµÑ€Ğ¼ĞµÑ€: {farmer_name}
ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {batch_data.get('culture', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}
ğŸ“¦ ĞĞ±ÑŠĞµĞ¼: {batch_data.get('volume', 0):,.0f} Ñ‚Ğ¾Ğ½Ğ½
ğŸ’° Ğ¦ĞµĞ½Ğ°: {batch_data.get('price', 0):,.0f} â‚½/Ñ‚
ğŸ“ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½: {batch_data.get('region', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}

ğŸ“Š ĞšĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ¾:
â€¢ Ğ’Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ: {batch_data.get('humidity', 0)}%
â€¢ ĞŸÑ€Ğ¸Ğ¼ĞµÑÑŒ: {batch_data.get('impurity', 0)}%
â€¢ ĞšĞ»Ğ°ÑÑ: {batch_data.get('quality_class', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}

ğŸ†” ID Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸: {batch_data.get('id', 'N/A')}

ğŸ’¬ Ğ”Ğ»Ñ Ğ¿Ğ¾ĞºÑƒĞ¿ĞºĞ¸ Ğ½Ğ°Ğ¿Ğ¸ÑˆĞ¸Ñ‚Ğµ Ğ±Ğ¾Ñ‚Ñƒ
"""
        await bot.send_message(CHANNEL_ID, message_text, parse_mode="HTML")
        logging.info(f'âœ… ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ {batch_data.get("id")} Ğ¾Ğ¿ÑƒĞ±Ğ»Ğ¸ĞºĞ¾Ğ²Ğ°Ğ½Ğ° Ğ² ĞºĞ°Ğ½Ğ°Ğ»')
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ² ĞºĞ°Ğ½Ğ°Ğ»: {e}")


async def generate_weekly_report():
    """Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ ĞµĞ¶ĞµĞ½ĞµĞ´ĞµĞ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¾Ñ‚Ñ‡ĞµÑ‚Ğ°"""
    try:
        farmers_count = len([u for u in users.values() if u.get("role") == "farmer"])
        exporters_count = len(
            [u for u in users.values() if u.get("role") == "exporter"]
        )
        logistics_count = len(
            [u for u in users.values() if u.get("role") == "logistic"]
        )
        expeditors_count = len(
            [u for u in users.values() if u.get("role") == "expeditor"]
        )

        total_batches = sum(len(batches) for user_batches in batches.values())
        total_pulls = len(pulls)
        total_deals = len(deals)

        total_batch_volume = 0
        for farmer_id, batches in batches.items():
            for batch in user_batches:
                total_batch_volume += batch.get("volume", 0)

        prices = []
        for farmer_id, batches in batches.items():
            for batch in user_batches:
                if batch.get("price"):
                    prices.append(batch["price"])

        avg_price = sum(prices) / len(prices) if prices else 0

        report_text = f"""ğŸ“Š <b>Ğ•Ğ–Ğ•ĞĞ•Ğ”Ğ•Ğ›Ğ¬ĞĞ«Ğ™ ĞĞ¢Ğ§Ğ•Ğ¢</b>
{'='*40}

ğŸ‘¥ <b>ĞŸĞĞ›Ğ¬Ğ—ĞĞ’ĞĞ¢Ğ•Ğ›Ğ˜:</b>
â€¢ Ğ¤ĞµÑ€Ğ¼ĞµÑ€Ñ‹: {farmers_count}
â€¢ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€Ñ‹: {exporters_count}
â€¢ Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚Ñ‹: {logistics_count}
â€¢ Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ñ‹: {expeditors_count}
â€¢ <b>Ğ’ÑĞµĞ³Ğ¾: {len(users)}</b>

ğŸ“¦ <b>ĞŸĞĞ Ğ¢Ğ˜Ğ˜:</b>
â€¢ Ğ’ÑĞµĞ³Ğ¾ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹: {total_batches}
â€¢ ĞĞ±Ñ‰Ğ¸Ğ¹ Ğ¾Ğ±ÑŠĞµĞ¼: {total_batch_volume:,.0f} Ñ‚Ğ¾Ğ½Ğ½
â€¢ Ğ¡Ñ€ĞµĞ´Ğ½ÑÑ Ñ†ĞµĞ½Ğ°: {avg_price:,.0f} â‚½/Ñ‚

ğŸŒ <b>ĞŸĞ£Ğ›Ğ›Ğ«:</b>
â€¢ Ğ’ÑĞµĞ³Ğ¾ Ğ¿ÑƒĞ»Ğ»Ğ¾Ğ²: {total_pulls}

ğŸ¤ <b>Ğ¡Ğ”Ğ•Ğ›ĞšĞ˜:</b>
â€¢ Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¾ ÑĞ´ĞµĞ»Ğ¾Ğº: {total_deals}

ğŸ“… Ğ”Ğ°Ñ‚Ğ° Ğ¾Ñ‚Ñ‡ĞµÑ‚Ğ°: {datetime.now().strftime('%d.%m.%Y %H:%M')}
"""

        admin_id = 1481790360  # Ğ—Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚Ğµ Ğ½Ğ° ID Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ°
        await bot.send_message(admin_id, report_text, parse_mode="HTML")

        try:
            await bot.send_message(CHANNEL_ID, report_text, parse_mode="HTML")
        except Exception as e:
            print(f"ĞÑˆĞ¸Ğ±ĞºĞ°: {e}")
            pass

        logging.info("âœ… Ğ•Ğ¶ĞµĞ½ĞµĞ´ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ Ğ¾Ñ‚Ñ‡ĞµÑ‚ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ğ¾Ñ‚Ñ‡ĞµÑ‚Ğ°: {e}")


async def schedule_weekly_reports():
    """Ğ—Ğ°Ğ¿ÑƒÑĞº scheduler Ğ´Ğ»Ñ ĞµĞ¶ĞµĞ½ĞµĞ´ĞµĞ»ÑŒĞ½Ñ‹Ñ… Ğ¾Ñ‚Ñ‡ĞµÑ‚Ğ¾Ğ²"""
    global scheduler
    try:
        scheduler.add_job(
            generate_weekly_report, "cron", day_of_week="mon", hour=9, minute=0
        )
        logging.info("âœ… Scheduler Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½: ĞµĞ¶ĞµĞ½ĞµĞ´ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ğ¾Ñ‚Ñ‡ĞµÑ‚Ñ‹ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹")
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ·Ğ°Ğ¿ÑƒÑĞºĞ° scheduler: {e}")


# ============================================================================
# CALLBACK ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜ĞšĞ˜ ĞĞ”ĞœĞ˜Ğ-ĞŸĞĞĞ•Ğ›Ğ˜
# ============================================================================


@dp.callback_query_handler(lambda c: c.data == "admin_refresh_stats", state="*")
async def admin_refresh_statistics(callback: CallbackQuery, state: FSMContext):
    """ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸"""
    await state.finish()

    if callback.from_user.id != ADMIN_ID:
        await callback.answer("ğŸš« Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½", show_alert=True)
        return

    stats_message = format_admin_statistics()

    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="admin_refresh_stats"),
        InlineKeyboardButton("ğŸ“Š Ğ”ĞµÑ‚Ğ°Ğ»Ğ¸", callback_data="admin_detailed_stats"),
    )

    try:
        await callback.message.edit_text(
            stats_message, reply_markup=keyboard, parse_mode="HTML"
        )
        await callback.answer("âœ… ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾")
    except MessageNotModified:
        await callback.answer("Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ°ĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ñ‹")
    except Exception as e:
        await callback.answer(f"ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)}", show_alert=True)


@dp.callback_query_handler(lambda c: c.data == "admin_refresh_analytics", state="*")
async def admin_refresh_analytics_callback(callback: CallbackQuery, state: FSMContext):
    """ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ°Ğ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ¸"""
    await state.finish()

    if callback.from_user.id != ADMIN_ID:
        await callback.answer("ğŸš« Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½", show_alert=True)
        return

    analytics_message = format_admin_analytics()

    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="admin_refresh_analytics"),
        InlineKeyboardButton("ğŸ“¤ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚", callback_data="admin_export_analytics"),
    )

    try:
        await callback.message.edit_text(
            analytics_message, reply_markup=keyboard, parse_mode="HTML"
        )
        await callback.answer("âœ… ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾")
    except MessageNotModified:
        await callback.answer("Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ°ĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ñ‹")
    except Exception as e:
        await callback.answer(f"ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)}", show_alert=True)


@dp.callback_query_handler(lambda c: c.data == "export_users", state="*")
async def export_users_callback(callback: CallbackQuery, state: FSMContext):
    """Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ² CSV"""
    await state.finish()

    if callback.from_user.id != ADMIN_ID:
        await callback.answer("ğŸš« Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½", show_alert=True)
        return

    try:
        output = StringIO()
        writer = csv.writer(output)
        writer.writerow(["ID", "Ğ Ğ¾Ğ»ÑŒ", "Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½", "Email", "Ğ ĞµĞ³Ğ¸Ğ¾Ğ½", "Ğ˜ĞĞ", "ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ"])

        for user_id_data, user_data in users.items():
            writer.writerow(
                [
                    user_id_data,
                    user_data.get("role", ""),
                    user_data.get("phone", ""),
                    user_data.get("email", ""),
                    user_data.get("region", ""),
                    user_data.get("inn", ""),
                    user_data.get("company_name", ""),
                ]
            )

        output.seek(0)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

        await bot.send_document(
            callback.from_user.id,
            ("users_" + timestamp + ".csv", output.getvalue().encode("utf-8-sig")),
            caption=f"ğŸ“¤ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹\nĞ’ÑĞµĞ³Ğ¾: {len(users)}",
        )

        await callback.answer("âœ… Ğ¤Ğ°Ğ¹Ğ» Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½")
        logging.info(f"Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½: {len(users)} Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹")

    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹: {e}")
        await callback.answer(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)}", show_alert=True)


@dp.callback_query_handler(lambda c: c.data == "export_pools", state="*")
async def export_pools_callback(callback: CallbackQuery, state: FSMContext):
    """Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ¿ÑƒĞ»Ğ¾Ğ² Ğ² CSV"""
    await state.finish()

    if callback.from_user.id != ADMIN_ID:
        await callback.answer("ğŸš« Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½", show_alert=True)
        return

    try:
        output = StringIO()
        writer = csv.writer(output)
        writer.writerow(
            ["ID", "Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€", "Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ", "ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°", "ĞĞ±ÑŠÑ‘Ğ¼", "Ğ¦ĞµĞ½Ğ°", "Ğ”Ğ°Ñ‚Ğ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ"]
        )

        for pool_id, pool_data in pools.items():
            exporter = users.get(pool_data.get("exporter_id"), {})
            writer.writerow(
                [
                    pool_id,
                    exporter.get("company_name", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾"),
                    pool_data.get("status", ""),
                    pool_data.get("culture", ""),
                    pool_data.get("volume", 0),
                    pool_data.get("price", 0),
                    pool_data.get("created_at", ""),
                ]
            )

        output.seek(0)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

        await bot.send_document(
            callback.from_user.id,
            ("pools_" + timestamp + ".csv", output.getvalue().encode("utf-8-sig")),
            caption=f"ğŸ“¤ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ¿ÑƒĞ»Ğ¾Ğ²\nĞ’ÑĞµĞ³Ğ¾: {len(pulls)}",
        )

        await callback.answer("âœ… Ğ¤Ğ°Ğ¹Ğ» Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½")
        logging.info(f"Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ¿ÑƒĞ»Ğ¾Ğ² Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½: {len(pulls)} Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹")

    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ° Ğ¿ÑƒĞ»Ğ¾Ğ²: {e}")
        await callback.answer(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)}", show_alert=True)


@dp.callback_query_handler(lambda c: c.data == "export_batches", state="*")
async def export_batches_callback(callback: CallbackQuery, state: FSMContext):
    """Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ² CSV"""
    await state.finish()

    if callback.from_user.id != ADMIN_ID:
        await callback.answer("ğŸš« Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½", show_alert=True)
        return

    try:
        output = StringIO()
        writer = csv.writer(output)
        writer.writerow(
            ["Ğ¤ĞµÑ€Ğ¼ĞµÑ€ ID", "Ğ¤ĞµÑ€Ğ¼ĞµÑ€", "Batch ID", "ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°", "ĞĞ±ÑŠÑ‘Ğ¼", "Ğ¦ĞµĞ½Ğ°", "Ğ ĞµĞ³Ğ¸Ğ¾Ğ½"]
        )

        for farmer_id, batches in batches.items():
            farmer = users.get(farmer_id, {})
            farmer_name = farmer.get("company_name", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")
            for batch in user_batches:
                writer.writerow(
                    [
                        farmer_id,
                        farmer_name,
                        batch.get("id", ""),
                        batch.get("culture", ""),
                        batch.get("volume", 0),
                        batch.get("price", 0),
                        batch.get("region", ""),
                    ]
                )

        output.seek(0)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        total_batches = sum(len(batches) for user_batches in batches.values())

        await bot.send_document(
            callback.from_user.id,
            ("batches_" + timestamp + ".csv", output.getvalue().encode("utf-8-sig")),
            caption=f"ğŸ“¤ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹\nĞ’ÑĞµĞ³Ğ¾: {total_batches}",
        )

        await callback.answer("âœ… Ğ¤Ğ°Ğ¹Ğ» Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½")
        logging.info(f"Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½: {total_batches} Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹")

    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹: {e}")
        await callback.answer(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)}", show_alert=True)


@dp.callback_query_handler(lambda c: c.data == "export_full", state="*")
async def export_full_backup_callback(callback: CallbackQuery, state: FSMContext):
    """ĞŸĞ¾Ğ»Ğ½Ñ‹Ğ¹ Ğ±ÑĞºĞ°Ğ¿ Ğ²ÑĞµÑ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…"""
    await state.finish()

    if callback.from_user.id != ADMIN_ID:
        await callback.answer("ğŸš« Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½", show_alert=True)
        return

    try:
        save_data()

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_dir = f"backup_{timestamp}"

        os.makedirs(backup_dir, exist_ok=True)

        for filename in [
            "users.pkl",
            "pools.pkl",
            "batches.pkl",
            "shipping_requests.pkl",
        ]:
            if os.path.exists(filename):
                shutil.copy(filename, os.path.join(backup_dir, filename))

        archive_name = f"backup_{timestamp}"
        shutil.make_archive(archive_name, "zip", backup_dir)
        shutil.rmtree(backup_dir)

        with open(f"{archive_name}.zip", "rb") as backup_file:
            await bot.send_document(
                callback.from_user.id,
                backup_file,
                caption=f"ğŸ’¾ ĞŸĞ¾Ğ»Ğ½Ğ°Ñ Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ½Ğ°Ñ ĞºĞ¾Ğ¿Ğ¸Ñ\nĞ”Ğ°Ñ‚Ğ°: {datetime.now().strftime('%d.%m.%Y %H:%M:%S')}",
            )

        os.remove(f"{archive_name}.zip")

        await callback.answer("âœ… Ğ‘ÑĞºĞ°Ğ¿ ÑĞ¾Ğ·Ğ´Ğ°Ğ½ Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½")
        logging.info(f"Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½ Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğ¹ Ğ±ÑĞºĞ°Ğ¿: {archive_name}.zip")

    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ±ÑĞºĞ°Ğ¿Ğ°: {e}")
        await callback.answer(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)}", show_alert=True)


@dp.callback_query_handler(lambda c: c.data == "reload_data", state="*")
async def reload_data_callback(callback: CallbackQuery, state: FSMContext):
    """ĞŸĞµÑ€ĞµĞ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¸Ğ· Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²"""
    await state.finish()

    if callback.from_user.id != ADMIN_ID:
        await callback.answer("ğŸš« Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½", show_alert=True)
        return

    try:
        load_data()
        await callback.answer("âœ… Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¿ĞµÑ€ĞµĞ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ñ‹", show_alert=True)
        logging.info("Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿ĞµÑ€ĞµĞ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ñ‹ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ¼")
    except Exception as e:
        await callback.answer(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)}", show_alert=True)
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿ĞµÑ€ĞµĞ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…: {e}")


# ============================================================================
# CALLBACK ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜ĞšĞ˜ Ğ”Ğ›Ğ¯ ĞĞ”ĞœĞ˜Ğ-ĞŸĞĞĞ•Ğ›Ğ˜
# ============================================================================


@dp.callback_query_handler(lambda c: c.data == "adminstat", state="*")
async def admin_statistics_callback(callback: types.CallbackQuery, state: FSMContext):
    """Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ñ‡ĞµÑ€ĞµĞ· callback"""
    await state.finish()

    user_id = callback.from_user.id
    if user_id != ADMIN_ID:
        await callback.answer("âŒ ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°", show_alert=True)
        return

    try:
        msg = format_admin_statistics()

        keyboard = InlineKeyboardMarkup(row_width=2)
        keyboard.add(
            InlineKeyboardButton("ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="adminstat"),
            InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="backtoadmin"),
        )

        await callback.message.edit_text(msg, reply_markup=keyboard, parse_mode="HTML")
        await callback.answer("âœ… Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°")
    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸: {e}")
        await callback.answer(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {e}", show_alert=True)


@dp.callback_query_handler(lambda c: c.data == "adminanalytics", state="*")
async def admin_analytics_callback(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ° Ñ‡ĞµÑ€ĞµĞ· callback"""
    await state.finish()

    user_id = callback.from_user.id
    if user_id != ADMIN_ID:
        await callback.answer("âŒ ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°", show_alert=True)
        return

    try:
        msg = format_admin_analytics()

        keyboard = InlineKeyboardMarkup(row_width=2)
        keyboard.add(
            InlineKeyboardButton("ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="adminanalytics"),
            InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="backtoadmin"),
        )

        await callback.message.edit_text(msg, reply_markup=keyboard, parse_mode="HTML")
        await callback.answer("âœ… ĞĞ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°")
    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ°Ğ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ¸: {e}")
        await callback.answer(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {e}", show_alert=True)


@dp.callback_query_handler(lambda c: c.data == "adminexport", state="*")
async def admin_export_callback(callback: types.CallbackQuery, state: FSMContext):
    """Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ñ‡ĞµÑ€ĞµĞ· callback"""
    await state.finish()

    user_id = callback.from_user.id
    if user_id != ADMIN_ID:
        await callback.answer("âŒ ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°", show_alert=True)
        return

    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("ğŸ‘¥ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸", callback_data="exportusers"),
        InlineKeyboardButton("ğŸ“¦ ĞŸÑƒĞ»Ğ»Ñ‹", callback_data="exportpulls"),
        InlineKeyboardButton("ğŸŒ¾ ĞŸĞ°Ñ€Ñ‚Ğ¸Ğ¸", callback_data="exportbatches"),
        InlineKeyboardButton("ğŸ“‹ Ğ—Ğ°ÑĞ²ĞºĞ¸", callback_data="exportrequests"),
        InlineKeyboardButton("ğŸ’¼ ĞŸĞ¾Ğ»Ğ½Ñ‹Ğ¹ Ğ±ÑĞºĞ°Ğ¿", callback_data="exportfull"),
        InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="backtoadmin"),
    )

    await callback.message.edit_text(
        "ğŸ“¤ <b>Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…</b>\n\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ»Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ°:",
        reply_markup=keyboard,
        parse_mode="HTML",
    )
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data == "adminusers", state="*")
async def admin_users_callback(callback: types.CallbackQuery, state: FSMContext):
    """Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ñ‡ĞµÑ€ĞµĞ· callback"""
    await state.finish()

    user_id = callback.from_user.id
    if user_id != ADMIN_ID:
        await callback.answer("âŒ ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°", show_alert=True)
        return

    try:
        # âœ… Ğ¡ĞĞ¡Ğ¢ĞĞ’Ğ›Ğ¯Ğ•Ğœ Ğ¡ĞĞĞ‘Ğ©Ğ•ĞĞ˜Ğ• ĞŸĞ Ğ¯ĞœĞ Ğ—Ğ”Ğ•Ğ¡Ğ¬
        msg = "ğŸ‘¥ <b>ĞŸĞĞ›Ğ¬Ğ—ĞĞ’ĞĞ¢Ğ•Ğ›Ğ˜ Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ«</b>\\n\\n"

        farmers = [u for u in users.values() if u.get("role") == "farmer"]
        exporters = [u for u in users.values() if u.get("role") == "exporter"]
        logists = [u for u in users.values() if u.get("role") == "logist"]
        expeditors = [u for u in users.values() if u.get("role") == "expeditor"]

        msg += f"ğŸŒ¾ <b>Ğ¤ĞµÑ€Ğ¼ĞµÑ€Ñ‹:</b> {len(farmers)}\\n"
        for user in farmers[:5]:
            msg += f"  â€¢ {user.get('name', 'N/A')} ({user.get('phone', 'N/A')})\\n"
        if len(farmers) > 5:
            msg += f"  ... Ğ¸ ĞµÑ‰Ñ‘ {len(farmers) - 5}\\n"
        msg += "\\n"

        msg += f"ğŸ“¦ <b>Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€Ñ‹:</b> {len(exporters)}\\n"
        for user in exporters[:5]:
            msg += f"  â€¢ {user.get('name', 'N/A')} ({user.get('phone', 'N/A')})\\n"
        if len(exporters) > 5:
            msg += f"  ... Ğ¸ ĞµÑ‰Ñ‘ {len(exporters) - 5}\\n"
        msg += "\\n"

        msg += f"ğŸšš <b>Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚Ñ‹:</b> {len(logists)}\\n"
        for user in logists[:5]:
            msg += f"  â€¢ {user.get('name', 'N/A')} ({user.get('phone', 'N/A')})\\n"
        if len(logists) > 5:
            msg += f"  ... Ğ¸ ĞµÑ‰Ñ‘ {len(logists) - 5}\\n"
        msg += "\\n"

        msg += f"âœˆï¸ <b>Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ñ‹:</b> {len(expeditors)}\\n"
        for user in expeditors[:5]:
            msg += f"  â€¢ {user.get('name', 'N/A')} ({user.get('phone', 'N/A')})\\n"
        if len(expeditors) > 5:
            msg += f"  ... Ğ¸ ĞµÑ‰Ñ‘ {len(expeditors) - 5}\\n"

        keyboard = InlineKeyboardMarkup(row_width=2)
        keyboard.add(
            InlineKeyboardButton("ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="adminusers"),
            InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="backtoadmin"),
        )

        await callback.message.edit_text(msg, reply_markup=keyboard, parse_mode="HTML")
        await callback.answer("âœ… Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹")

    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¿Ğ¸ÑĞºĞ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹: {e}")
        await callback.answer(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {e}", show_alert=True)


@dp.callback_query_handler(lambda c: c.data == "adminbroadcast", state="*")
async def admin_broadcast_callback(callback: types.CallbackQuery, state: FSMContext):
    """Ğ Ğ°ÑÑÑ‹Ğ»ĞºĞ° Ñ‡ĞµÑ€ĞµĞ· callback"""
    await state.finish()

    user_id = callback.from_user.id
    if user_id != ADMIN_ID:
        await callback.answer("âŒ ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°", show_alert=True)
        return

    keyboard = InlineKeyboardMarkup(row_width=1)
    keyboard.add(InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="backtoadmin"))

    await callback.message.edit_text(
        "ğŸ“§ <b>Ğ Ğ°ÑÑÑ‹Ğ»ĞºĞ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹</b>\\n\\n"
        "ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸ Ğ²ÑĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼:\\n\\n"
        "<i>ĞĞ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: /broadcast Ğ’Ğ°Ğ¶Ğ½Ğ¾Ğµ Ğ¾Ğ±ÑŠÑĞ²Ğ»ĞµĞ½Ğ¸Ğµ</i>",
        reply_markup=keyboard,
        parse_mode="HTML",
    )
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data == "adminprices", state="*")
async def admin_prices_callback(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ñ†ĞµĞ½ Ñ‡ĞµÑ€ĞµĞ· callback"""
    await state.finish()

    user_id = callback.from_user.id
    if user_id != ADMIN_ID:
        await callback.answer("âŒ ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°", show_alert=True)
        return

    await callback.answer("â³ ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑÑ Ñ†ĞµĞ½Ñ‹...", show_alert=True)

    keyboard = InlineKeyboardMarkup(row_width=1)
    keyboard.add(InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="backtoadmin"))

    try:
        # Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ñ†ĞµĞ½ (ĞµÑĞ»Ğ¸ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚)
        # await update_grain_prices()

        # âœ… Ğ¢ĞĞ›Ğ¬ĞšĞ ĞĞ”Ğ˜Ğ edit_text!
        await callback.message.edit_text(
            "âœ… <b>Ğ¦ĞµĞ½Ñ‹ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ñ‹!</b>\\n\\n"
            "Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ñ‹ Ğ¸Ğ· Ğ¸ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸ĞºĞ¾Ğ².\\n"
            f"Ğ’Ñ€ĞµĞ¼Ñ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ: {datetime.now().strftime('%H:%M:%S')}",
            reply_markup=keyboard,
            parse_mode="HTML",
        )
        logging.info("âœ… Ğ¦ĞµĞ½Ñ‹ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ñ‹")

    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ñ†ĞµĞ½: {e}")

        # âœ… Ğ¢ĞĞ›Ğ¬ĞšĞ ĞĞ”Ğ˜Ğ edit_text!
        await callback.message.edit_text(
            f"âŒ <b>ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ñ†ĞµĞ½</b>\\n\\n{str(e)[:100]}",
            reply_markup=keyboard,
            parse_mode="HTML",
        )


# === HANDLER: ĞŸÑ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğº Ğ¿ÑƒĞ»Ğ»Ñƒ ===


@dp.callback_query_handler(
    lambda c: c.data and c.data.startswith("selectbatch_"), state="*"
)
async def process_batch_selection_for_pull(
    callback_query: CallbackQuery, state: FSMContext
):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ´Ğ»Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ² Ğ¿ÑƒĞ»Ğ»"""
    try:
        batch_id = callback_query.data.split("_")[1]
        user_id = callback_query.from_user.id

        logging.info(f"Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ {batch_id}")

        data = await state.get_data()
        pull_id = data.get("pull_id")

        if not pull_id:
            await callback_query.answer("âŒ ĞŸÑƒĞ»Ğ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
            return

        load_batches_from_pickle()
        pulls = load_pulls()

        batch = next((b for b in batches if b.get("id") == batch_id), None)
        if not batch:
            await callback_query.answer("âŒ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
            return

        if str(batch.get("farmer_id")) != str(user_id):
            await callback_query.answer("âŒ ĞĞµ Ğ²Ğ°ÑˆĞ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ", show_alert=True)
            return

        pull = next((p for p in pulls if p.get("id") == pull_id), None)
        if not pull:
            await callback_query.answer("âŒ ĞŸÑƒĞ»Ğ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
            return

        if "batches" not in pull:
            pull["batches"] = []

        if batch_id in pull["batches"]:
            await callback_query.answer("âš ï¸ Ğ£Ğ¶Ğµ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ°", show_alert=True)
            return

        pull["batches"].append(batch_id)
        current_volume = pull.get("current_volume", 0)
        pull["current_volume"] = current_volume + batch.get("volume", 0)

        save_pulls(pulls)

        await callback_query.answer("âœ… ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ°!", show_alert=True)

        logging.info(f"âœ… ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ {batch_id} Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ° Ğ² Ğ¿ÑƒĞ»Ğ» {pull_id}")

        try:
            if hasattr(gs, "sync_pull_to_sheets"):
                gs.sync_pull_to_sheets(pull_id, pull)
        except Exception as e:
            logging.debug(f"Ğ¡Ğ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ: {e}")

    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ°: {e}")
        await callback_query.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)


# === Ğ‘Ğ•Ğ—ĞĞŸĞĞ¡ĞĞ«Ğ• Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ˜ ===


async def safe_notify_exporter(pull, batch):
    """Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾Ğµ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ° Ğ¾ Ğ½Ğ¾Ğ²Ğ¾Ğ¹ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""
    try:
        if not pull or not isinstance(pull, dict):
            logging.debug("ĞŸÑƒĞ»Ğ» Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
            return

        exporter_id = pull.get("exporter_id")
        if not exporter_id:
            logging.debug("Ğ£ Ğ¿ÑƒĞ»Ğ»Ğ° Ğ½ĞµÑ‚ exporter_id")
            return

        users = load_users()
        if exporter_id not in users:
            logging.debug(f"Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€ {exporter_id} Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½")
            return

        message = f"ğŸ”” ĞĞ¾Ğ²Ğ°Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ!\n{batch.get('culture')} - {batch.get('volume')} Ñ‚"
        await bot.send_message(exporter_id, message)
        logging.info(f"âœ… Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€ {exporter_id} ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»Ñ‘Ğ½")

    except Exception as e:
        logging.debug(f"Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ: {e}")


async def safe_publish_to_channel(batch):
    """Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ°Ñ Ğ¿ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ğ² ĞºĞ°Ğ½Ğ°Ğ»"""
    try:
        channel_id = os.getenv("CHANNEL_ID")
        if not channel_id:
            logging.debug("CHANNEL_ID Ğ½Ğµ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞ½")
            return

        message = f"ğŸŒ¾ ĞĞ¾Ğ²Ğ°Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ!\n{batch.get('culture')} - {batch.get('volume')} Ñ‚"
        await bot.send_message(channel_id, message)
        logging.info("âœ… ĞĞ¿ÑƒĞ±Ğ»Ğ¸ĞºĞ¾Ğ²Ğ°Ğ½Ğ¾ Ğ² ĞºĞ°Ğ½Ğ°Ğ»Ğµ")

    except Exception as e:
        if "Chat not found" in str(e):
            logging.debug("ĞšĞ°Ğ½Ğ°Ğ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ (Ğ½Ğ¾Ñ€Ğ¼Ğ°)")
        else:
            logging.debug(f"ĞŸÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ†Ğ¸Ñ: {e}")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜ĞšĞ˜ ĞĞ¡ĞĞĞ’ĞĞ«Ğ¥ ĞšĞĞĞŸĞĞš ĞœĞ•ĞĞ® (Ğ”ĞĞ‘ĞĞ’Ğ›Ğ•ĞĞ«)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
@dp.message_handler(lambda m: m.text == "ğŸ“‹ ĞœĞ¾Ğ¸ Ğ¿ÑƒĞ»Ğ»Ñ‹", state="*")
async def show_my_pulls_farmer(message: types.Message, state: FSMContext):
    """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¿ÑƒĞ»Ğ»Ñ‹ Ğ² ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ñ… ÑƒÑ‡Ğ°ÑÑ‚Ğ²ÑƒĞµÑ‚ Ñ„ĞµÑ€Ğ¼ĞµÑ€"""
    user_id = message.from_user.id

    if user_id not in users:
        await message.answer("âŒ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½")
        return

    my_pulls = []

    for exporter_id, pulls in exporter_pulls.items():
        for pull in pulls:
            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑƒÑ‡Ğ°ÑÑ‚Ğ²ÑƒĞµÑ‚ Ğ»Ğ¸ Ñ„ĞµÑ€Ğ¼ĞµÑ€ Ğ² ÑÑ‚Ğ¾Ğ¼ Ğ¿ÑƒĞ»Ğ»Ğµ
            for batch_id in pull.get("batches", []):
                if user_id in batches:
                    for batch in batches[user_id]:
                        if batch.get("id") == batch_id:
                            my_pulls.append(
                                {
                                    "pull": pull,
                                    "exporter_id": exporter_id,
                                    "batch": batch,
                                }
                            )

    if not my_pulls:
        await message.answer(
            "ğŸ“‹ Ğ’Ñ‹ Ğ¿Ğ¾ĞºĞ° Ğ½Ğµ ÑƒÑ‡Ğ°ÑÑ‚Ğ²ÑƒĞµÑ‚Ğµ Ğ½Ğ¸ Ğ² Ğ¾Ğ´Ğ½Ğ¾Ğ¼ Ğ¿ÑƒĞ»Ğ»Ğµ\n\n"
            "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ 'ğŸ” ĞĞ°Ğ¹Ñ‚Ğ¸ Ğ¿ÑƒĞ»Ğ»' Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ½Ğ°Ğ¹Ñ‚Ğ¸ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´ÑÑ‰Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ»Ñ‹",
            parse_mode="Markdown",
        )
        return

    msg = "ğŸ“‹ *ĞŸÑƒĞ»Ğ»Ñ‹ Ğ² ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ñ… Ğ²Ñ‹ ÑƒÑ‡Ğ°ÑÑ‚Ğ²ÑƒĞµÑ‚Ğµ:*\n\n"

    for i, item in enumerate(my_pulls, 1):
        pull = item["pull"]
        batch = item["batch"]

        status_emoji = {"open": "ğŸŸ¢", "filling": "ğŸŸ¡", "closed": "ğŸ”´"}.get(
            pull.get("status", "open"), "â“"
        )
        msg += f"{i}. {status_emoji} {pull['culture']}\n"
        msg += f"   Ğ’Ğ°ÑˆĞ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ: {batch['volume']} Ñ‚\n"
        msg += f"   ĞŸĞ¾Ñ€Ñ‚: {pull.get('port', 'Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
        msg += f"   ĞŸÑ€Ğ¾Ğ³Ñ€ĞµÑÑ: {pull.get('current_volume', 0)}/{pull['target_volume']} Ñ‚\n\n"

    await message.answer(msg, parse_mode="Markdown")


@dp.message_handler(lambda m: m.text == "â• Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ", state="*")
async def create_batch_start(message: types.Message, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ñ‚ÑŒ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""
    user_id = message.from_user.id

    if user_id not in users or users[user_id].get("role") != "farmer":
        await message.answer("âŒ Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°Ğ¼")
        return

    await message.answer(
        "ğŸŒ¾ *Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ½Ğ¾Ğ²Ğ¾Ğ¹ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸*\n\n" "Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñƒ:",
        reply_markup=culture_keyboard(),
        parse_mode="Markdown",
    )
    await CreateBatchStates.culture.set()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ”ĞĞŸĞĞ›ĞĞ˜Ğ¢Ğ•Ğ›Ğ¬ĞĞĞ¯ Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ¯: /debug Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


@dp.message_handler(commands=["debug"], state="*")
async def debug_account(message: types.Message):
    """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ ÑĞ²Ğ¾Ñ‘Ğ¼ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğµ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ»Ğ°Ğ´ĞºĞ¸"""
    user_id = message.from_user.id

    info = []
    info.append("ğŸ‘¤ *Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ± Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğµ*\n")
    info.append(f"User ID: `{user_id}`\n")

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ users
    if user_id in users:
        user_data = users[user_id]
        info.append("âœ… ĞĞ°Ğ¹Ğ´ĞµĞ½ Ğ² Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸ (users)")
        info.append(f"   Ğ Ğ¾Ğ»ÑŒ: {user_data.get('role', 'Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}")
        info.append(f"   Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: {user_data.get('phone', 'Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}")
        info.append(f"   Ğ ĞµĞ³Ğ¸Ğ¾Ğ½: {user_data.get('region', 'Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n")
    else:
        info.append("âŒ ĞĞµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ Ğ² Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸ (users)\n")

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ batches
    if user_id in batches:
        batch_count = len(batches[user_id])
        info.append(f"ğŸ“¦ ĞŸĞ°Ñ€Ñ‚Ğ¸Ğ¹ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°: {batch_count}\n")

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ exporter_pulls
    if user_id in exporter_pulls:
        pull_count = len(exporter_pulls[user_id])
        info.append(f"ğŸ¯ ĞŸÑƒĞ»Ğ»Ğ¾Ğ² ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°: {pull_count}\n")

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Google Sheets
    try:  # â† ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞ«Ğ™ ĞĞ¢Ğ¡Ğ¢Ğ£ĞŸ!
        if gs and gs.spreadsheet:
            worksheet = gs.spreadsheet.worksheet("Users")
            cell = worksheet.find(str(user_id))
            if cell:
                info.append(f"âœ… ĞĞ°Ğ¹Ğ´ĞµĞ½ Ğ² Google Sheets (ÑÑ‚Ñ€Ğ¾ĞºĞ° {cell.row})")
            else:
                info.append("âŒ ĞĞµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ Ğ² Google Sheets")
        else:
            info.append("âš ï¸ Google Sheets Ğ½Ğµ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡Ñ‘Ğ½")
    except Exception as e:
        info.append(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Google Sheets: {e}")

    await message.answer("\n".join(info), parse_mode="Markdown")


# ============================================================================
# Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢Ğ˜Ğ§Ğ•Ğ¡ĞšĞ˜Ğ¥ Ğ—ĞĞ¯Ğ’ĞĞš
# ============================================================================
# -------------------- Ğ­ĞšĞ¡ĞŸĞĞ Ğ¢ĞĞ : Ğ¡ĞĞ—Ğ”ĞĞĞ˜Ğ• Ğ—ĞĞ¯Ğ’ĞšĞ˜ --------------------
@dp.message_handler(lambda m: m.text == "ğŸšš Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ", state="*")
async def create_logistics_request_start(message: types.Message, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ğ»Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ â€” Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚"""
    await state.finish()
    user_id = message.from_user.id

    if user_id not in users or users[user_id].get("role") != "exporter":
        await message.answer("âŒ Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°Ğ¼")
        return

    # --- ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞµĞ¼ ÑƒĞ½Ğ¸Ğ²ĞµÑ€ÑĞ°Ğ»ÑŒĞ½Ğ¾ Ğ´Ğ¾ÑÑ‚Ğ°Ñ‚ÑŒ Ğ¿ÑƒĞ»Ñ‹
    # Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ğ¿Ñ‹Ñ‚Ğ°ĞµĞ¼ÑÑ pulls['pulls'], ĞµÑĞ»Ğ¸ Ğ½ĞµÑ‚ â€” ÑĞ°Ğ¼ pulls
    true_pulls = None
    if (
        isinstance(pulls, dict)
        and "pulls" in pulls
        and isinstance(pulls["pulls"], dict)
    ):
        true_pulls = pulls["pulls"]
    elif isinstance(pulls, dict):
        true_pulls = pulls
    else:
        true_pulls = {}

    logging.info(f"\n{'='*50}")
    logging.info(f"USER {user_id} requested logistics")
    logging.info(f"ALL PULLS IN SYSTEM: {len(true_pulls)}")

    for pid, p in true_pulls.items():
        logging.info(
            f"  Pull #{pid}: exporter_id={p.get('exporter_id')}, status={p.get('status')}, culture={p.get('culture')}"
        )

    logging.info(f"{'='*50}\n")

    exporter_pulls = {}
    for pid, p in true_pulls.items():
        exp_id = p.get("exporter_id")
        pull_status = str(p.get("status", "")).lower().strip()
        logging.info(
            f"Checking pull {pid}: exp_id={exp_id}, user_id={user_id}, match={exp_id == user_id}, status={pull_status}"
        )
        if exp_id == user_id and pull_status not in [
            "filled",
            "Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½",
            "shipped",
            "Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½",
            "closed",
            "Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚",
        ]:
            exporter_pulls[pid] = p
            logging.info(f"  âœ… ADDED to exporter_pulls")

    logging.info(f"FOUND {len(exporter_pulls)} active pulls for user {user_id}")

    if not exporter_pulls:
        await message.answer(
            "âŒ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ¿ÑƒĞ»Ğ¾Ğ².\n\n"
            "Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ Ğ¿ÑƒĞ», Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ·Ğ°ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ.",
            reply_markup=exporter_keyboard(),
        )
        return

    keyboard = InlineKeyboardMarkup(row_width=1)
    for pull_id, pull in list(exporter_pulls.items())[:10]:
        culture = pull.get("culture", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")
        current_vol = pull.get("current_volume", 0) or 0
        btn_text = f"#{pull_id} â€¢ {culture} â€¢ {current_vol:.0f} Ñ‚"
        keyboard.add(
            InlineKeyboardButton(
                btn_text, callback_data=f"create_logistic_req:{pull_id}"
            )
        )

    await message.answer(
        "ğŸšš <b>Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ</b>\n\n"
        f"<b>ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ¿ÑƒĞ»Ğ¾Ğ²: {len(exporter_pulls)}</b>\n\n"
        "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿ÑƒĞ» Ğ´Ğ»Ñ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºĞ¸:",
        reply_markup=keyboard,
        parse_mode="HTML",
    )


@dp.callback_query_handler(
    lambda c: c.data.startswith("create_logistic_req:"), state="*"
)
async def select_pull_for_logistics(callback: types.CallbackQuery, state: FSMContext):
    """Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ¿ÑƒĞ»Ğ° Ğ´Ğ»Ñ Ğ·Ğ°ÑĞ²ĞºĞ¸"""
    try:
        pull_id = parse_callback_id(callback.data)
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    if pull_id not in pulls.get("pulls", {}):
        await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    pull = pulls["pulls"][pull_id]

    await state.update_data(
        pull_id=pull_id,
        culture=pull["culture"],
        volume=pull.get("current_volume", 0),
        port=pull.get("port", ""),
    )

    await callback.message.edit_text(
        f"ğŸšš <b>Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ</b>\n\n"
        f"<b>Ğ¨Ğ°Ğ³ 1 Ğ¸Ğ· 4</b>\n\n"
        f"ĞŸÑƒĞ»: #{pull_id} â€¢ {pull['culture']} â€¢ {pull.get('current_volume', 0):.0f} Ñ‚\n"
        f"ĞŸĞ¾Ñ€Ñ‚: {pull.get('port', '')}\n\n"
        f"ĞÑ‚ĞºÑƒĞ´Ğ° (Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½/Ğ³Ğ¾Ñ€Ğ¾Ğ´ Ğ¿Ğ¾Ğ³Ñ€ÑƒĞ·ĞºĞ¸):",
        parse_mode="HTML",
    )

    await CreateLogisticRequestStatesGroup.route_from.set()
    await callback.answer()


@dp.message_handler(state=CreateLogisticRequestStatesGroup.route_from)
async def logistics_request_from(message: types.Message, state: FSMContext):
    """ĞœĞµÑÑ‚Ğ¾ Ğ¿Ğ¾Ğ³Ñ€ÑƒĞ·ĞºĞ¸"""
    route_from = message.text.strip()
    await state.update_data(route_from=route_from)

    data = await state.get_data()

    await message.answer(
        f"ğŸšš <b>Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ</b>\n\n"
        f"<b>Ğ¨Ğ°Ğ³ 2 Ğ¸Ğ· 4</b>\n\n"
        f"ĞÑ‚ĞºÑƒĞ´Ğ°: <b>{route_from}</b>\n"
        f"ĞšÑƒĞ´Ğ°: <b>{data.get('port', '')}</b>\n\n"
        f"Ğ–ĞµĞ»Ğ°ĞµĞ¼Ğ°Ñ Ğ´Ğ°Ñ‚Ğ° Ğ¿Ğ¾Ğ³Ñ€ÑƒĞ·ĞºĞ¸ (Ğ”Ğ”.ĞœĞœ.Ğ“Ğ“Ğ“Ğ“):",
        parse_mode="HTML",
    )

    await CreateLogisticRequestStatesGroup.loading_date.set()


@dp.message_handler(state=CreateLogisticRequestStatesGroup.loading_date)
async def logistics_request_date(message: types.Message, state: FSMContext):
    """Ğ”Ğ°Ñ‚Ğ° Ğ¿Ğ¾Ğ³Ñ€ÑƒĞ·ĞºĞ¸"""
    loading_date = message.text.strip()

    if not validate_date(loading_date):
        await message.answer(
            "âŒ ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ğ´Ğ°Ñ‚Ñ‹. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ğ”Ğ”.ĞœĞœ.Ğ“Ğ“Ğ“Ğ“ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: 15.12.2025)"
        )
        return

    await state.update_data(loading_date=loading_date)

    # âœ… ĞĞĞ’Ğ«Ğ™ Ğ¨ĞĞ“: ĞĞ–Ğ˜Ğ”ĞĞ•ĞœĞĞ¯ Ğ¦Ğ•ĞĞ
    data = await state.get_data()

    await message.answer(
        f"ğŸšš <b>Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ</b>\n\n"
        f"<b>Ğ¨Ğ°Ğ³ 3 Ğ¸Ğ· 4</b>\n\n"
        f"ĞÑ‚ĞºÑƒĞ´Ğ°: <b>{data.get('route_from', '')}</b>\n"
        f"ĞšÑƒĞ´Ğ°: <b>{data.get('port', '')}</b>\n"
        f"Ğ”Ğ°Ñ‚Ğ°: <b>{loading_date}</b>\n\n"
        f"ĞĞ¶Ğ¸Ğ´Ğ°ĞµĞ¼Ğ°Ñ Ñ†ĞµĞ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸ Ğ·Ğ° Ñ‚Ğ¾Ğ½Ğ½Ñƒ (â‚½/Ñ‚):\n"
        f"<i>ĞĞ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: 500 Ğ¸Ğ»Ğ¸ 1200.5</i>",
        parse_mode="HTML",
    )

    await CreateLogisticRequestStatesGroup.desired_price.set()


@dp.message_handler(state=CreateLogisticRequestStatesGroup.desired_price)
async def logistics_request_desired_price(message: types.Message, state: FSMContext):
    """ĞĞ¶Ğ¸Ğ´Ğ°ĞµĞ¼Ğ°Ñ Ñ†ĞµĞ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸"""
    try:
        desired_price = float(message.text.replace(",", ".").replace(" ", ""))

        if desired_price <= 0:
            raise ValueError("Ğ¦ĞµĞ½Ğ° Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ 0")

        await state.update_data(desired_price=desired_price)

        await message.answer(
            "ğŸšš <b>Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ</b>\n\n"
            "<b>Ğ¨Ğ°Ğ³ 4 Ğ¸Ğ· 4</b>\n\n"
            "Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ñ‚Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ (Ğ¸Ğ»Ğ¸ /skip Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ°):",
            parse_mode="HTML",
        )

        await CreateLogisticRequestStatesGroup.notes.set()

    except (ValueError, Exception) as e:
        await message.answer(
            "âŒ ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ñ†ĞµĞ½Ñ‹. Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: 700 Ğ¸Ğ»Ğ¸ 750.5)"
        )


@dp.message_handler(
    lambda m: m.text == "/skip", state=CreateLogisticRequestStatesGroup.notes
)
@dp.message_handler(state=CreateLogisticRequestStatesGroup.notes)
async def logistics_request_finish(message: types.Message, state: FSMContext):
    """Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğµ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ·Ğ°ÑĞ²ĞºĞ¸"""
    global logistics_request_counter

    notes = "" if message.text == "/skip" else message.text.strip()
    data = await state.get_data()
    user_id = message.from_user.id

    pull_id = data["pull_id"]
    pull = pulls["pulls"][pull_id]

    logistics_request_counter += 1

    # âœ… Ğ¡ĞĞ—Ğ”ĞĞĞœ Ğ—ĞĞ¯Ğ’ĞšĞ£ Ğ¡ ĞŸĞĞ›Ğ•Ğœ desired_price
    request = {
        "id": logistics_request_counter,
        "exporter_id": user_id,
        "exporter_name": users[user_id].get("name", ""),
        "pull_id": pull_id,
        "culture": data["culture"],
        "volume": data["volume"],
        "route_from": data["route_from"],
        "route_to": data.get("port", ""),
        "loading_date": data["loading_date"],
        "desired_price": data.get("desired_price", 0),  # â† ĞĞĞ’ĞĞ•!
        "notes": notes,
        "status": "active",
        "offers_count": 0,
        "selected_offer_id": None,
        "created_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
    }

    logistics_requests[logistics_request_counter] = request
    save_logistics_requests_to_pickle()

    await state.finish()

    # âœ… ĞŸĞĞšĞĞ—Ğ«Ğ’ĞĞ•Ğœ ĞĞ–Ğ˜Ğ”ĞĞ•ĞœĞ£Ğ® Ğ¦Ğ•ĞĞ£ Ğ’ Ğ˜Ğ¢ĞĞ“Ğ•
    exporter = users[user_id]
    exporter_inn = exporter.get("inn", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
    exporter_ogrn = exporter.get("ogrn", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
    exporter_phone = exporter.get("phone", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
    exporter_email = exporter.get("email", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")

    summary = (
        f"âœ… <b>Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ #{logistics_request_counter} ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ°!</b>\n\n"
        f"ğŸ“¦ ĞŸÑƒĞ»: #{pull_id}\n"
        f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {data['culture']}\n"
        f"ğŸ“¦ ĞĞ±ÑŠĞµĞ¼: {data['volume']:.0f} Ñ‚\n"
        f"ğŸ“ ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚: {data['route_from']} â†’ {request['route_to']}\n"
        f"ğŸ“… Ğ”Ğ°Ñ‚Ğ°: {data['loading_date']}\n"
        f"ğŸ’° ĞĞ¶Ğ¸Ğ´Ğ°ĞµĞ¼Ğ°Ñ Ñ†ĞµĞ½Ğ°: <code>{data.get('desired_price', 0):,.0f}</code> â‚½/Ñ‚\n"
    )

    if notes:
        summary += f"ğŸ“ ĞŸÑ€Ğ¸Ğ¼ĞµÑ‡Ğ°Ğ½Ğ¸Ñ: {notes}\n"

    summary += (
        f"\nğŸ‘¤ ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚: {exporter.get('name', '')}\n"
        f"ğŸ“‹ Ğ˜ĞĞ: <code>{exporter_inn}</code>\n"
        f"ğŸ“‹ ĞĞ“Ğ Ğ: <code>{exporter_ogrn}</code>\n"
        f"ğŸ“ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <code>{exporter_phone}</code>\n"
        f"ğŸ“§ Email: <code>{exporter_email}</code>\n\n"
        f"ğŸ”” Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°Ñ‚ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾ Ğ²Ğ°ÑˆĞµĞ¹ Ğ·Ğ°ÑĞ²ĞºĞµ"
    )

    await message.answer(summary, parse_mode="HTML", reply_markup=exporter_keyboard())

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²
    await notify_logistics_about_new_request(request)

    logging.info(
        f"âœ… Logistics request {logistics_request_counter} created by exporter {user_id} "
        f"with desired_price {data.get('desired_price', 0)}"
    )

@dp.callback_query_handler(
    lambda c: c.data.startswith("view_logistics_req:"), state="*"
)
async def view_logistics_request_details(
    callback: types.CallbackQuery, state: FSMContext
):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°"""

    await state.finish()

    try:
        req_id = parse_callback_id(callback.data)
    except ValueError as e:
        await callback.answer(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {e}", show_alert=True)
        return

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸
    if req_id not in logistics_requests:
        await callback.answer("âŒ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    req = logistics_requests[req_id]
    user_id = callback.from_user.id

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ°Ğ»ÑÑ Ğ»Ğ¸ ÑƒĞ¶Ğµ
    already_offered = any(
        o.get("logist_id") == user_id and o.get("status") != "cancelled"
        for o in logistics_offers.values()
        if o.get("request_id") == req_id
    )

    # âœ… ĞŸĞĞ›ĞĞĞ¯ Ğ˜ĞĞ¤ĞĞ ĞœĞĞ¦Ğ˜Ğ¯ Ğ Ğ—ĞĞ¯Ğ’ĞšĞ•
    msg = f"""
ğŸ“‹ <b>Ğ—ĞĞ¯Ğ’ĞšĞ #{req_id}</b>

<b>ğŸŒ¾ Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ³Ñ€ÑƒĞ·Ğµ:</b>
ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {req.get('culture', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}
ĞĞ±ÑŠĞµĞ¼: {req.get('volume', 0):.0f} Ñ‚

<b>ğŸ“ ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸:</b>
ĞÑ‚: {req.get('route_from', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}
Ğ”Ğ¾: {req.get('route_to', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}

<b>ğŸ“… Ğ¡Ñ€Ğ¾ĞºĞ¸:</b>
Ğ”Ğ°Ñ‚Ğ° Ğ¿Ğ¾Ğ³Ñ€ÑƒĞ·ĞºĞ¸: {req.get('loading_date', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}
Ğ¡Ñ€Ğ¾Ğº Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸: {req.get('delivery_date', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}

<b>ğŸ’¼ Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°:</b>
ĞÑ‚ĞºĞ»Ğ¸ĞºĞ¾Ğ² Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¾: {req.get('offers_count', 0)}
Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: {req.get('status', 'active')}
"""

    if req.get("notes"):
        msg += f"\n<b>ğŸ“ Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾:</b>\n{req['notes']}"

    # Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ·Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸ĞºĞµ
    farmer_id = req.get("farmer_id")
    if farmer_id and farmer_id in users:
        farmer = users[farmer_id]
        msg += f"""

<b>ğŸ‘¨â€ğŸŒ¾ Ğ—Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸Ğº:</b>
Ğ˜Ğ¼Ñ: {farmer.get('name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}
Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <code>{farmer.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>
Email: <code>{farmer.get('email', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>
Ğ ĞµĞ³Ğ¸Ğ¾Ğ½: {farmer.get('region', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}
"""

    keyboard = InlineKeyboardMarkup(row_width=1)

    # ĞšĞ½Ğ¾Ğ¿ĞºĞ° Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ° (ĞµÑĞ»Ğ¸ Ğ·Ğ°ÑĞ²ĞºĞ° Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ° Ğ¸ Ğ½Ğµ Ğ±Ñ‹Ğ»Ğ¾ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ°)
    if not already_offered and req.get("status") in ["active", "has_offers"]:
        keyboard.add(
            InlineKeyboardButton(
                "âœ… ĞÑ‚ĞºĞ»Ğ¸ĞºĞ½ÑƒÑ‚ÑŒÑÑ Ğ½Ğ° Ğ·Ğ°ÑĞ²ĞºÑƒ", callback_data=f"respond_logistics:{req_id}"
            )
        )
    elif already_offered:
        keyboard.add(
            InlineKeyboardButton("âœ”ï¸ Ğ’Ñ‹ ÑƒĞ¶Ğµ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ½ÑƒĞ»Ğ¸ÑÑŒ", callback_data="noop")
        )

    # ĞšĞ½Ğ¾Ğ¿ĞºĞ° ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ğ° (ĞµÑĞ»Ğ¸ ÑÑ‚Ğ¾ Ğ½Ğµ Ğ²Ğ°ÑˆĞ° Ğ·Ğ°ÑĞ²ĞºĞ°)
    if farmer_id and farmer_id != user_id:
        keyboard.add(
            InlineKeyboardButton(
                "ğŸ“ ĞŸĞ¾Ğ·Ğ²Ğ¾Ğ½Ğ¸Ñ‚ÑŒ Ğ·Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸ĞºÑƒ",
                url=f"tel:{users.get(farmer_id, {}).get('phone', '')}",
            )
        )
        keyboard.add(
            InlineKeyboardButton(
                "ğŸ’¬ ĞĞ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒ Ğ² Telegram", url=f"tg://user?id={farmer_id}"
            )
        )

    keyboard.add(
        InlineKeyboardButton(
            "â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğº Ğ·Ğ°ÑĞ²ĞºĞ°Ğ¼", callback_data="back_to_logistics_requests"
        )
    )

    await callback.message.edit_text(msg, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("respond_logistics:"), state="*")
async def respond_to_logistics_request(
    callback: types.CallbackQuery, state: FSMContext
):
    """ĞÑ‚ĞºĞ»Ğ¸Ğº Ğ½Ğ° Ğ·Ğ°ÑĞ²ĞºÑƒ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°"""

    try:
        req_id = parse_callback_id(callback.data)
    except ValueError:
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    # âœ… Ğ”ĞĞ‘ĞĞ’Ğ›Ğ¯Ğ•Ğœ: Ğ¸Ñ‰ĞµĞ¼ Ğ² ĞĞ‘ĞĞ˜Ğ¥ Ñ…Ñ€Ğ°Ğ½Ğ¸Ğ»Ğ¸Ñ‰Ğ°Ñ…
    req = logistics_requests.get(req_id)
    req_storage = "logistics"

    if not req:
        req = shipping_requests.get(req_id)
        req_storage = "shipping"

    if not req:
        await callback.answer("âŒ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    user_id = callback.from_user.id

    # âœ… Ğ”ĞĞ‘ĞĞ’Ğ›Ğ¯Ğ•Ğœ: Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ğ½ÑƒĞ¶Ğ½Ğ¾Ğµ Ñ…Ñ€Ğ°Ğ½Ğ¸Ğ»Ğ¸Ñ‰Ğµ Ğ´Ğ»Ñ offers
    if "offers" not in req:
        req["offers"] = []

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ´ÑƒĞ±Ğ»ÑŒ
    if any(o.get("logist_id") == user_id for o in req["offers"]):
        await callback.answer("âŒ Ğ’Ñ‹ ÑƒĞ¶Ğµ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ½ÑƒĞ»Ğ¸ÑÑŒ", show_alert=True)
        return

    # Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµĞ¼ ID Ğ´Ğ»Ñ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ°
    offer_id = len(req["offers"]) + 1

    # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ¾Ñ‚ĞºĞ»Ğ¸Ğº Ğ² ÑĞ¿Ğ¸ÑĞ¾Ğº offers
    req["offers"].append(
        {
            "offer_id": offer_id,
            "request_id": req_id,
            "logist_id": user_id,
            "logist_name": users.get(user_id, {}).get("name", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾"),
            "logist_phone": users.get(user_id, {}).get("phone", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"),
            "logist_inn": users.get(user_id, {}).get("inn", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"),
            "logist_ogrn": users.get(user_id, {}).get("ogrn", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"),
            "status": "pending",
            "created_at": datetime.now().strftime("%d.%m.%Y %H:%M"),
            "message": "Ğ“Ğ¾Ñ‚Ğ¾Ğ² Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ÑŒ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºÑƒ",
        }
    )

    # Ğ£Ğ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ ÑÑ‡ĞµÑ‚Ñ‡Ğ¸Ğº Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ¾Ğ²
    req["offers_count"] = len(req["offers"])
    req["status"] = "has_offers"

    # âœ… Ğ”ĞĞ‘ĞĞ’Ğ›Ğ¯Ğ•Ğœ: Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ ĞºÑƒĞ´Ğ° ÑĞ¾Ñ…Ñ€Ğ°Ğ½ÑÑ‚ÑŒ
    if req_storage == "logistics":
        logistics_requests[req_id] = req
    else:
        shipping_requests[req_id] = req

    save_data()

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ·Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸ĞºĞ°
    farmer_id = req.get("farmer_id") or req.get(
        "user_id"
    )  # âœ… Ğ”ĞĞ‘ĞĞ’Ğ›Ğ¯Ğ•Ğœ: user_id Ğ´Ğ»Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ²
    if farmer_id:
        farmer_name = users.get(farmer_id, {}).get("name", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")
        notify_msg = f"""
âœ… <b>ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ¾Ñ‚ĞºĞ»Ğ¸Ğº Ğ½Ğ° Ğ²Ğ°ÑˆÑƒ Ğ·Ğ°ÑĞ²ĞºÑƒ!</b>


ğŸ“‹ Ğ—Ğ°ÑĞ²ĞºĞ°: #{req_id}
ğŸ‘¤ Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚: {users.get(user_id, {}).get('name', 'ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾')}
ğŸ“± Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <code>{users.get(user_id, {}).get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>


Ğ’ÑĞµĞ³Ğ¾ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ¾Ğ²: {req['offers_count']}


ğŸ“² ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ğ²ÑĞµ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ¸: /my_requests
"""
        try:
            await bot.send_message(farmer_id, notify_msg, parse_mode="HTML")
        except:
            pass

    # ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°
    msg = f"""
âœ… <b>ĞÑ‚ĞºĞ»Ğ¸Ğº Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½!</b>


ğŸ“‹ Ğ—Ğ°ÑĞ²ĞºĞ°: #{req_id}
ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {req.get('culture', 'Ğ/Ğ”')}
ğŸ“¦ ĞĞ±ÑŠĞµĞ¼: {req.get('volume', 0):.0f} Ñ‚


Ğ—Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸Ğº ÑĞ¼Ğ¾Ğ¶ĞµÑ‚ ÑĞ²ÑĞ·Ğ°Ñ‚ÑŒÑÑ Ñ Ğ²Ğ°Ğ¼Ğ¸ Ğ¿Ğ¾ Ğ½Ğ¾Ğ¼ĞµÑ€Ñƒ:
<code>{users.get(user_id, {}).get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>


â³ ĞĞ¶Ğ¸Ğ´Ğ°ĞµĞ¼ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ Ğ·Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸ĞºĞ°...
"""

    keyboard = InlineKeyboardMarkup()
    keyboard.add(
        InlineKeyboardButton(
            "â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğº Ğ·Ğ°ÑĞ²ĞºĞ°Ğ¼", callback_data="back_to_logistics_requests"
        )
    )

    await callback.message.edit_text(msg, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer("âœ… Ğ’Ğ°Ñˆ Ğ¾Ñ‚ĞºĞ»Ğ¸Ğº Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½!", show_alert=True)


@dp.message_handler(state=LogisticOfferStatesGroup.price)
async def logistics_offer_price(message: types.Message, state: FSMContext):
    """Ğ¦ĞµĞ½Ğ° Ğ·Ğ° Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºÑƒ"""
    try:
        price = float(message.text.strip().replace(",", ".").replace(" ", ""))
        if price <= 0:
            raise ValueError

        await state.update_data(price=price)

        await message.answer(
            f"ğŸ’¼ <b>ĞÑ‚ĞºĞ»Ğ¸Ğº Ğ½Ğ° Ğ·Ğ°ÑĞ²ĞºÑƒ</b>\n\n"
            f"<b>Ğ¨Ğ°Ğ³ 2 Ğ¸Ğ· 4</b>\n\n"
            f"Ğ¦ĞµĞ½Ğ°: <b>{price:,.0f} â‚½/Ñ‚</b>\n\n"
            f"Ğ¢Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ° (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: Ğ¤ÑƒÑ€Ğ° 20Ñ‚, Ğ—ĞµÑ€Ğ½Ğ¾Ğ²Ğ¾Ğ·):",
            parse_mode="HTML",
        )

        await LogisticOfferStatesGroup.vehicle_type.set()

    except ValueError:
        await message.answer("âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ°Ñ Ñ†ĞµĞ½Ğ°. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾.")


@dp.message_handler(state=LogisticOfferStatesGroup.vehicle_type)
async def logistics_offer_vehicle(message: types.Message, state: FSMContext):
    """Ğ¢Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°"""
    vehicle_type = message.text.strip()
    await state.update_data(vehicle_type=vehicle_type)

    await message.answer(
        f"ğŸ’¼ <b>ĞÑ‚ĞºĞ»Ğ¸Ğº Ğ½Ğ° Ğ·Ğ°ÑĞ²ĞºÑƒ</b>\n\n"
        f"<b>Ğ¨Ğ°Ğ³ 3 Ğ¸Ğ· 4</b>\n\n"
        f"Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚: <b>{transport}</b>\n\n"
        f"Ğ¡Ñ€Ğ¾Ğº Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸ (Ğ´Ğ½ĞµĞ¹):",
        parse_mode="HTML",
    )

    await LogisticOfferStatesGroup.delivery_date.set()


@dp.message_handler(state=LogisticOfferStatesGroup.delivery_date)
async def logistics_offer_days(message: types.Message, state: FSMContext):
    """Ğ¡Ñ€Ğ¾Ğº Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸"""
    try:
        delivery_days = int(message.text.strip())
        if delivery_days <= 0:
            raise ValueError

        await state.update_data(delivery_days=delivery_days)

        await message.answer(
            f"ğŸ’¼ <b>ĞÑ‚ĞºĞ»Ğ¸Ğº Ğ½Ğ° Ğ·Ğ°ÑĞ²ĞºÑƒ</b>\n\n"
            f"<b>Ğ¨Ğ°Ğ³ 4 Ğ¸Ğ· 4</b>\n\n"
            f"Ğ¡Ñ€Ğ¾Ğº: <b>{delivery_days} Ğ´Ğ½ĞµĞ¹</b>\n\n"
            f"Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ°Ñ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ (Ğ¸Ğ»Ğ¸ /skip):",
            parse_mode="HTML",
        )

        await LogisticOfferStatesGroup.additional_info.set()

    except ValueError:
        await message.answer("âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¹ ÑÑ€Ğ¾Ğº. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ†ĞµĞ»Ğ¾Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ Ğ´Ğ½ĞµĞ¹.")


# ============================================================================
# ğŸš› Ğ—ĞĞ’Ğ•Ğ Ğ¨Ğ•ĞĞ˜Ğ• ĞĞ¢ĞšĞ›Ğ˜ĞšĞ Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢Ğ ĞĞ Ğ—ĞĞ¯Ğ’ĞšĞ£
# ============================================================================


@dp.message_handler(
    lambda m: m.text == "/skip", state=LogisticOfferStatesGroup.additional_info
)
@dp.message_handler(state=LogisticOfferStatesGroup.additional_info)
async def logistics_offer_finish(message: types.Message, state: FSMContext):
    """Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°"""
    global logistics_offer_counter

    notes = "" if message.text == "/skip" else message.text.strip()
    data = await state.get_data()
    user_id = message.from_user.id

    req_id = data["request_id"]
    req = logistics_requests.get(req_id)

    if not req:
        await message.answer("âŒ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·.")
        await state.finish()
        return

    logistics_offer_counter += 1

    offer = {
        "id": logistics_offer_counter,
        "request_id": req_id,
        "logist_id": user_id,
        "logist_name": users[user_id].get("name", "N/A"),
        "logist_phone": users[user_id].get("phone", "N/A"),
        "logist_email": users[user_id].get("email", "N/A"),
        "price": data["price"],
        "vehicle_type": data["vehicle_type"],
        "delivery_days": data["delivery_days"],
        "notes": notes,
        "status": "pending",
        "created_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
    }

    logistics_offers[logistics_offer_counter] = offer

    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ÑÑ‡Ñ‘Ñ‚Ñ‡Ğ¸Ğº Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ¾Ğ² Ğ² Ğ·Ğ°ÑĞ²ĞºĞµ
    req["offers_count"] = req.get("offers_count", 0) + 1
    if req["status"] == "active":
        req["status"] = "has_offers"

    save_logistics_requests_to_pickle()
    save_logistics_offers_to_pickle()

    await state.finish()

    # Ğ ĞĞ¡Ğ§ĞĞ¢ Ğ˜Ğ¢ĞĞ“ĞĞ’ĞĞ™ Ğ¡Ğ£ĞœĞœĞ«
    total_price = data["price"] * req["volume"]

    # Ğ˜Ğ¢ĞĞ“ĞĞ’ĞĞ• Ğ¡ĞĞĞ‘Ğ©Ğ•ĞĞ˜Ğ• Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢Ğ£
    summary = (
        f"âœ… <b>ĞÑ‚ĞºĞ»Ğ¸Ğº Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½!</b>\n\n"
        f"ğŸ“‹ Ğ—Ğ°ÑĞ²ĞºĞ°: #{req_id}\n"
        f"ğŸŒ¾ {req['culture']} â€¢ {req['volume']:.0f} Ñ‚\n"
        f"ğŸ“ {req['route_from']} â†’ {req['route_to']}\n\n"
        f"ğŸ’° <b>Ğ’Ğ°ÑˆĞ° Ñ†ĞµĞ½Ğ°:</b> <code>{data['price']:,.0f}</code> â‚½/Ñ‚\n"
        f"ğŸ’µ <b>ĞĞ±Ñ‰Ğ°Ñ ÑÑƒĞ¼Ğ¼Ğ°:</b> <code>{total_price:,.0f}</code> â‚½\n"
        f"ğŸš› <b>Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚:</b> {data['vehicle_type']}\n"
        f"â± <b>Ğ¡Ñ€Ğ¾Ğº:</b> {data['delivery_days']} Ğ´Ğ½.\n\n"
        f"ğŸ‘¤ Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚: {users[user_id].get('name', 'N/A')}\n"
        f"â˜ï¸ <code>{users[user_id].get('phone', 'N/A')}</code>\n"
        f"ğŸ“§ <code>{users[user_id].get('email', 'N/A')}</code>\n\n"
        f"Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾ Ğ²Ğ°ÑˆĞµĞ¼ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞµ."
    )

    await message.answer(summary, parse_mode="HTML", reply_markup=logistic_keyboard())

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°
    await notify_exporter_about_offer(req, offer)

    logging.info(
        f"âœ… Logistics offer {logistics_offer_counter} created by logist {user_id}"
    )


# ============================================================================
# ğŸ”” Ğ’Ğ¡ĞŸĞĞœĞĞ“ĞĞ¢Ğ•Ğ›Ğ¬ĞĞ«Ğ• Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ˜ Ğ£Ğ’Ğ•Ğ”ĞĞœĞ›Ğ•ĞĞ˜Ğ™
# ============================================================================
async def notify_logistics_about_new_request(request):
    """Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ² Ğ¾ Ğ½Ğ¾Ğ²Ğ¾Ğ¹ Ğ·Ğ°ÑĞ²ĞºĞµ Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ"""
    logistics_users = [uid for uid, u in users.items() if u.get("role") == "logistic"]

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ .get() Ñ Ğ´ĞµÑ„Ğ¾Ğ»Ñ‚Ğ½Ñ‹Ğ¼ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸ĞµĞ¼
    desired_date = request.get("desired_date", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°")

    msg = (
        f"âœ… <b>Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ #{request['id']}</b>\n\n"
        f"ğŸ“¦ ĞŸÑƒĞ»: #{request['pull_id']}\n"
        f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {request['culture']}\n"
        f"ğŸ“Š ĞĞ±ÑŠÑ‘Ğ¼: {request['volume']:.0f} Ñ‚\n"
        f"ğŸ“ ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚: {request['route_from']} â†’ {request['route_to']}\n"
        f"ğŸ“… Ğ”Ğ°Ñ‚Ğ°: {desired_date}\n\n"  # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ
        f"ğŸ‘¤ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€: {request['exporter_name']}\n"
        f"â˜ï¸ <code>{request['exporter_phone']}</code>\n\n"
        f"ğŸ’¼ ĞÑ‚ĞºĞ»Ğ¸ĞºĞ½Ğ¸Ñ‚ĞµÑÑŒ Ñ‡ĞµÑ€ĞµĞ· Ğ¼ĞµĞ½Ñ 'ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸'"
    )

    for logist_id in logistics_users:
        try:
            await bot.send_message(logist_id, msg, parse_mode="HTML")
            logging.info(
                f"âœ… Notified logist {logist_id} about request #{request['id']}"
            )
        except Exception as e:
            logging.error(f"âŒ Error notifying logist {logist_id}: {e}")


async def notify_exporter_about_offer(request, offer):
    """Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ° Ğ¾ Ğ½Ğ¾Ğ²Ğ¾Ğ¼ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞµ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° Ğ½Ğ° Ğ·Ğ°ÑĞ²ĞºÑƒ"""
    exporter_id = request.get("exporter_id")
    total_price = offer.get("price", 0) * request.get("volume", 0)
    msg = (
        f"ğŸ’¼ <b>ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ¾Ñ‚ĞºĞ»Ğ¸Ğº Ğ½Ğ° Ğ·Ğ°ÑĞ²ĞºÑƒ #{request.get('id', '-')}</b>\n\n"
        f"ğŸ“¦ ĞŸÑƒĞ»: #{request.get('pull_id', '-')}\n"
        f"ğŸŒ¾ {request.get('culture', '-')} â€¢ {request.get('volume', 0):.0f} Ñ‚\n"
        f"ğŸ“ {request.get('route_from', '-')} â†’ {request.get('route_to', '-')}\n\n"
        f"ğŸ‘¤ <b>Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚:</b> {offer.get('logist_name', '-')}\n"
        f"â˜ï¸ <code>{offer.get('logist_phone', '-')}</code>\n"
        f"ğŸ“§ <code>{offer.get('logist_email', '-')}</code>\n\n"
        f"ğŸ’° <b>Ğ¦ĞµĞ½Ğ°:</b> <code>{offer.get('price', 0):,.0f}</code> â‚½/Ñ‚\n"
        f"ğŸ’µ <b>Ğ¡ÑƒĞ¼Ğ¼Ğ°:</b> <code>{total_price:,.0f}</code> â‚½\n"
        f"ğŸš› <b>Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚:</b> {offer.get('vehicle_type', '-')}\n"
        f"â± <b>Ğ¡Ñ€Ğ¾Ğº:</b> {offer.get('delivery_days', '-')} Ğ´Ğ½.\n\n"
        f"ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ 'ĞœĞ¾Ğ¸ Ğ·Ğ°ÑĞ²ĞºĞ¸' Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ñ€Ğ°ÑÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ"
    )

    try:
        await bot.send_message(exporter_id, msg, parse_mode="HTML")
        logging.info(
            f"âœ… Notified exporter {exporter_id} about offer #{offer.get('id', '-')}"
        )
    except Exception as e:
        logging.error(f"âŒ Error notifying exporter {exporter_id}: {e}")


# ============================================================================
# ğŸ”™ ĞĞĞ’Ğ˜Ğ“ĞĞ¦Ğ˜ĞĞĞĞ«Ğ• ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜ĞšĞ˜
# ===========================================================================
@dp.callback_query_handler(lambda c: c.data == "back_to_logistics_requests", state="*")
async def back_to_logistics_requests_handler(
    callback: types.CallbackQuery, state: FSMContext
):
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğº ÑĞ¿Ğ¸ÑĞºÑƒ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ·Ğ°ÑĞ²Ğ¾Ğº"""
    await state.finish()
    await show_active_requests(callback.message, state)
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data == "noop", state="*")
async def noop_handler(callback: types.CallbackQuery):
    """ĞŸÑƒÑÑ‚Ğ¾Ğ¹ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ğ´Ğ»Ñ ĞºĞ½Ğ¾Ğ¿Ğ¾Ğº Ğ±ĞµĞ· Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ"""
    await callback.answer()


# ====================================================================
# ĞŸĞĞ˜Ğ¡Ğš ĞŸĞ ĞšĞ£Ğ›Ğ¬Ğ¢Ğ£Ğ Ğ•
# ====================================================================
@dp.message_handler(Text(equals="ğŸ” ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğµ"), state="*")
async def start_search_by_culture(message: types.Message, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ğ»Ğ¾ Ğ¿Ğ¾Ğ¸ÑĞºĞ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ¿Ğ¾ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğµ"""

    # 1. ĞÑ‡Ğ¸Ñ‰Ğ°ĞµĞ¼ Ğ¿Ñ€ĞµĞ´Ñ‹Ğ´ÑƒÑ‰Ğ¸Ğ¹ state (ĞµÑĞ»Ğ¸ Ğ±Ñ‹Ğ»)
    await state.finish()

    # 2. Ğ¡ĞĞĞ§ĞĞ›Ğ ÑƒÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ state!
    await SearchByCulture.waiting_culture.set()

    # 3. ĞŸĞĞ¢ĞĞœ Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸
    await message.answer(
        "ğŸ” <b>ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğµ</b>\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñƒ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ¸ÑĞºĞ° Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹:",
        reply_markup=culture_keyboard(),
        parse_mode="HTML",
    )


if "logistics_cards" not in globals():
    logistics_cards = {}
if "expeditor_cards" not in globals():
    expeditor_cards = {}


@dp.message_handler(Text(equals="ğŸ“‹ ĞœĞ¾Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ°"), state="*")
async def show_my_card_menu(message: types.Message, state: FSMContext):
    """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¼ĞµĞ½Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°/ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°"""
    await state.finish()

    user_id = message.from_user.id
    if user_id not in users:
        await message.answer("âŒ Ğ’Ñ‹ Ğ½Ğµ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ /start")
        return

    user = users[user_id]
    role = user.get("role")

    if role == "logistic":
        if user_id in logistics_cards:
            card = logistics_cards[user_id]
            text = f"""
ğŸ“‹ <b>Ğ’Ğ°ÑˆĞ° ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°</b>

ğŸšš <b>ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚Ñ‹:</b> {card.get('routes', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}
ğŸ’° <b>Ğ¦ĞµĞ½Ğ° Ğ·Ğ° ĞºĞ¼:</b> {card.get('price_per_km', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')} â‚½/ĞºĞ¼
ğŸ’° <b>Ğ¦ĞµĞ½Ğ° Ğ·Ğ° Ñ‚Ğ¾Ğ½Ğ½Ñƒ:</b> {card.get('price_per_ton', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')} â‚½/Ñ‚
ğŸ“¦ <b>ĞœĞ¸Ğ½. Ğ¾Ğ±ÑŠÑ‘Ğ¼:</b> {card.get('min_volume', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')} Ñ‚
ğŸš› <b>Ğ¢Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°:</b> {card.get('transport_type', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}
ğŸ¢ <b>ĞŸĞ¾Ñ€Ñ‚Ñ‹:</b> {card.get('ports', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}
"""
            keyboard = InlineKeyboardMarkup(row_width=1)
            keyboard.add(
                InlineKeyboardButton(
                    "âœï¸ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ", callback_data="edit_logistic_card"
                ),
                InlineKeyboardButton("ğŸ—‘ Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ", callback_data="delete_logistic_card"),
            )
        else:
            text = "ğŸ“‹ Ğ£ Ğ²Ğ°Ñ ĞµÑ‰Ñ‘ Ğ½ĞµÑ‚ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸. Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ ĞµÑ‘, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°Ñ‚ÑŒ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹!"
            keyboard = InlineKeyboardMarkup()
            keyboard.add(
                InlineKeyboardButton(
                    "â• Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ", callback_data="create_logistic_card"
                )
            )

    elif role == "expeditor":
        if user_id in expeditor_cards:
            card = expeditor_cards[user_id]
            text = f"""
ğŸ“‹ <b>Ğ’Ğ°ÑˆĞ° ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°</b>

ğŸ“œ <b>Ğ£ÑĞ»ÑƒĞ³Ğ¸:</b> {card.get('services', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}
ğŸ’° <b>Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ Ğ”Ğ¢:</b> {card.get('dt_price', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')} â‚½
ğŸ¢ <b>ĞŸĞ¾Ñ€Ñ‚Ñ‹:</b> {card.get('ports', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}
â­ <b>ĞĞ¿Ñ‹Ñ‚:</b> {card.get('experience', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}
"""
            keyboard = InlineKeyboardMarkup(row_width=1)
            keyboard.add(
                InlineKeyboardButton(
                    "âœï¸ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ", callback_data="edit_expeditor_card"
                ),
                InlineKeyboardButton(
                    "ğŸ—‘ Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ", callback_data="delete_expeditor_card"
                ),
            )
        else:
            text = "ğŸ“‹ Ğ£ Ğ²Ğ°Ñ ĞµÑ‰Ñ‘ Ğ½ĞµÑ‚ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸. Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ ĞµÑ‘, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°Ñ‚ÑŒ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹!"
            keyboard = InlineKeyboardMarkup()
            keyboard.add(
                InlineKeyboardButton(
                    "â• Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ", callback_data="create_expeditor_card"
                )
            )
    else:
        await message.answer("âŒ ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°Ğ¼ Ğ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°Ğ¼")
        return

    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")


# ====================================================================
# Ğ¡ĞĞ—Ğ”ĞĞĞ˜Ğ• ĞšĞĞ Ğ¢ĞĞ§ĞšĞ˜ Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢Ğ
# ====================================================================


@dp.callback_query_handler(lambda c: c.data == "create_logistic_card", state="*")
async def start_create_logistic_card(callback: types.CallbackQuery, state: FSMContext):
    await state.finish()
    await callback.message.edit_text(
        "ğŸšš <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°</b>\n\n"
        "Ğ¨Ğ°Ğ³ 1/7\n\n"
        "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ²Ğ°ÑˆĞ¸ Ğ¼Ğ°Ñ€ÑˆÑ€ÑƒÑ‚Ñ‹ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: ĞšÑ€Ğ°ÑĞ½Ğ¾Ğ´Ğ°Ñ€-ĞĞ¾Ğ²Ğ¾Ñ€Ğ¾ÑÑĞ¸Ğ¹ÑĞº, Ğ Ğ¾ÑÑ‚Ğ¾Ğ²-ĞĞ·Ğ¾Ğ²):",
        parse_mode="HTML",
    )
    await CreateLogisticCardStates.routes.set()
    await callback.answer()


@dp.message_handler(state=CreateLogisticCardStates.routes)
async def process_logistic_routes(message: types.Message, state: FSMContext):
    await state.update_data(routes=message.text)
    await message.answer(
        "ğŸ’° Ğ¨Ğ°Ğ³ 2/7\n\nĞ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ñ†ĞµĞ½Ñƒ Ğ·Ğ° ĞºĞ¸Ğ»Ğ¾Ğ¼ĞµÑ‚Ñ€ (Ñ€ÑƒĞ±.):", parse_mode="HTML"
    )
    await CreateLogisticCardStates.price_per_km.set()


@dp.message_handler(state=CreateLogisticCardStates.price_per_km)
async def process_price_per_km(message: types.Message, state: FSMContext):
    try:
        price = float(message.text.replace(",", "."))
        await state.update_data(price_per_km=price)
        await message.answer(
            "ğŸ’° Ğ¨Ğ°Ğ³ 3/7\n\nĞ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ñ†ĞµĞ½Ñƒ Ğ·Ğ° Ñ‚Ğ¾Ğ½Ğ½Ñƒ (Ñ€ÑƒĞ±.):", parse_mode="HTML"
        )
        await CreateLogisticCardStates.price_per_ton.set()
    except ValueError:
        await message.answer("âŒ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ÑĞ½Ğ¾Ğ²Ğ°:")


@dp.message_handler(state=CreateLogisticCardStates.price_per_ton)
async def process_price_per_ton(message: types.Message, state: FSMContext):
    try:
        price = float(message.text.replace(",", "."))
        await state.update_data(price_per_ton=price)
        await message.answer(
            "ğŸ“¦ Ğ¨Ğ°Ğ³ 4/7\n\nĞ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¾Ğ±ÑŠÑ‘Ğ¼ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºĞ¸ (Ñ‚Ğ¾Ğ½Ğ½):",
            parse_mode="HTML",
        )
        await CreateLogisticCardStates.min_volume.set()
    except ValueError:
        await message.answer("âŒ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ÑĞ½Ğ¾Ğ²Ğ°:")


@dp.message_handler(state=CreateLogisticCardStates.min_volume)
async def process_min_volume(message: types.Message, state: FSMContext):
    try:
        volume = float(message.text.replace(",", "."))
        await state.update_data(min_volume=volume)
        await message.answer(
            "ğŸš› Ğ¨Ğ°Ğ³ 5/7\n\nĞ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ñ‚Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ° (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: Ğ¤ÑƒÑ€Ğ° 20Ñ‚):",
            parse_mode="HTML",
        )
        await CreateLogisticCardStates.transport_type.set()
    except ValueError:
        await message.answer("âŒ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ÑĞ½Ğ¾Ğ²Ğ°:")


@dp.message_handler(state=CreateLogisticCardStates.transport_type)
async def process_transport_type(message: types.Message, state: FSMContext):
    await state.update_data(transport_type=message.text)

    keyboard = InlineKeyboardMarkup(row_width=2)
    ports = [
        "ĞÑ€Ğ¸Ğ±",
        "ĞŸĞšĞ¤ Â«Ğ’Ğ¾Ğ»Ğ³Ğ°-ĞŸĞ¾Ñ€Ñ‚Â»",
        "ĞŸĞšĞ¤ Â«Ğ®Ğ³-Ğ¢ĞµÑ€Â»",
        "ĞŸĞĞ Â«ĞÑÑ‚Ñ€.ĞŸĞ¾Ñ€Ñ‚Â»",
        "Ğ£Ğ½Ğ¸Ğ²ĞµÑ€.ĞŸĞ¾Ñ€Ñ‚",
        "Ğ®Ğ¶.ĞŸĞ¾Ñ€Ñ‚",
        "ĞĞ³Ñ€Ğ¾Ñ„ÑƒĞ´",
        "ĞœĞ¾ÑĞ¿Ğ¾Ñ€Ñ‚",
        "Ğ¦Ğ“ĞŸ",
        "Ğ¤Ğ—Ğ¢",
        "ĞĞœĞŸ",
        "ĞÑ€Ğ¼Ğ°Ğ´Ğ°",
        "Ğ¡Ñ‚Ñ€ĞµĞ»ĞµÑ†",
        "ĞĞ»ÑŒÑ„Ğ°",
    ]

    for port in ports:
        keyboard.insert(InlineKeyboardButton(port, callback_data=f"selectport_{port}"))
    keyboard.add(InlineKeyboardButton("âœ… Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾", callback_data="ports_selected"))

    await message.answer(
        "ğŸ¢ Ğ¨Ğ°Ğ³ 6/7\n\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ñ€Ñ‚Ñ‹, Ğ² ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ñ… Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚Ğµ (Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾):",
        reply_markup=keyboard,
        parse_mode="HTML",
    )
    await CreateLogisticCardStates.ports.set()


@dp.callback_query_handler(
    lambda c: c.data.startswith("selectport_"), state=CreateLogisticCardStates.ports
)
async def toggle_port_selection(callback: types.CallbackQuery, state: FSMContext):
    port = callback.data.replace("selectport_", "")

    data = await state.get_data()
    selected_ports = data.get("selected_ports", [])

    if port in selected_ports:
        selected_ports.remove(port)
    else:
        selected_ports.append(port)

    await state.update_data(selected_ports=selected_ports)

    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ĞºĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ñƒ
    keyboard = InlineKeyboardMarkup(row_width=2)
    ports = [
        "ĞÑ€Ğ¸Ğ±",
        "ĞŸĞšĞ¤ Â«Ğ’Ğ¾Ğ»Ğ³Ğ°-ĞŸĞ¾Ñ€Ñ‚Â»",
        "ĞŸĞšĞ¤ Â«Ğ®Ğ³-Ğ¢ĞµÑ€Â»",
        "ĞŸĞĞ Â«ĞÑÑ‚Ñ€.ĞŸĞ¾Ñ€Ñ‚Â»",
        "Ğ£Ğ½Ğ¸Ğ²ĞµÑ€.ĞŸĞ¾Ñ€Ñ‚",
        "Ğ®Ğ¶.ĞŸĞ¾Ñ€Ñ‚",
        "ĞĞ³Ñ€Ğ¾Ñ„ÑƒĞ´",
        "ĞœĞ¾ÑĞ¿Ğ¾Ñ€Ñ‚",
        "Ğ¦Ğ“ĞŸ",
        "Ğ¤Ğ—Ğ¢",
        "ĞĞœĞŸ",
        "ĞÑ€Ğ¼Ğ°Ğ´Ğ°",
        "Ğ¡Ñ‚Ñ€ĞµĞ»ĞµÑ†",
        "ĞĞ»ÑŒÑ„Ğ°",
    ]
    for p in ports:
        mark = "âœ… " if p in selected_ports else ""
        keyboard.insert(
            InlineKeyboardButton(f"{mark}{p}", callback_data=f"selectport_{p}")
        )
    keyboard.add(InlineKeyboardButton("âœ… Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾", callback_data="ports_selected"))

    await callback.message.edit_reply_markup(reply_markup=keyboard)
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data == "ports_selected", state=CreateLogisticCardStates.ports
)
async def ports_selected(callback: types.CallbackQuery, state: FSMContext):
    data = await state.get_data()
    selected_ports = data.get("selected_ports", [])

    if not selected_ports:
        await callback.answer("âŒ Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ…Ğ¾Ñ‚Ñ Ğ±Ñ‹ Ğ¾Ğ´Ğ¸Ğ½ Ğ¿Ğ¾Ñ€Ñ‚", show_alert=True)
        return

    await state.update_data(ports=", ".join(selected_ports))
    await callback.message.edit_text(
        "ğŸ“ Ğ¨Ğ°Ğ³ 7/7\n\nĞ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½ÑƒÑ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ (Ğ¸Ğ»Ğ¸ Ğ½Ğ°Ğ¿Ğ¸ÑˆĞ¸Ñ‚Ğµ 'Ğ½ĞµÑ‚'):",
        parse_mode="HTML",
    )
    await CreateLogisticCardStates.additional_info.set()
    await callback.answer()


@dp.message_handler(state=CreateLogisticCardStates.additional_info)
async def save_logistic_card(message: types.Message, state: FSMContext):
    additional = message.text if message.text.lower() != "Ğ½ĞµÑ‚" else ""
    await state.update_data(additional_info=additional)

    data = await state.get_data()
    user_id = message.from_user.id

    logistics_cards[user_id] = {
        # ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸
        "user_id": user_id,
        "vehicle_type": data.get("vehicle_type", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾"),
        "capacity": data.get("capacity", 0),
        "ports": data.get("ports", []),
        "price_per_ton": data.get("price_per_ton", 0),
        "description": description,
        "transport_type": data.get("transport_type", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾"),
        # ĞœĞµÑ‚Ğ°Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸
        "status": "active",
        "created_at": datetime.now().strftime("%d.%m.%Y %H:%M"),
        "views": 0,
        # âœ… Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ (ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ğ½Ñ‹Ğµ Ğ»Ğ¸Ñ†Ğ°)
        "name": user_data.get("name", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾"),
        "user_name": user_data.get("name", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾"),
        "phone": user_data.get("phone", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"),
        "email": user_data.get("email", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"),
        # âœ… Ğ ĞµĞºĞ²Ğ¸Ğ·Ğ¸Ñ‚Ñ‹ ĞºĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ğ¸
        "company": user_data.get("company_details", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°"),
        "inn": user_data.get("inn", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"),
        "ogrn": user_data.get("ogrn", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"),
        "region": user_data.get("region", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"),
    }

    save_logistics_cards_to_pickle()

    await state.finish()
    await message.answer(
        "âœ… <b>ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ°!</b>\n\n"
        "Ğ¢ĞµĞ¿ĞµÑ€ÑŒ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ñ‹ Ğ±ÑƒĞ´ÑƒÑ‚ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°Ñ‚ÑŒ Ğ²Ğ°ÑˆÑƒ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ Ğ¿Ñ€Ğ¸ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ğ¸ Ğ¿ÑƒĞ»Ğ¾Ğ².",
        parse_mode="HTML",
    )

    logging.info(f"âœ… Logistic card created for user {user_id}")


# ====================================================================
# Ğ¡ĞĞ—Ğ”ĞĞĞ˜Ğ• ĞšĞĞ Ğ¢ĞĞ§ĞšĞ˜ Ğ­ĞšĞ¡ĞŸĞ•Ğ”Ğ˜Ğ¢ĞĞ Ğ (ĞĞĞĞ›ĞĞ“Ğ˜Ğ§ĞĞ)
# ====================================================================


@dp.callback_query_handler(lambda c: c.data == "create_expeditor_card", state="*")
async def start_create_expeditor_card(callback: types.CallbackQuery, state: FSMContext):
    await state.finish()
    await callback.message.edit_text(
        "ğŸ“œ <b>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°</b>\n\nĞ¨Ğ°Ğ³ 1/5\n\n"
        "ĞĞ¿Ğ¸ÑˆĞ¸Ñ‚Ğµ Ğ²Ğ°ÑˆĞ¸ ÑƒÑĞ»ÑƒĞ³Ğ¸ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: ĞÑ„Ğ¾Ñ€Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ”Ğ¢, Ñ‚Ğ°Ğ¼Ğ¾Ğ¶ĞµĞ½Ğ½Ğ¾Ğµ ÑĞ¾Ğ¿Ñ€Ğ¾Ğ²Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ):",
        parse_mode="HTML",
    )
    await CreateExpeditorCardStates.services.set()
    await callback.answer()


@dp.message_handler(state=CreateExpeditorCardStates.services)
async def process_expeditor_services(message: types.Message, state: FSMContext):
    await state.update_data(services=message.text)
    await message.answer(
        "ğŸ’° Ğ¨Ğ°Ğ³ 2/5\n\nĞ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ ÑÑ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ Ğ¾Ñ„Ğ¾Ñ€Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ”Ğ¢ (Ñ€ÑƒĞ±.):", parse_mode="HTML"
    )
    await CreateExpeditorCardStates.dt_price.set()


@dp.message_handler(state=CreateExpeditorCardStates.dt_price)
async def process_dt_price(message: types.Message, state: FSMContext):
    try:
        price = float(message.text.replace(",", ".").replace(" ", ""))
        await state.update_data(dt_price=price)

        keyboard = InlineKeyboardMarkup(row_width=2)
        ports = [
            "ĞÑ€Ğ¸Ğ±",
            "ĞŸĞšĞ¤ Â«Ğ’Ğ¾Ğ»Ğ³Ğ°-ĞŸĞ¾Ñ€Ñ‚Â»",
            "ĞŸĞšĞ¤ Â«Ğ®Ğ³-Ğ¢ĞµÑ€Â»",
            "ĞŸĞĞ Â«ĞÑÑ‚Ñ€.ĞŸĞ¾Ñ€Ñ‚Â»",
            "Ğ£Ğ½Ğ¸Ğ²ĞµÑ€.ĞŸĞ¾Ñ€Ñ‚",
            "Ğ®Ğ¶.ĞŸĞ¾Ñ€Ñ‚",
            "ĞĞ³Ñ€Ğ¾Ñ„ÑƒĞ´",
            "ĞœĞ¾ÑĞ¿Ğ¾Ñ€Ñ‚",
            "Ğ¦Ğ“ĞŸ",
            "Ğ¤Ğ—Ğ¢",
            "ĞĞœĞŸ",
            "ĞÑ€Ğ¼Ğ°Ğ´Ğ°",
            "Ğ¡Ñ‚Ñ€ĞµĞ»ĞµÑ†",
            "ĞĞ»ÑŒÑ„Ğ°",
        ]

        for port in ports:
            keyboard.insert(
                InlineKeyboardButton(port, callback_data=f"selectexpport_{port}")
            )
        keyboard.add(
            InlineKeyboardButton("âœ… Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾", callback_data="expeditor_ports_selected")
        )

        await message.answer(
            "ğŸ¢ Ğ¨Ğ°Ğ³ 3/5\n\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ñ€Ñ‚Ñ‹, Ğ² ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ñ… Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚Ğµ:",
            reply_markup=keyboard,
            parse_mode="HTML",
        )
        await CreateExpeditorCardStates.ports.set()
    except ValueError:
        await message.answer("âŒ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ÑĞ½Ğ¾Ğ²Ğ°:")


@dp.callback_query_handler(
    lambda c: c.data.startswith("selectexpport_"), state=CreateExpeditorCardStates.ports
)
async def toggle_expeditor_port(callback: types.CallbackQuery, state: FSMContext):
    port = callback.data.replace("selectexpport_", "")

    data = await state.get_data()
    selected_ports = data.get("selected_ports", [])

    if port in selected_ports:
        selected_ports.remove(port)
    else:
        selected_ports.append(port)

    await state.update_data(selected_ports=selected_ports)

    keyboard = InlineKeyboardMarkup(row_width=2)
    ports = [
        "ĞÑ€Ğ¸Ğ±",
        "ĞŸĞšĞ¤ Â«Ğ’Ğ¾Ğ»Ğ³Ğ°-ĞŸĞ¾Ñ€Ñ‚Â»",
        "ĞŸĞšĞ¤ Â«Ğ®Ğ³-Ğ¢ĞµÑ€Â»",
        "ĞŸĞĞ Â«ĞÑÑ‚Ñ€.ĞŸĞ¾Ñ€Ñ‚Â»",
        "Ğ£Ğ½Ğ¸Ğ²ĞµÑ€.ĞŸĞ¾Ñ€Ñ‚",
        "Ğ®Ğ¶.ĞŸĞ¾Ñ€Ñ‚",
        "ĞĞ³Ñ€Ğ¾Ñ„ÑƒĞ´",
        "ĞœĞ¾ÑĞ¿Ğ¾Ñ€Ñ‚",
        "Ğ¦Ğ“ĞŸ",
        "Ğ¤Ğ—Ğ¢",
        "ĞĞœĞŸ",
        "ĞÑ€Ğ¼Ğ°Ğ´Ğ°",
        "Ğ¡Ñ‚Ñ€ĞµĞ»ĞµÑ†",
        "ĞĞ»ÑŒÑ„Ğ°",
    ]
    for p in ports:
        mark = "âœ… " if p in selected_ports else ""
        keyboard.insert(
            InlineKeyboardButton(f"{mark}{p}", callback_data=f"selectexpport_{p}")
        )
    keyboard.add(
        InlineKeyboardButton("âœ… Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾", callback_data="expeditor_ports_selected")
    )

    await callback.message.edit_reply_markup(reply_markup=keyboard)
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data == "expeditor_ports_selected",
    state=CreateExpeditorCardStates.ports,
)
async def expeditor_ports_selected(callback: types.CallbackQuery, state: FSMContext):
    data = await state.get_data()
    selected_ports = data.get("selected_ports", [])

    if not selected_ports:
        await callback.answer("âŒ Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ…Ğ¾Ñ‚Ñ Ğ±Ñ‹ Ğ¾Ğ´Ğ¸Ğ½ Ğ¿Ğ¾Ñ€Ñ‚", show_alert=True)
        return

    await state.update_data(ports=", ".join(selected_ports))
    await callback.message.edit_text(
        "â­ Ğ¨Ğ°Ğ³ 4/5\n\nĞ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ğ²Ğ°Ñˆ Ğ¾Ğ¿Ñ‹Ñ‚ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ (Ğ»ĞµÑ‚):", parse_mode="HTML"
    )
    await CreateExpeditorCardStates.experience.set()
    await callback.answer()


@dp.message_handler(state=CreateExpeditorCardStates.experience)
async def process_expeditor_experience(message: types.Message, state: FSMContext):
    await state.update_data(experience=message.text)
    await message.answer(
        "ğŸ“ Ğ¨Ğ°Ğ³ 5/5\n\nĞ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½ÑƒÑ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ (Ğ¸Ğ»Ğ¸ 'Ğ½ĞµÑ‚'):",
        parse_mode="HTML",
    )
    await CreateExpeditorCardStates.additional_info.set()


@dp.message_handler(state=CreateExpeditorCardStates.additional_info)
async def save_expeditor_card(message: types.Message, state: FSMContext):
    additional = message.text if message.text.lower() != "Ğ½ĞµÑ‚" else ""
    await state.update_data(additional_info=additional)

    data = await state.get_data()
    user_id = message.from_user.id

    expeditor_cards[user_id] = {
        # ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸
        "user_id": user_id,
        "vehicle_type": data.get("vehicle_type", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾"),
        "capacity": data.get("capacity", 0),
        "regions": data.get("regions", []),
        "price_per_km": data.get("price_per_km", 0),
        "description": description,
        "services": data.get("services", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ñ‹"),
        "dt_price": data.get("dt_price", 0),
        # ĞœĞµÑ‚Ğ°Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸
        "status": "active",
        "created_at": datetime.now().strftime("%d.%m.%Y %H:%M"),
        "views": 0,
        # âœ… Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ (ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ğ½Ñ‹Ğµ Ğ»Ğ¸Ñ†Ğ°)
        "name": user_data.get("name", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾"),
        "user_name": user_data.get("name", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾"),
        "phone": user_data.get("phone", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"),
        "email": user_data.get("email", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"),
        # âœ… Ğ ĞµĞºĞ²Ğ¸Ğ·Ğ¸Ñ‚Ñ‹ ĞºĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ğ¸
        "company": user_data.get("company_details", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°"),
        "inn": user_data.get("inn", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"),
        "ogrn": user_data.get("ogrn", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"),
        "region": user_data.get("region", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"),
    }

    save_expeditor_cards_to_pickle()

    await state.finish()
    await message.answer(
        "âœ… <b>ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ°!</b>\n\n"
        "Ğ¢ĞµĞ¿ĞµÑ€ÑŒ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ñ‹ Ğ±ÑƒĞ´ÑƒÑ‚ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°Ñ‚ÑŒ Ğ²Ğ°ÑˆÑƒ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ Ğ¿Ñ€Ğ¸ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ğ¸ Ğ¿ÑƒĞ»Ğ¾Ğ².",
        parse_mode="HTML",
    )

    logging.info(f"âœ… Expeditor card created for user {user_id}")


# ====================================================================
# Ğ’Ğ«Ğ‘ĞĞ  Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢Ğ Ğ­ĞšĞ¡ĞŸĞĞ Ğ¢ĞĞ ĞĞœ
# ====================================================================


@dp.callback_query_handler(lambda c: c.data.startswith("select_logistic_"))
async def select_logistic_handler(callback: types.CallbackQuery):
    """Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° Ğ´Ğ»Ñ ÑĞ´ĞµĞ»ĞºĞ¸"""
    try:
        parts = callback.data.split("_")
        logistic_id = int(parts[2])
        deal_id = int(parts[3])

        if deal_id not in deals:
            await callback.answer("âŒ Ğ¡Ğ´ĞµĞ»ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
            return

        deals[deal_id]["logistic_id"] = logistic_id
        deals[deal_id]["logistic_selected_at"] = datetime.now().strftime(
            "%Y-%m-%d %H:%M:%S"
        )
        save_deals_to_pickle()

        logistic = users.get(logistic_id, {})
        inn = logistic.get("inn", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾")
        ogrn = logistic.get("ogrn", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾")
        company = logistic.get("company_details", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾")

        await callback.message.edit_text(
            f"âœ… <b>Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½!</b>\n\n"
            f"ğŸ‘¤ ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚: {logistic.get('name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n"
            f"ğŸ¢ ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ: {company}\n"
            f"ğŸ“‹ Ğ˜ĞĞ: <code>{inn}</code>\n"
            f"ğŸ“‹ ĞĞ“Ğ Ğ: <code>{ogrn}</code>\n"
            f"ğŸ“ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <code>{logistic.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}</code>\n"
            f"ğŸ“§ Email: <code>{logistic.get('email', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}</code>",
            parse_mode="HTML",
        )

        # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ñƒ
        deal = deals[deal_id]
        pull_id = deal.get("pull_id")
        pull = pulls.get(pull_id, {})

        try:
            await bot.send_message(
                logistic_id,
                f"ğŸ‰ <b>Ğ’Ğ« Ğ’Ğ«Ğ‘Ğ ĞĞĞ«!</b>\n\n"
                f"ğŸ“¦ Ğ¡Ğ´ĞµĞ»ĞºĞ° #{deal_id}\n"
                f"ğŸ¯ ĞĞ±ÑŠÑ‘Ğ¼: {pull.get('current_volume', 0)} Ñ‚\n"
                f"ğŸ¢ ĞŸĞ¾Ñ€Ñ‚: {pull.get('port', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n\n"
                f"Ğ¡Ğ²ÑĞ¶Ğ¸Ñ‚ĞµÑÑŒ Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ¼!",
                parse_mode="HTML",
            )
            logging.info(
                f"âœ… Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ {logistic_id} ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½ Ğ¾ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğµ Ğ´Ğ»Ñ ÑĞ´ĞµĞ»ĞºĞ¸ {deal_id}"
            )
        except Exception as e:
            logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞµ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ: {e}")

        logging.info(f"âœ… Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ {logistic_id} Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½ Ğ´Ğ»Ñ ÑĞ´ĞµĞ»ĞºĞ¸ {deal_id}")

    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğµ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°: {e}")
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)


# ====================================================================
# Ğ’Ğ«Ğ‘ĞĞ  Ğ­ĞšĞ¡ĞŸĞ•Ğ”Ğ˜Ğ¢ĞĞ Ğ Ğ­ĞšĞ¡ĞŸĞĞ Ğ¢ĞĞ ĞĞœ
# ====================================================================


@dp.callback_query_handler(lambda c: c.data.startswith("select_expeditor_"))
async def select_expeditor_handler(callback: types.CallbackQuery):
    try:
        parts = callback.data.split("_")
        expeditor_id = int(parts[2])
        deal_id = int(parts[3])

        if deal_id not in deals:
            await callback.answer("âŒ Ğ¡Ğ´ĞµĞ»ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
            return

        deals[deal_id]["expeditor_id"] = expeditor_id
        deals[deal_id]["expeditor_selected_at"] = datetime.now().strftime(
            "%Y-%m-%d %H:%M:%S"
        )
        save_deals_to_pickle()

        expeditor = users.get(expeditor_id, {})
        await callback.message.edit_text(
            f"âœ… <b>Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½!</b>\n\n"
            f"ğŸ“œ ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ: {expeditor.get('company', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n"
            f"ğŸ‘¤ ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚: {expeditor.get('name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n"
            f"ğŸ“ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: {expeditor.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}",
            parse_mode="HTML",
        )

        # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ñƒ
        deal = deals[deal_id]
        pull_id = deal.get("pull_id")
        pull = pulls.get(pull_id, {})

        try:
            await bot.send_message(
                expeditor_id,
                f"ğŸ‰ <b>Ğ’Ğ« Ğ’Ğ«Ğ‘Ğ ĞĞĞ«!</b>\n\n"
                f"ğŸ“¦ Ğ¡Ğ´ĞµĞ»ĞºĞ° #{deal_id}\n"
                f"ğŸ¯ ĞĞ±ÑŠÑ‘Ğ¼: {pull.get('current_volume', 0)} Ñ‚\n"
                f"ğŸ¢ ĞŸĞ¾Ñ€Ñ‚: {pull.get('port', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n\n"
                f"Ğ¡Ğ²ÑĞ¶Ğ¸Ñ‚ĞµÑÑŒ Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ¼!",
                parse_mode="HTML",
            )
        except Exception as e:
            print(f"ĞÑˆĞ¸Ğ±ĞºĞ°: {e}")
            pass

        logging.info(f"âœ… Expeditor {expeditor_id} selected for deal {deal_id}")

    except Exception as e:
        logging.error(f"Error selecting expeditor: {e}")


# ============================================================================
# ĞĞ•Ğ”ĞĞ¡Ğ¢ĞĞ®Ğ©Ğ˜Ğ• ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜ĞšĞ˜ (Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ñ‹ Ğ¿Ñ€Ğ¸ Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğ¸)
# ============================================================================


@dp.callback_query_handler(lambda c: c.data == "back_to_menu", state="*")
async def back_to_menu_handler(callback: types.CallbackQuery, state: FSMContext):
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğ² Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ"""
    await state.finish()
    user_id = callback.from_user.id
    role = users.get(user_id, {}).get("role", "")

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ•: Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ get_role_keyboard
    if role == "farmer":
        await callback.message.answer(
            "ğŸŒ¾ <b>Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°</b>\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ:",
            reply_markup=get_role_keyboard("farmer"),
            parse_mode="HTML",
        )
    elif role == "exporter":
        await callback.message.answer(
            "ğŸš¢ <b>Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°</b>\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ:",
            reply_markup=get_role_keyboard("exporter"),
            parse_mode="HTML",
        )
    elif role == "logistics":
        await callback.message.answer(
            "ğŸšš <b>Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°</b>\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ:",
            reply_markup=get_role_keyboard("logistics"),
            parse_mode="HTML",
        )
    elif role == "expeditor":
        await callback.message.answer(
            "ğŸ“‹ <b>Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°</b>\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ:",
            reply_markup=get_role_keyboard("expeditor"),
            parse_mode="HTML",
        )
    else:
        await callback.message.answer("âš ï¸ Ğ Ğ¾Ğ»ÑŒ Ğ½Ğµ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ°. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ /start")

    await callback.answer()


@dp.callback_query_handler(lambda c: c.data == "cancel", state="*")
async def cancel_handler(callback: types.CallbackQuery, state: FSMContext):
    """ĞÑ‚Ğ¼ĞµĞ½Ğ° Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ"""
    await state.finish()
    await callback.message.answer("âŒ Ğ”ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾")
    await back_to_menu_handler(callback, state)
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data == "cancel_action", state="*")
async def cancel_action_handler(callback: types.CallbackQuery, state: FSMContext):
    """ĞÑ‚Ğ¼ĞµĞ½Ğ° Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ"""
    await cancel_handler(callback, state)


@dp.callback_query_handler(lambda c: c.data == "transport_type", state="*")
async def transport_type_handler(callback: types.CallbackQuery):
    """Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ñ‚Ğ¸Ğ¿Ğ° Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°"""
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("ğŸš› ĞĞ²Ñ‚Ğ¾Ğ¼Ğ¾Ğ±Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹", callback_data="transport:auto"),
        InlineKeyboardButton("ğŸš‚ Ğ–ĞµĞ»ĞµĞ·Ğ½Ğ¾Ğ´Ğ¾Ñ€Ğ¾Ğ¶Ğ½Ñ‹Ğ¹", callback_data="transport:rail"),
        InlineKeyboardButton("ğŸš¢ ĞœĞ¾Ñ€ÑĞºĞ¾Ğ¹", callback_data="transport:sea"),
        InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_menu"),
    )
    await callback.message.edit_text(
        "ğŸšš Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ‚Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°:", reply_markup=keyboard
    )
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data == "view_my_batches", state="*")
async def view_my_batches_handler(callback: types.CallbackQuery):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ¼Ğ¾Ğ¸Ñ… Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹"""
    user_id = callback.from_user.id
    user_batches = batches.get(user_id, [])

    if not user_batches:
        await callback.message.answer("ğŸ“¦ Ğ£ Ğ²Ğ°Ñ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹")
        await callback.answer()
        return

    text = "<b>ğŸ“¦ Ğ’Ğ°ÑˆĞ¸ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸:</b>\n\n"
    keyboard = InlineKeyboardMarkup(row_width=1)

    for i, batch in enumerate(user_batches[:10], 1):
        crop = batch.get("culture", "Ğ/Ğ”")
        volume = batch.get("volume", 0)
        text += f"{i}. {crop} - {volume} Ñ‚Ğ¾Ğ½Ğ½\n"
        keyboard.add(
            InlineKeyboardButton(
                f"ğŸ“¦ {crop} ({volume}Ñ‚)", callback_data=f"view_batch:{batch.get('id')}"
            )
        )

    keyboard.add(InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_menu"))

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data == "startsearch", state="*")
async def startsearch_handler(callback: types.CallbackQuery):
    """ĞĞ°Ñ‡Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ¸ÑĞº"""
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("ğŸŒ¾ ĞŸĞ¾ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğµ", callback_data="search_by_culture"),
        InlineKeyboardButton("ğŸ“ ĞŸĞ¾ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñƒ", callback_data="search_by_region"),
        InlineKeyboardButton("ğŸ’° ĞŸĞ¾ Ñ†ĞµĞ½Ğµ", callback_data="search_by:price"),
        InlineKeyboardButton("ğŸ“Š ĞŸĞ¾ Ğ¾Ğ±ÑŠÑ‘Ğ¼Ñƒ", callback_data="search_by:volume"),
        InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_menu"),
    )
    await callback.message.edit_text(
        "ğŸ” Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºÑ€Ğ¸Ñ‚ĞµÑ€Ğ¸Ğ¹ Ğ¿Ğ¾Ğ¸ÑĞºĞ°:", reply_markup=keyboard
    )
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data == "broadcast_confirm", state="*")
async def broadcast_confirm_handler(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸"""
    data = await state.get_data()
    message_text = data.get("broadcast_message")

    if not message_text:
        await callback.message.answer("âŒ Ğ¡Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾")
        await callback.answer()
        return

    # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ²ÑĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼
    sent = 0
    failed = 0

    for user_id in users.keys():
        try:
            await bot.send_message(
                user_id, f"ğŸ“¢ <b>Ğ Ğ°ÑÑÑ‹Ğ»ĞºĞ°:</b>\n\n{message_text}", parse_mode="HTML"
            )
            sent += 1
        except Exception as e:
            failed += 1
            logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸ {user_id}: {e}")

    await callback.message.answer(
        f"âœ… Ğ Ğ°ÑÑÑ‹Ğ»ĞºĞ° Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°\nğŸ“¤ ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾: {sent}\nâŒ ĞÑˆĞ¸Ğ±Ğ¾Ğº: {failed}"
    )
    await state.finish()
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data in ["exportusers", "export_users"], state="*"
)
async def export_users_unified_handler(callback: types.CallbackQuery):
    """Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ (ÑƒĞ½Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹)"""
    await export_users_handler(callback)


@dp.callback_query_handler(
    lambda c: c.data in ["exportbatches", "export_batches"], state="*"
)
async def export_batches_unified_handler(callback: types.CallbackQuery):
    """Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ (ÑƒĞ½Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹)"""
    await export_batches_handler(callback)


@dp.callback_query_handler(
    lambda c: c.data in ["exportpulls", "export_pools"], state="*"
)
async def export_pulls_unified_handler(callback: types.CallbackQuery):
    """Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ¿ÑƒĞ»Ğ¾Ğ² (ÑƒĞ½Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹)"""
    await export_pools_handler(callback)


@dp.callback_query_handler(lambda c: c.data in ["exportfull", "export_full"], state="*")
async def export_full_unified_handler(callback: types.CallbackQuery):
    """ĞŸĞ¾Ğ»Ğ½Ñ‹Ğ¹ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚ (ÑƒĞ½Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹)"""
    await export_full_handler(callback)


@dp.callback_query_handler(lambda c: c.data == "back_to_pools", state="*")
async def back_to_pools_handler(callback: types.CallbackQuery):
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğº ÑĞ¿Ğ¸ÑĞºÑƒ Ğ¿ÑƒĞ»Ğ¾Ğ²"""
    await show_pools_list(callback.message)
    await callback.answer()


# ============================================================================
# Ğ¤Ğ˜ĞĞĞ›Ğ¬ĞĞ«Ğ• ĞĞ•Ğ”ĞĞ¡Ğ¢ĞĞ®Ğ©Ğ˜Ğ• ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜ĞšĞ˜
# ============================================================================


@dp.callback_query_handler(lambda c: c.data == "admin_detailed_stats", state="*")
async def admin_detailed_stats_handler(callback: types.CallbackQuery):
    """Ğ”ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ğ°Ñ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ´Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ°"""
    if callback.from_user.id != ADMIN_ID:
        await callback.answer("ğŸš« Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½", show_alert=True)
        return

    # ĞŸĞ¾Ğ´ÑÑ‡Ñ‘Ñ‚ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸
    total_users = len(users)
    roles_count = {}
    for user in users.values():
        role = user.get("role", "unknown")
        roles_count[role] = roles_count.get(role, 0) + 1

    total_batches = sum(len(b) for b in batches.values())
    active_batches = sum(
        1
        for user_batches in batches.values()
        for batch in user_batches
        if batch.get("status") == "ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ°"
    )
    total_pulls = len(pulls)
    active_pulls = sum(1 for p in pulls.values() if p.get("status") == "active")

    text = "<b>ğŸ“Š Ğ”ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ğ°Ñ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°:</b>\n\n"
    text += f"ğŸ‘¥ <b>ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸:</b> {total_users}\n"
    for role, count in roles_count.items():
        text += f"   â€¢ {role}: {count}\n"

    text += f"\nğŸ“¦ <b>ĞŸĞ°Ñ€Ñ‚Ğ¸Ğ¸:</b>\n"
    text += f"   â€¢ Ğ’ÑĞµĞ³Ğ¾: {total_batches}\n"
    text += f"   â€¢ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ…: {active_batches}\n"

    text += f"\nğŸŒ¾ <b>ĞŸÑƒĞ»Ñ‹:</b>\n"
    text += f"   â€¢ Ğ’ÑĞµĞ³Ğ¾: {total_pulls}\n"
    text += f"   â€¢ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ…: {active_pulls}\n"

    keyboard = InlineKeyboardMarkup(row_width=1)
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ“¤ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", callback_data="admin_export_analytics"
        ),
        InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="admin"),
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data == "admin_export_analytics", state="*")
async def admin_export_analytics_handler(callback: types.CallbackQuery):
    """Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ°Ğ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ¸"""
    if callback.from_user.id != ADMIN_ID:
        await callback.answer("ğŸš« Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½", show_alert=True)
        return

    try:
        from io import StringIO
        import csv

        output = StringIO()
        writer = csv.writer(output)

        # Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº
        writer.writerow(["ĞœĞµÑ‚Ñ€Ğ¸ĞºĞ°", "Ğ—Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ"])

        # Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ
        writer.writerow(["Ğ’ÑĞµĞ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹", len(users)])
        writer.writerow(["Ğ’ÑĞµĞ³Ğ¾ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹", sum(len(b) for b in batches.values())])
        writer.writerow(["Ğ’ÑĞµĞ³Ğ¾ Ğ¿ÑƒĞ»Ğ¾Ğ²", len(pulls)])

        roles_count = {}
        for user in users.values():
            role = user.get("role", "unknown")
            roles_count[role] = roles_count.get(role, 0) + 1

        for role, count in roles_count.items():
            writer.writerow([f"ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸: {role}", count])

        output.seek(0)

        from aiogram.types import BufferedInputFile

        file = BufferedInputFile(
            output.getvalue().encode("utf-8-sig"), filename="analytics.csv"
        )

        await callback.message.answer_document(
            file, caption="ğŸ“Š ĞĞ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ° ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ°"
        )
        await callback.answer()

    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ° Ğ°Ğ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ¸: {e}")
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ°", show_alert=True)


@dp.callback_query_handler(lambda c: c.data == "admin_search_user", state="*")
async def admin_search_user_handler(callback: types.CallbackQuery):
    """ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¾Ğ¼"""
    if callback.from_user.id != ADMIN_ID:
        await callback.answer("ğŸš« Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½", show_alert=True)
        return

    await callback.message.answer(
        "ğŸ” <b>ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ</b>\n\n"
        "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¾Ğ´Ğ¸Ğ½ Ğ¸Ğ· Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ¾Ğ²:\n"
        "â€¢ Telegram ID\n"
        "â€¢ ĞĞ¾Ğ¼ĞµÑ€ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°\n"
        "â€¢ Email\n"
        "â€¢ Ğ˜ĞĞ",
        parse_mode="HTML",
    )
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("doctype_"), state="*")
async def doctype_handler(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ñ‚Ğ¸Ğ¿Ğ° Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ° (CPT, FOB, CIF, EXW)"""
    doctype = callback.data.split("_", 1)[1] if "_" in callback.data else "CPT"

    # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ñ‚Ğ¸Ğ¿ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°
    await state.update_data(doctype=doctype)

    await callback.answer(f"âœ… Ğ’Ñ‹Ğ±Ñ€Ğ°Ğ½ Ñ‚Ğ¸Ğ¿: {doctype}")

    # ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ°ĞµĞ¼ Ğ»Ğ¾Ğ³Ğ¸ĞºÑƒ Ğ² Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ¾Ñ‚ ĞºĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚Ğ°
    data = await state.get_data()

    # ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¹ ÑˆĞ°Ğ³
    keyboard = InlineKeyboardMarkup(row_width=1)
    keyboard.add(
        InlineKeyboardButton("â¡ï¸ ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ¸Ñ‚ÑŒ", callback_data="continue_shipping"),
        InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_menu"),
    )

    await callback.message.edit_text(
        f"âœ… <b>Ğ¢Ğ¸Ğ¿ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°:</b> {doctype}\n\n"
        f"ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ 'ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ¸Ñ‚ÑŒ' Ğ´Ğ»Ñ ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ³Ğ¾ ÑˆĞ°Ğ³Ğ°",
        reply_markup=keyboard,
        parse_mode="HTML",
    )


@dp.callback_query_handler(lambda c: c.data == "continue_shipping", state="*")
async def continue_shipping_handler(callback: types.CallbackQuery):
    """ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑĞ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ·Ğ°ÑĞ²ĞºĞ¸"""
    await callback.answer("âœ… ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ°ĞµĞ¼...")
    # Ğ”Ğ°Ğ»ÑŒĞ½ĞµĞ¹ÑˆĞ°Ñ Ğ»Ğ¾Ğ³Ğ¸ĞºĞ°

    keyboard.add(InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_menu"))

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢: ĞœĞĞ˜ ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


@dp.callback_query_handler(lambda c: c.data.startswith("viewoffer:"))
async def view_offer_details(callback: types.CallbackQuery):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ"""
    try:
        user_id = callback.from_user.id
        offer_id = int(callback.data.split(":")[1])

        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑÑƒÑ‰ĞµÑÑ‚Ğ²Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
        if offer_id not in logistic_offers:
            await callback.answer("âŒ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾", show_alert=True)
            return

        offer = logistic_offers[offer_id]

        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, ÑÑ‚Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°
        if offer.get("logist_id") != user_id:
            await callback.answer("âŒ Ğ­Ñ‚Ğ¾ Ğ½Ğµ Ğ²Ğ°ÑˆĞµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ", show_alert=True)
            return

        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
        request_id = offer.get("request_id")
        status = offer.get("status", "pending")
        price = offer.get("price", 0)
        vehicle_type = offer.get("vehicle_type", "?")
        delivery_date = offer.get("delivery_date", "?")
        additional_info = offer.get("additional_info", "")
        created_at = offer.get("created_at", "?")

        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸
        request = shipping_requests.get(request_id, {})
        culture = request.get("culture", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°")
        route_from = request.get("route_from", "?")
        route_to = request.get("route_to", "?")
        volume = request.get("volume", 0)

        # Ğ¡Ğ»Ğ¾Ğ²Ğ°Ñ€ÑŒ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°
        vehicles = {
            "fura": "ğŸš› Ğ¤ÑƒÑ€Ğ°",
            "railway": "ğŸš‚ Ğ–/Ğ´ Ğ²Ğ°Ğ³Ğ¾Ğ½",
            "grain": "ğŸšš Ğ—ĞµÑ€Ğ½Ğ¾Ğ²Ğ¾Ğ·",
        }

        # Ğ¡Ğ»Ğ¾Ğ²Ğ°Ñ€ÑŒ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ¾Ğ²
        statuses = {
            "pending": ("â³", "ĞĞ–Ğ˜Ğ”ĞĞ•Ğ¢ ĞĞ¢Ğ’Ğ•Ğ¢Ğ"),
            "accepted": ("âœ…", "ĞŸĞ Ğ˜ĞĞ¯Ğ¢Ğ"),
            "in_progress": ("ğŸšš", "Ğ’ Ğ ĞĞ‘ĞĞ¢Ğ•"),
            "rejected": ("âŒ", "ĞĞ¢ĞšĞ›ĞĞĞ•ĞĞ"),
        }

        emoji, status_text = statuses.get(status, ("â“", "ĞĞ•Ğ˜Ğ—Ğ’Ğ•Ğ¡Ğ¢ĞĞ"))

        # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‚ĞµĞºÑÑ‚
        text = f"""ğŸ“‹ <b>Ğ”Ğ•Ğ¢ĞĞ›Ğ˜ ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯ #{offer_id}</b>

{emoji} <b>Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ:</b> {status_text}

<b>â”â” Ğ—ĞĞ¯Ğ’ĞšĞ â”â”</b>
ğŸ“¦ Ğ—Ğ°ÑĞ²ĞºĞ° â„–: <b>#{request_id}</b>
ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: <b>{culture}</b>
ğŸ“Š ĞĞ±ÑŠĞµĞ¼: <b>{volume:,} Ñ‚</b>
ğŸ“ ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚: <b>{route_from} â†’ {route_to}</b>

<b>â”â” Ğ’ĞĞ¨Ğ• ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ• â”â”</b>
ğŸš› Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚: <b>{vehicles.get(vehicle_type, vehicle_type)}</b>
ğŸ’° Ğ¦ĞµĞ½Ğ°: <b>{price:,} â‚½</b>
ğŸ“… Ğ”Ğ°Ñ‚Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸: <b>{delivery_date}</b>
â° Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¾: <b>{created_at}</b>"""

        if additional_info:
            text += f"\n\n<b>â„¹ï¸ Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾:</b>\n{additional_info}"

        # ĞšĞ½Ğ¾Ğ¿ĞºĞ¸
        keyboard = InlineKeyboardMarkup()

        # ĞšĞ½Ğ¾Ğ¿ĞºĞ° Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ Ğ¾Ğ¶Ğ¸Ğ´Ğ°ÑÑ‰Ğ¸Ñ…
        if status == "pending":
            keyboard.add(
                InlineKeyboardButton(
                    "âœï¸ Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ†ĞµĞ½Ñƒ", callback_data=f"editprice:{offer_id}"
                ),
                InlineKeyboardButton(
                    "ğŸ—‘ï¸ Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ", callback_data=f"deleteoffer:{offer_id}"
                ),
            )

        keyboard.add(InlineKeyboardButton("ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_offers"))

        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
        await callback.answer()

    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ² view_offer_details: {e}")
        await callback.answer(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)}", show_alert=True)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢: ĞŸĞ ĞĞ¡ĞœĞĞ¢Ğ  Ğ”Ğ•Ğ¢ĞĞ›Ğ•Ğ™ ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


@dp.callback_query_handler(lambda c: c.data.startswith("viewoffer:"), state="*")
async def view_offer_details_callback(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ"""
    await state.finish()

    try:
        offer_id = int(callback.data.split(":")[1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
        return

    if offer_id not in logistic_offers:
        await callback.answer("âŒ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾", show_alert=True)
        return

    offer = logistic_offers[offer_id]
    request_id = offer.get("request_id")
    request = shipping_requests.get(request_id, {})

    if not request:
        await callback.answer("âŒ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    exporter_id = request.get("exporter_id")
    exporter = users.get(exporter_id, {})
    pull_id = request.get("pull_id")
    pull = pulls.get(pull_id, {})

    status = offer.get("status", "pending")
    status_text = {
        "pending": "â³ ĞĞ¶Ğ¸Ğ´Ğ°ĞµÑ‚ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ°",
        "accepted": "âœ… ĞŸÑ€Ğ¸Ğ½ÑÑ‚Ğ¾",
        "in_progress": "ğŸšš Ğ’ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğµ",
        "rejected": "âŒ ĞÑ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¾",
        "completed": "âœ”ï¸ Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¾",
        "cancelled": "ğŸš« ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾",
    }.get(status, "â“ ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")

    text = (
        f"<b>ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ:</b> {status_text}\n\n"
        f"<b>ğŸ“‹ Ğ’Ğ°ÑˆĞµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ:</b>\n"
        f"ğŸš› Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚: {offer.get('vehicle_type', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
        f"ğŸ’° Ğ¦ĞµĞ½Ğ°: {offer.get('price', 0):,} â‚½\n"
        f"ğŸ“… Ğ”Ğ°Ñ‚Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸: {offer.get('delivery_date', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}\n"
        f"ğŸ“ ĞšĞ¾Ğ¼Ğ¼ĞµĞ½Ñ‚Ğ°Ñ€Ğ¸Ğ¹: {offer.get('comment', 'ĞĞµÑ‚')}\n"
        f"ğŸ“… Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¾: {offer.get('created_at', 'Ğ/Ğ”')}\n\n"
        f"<b>ğŸ“¦ Ğ¡Ğ²ÑĞ·Ğ°Ğ½Ğ½Ğ°Ñ Ğ·Ğ°ÑĞ²ĞºĞ° #{request_id}:</b>\n"
        f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {request.get('culture', 'Ğ/Ğ”')}\n"
        f"âš–ï¸ ĞĞ±ÑŠÑ‘Ğ¼: {request.get('volume', 0):.0f} Ñ‚\n"
        f"ğŸ“ ĞÑ‚ĞºÑƒĞ´Ğ°: {request.get('route_from', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n"
        f"ğŸ“ ĞšÑƒĞ´Ğ°: {request.get('route_to', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n"
        f"ğŸ“… Ğ–ĞµĞ»Ğ°ĞµĞ¼Ğ°Ñ Ğ´Ğ°Ñ‚Ğ°: {request.get('desired_date', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}\n"
        f"ğŸš¢ ĞŸĞ¾Ñ€Ñ‚: {pull.get('port', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n\n"
        f"<b>ğŸ‘¤ Ğ—Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸Ğº (ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€):</b>\n"
        f"ğŸ¢ ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ: {exporter.get('company_name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}\n"
        f"ğŸ‘¤ Ğ˜Ğ¼Ñ: {exporter.get('name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n"
        f"ğŸ“ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <code>{exporter.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</code>\n"
        f"ğŸ“§ Email: {exporter.get('email', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
        f"ğŸ“ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½: {exporter.get('region', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}"
    )

    keyboard = InlineKeyboardMarkup(row_width=1)

    # ĞšĞ½Ğ¾Ğ¿ĞºĞ° ÑĞ²ÑĞ·Ğ°Ñ‚ÑŒÑÑ
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ“ Ğ¡Ğ²ÑĞ·Ğ°Ñ‚ÑŒÑÑ Ñ Ğ·Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸ĞºĞ¾Ğ¼", url=f"tg://user?id={exporter_id}"
        )
    )

    # ğŸš« ĞšĞĞĞŸĞšĞ ĞĞ¢ĞœĞ•ĞĞ« (Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ pending)
    if status == "pending":
        keyboard.add(
            InlineKeyboardButton(
                "ğŸš« ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ", callback_data=f"cancel_offer:{offer_id}"
            )
        )

    # Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸
    if status == "accepted":
        keyboard.add(
            InlineKeyboardButton(
                "ğŸšš ĞŸĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğº Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞµ", callback_data=f"view_delivery:{offer_id}"
            )
        )
    elif status == "rejected":
        text += f"\n\n<b>âŒ ĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ° Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ñ:</b>\n{offer.get('rejection_reason', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}"
    elif status == "cancelled":
        text += f"\n\n<b>ğŸš« ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾:</b> {offer.get('cancelled_at', 'Ğ/Ğ”')}"

    keyboard.add(
        InlineKeyboardButton(
            "ğŸ”™ Ğš ÑĞ¿Ğ¸ÑĞºÑƒ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹", callback_data="back_to_offers_list"
        )
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ĞĞ¢ĞœĞ•ĞĞ ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


@dp.callback_query_handler(lambda c: c.data.startswith("cancel_offer:"), state="*")
async def cancel_offer_handler(callback: types.CallbackQuery):
    """ĞÑ‚Ğ¼ĞµĞ½Ğ° Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ¼"""
    try:
        offer_id = int(callback.data.split(":")[1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
        return

    if offer_id not in logistic_offers:
        await callback.answer("âŒ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾", show_alert=True)
        return

    offer = logistic_offers[offer_id]

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ñ‡Ñ‚Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ ĞµÑ‰Ñ‘ Ğ² ÑÑ‚Ğ°Ñ‚ÑƒÑĞµ pending
    if offer.get("status") != "pending":
        await callback.answer(
            "âŒ ĞœĞ¾Ğ¶Ğ½Ğ¾ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ² Ğ¾Ğ¶Ğ¸Ğ´Ğ°Ğ½Ğ¸Ğ¸ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ°", show_alert=True
        )
        return

    # ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‹
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton(
            "âœ… Ğ”Ğ°, Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ", callback_data=f"confirm_cancel_offer:{offer_id}"
        ),
        InlineKeyboardButton("âŒ ĞĞµÑ‚", callback_data=f"viewoffer:{offer_id}"),
    )

    await callback.message.edit_text(
        f"ğŸš« <b>ĞÑ‚Ğ¼ĞµĞ½Ğ° Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ #{offer_id}</b>\n\n"
        f"Ğ’Ñ‹ ÑƒĞ²ĞµÑ€ĞµĞ½Ñ‹ Ñ‡Ñ‚Ğ¾ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ÑÑ‚Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ?\n"
        f"Ğ­Ñ‚Ğ¾ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ½ĞµĞ»ÑŒĞ·Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ.",
        reply_markup=keyboard,
        parse_mode="HTML",
    )
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("confirm_cancel_offer:"), state="*"
)
async def confirm_cancel_offer(callback: types.CallbackQuery):
    """ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¸ Ñ„Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‹ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ"""
    try:
        # ĞŸĞ°Ñ€ÑĞ¸Ğ¼ offer_id
        offer_id = int(callback.data.split(":")[1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", show_alert=True)
        return

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑÑƒÑ‰ĞµÑÑ‚Ğ²Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
    if offer_id not in logistic_offers:
        await callback.answer("âŒ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾", show_alert=True)
        return

    offer = logistic_offers[offer_id]
    request_id = offer.get("request_id")
    request = shipping_requests.get(request_id, {})
    exporter_id = request.get("exporter_id")

    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
    logistic_offers[offer_id]["status"] = "cancelled"
    logistic_offers[offer_id]["cancelled_at"] = datetime.now().strftime(
        "%d.%m.%Y %H:%M"
    )

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ»Ñ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ
    price = offer.get("price", 0)
    vehicle_type = offer.get("vehicle_type", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")
    delivery_date = offer.get("delivery_date", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°")

    # ğŸ“¬ Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ° Ğ¾Ğ± Ğ¾Ñ‚Ğ¼ĞµĞ½Ğµ
    if exporter_id:
        try:
            await bot.send_message(
                chat_id=exporter_id,
                text=f"""ğŸš« <b>Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ğ» Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ</b>

ğŸ“‹ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ: #{offer_id}
ğŸ“¦ Ğ—Ğ°ÑĞ²ĞºĞ°: #{request_id}
ğŸš› Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚: {vehicle_type}
ğŸ’° Ğ¦ĞµĞ½Ğ°: {price:,} â‚½
ğŸ“… Ğ”Ğ°Ñ‚Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸: {delivery_date}

Ğ’Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ñ€Ğ°ÑÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ¾Ñ‚ Ğ´Ñ€ÑƒĞ³Ğ¸Ñ… Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ².""",
                parse_mode="HTML",
            )
            logging.info(
                f"âœ… Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ñƒ {exporter_id} Ğ¾Ğ± Ğ¾Ñ‚Ğ¼ĞµĞ½Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ #{offer_id}"
            )
        except Exception as e:
            logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ñƒ: {e}")

    # âœ… ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¾Ğ± ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾Ğ¹ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğµ
    keyboard = InlineKeyboardMarkup()
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ“‹ Ğš Ğ¼Ğ¾Ğ¸Ğ¼ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸ÑĞ¼", callback_data="back_to_offers_list"
        )
    )

    await callback.message.edit_text(
        f"""âœ… <b>ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾</b>

ğŸš« ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ: #{offer_id}
â° ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾: {logistic_offers[offer_id]['cancelled_at']}
ğŸ“ Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: ĞĞ¢ĞœĞ•ĞĞ•ĞĞ

<i>Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ğ» ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ğ± Ğ¾Ñ‚Ğ¼ĞµĞ½Ğµ</i>""",
        reply_markup=keyboard,
        parse_mode="HTML",
    )

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°
    await callback.answer("âœ… ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾", show_alert=True)

    # Ğ›Ğ¾Ğ³Ğ¸Ñ€ÑƒĞµĞ¼ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ
    logging.info(f"ğŸš« ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ #{offer_id} Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ¼")


# ============================================================================
# ğŸ”™ Ğ’ĞĞ—Ğ’Ğ ĞĞ¢ Ğš Ğ¡ĞŸĞ˜Ğ¡ĞšĞ£ ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ™ - ĞŸĞĞ›ĞĞĞ¯ Ğ’Ğ•Ğ Ğ¡Ğ˜Ğ¯
# ============================================================================


@dp.callback_query_handler(lambda c: c.data == "back_to_offers_list", state="*")
async def back_to_offers_list(callback: types.CallbackQuery, state: FSMContext):
    """Ğ’ĞµÑ€Ğ½ÑƒÑ‚ÑŒÑÑ Ğº ÑĞ¿Ğ¸ÑĞºÑƒ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°"""
    await state.finish()

    user_id = callback.from_user.id

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿
    if user_id not in users or users[user_id].get("role") != "logistic":
        await callback.answer("âŒ Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½", show_alert=True)
        return

    try:
        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ²ÑĞµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°
        my_offers = {
            oid: o
            for oid, o in logistic_offers.items()
            if o.get("logist_id") == user_id
        }

        # Ğ•ÑĞ»Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹ Ğ½ĞµÑ‚
        if not my_offers:
            keyboard = InlineKeyboardMarkup()
            keyboard.add(
                InlineKeyboardButton(
                    "ğŸšš Ğš Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¼ Ğ·Ğ°ÑĞ²ĞºĞ°Ğ¼", callback_data="logistic_requests_list"
                )
            )

            await callback.message.edit_text(
                "ğŸ’¼ <b>ĞœĞ¾Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ</b>\n\n"
                "Ğ£ Ğ²Ğ°Ñ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹.\n"
                "ĞÑ‚ĞºĞ»Ğ¸ĞºĞ°Ğ¹Ñ‚ĞµÑÑŒ Ğ½Ğ° Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ² Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ğµ Â«ğŸšš ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸Â»!",
                reply_markup=keyboard,
                parse_mode="HTML",
            )
            await callback.answer()
            return

        # ĞŸĞ¾Ğ´ÑÑ‡Ñ‘Ñ‚ Ğ¿Ğ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°Ğ¼
        pending = sum(1 for o in my_offers.values() if o.get("status") == "pending")
        accepted = sum(1 for o in my_offers.values() if o.get("status") == "accepted")
        rejected = sum(1 for o in my_offers.values() if o.get("status") == "rejected")
        in_progress = sum(
            1 for o in my_offers.values() if o.get("status") == "in_progress"
        )
        completed = sum(1 for o in my_offers.values() if o.get("status") == "completed")
        cancelled = sum(1 for o in my_offers.values() if o.get("status") == "cancelled")

        text = (
            f"ğŸ’¼ <b>ĞœĞ¾Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ</b>\n\n"
            f"ğŸ“Š <b>Ğ’ÑĞµĞ³Ğ¾:</b> {len(my_offers)}\n"
            f"â³ ĞĞ¶Ğ¸Ğ´Ğ°ÑÑ‚ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ°: {pending}\n"
            f"âœ… ĞŸÑ€Ğ¸Ğ½ÑÑ‚Ñ‹: {accepted}\n"
            f"ğŸšš Ğ’ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğµ: {in_progress}\n"
            f"âœ”ï¸ Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ñ‹: {completed}\n"
            f"âŒ ĞÑ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ñ‹: {rejected}\n"
            f"ğŸš« ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½Ñ‹: {cancelled}\n\n"
            f"<b>ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ:</b>\n\n"
        )

        keyboard = InlineKeyboardMarkup(row_width=1)

        # Ğ¡Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ (Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¼Ğ¸)
        sorted_offers = sorted(
            my_offers.items(),
            key=lambda x: {
                "pending": 0,
                "accepted": 1,
                "in_progress": 2,
                "completed": 3,
                "rejected": 4,
                "cancelled": 5,
            }.get(x[1].get("status"), 6),
        )

        # ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¿ĞµÑ€Ğ²Ñ‹Ğµ 10 Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹
        for idx, (offer_id, offer) in enumerate(sorted_offers[:10], 1):
            req_id = offer.get("request_id")
            status = offer.get("status", "pending")
            price = offer.get("price", 0)
            vehicle = offer.get("vehicle_type", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")

            # Ğ­Ğ¼Ğ¾Ğ´Ğ·Ğ¸ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°
            status_emoji = {
                "pending": "â³",
                "accepted": "âœ…",
                "in_progress": "ğŸšš",
                "completed": "âœ”ï¸",
                "rejected": "âŒ",
                "cancelled": "ğŸš«",
            }.get(status, "â“")

            # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ñƒ Ğ¸Ğ· Ğ·Ğ°ÑĞ²ĞºĞ¸
            request = shipping_requests.get(req_id, {})
            culture = request.get("culture", "Ğ/Ğ”")

            text += f"{idx}. {status_emoji} <b>ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ #{offer_id}</b>\n"
            text += f"   ğŸ“‹ Ğ—Ğ°ÑĞ²ĞºĞ° #{req_id} | {culture}\n"
            text += f"   ğŸ’° {price:,} â‚½\n\n"

            # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ
            keyboard.add(
                InlineKeyboardButton(
                    f"{status_emoji} ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ #{offer_id}",
                    callback_data=f"viewoffer:{offer_id}",
                )
            )

        # Ğ•ÑĞ»Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ñ‡ĞµĞ¼ Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼
        if len(my_offers) > 10:
            text += f"<i>...Ğ¸ ĞµÑ‰Ñ‘ {len(my_offers) - 10} Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹</i>\n"

        # Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ
        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")

        await callback.answer()

    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ² back_to_offers_list: {e}", exc_info=True)
        await callback.answer(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)}", show_alert=True)


# ============================================================================
# FSM Ğ¡ĞĞ¡Ğ¢ĞĞ¯ĞĞ˜Ğ¯ Ğ”Ğ›Ğ¯ Ğ Ğ•Ğ”ĞĞšĞ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ¯ ĞšĞĞ Ğ¢ĞĞ§ĞšĞ˜
# ============================================================================


class EditCardStates(StatesGroup):
    """Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ğ´Ğ»Ñ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°"""

    vehicle_type = State()
    capacity = State()
    regions = State()
    price_per_km = State()
    description = State()


# ============================================================================
# âœï¸ ĞœĞ•ĞĞ® Ğ Ğ•Ğ”ĞĞšĞ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ¯ ĞšĞĞ Ğ¢ĞĞ§ĞšĞ˜
# ============================================================================


@dp.callback_query_handler(lambda c: c.data == "edit_logistic_card", state="*")
async def edit_logistic_card_menu(callback: types.CallbackQuery, state: FSMContext):
    """ĞœĞµĞ½Ñ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°"""
    await state.finish()

    user_id = callback.from_user.id

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸
    if user_id not in logistics_cards:
        await callback.answer("âŒ ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    card = logistics_cards[user_id]

    keyboard = InlineKeyboardMarkup(row_width=1)
    keyboard.add(
        InlineKeyboardButton(
            "ğŸš› Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ‚Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°", callback_data="edit_card_vehicle"
        ),
        InlineKeyboardButton(
            "ğŸ“¦ Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ³Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ", callback_data="edit_card_capacity"
        ),
        InlineKeyboardButton("ğŸ“ Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹", callback_data="edit_card_regions"),
        InlineKeyboardButton(
            "ğŸ’° Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ†ĞµĞ½Ñƒ (â‚½/ĞºĞ¼)", callback_data="edit_card_price"
        ),
        InlineKeyboardButton(
            "ğŸ“ Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ", callback_data="edit_card_description"
        ),
        InlineKeyboardButton("ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´ Ğº ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞµ", callback_data="back_to_card"),
    )

    await callback.message.edit_text(
        "âœï¸ <b>Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸</b>\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ‡Ñ‚Ğ¾ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ:",
        reply_markup=keyboard,
        parse_mode="HTML",
    )
    await callback.answer()


# Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°
@dp.callback_query_handler(lambda c: c.data == "edit_card_vehicle", state="*")
async def edit_card_vehicle(callback: types.CallbackQuery, state: FSMContext):
    """Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ‚Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ° Ğ² ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞµ"""
    await state.finish()

    user_id = callback.from_user.id

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğ¹ Ñ‚Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°
    current_vehicle = "Ğ½Ğµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½"
    if user_id in logistics_cards:
        current_vehicle = logistics_cards[user_id].get("vehicle_type", "Ğ½Ğµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½")

    # Ğ¡Ğ»Ğ¾Ğ²Ğ°Ñ€ÑŒ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ
    vehicle_display = {
        "fura": "ğŸš› Ğ¤ÑƒÑ€Ğ°",
        "railway": "ğŸš‚ Ğ–/Ğ´ Ğ²Ğ°Ğ³Ğ¾Ğ½",
        "grain": "ğŸšš Ğ—ĞµÑ€Ğ½Ğ¾Ğ²Ğ¾Ğ·",
    }

    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("ğŸš‚ Ğ–Ğ”", callback_data="edit_vtype_railway"),
        InlineKeyboardButton("ğŸšš Ğ—ĞµÑ€Ğ½Ğ¾Ğ²Ğ¾Ğ·", callback_data="edit_vtype_grain"),
        InlineKeyboardButton("ğŸš› Ğ¤ÑƒÑ€Ğ°", callback_data="edit_vtype_truck"),
        InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="edit_logistic_card"),
    )

    await callback.message.edit_text(
        f"ğŸš› <b>Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ñ‚Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°</b>\n\n"
        f"<i>Ğ¢ĞµĞºÑƒÑ‰Ğ¸Ğ¹:</i> <b>{vehicle_display.get(current_vehicle, current_vehicle)}</b>",
        reply_markup=keyboard,
        parse_mode="HTML",
    )
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("edit_vtype_"), state="*")
async def save_edit_vehicle(callback: types.CallbackQuery, state: FSMContext):
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ñ‚Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ° Ğ¸ Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½ÑƒÑ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ"""
    await state.finish()

    user_id = callback.from_user.id

    # Ğ˜Ğ·Ğ²Ğ»ĞµĞºĞ°ĞµĞ¼ Ñ‚Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ° Ğ¸Ğ· callback_data
    try:
        # Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚: edit_vtype_Ğ¢Ğ˜ĞŸ (Ğ³Ğ´Ğµ Ğ¢Ğ˜ĞŸ Ğ¼Ğ¾Ğ¶ĞµÑ‚ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ´Ñ‡Ñ‘Ñ€ĞºĞ¸Ğ²Ğ°Ğ½Ğ¸Ñ)
        vehicle_type = callback.data.replace("edit_vtype_", "")
    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ°Ñ€ÑĞ¸Ğ½Ğ³Ğ° callback_data: {e}")
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞµ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ°", show_alert=True)
        return

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸
    if user_id not in logistics_cards:
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    try:
        # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ ÑÑ‚Ğ°Ñ€Ñ‹Ğ¹ Ñ‚Ğ¸Ğ¿ Ğ´Ğ»Ñ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
        old_vehicle = logistics_cards[user_id].get("vehicle_type", "Ğ½Ğµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½")

        # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ñ‚Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°
        logistics_cards[user_id]["vehicle_type"] = vehicle_type
        logistics_cards[user_id]["updated_at"] = datetime.now().strftime(
            "%d.%m.%Y %H:%M:%S"
        )

        # Ğ¡Ğ»Ğ¾Ğ²Ğ°Ñ€Ğ¸ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ
        vehicle_names = {
            "fura": "ğŸš› Ğ¤ÑƒÑ€Ğ°",
            "truck": "ğŸšš Ğ“Ñ€ÑƒĞ·Ğ¾Ğ²Ğ¸Ğº",
            "wagon": "ğŸš‚ Ğ–/Ğ´ Ğ²Ğ°Ğ³Ğ¾Ğ½",
        }

        # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ¾Ğ± ÑƒÑĞ¿ĞµÑ…Ğµ
        await callback.answer("âœ… Ğ¢Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»Ñ‘Ğ½", show_alert=False)

        # ĞÑ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶Ğ°ĞµĞ¼ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½ÑƒÑ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ
        await show_card_after_edit(callback.message, user_id)

        # Ğ›Ğ¾Ğ³Ğ¸Ñ€ÑƒĞµĞ¼ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ
        logging.info(
            f"Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ {user_id} Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ¸Ğ» Ñ‚Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°: "
            f"'{old_vehicle}' â†’ '{vehicle_type}' ({vehicle_names.get(vehicle_type, 'Unknown')})"
        )

    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğ¸ Ñ‚Ğ¸Ğ¿Ğ° Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°: {e}", exc_info=True)
        await callback.answer(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)}", show_alert=True)


# Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ³Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚Ğ¸
# ============================================================================
# ğŸ“¦ Ğ˜ĞĞ˜Ğ¦Ğ˜ĞĞ¦Ğ˜Ğ¯ Ğ Ğ•Ğ”ĞĞšĞ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ¯ Ğ“Ğ Ğ£Ğ—ĞĞŸĞĞ”ĞªĞĞœĞĞĞ¡Ğ¢Ğ˜
# ============================================================================


@dp.callback_query_handler(lambda c: c.data == "edit_card_capacity", state="*")
async def edit_card_capacity(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ñ‚ÑŒ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ³Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚Ğ¸"""
    await state.finish()

    user_id = callback.from_user.id

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ Ğ³Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ
    current_capacity = "Ğ½Ğµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°"
    if user_id in logistics_cards:
        capacity_key = logistics_cards[user_id].get("capacity", "unknown")
        capacity_display = {
            "1_5": "1-5 Ñ‚Ğ¾Ğ½Ğ½",
            "5_10": "5-10 Ñ‚Ğ¾Ğ½Ğ½",
            "10_20": "10-20 Ñ‚Ğ¾Ğ½Ğ½",
            "20_plus": "20+ Ñ‚Ğ¾Ğ½Ğ½",
        }
        current_capacity = capacity_display.get(capacity_key, "Ğ½Ğµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°")

    # ĞŸÑ€ĞµĞ´Ğ»Ğ°Ğ³Ğ°ĞµĞ¼ Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹ Ğ²Ñ‹Ğ±Ğ¾Ñ€ Ñ ĞºĞ½Ğ¾Ğ¿ĞºĞ°Ğ¼Ğ¸
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("ğŸ“¦ 1-5 Ñ‚", callback_data="edit_cap_1_5"),
        InlineKeyboardButton("ğŸ“¦ 5-10 Ñ‚", callback_data="edit_cap_5_10"),
        InlineKeyboardButton("ğŸ“¦ 10-20 Ñ‚", callback_data="edit_cap_10_20"),
        InlineKeyboardButton("ğŸ“¦ 20+ Ñ‚", callback_data="edit_cap_20_plus"),
        InlineKeyboardButton("âœï¸ Ğ’Ğ²ĞµÑÑ‚Ğ¸ Ğ²Ñ€ÑƒÑ‡Ğ½ÑƒÑ", callback_data="edit_cap_custom"),
        InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="edit_logistic_card"),
    )

    text = (
        f"ğŸ“¦ <b>Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ³Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚Ğ¸</b>\n\n"
        f"<i>Ğ¢ĞµĞºÑƒÑ‰ĞµĞµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ:</i> <b>{current_capacity}</b>\n\n"
        f"<b>Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ñ Ğ¸Ğ»Ğ¸ Ğ²Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ÑĞ²Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ:</b>"
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


# ============================================================================
# ğŸ“¦ ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜Ğš Ğ’Ğ’ĞĞ”Ğ Ğ˜ Ğ¡ĞĞ¥Ğ ĞĞĞ•ĞĞ˜Ğ¯ Ğ“Ğ Ğ£Ğ—ĞĞŸĞĞ”ĞªĞĞœĞĞĞ¡Ğ¢Ğ˜
# ============================================================================


@dp.message_handler(state=EditCardStates.capacity, content_types=["text"])
async def save_edit_capacity(message: types.Message, state: FSMContext):
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ½Ğ¾Ğ²ÑƒÑ Ğ³Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ Ğ¸Ğ· Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ²Ğ²Ğ¾Ğ´Ğ°"""
    user_id = message.from_user.id
    capacity_text = message.text.strip()

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸
    if user_id not in logistics_cards:
        await message.answer(
            "âŒ <b>ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°</b>\n\n" "ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, ÑĞ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ Ğ·Ğ°Ğ½Ğ¾Ğ²Ğ¾",
            parse_mode="HTML",
        )
        await state.finish()
        return

    try:
        # ĞŸĞ°Ñ€ÑĞ¸Ğ¼ Ğ²Ğ²Ğ¾Ğ´: Ğ·Ğ°Ğ¼ĞµĞ½ÑĞµĞ¼ Ğ·Ğ°Ğ¿ÑÑ‚ÑƒÑ Ğ½Ğ° Ñ‚Ğ¾Ñ‡ĞºÑƒ
        capacity_text = capacity_text.replace(",", ".").strip()

        # ĞŸÑ‹Ñ‚Ğ°ĞµĞ¼ÑÑ ĞºĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ² float
        capacity = float(capacity_text)

        # Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ¸Ñ€ÑƒĞµĞ¼ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ
        if capacity <= 0:
            raise ValueError("Ğ—Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ¾ Ğ±Ñ‹Ñ‚ÑŒ Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¼")

        if capacity > 10000:
            raise ValueError("Ğ—Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ²ĞµĞ»Ğ¸ĞºĞ¾ (Ğ¼Ğ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ 10000 Ñ‚Ğ¾Ğ½Ğ½)")

        # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ ÑÑ‚Ğ°Ñ€Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
        old_capacity = logistics_cards[user_id].get("capacity", "Ğ½Ğµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°")

        # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ³Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ
        logistics_cards[user_id]["capacity"] = capacity
        logistics_cards[user_id]["updated_at"] = datetime.now().strftime(
            "%d.%m.%Y %H:%M:%S"
        )

        # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ñ ÑĞ¼Ğ¾Ğ´Ğ·Ğ¸
        await message.answer(
            f"âœ… <b>Ğ“Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°</b>\n\n"
            f"ğŸ“¦ <b>ĞĞ¾Ğ²Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ:</b> {capacity} Ñ‚Ğ¾Ğ½Ğ½\n"
            f"ğŸ“¦ <b>Ğ¡Ñ‚Ğ°Ñ€Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ:</b> {old_capacity}",
            parse_mode="HTML",
        )

        # Ğ›Ğ¾Ğ³Ğ¸Ñ€ÑƒĞµĞ¼ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ
        logging.info(
            f"Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ {user_id} Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ¸Ğ» Ğ³Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ: "
            f"'{old_capacity}' â†’ '{capacity}' Ñ‚Ğ¾Ğ½Ğ½"
        )

        # ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½ÑƒÑ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ
        await show_card_after_edit(message, user_id)

        await state.finish()

    except ValueError as ve:
        # ĞÑˆĞ¸Ğ±ĞºĞ° Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸
        error_msg = str(ve)

        await message.answer(
            f"âŒ <b>ĞÑˆĞ¸Ğ±ĞºĞ° Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸</b>\n\n"
            f"<i>{error_msg}</i>\n\n"
            f"<b>ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ²Ğ²Ğ¾Ğ´Ğ°:</b>\n"
            f"â€¢ <code>15</code>\n"
            f"â€¢ <code>25.5</code>\n"
            f"â€¢ <code>20,75</code>",
            parse_mode="HTML",
        )

        logging.warning(
            f"Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ {user_id} Ğ²Ğ²ĞµĞ» Ğ½ĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½ÑƒÑ Ğ³Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ: {capacity_text}"
        )

    except Exception as e:
        # ĞĞµĞ¿Ñ€ĞµĞ´Ğ²Ğ¸Ğ´ĞµĞ½Ğ½Ğ°Ñ Ğ¾ÑˆĞ¸Ğ±ĞºĞ°
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğ¸ Ğ³Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚Ğ¸: {e}", exc_info=True)

        await message.answer(
            f"âŒ <b>ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ</b>\n\n"
            f"ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ· Ğ¸Ğ»Ğ¸ Ğ²Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾\n\n"
            f"<i>ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹: 15, 25.5, 20,75</i>",
            parse_mode="HTML",
        )


# Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ¾Ğ²
# ============================================================================
# ğŸ“ Ğ˜ĞĞ˜Ğ¦Ğ˜ĞĞ¦Ğ˜Ğ¯ Ğ Ğ•Ğ”ĞĞšĞ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ¯ Ğ Ğ•Ğ“Ğ˜ĞĞĞĞ’
# ============================================================================


@dp.callback_query_handler(lambda c: c.data == "edit_card_regions", state="*")
async def edit_card_regions(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ñ‚ÑŒ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ¾Ğ² Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸"""
    await state.finish()

    user_id = callback.from_user.id

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğµ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹
    current_regions = "Ğ½Ğµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ñ‹"
    if user_id in logistics_cards:
        regions_list = logistics_cards[user_id].get("regions", [])
        if regions_list:
            current_regions = ", ".join(regions_list)

    keyboard = InlineKeyboardMarkup()
    keyboard.add(InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="edit_logistic_card"))

    text = (
        f"ğŸ“ <b>Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ¾Ğ² Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸</b>\n\n"
        f"<i>Ğ¢ĞµĞºÑƒÑ‰Ğ¸Ğµ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹:</i> <b>{current_regions}</b>\n\n"
        f"<b>Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ñ‹Ğµ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹</b>\n"
        f"(Ğ¿ĞµÑ€ĞµÑ‡Ğ¸ÑĞ»Ğ¸Ñ‚Ğµ Ñ‡ĞµÑ€ĞµĞ· Ğ·Ğ°Ğ¿ÑÑ‚ÑƒÑ)\n\n"
        f"<b>ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹:</b>\n"
        f"â€¢ <code>ĞšÑ€Ğ°ÑĞ½Ğ¾Ğ´Ğ°Ñ€ÑĞºĞ¸Ğ¹ ĞºÑ€Ğ°Ğ¹, Ğ Ğ¾ÑÑ‚Ğ¾Ğ²ÑĞºĞ°Ñ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ</code>\n"
        f"â€¢ <code>ĞœĞ¾ÑĞºĞ¾Ğ²ÑĞºĞ°Ñ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ, Ğ¢Ğ²ĞµÑ€ÑĞºĞ°Ñ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ, ĞšĞ°Ğ»ÑƒĞ¶ÑĞºĞ°Ñ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ</code>\n"
        f"â€¢ <code>Ğ¡Ğ°Ğ½ĞºÑ‚-ĞŸĞµÑ‚ĞµÑ€Ğ±ÑƒÑ€Ğ³, Ğ›ĞµĞ½Ğ¸Ğ½Ğ³Ñ€Ğ°Ğ´ÑĞºĞ°Ñ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ</code>"
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await state.set_state(EditCardStates.regions)
    await callback.answer()


# ============================================================================
# ğŸ“ ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜Ğš Ğ’Ğ’ĞĞ”Ğ Ğ˜ Ğ¡ĞĞ¥Ğ ĞĞĞ•ĞĞ˜Ğ¯ Ğ Ğ•Ğ“Ğ˜ĞĞĞĞ’
# ============================================================================


@dp.message_handler(state=EditCardStates.regions, content_types=["text"])
async def save_edit_regions(message: types.Message, state: FSMContext):
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğµ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸"""
    user_id = message.from_user.id
    regions_text = message.text.strip()

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸
    if user_id not in logistics_cards:
        await message.answer(
            "âŒ <b>ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°</b>\n\n" "ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, ÑĞ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ Ğ·Ğ°Ğ½Ğ¾Ğ²Ğ¾",
            parse_mode="HTML",
        )
        await state.finish()
        return

    try:
        # ĞŸĞ°Ñ€ÑĞ¸Ğ¼ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹ (Ñ€Ğ°Ğ·Ğ´ĞµĞ»ĞµĞ½Ñ‹ Ğ·Ğ°Ğ¿ÑÑ‚Ñ‹Ğ¼Ğ¸)
        regions_list = [region.strip() for region in regions_text.split(",")]

        # Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ¸Ñ€ÑƒĞµĞ¼: ÑƒĞ±ĞµĞ¶Ğ´Ğ°ĞµĞ¼ÑÑ Ñ‡Ñ‚Ğ¾ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ½Ğµ Ğ¿ÑƒÑÑ‚
        regions_list = [r for r in regions_list if r]  # Ğ£Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ğ¿ÑƒÑÑ‚Ñ‹Ğµ ÑÑ‚Ñ€Ğ¾ĞºĞ¸

        if not regions_list:
            await message.answer(
                "âŒ <b>ĞÑˆĞ¸Ğ±ĞºĞ°</b>\n\n" "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ…Ğ¾Ñ‚Ñ Ğ±Ñ‹ Ğ¾Ğ´Ğ¸Ğ½ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½", parse_mode="HTML"
            )
            return

        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ¾Ğ²
        if len(regions_list) > 20:
            await message.answer(
                f"âŒ <b>Ğ¡Ğ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ¼Ğ½Ğ¾Ğ³Ğ¾ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ¾Ğ²</b>\n\n"
                f"ĞœĞ°ĞºÑĞ¸Ğ¼ÑƒĞ¼: 20 Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ¾Ğ²\n"
                f"Ğ’Ñ‹ ÑƒĞºĞ°Ğ·Ğ°Ğ»Ğ¸: {len(regions_list)}",
                parse_mode="HTML",
            )
            return

        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ´Ğ»Ğ¸Ğ½Ñƒ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ°
        for region in regions_list:
            if len(region) < 2:
                await message.answer(
                    f"âŒ <b>ĞÑˆĞ¸Ğ±ĞºĞ° Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸</b>\n\n"
                    f"ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ° ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ ĞºĞ¾Ñ€Ğ¾Ñ‚ĞºĞ¾Ğµ: <b>{region}</b>\n"
                    f"ĞœĞ¸Ğ½Ğ¸Ğ¼ÑƒĞ¼: 2 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ°",
                    parse_mode="HTML",
                )
                return

            if len(region) > 50:
                await message.answer(
                    f"âŒ <b>ĞÑˆĞ¸Ğ±ĞºĞ° Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸</b>\n\n"
                    f"ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ° ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ´Ğ»Ğ¸Ğ½Ğ½Ğ¾Ğµ: <b>{region}</b>\n"
                    f"ĞœĞ°ĞºÑĞ¸Ğ¼ÑƒĞ¼: 50 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²",
                    parse_mode="HTML",
                )
                return

        # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ ÑÑ‚Ğ°Ñ€Ñ‹Ğµ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹ Ğ´Ğ»Ñ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
        old_regions = logistics_cards[user_id].get("regions", [])

        # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹
        logistics_cards[user_id]["regions"] = regions_list
        logistics_cards[user_id]["updated_at"] = datetime.now().strftime(
            "%d.%m.%Y %H:%M:%S"
        )

        # Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ
        regions_display = "\n".join([f"â€¢ {r}" for r in regions_list])
        old_regions_display = (
            "\n".join([f"â€¢ {r}" for r in old_regions])
            if old_regions
            else "ĞĞµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ñ‹"
        )

        # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ½Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ
        text = (
            f"âœ… <b>Ğ ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ñ‹</b>\n\n"
            f"<b>ĞĞ¾Ğ²Ñ‹Ğµ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹:</b>\n{regions_display}\n\n"
            f"<b>ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ¾Ğ²:</b> {len(regions_list)}\n\n"
            f"â° ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾: <i>{logistics_cards[user_id]['updated_at']}</i>"
        )

        keyboard = InlineKeyboardMarkup()
        keyboard.add(
            InlineKeyboardButton(
                "âœï¸ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ĞµÑ‰Ñ‘", callback_data="edit_logistic_card"
            ),
            InlineKeyboardButton("ğŸ“‹ Ğš ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞµ", callback_data="refresh_card"),
        )

        await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

        logging.info(
            f"Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ {user_id} Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ¸Ğ» Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹: "
            f"'{', '.join(old_regions)}' â†’ '{', '.join(regions_list)}'"
        )

        await state.finish()

    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğ¸ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ¾Ğ²: {e}", exc_info=True)

        await message.answer(
            f"âŒ <b>ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğ¸</b>\n\n"
            f"<i>{str(e)}</i>\n\n"
            f"ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·",
            parse_mode="HTML",
        )


# Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ†ĞµĞ½Ñ‹
# ============================================================================
# ğŸ’° Ğ˜ĞĞ˜Ğ¦Ğ˜ĞĞ¦Ğ˜Ğ¯ Ğ Ğ•Ğ”ĞĞšĞ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ¯ Ğ¦Ğ•ĞĞ« Ğ—Ğ ĞšĞœ
# ============================================================================


@dp.callback_query_handler(lambda c: c.data == "edit_card_price", state="*")
async def edit_card_price(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ñ‚ÑŒ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ†ĞµĞ½Ñ‹ Ğ·Ğ° ĞºĞ¼"""
    await state.finish()

    user_id = callback.from_user.id

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ Ñ†ĞµĞ½Ñƒ
    current_price = "Ğ½Ğµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°"
    if user_id in logistics_cards:
        price = logistics_cards[user_id].get("price_per_km", None)
        if price:
            current_price = f"{price} â‚½/ĞºĞ¼"

    keyboard = InlineKeyboardMarkup()
    keyboard.add(InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="edit_logistic_card"))

    text = (
        f"ğŸ’° <b>Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ†ĞµĞ½Ñ‹ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸</b>\n\n"
        f"<i>Ğ¢ĞµĞºÑƒÑ‰Ğ°Ñ Ñ†ĞµĞ½Ğ°:</i> <b>{current_price}</b>\n\n"
        f"<b>Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²ÑƒÑ Ñ†ĞµĞ½Ñƒ Ğ·Ğ° ĞºĞ¼ (â‚½/ĞºĞ¼)</b>\n\n"
        f"<b>ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹:</b>\n"
        f"â€¢ <code>15</code> - Ñ†ĞµĞ»Ğ¾Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾\n"
        f"â€¢ <code>25.50</code> - Ñ Ğ´Ñ€Ğ¾Ğ±Ğ½Ğ¾Ğ¹ Ñ‡Ğ°ÑÑ‚ÑŒÑ\n"
        f"â€¢ <code>30,99</code> - Ñ‡ĞµÑ€ĞµĞ· Ğ·Ğ°Ğ¿ÑÑ‚ÑƒÑ\n\n"
        f"<b>ĞĞ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ñ:</b>\n"
        f"â€¢ ĞœĞ¸Ğ½Ğ¸Ğ¼ÑƒĞ¼: 0.01 â‚½/ĞºĞ¼\n"
        f"â€¢ ĞœĞ°ĞºÑĞ¸Ğ¼ÑƒĞ¼: 10000 â‚½/ĞºĞ¼"
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await state.set_state(EditCardStates.price_per_km)
    await callback.answer()


# ============================================================================
# ğŸ’³ ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜Ğš Ğ’Ğ’ĞĞ”Ğ Ğ˜ Ğ¡ĞĞ¥Ğ ĞĞĞ•ĞĞ˜Ğ¯ Ğ¦Ğ•ĞĞ«
# ============================================================================


@dp.message_handler(state=EditCardStates.price_per_km, content_types=["text"])
async def save_edit_price(message: types.Message, state: FSMContext):
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ½Ğ¾Ğ²ÑƒÑ Ñ†ĞµĞ½Ñƒ Ğ·Ğ° ĞºĞ¼"""
    user_id = message.from_user.id
    price_text = message.text.strip()

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸
    if user_id not in logistics_cards:
        await message.answer(
            "âŒ <b>ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°</b>\n\n" "ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, ÑĞ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ Ğ·Ğ°Ğ½Ğ¾Ğ²Ğ¾",
            parse_mode="HTML",
        )
        await state.finish()
        return

    try:
        # ĞŸĞ°Ñ€ÑĞ¸Ğ¼ Ñ†ĞµĞ½Ñƒ: Ğ·Ğ°Ğ¼ĞµĞ½ÑĞµĞ¼ Ğ·Ğ°Ğ¿ÑÑ‚ÑƒÑ Ğ½Ğ° Ñ‚Ğ¾Ñ‡ĞºÑƒ
        price_text = price_text.replace(",", ".").replace(" ", "").strip()

        # ĞŸÑ‹Ñ‚Ğ°ĞµĞ¼ÑÑ ĞºĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ² float
        price = float(price_text)

        # Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ¸Ñ€ÑƒĞµĞ¼ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ
        if price < 0.01:
            await message.answer(
                "âŒ <b>ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ñ†ĞµĞ½Ğ°:</b> 0.01 â‚½/ĞºĞ¼", parse_mode="HTML"
            )
            return

        if price > 10000:
            await message.answer(
                "âŒ <b>ĞœĞ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ñ†ĞµĞ½Ğ°:</b> 10000 â‚½/ĞºĞ¼", parse_mode="HTML"
            )
            return

        # ĞĞºÑ€ÑƒĞ³Ğ»ÑĞµĞ¼ Ğ´Ğ¾ 2 Ğ·Ğ½Ğ°ĞºĞ¾Ğ² Ğ¿Ğ¾ÑĞ»Ğµ Ğ·Ğ°Ğ¿ÑÑ‚Ğ¾Ğ¹
        price = round(price, 2)

        # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ ÑÑ‚Ğ°Ñ€ÑƒÑ Ñ†ĞµĞ½Ñƒ Ğ´Ğ»Ñ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
        old_price = logistics_cards[user_id].get("price_per_km", "Ğ½Ğµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°")

        # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ñ†ĞµĞ½Ñƒ
        logistics_cards[user_id]["price_per_km"] = price
        logistics_cards[user_id]["updated_at"] = datetime.now().strftime(
            "%d.%m.%Y %H:%M:%S"
        )

        # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ½Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ
        text = (
            f"âœ… <b>Ğ¦ĞµĞ½Ğ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°</b>\n\n"
            f"ğŸ’° <b>ĞĞ¾Ğ²Ğ°Ñ Ñ†ĞµĞ½Ğ°:</b> {price} â‚½/ĞºĞ¼\n"
            f"ğŸ’° <b>Ğ¡Ñ‚Ğ°Ñ€Ğ°Ñ Ñ†ĞµĞ½Ğ°:</b> {old_price}\n\n"
            f"ğŸ“Š <b>Ğ Ğ°ÑÑ‡ĞµÑ‚ Ğ·Ğ° Ğ¼Ğ°Ñ€ÑˆÑ€ÑƒÑ‚Ñ‹:</b>\n"
            f"â€¢ 100 ĞºĞ¼: {price * 100:.2f} â‚½\n"
            f"â€¢ 500 ĞºĞ¼: {price * 500:.2f} â‚½\n"
            f"â€¢ 1000 ĞºĞ¼: {price * 1000:.2f} â‚½\n\n"
            f"â° ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾: <i>{logistics_cards[user_id]['updated_at']}</i>"
        )

        keyboard = InlineKeyboardMarkup()
        keyboard.add(
            InlineKeyboardButton(
                "âœï¸ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ĞµÑ‰Ñ‘", callback_data="edit_logistic_card"
            ),
            InlineKeyboardButton("ğŸ“‹ Ğš ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞµ", callback_data="refresh_card"),
        )

        await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

        logging.info(
            f"Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ {user_id} Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ¸Ğ» Ñ†ĞµĞ½Ñƒ Ğ·Ğ° ĞºĞ¼: " f"'{old_price}' â†’ '{price}' â‚½/ĞºĞ¼"
        )

        await state.finish()

    except ValueError as ve:
        # ĞÑˆĞ¸Ğ±ĞºĞ° Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸
        await message.answer(
            "âŒ <b>ĞÑˆĞ¸Ğ±ĞºĞ° Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸</b>\n\n"
            "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾\n\n"
            "<b>ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ²Ğ²Ğ¾Ğ´Ğ°:</b>\n"
            "â€¢ <code>15</code>\n"
            "â€¢ <code>25.50</code>\n"
            "â€¢ <code>30,99</code>",
            parse_mode="HTML",
        )

        logging.warning(f"Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ {user_id} Ğ²Ğ²ĞµĞ» Ğ½ĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½ÑƒÑ Ñ†ĞµĞ½Ñƒ: {price_text}")

    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğ¸ Ñ†ĞµĞ½Ñ‹: {e}", exc_info=True)

        await message.answer(
            f"âŒ <b>ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğ¸</b>\n\n"
            f"ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ· Ğ¸Ğ»Ğ¸ Ğ²Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾",
            parse_mode="HTML",
        )


# Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ
# ============================================================================
# ğŸ“ Ğ˜ĞĞ˜Ğ¦Ğ˜ĞĞ¦Ğ˜Ğ¯ Ğ Ğ•Ğ”ĞĞšĞ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ¯ ĞĞŸĞ˜Ğ¡ĞĞĞ˜Ğ¯
# ============================================================================


@dp.callback_query_handler(lambda c: c.data == "edit_card_description", state="*")
async def edit_card_description(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ñ‚ÑŒ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ ĞºĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ğ¸"""
    await state.finish()

    user_id = callback.from_user.id

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ñ‚ĞµĞºÑƒÑ‰ĞµĞµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ
    current_description = "Ğ½Ğµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾"
    if user_id in logistics_cards:
        desc = logistics_cards[user_id].get("description", "")
        if desc:
            current_description = desc[:100] + "..." if len(desc) > 100 else desc

    keyboard = InlineKeyboardMarkup()
    keyboard.add(InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="edit_logistic_card"))

    text = (
        f"ğŸ“ <b>Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ ĞºĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ğ¸</b>\n\n"
        f"<i>Ğ¢ĞµĞºÑƒÑ‰ĞµĞµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ:</i>\n"
        f"<b>{current_description}</b>\n\n"
        f"<b>Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ğ¾Ğµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ</b>\n\n"
        f"<b>Ğ¡Ğ¾Ğ²ĞµÑ‚Ñ‹:</b>\n"
        f"âœ“ ĞĞ¿Ğ¸ÑˆĞ¸Ñ‚Ğµ ÑƒÑĞ»ÑƒĞ³Ğ¸ Ğ¸ Ğ¿Ñ€ĞµĞ¸Ğ¼ÑƒÑ‰ĞµÑÑ‚Ğ²Ğ°\n"
        f"âœ“ Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ğ¾Ğ¿Ñ‹Ñ‚ Ğ¸ Ğ´Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ñ\n"
        f"âœ“ Ğ Ğ°ÑÑĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ğ¾ Ğ²Ğ°ÑˆĞ¸Ñ… Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑÑ…\n\n"
        f"<b>ĞĞ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ñ:</b>\n"
        f"â€¢ ĞœĞ¸Ğ½Ğ¸Ğ¼ÑƒĞ¼: 10 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²\n"
        f"â€¢ ĞœĞ°ĞºÑĞ¸Ğ¼ÑƒĞ¼: 1000 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²"
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await state.set_state(EditCardStates.description)
    await callback.answer()


# ============================================================================
# ğŸ“‹ ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜Ğš Ğ’Ğ’ĞĞ”Ğ Ğ˜ Ğ¡ĞĞ¥Ğ ĞĞĞ•ĞĞ˜Ğ¯ ĞĞŸĞ˜Ğ¡ĞĞĞ˜Ğ¯
# ============================================================================


@dp.message_handler(state=EditCardStates.description, content_types=["text"])
async def save_edit_description(message: types.Message, state: FSMContext):
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ğ¾Ğµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ ĞºĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ğ¸"""
    user_id = message.from_user.id
    description_text = message.text.strip()

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸
    if user_id not in logistics_cards:
        await message.answer(
            "âŒ <b>ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°</b>\n\n" "ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, ÑĞ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ Ğ·Ğ°Ğ½Ğ¾Ğ²Ğ¾",
            parse_mode="HTML",
        )
        await state.finish()
        return

    try:
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½ÑƒÑ Ğ´Ğ»Ğ¸Ğ½Ñƒ
        if len(description_text) < 10:
            await message.answer(
                f"âŒ <b>ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ ĞºĞ¾Ñ€Ğ¾Ñ‚ĞºĞ¾Ğµ</b>\n\n"
                f"Ğ’Ğ²ĞµĞ´ĞµĞ½Ğ¾: <b>{len(description_text)}</b> ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²\n"
                f"Ğ¢Ñ€ĞµĞ±ÑƒĞµÑ‚ÑÑ: Ğ¼Ğ¸Ğ½Ğ¸Ğ¼ÑƒĞ¼ <b>10</b> ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²",
                parse_mode="HTML",
            )
            return

        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½ÑƒÑ Ğ´Ğ»Ğ¸Ğ½Ñƒ
        if len(description_text) > 1000:
            await message.answer(
                f"âŒ <b>ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ´Ğ»Ğ¸Ğ½Ğ½Ğ¾Ğµ</b>\n\n"
                f"Ğ’Ğ²ĞµĞ´ĞµĞ½Ğ¾: <b>{len(description_text)}</b> ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²\n"
                f"ĞœĞ°ĞºÑĞ¸Ğ¼ÑƒĞ¼: <b>1000</b> ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²",
                parse_mode="HTML",
            )
            return

        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ° Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰Ñ‘Ğ½Ğ½Ñ‹Ğµ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñ‹
        forbidden_chars = ["<script", "<?php", "javascript:", "onclick", "onerror"]
        description_lower = description_text.lower()

        for forbidden in forbidden_chars:
            if forbidden in description_lower:
                await message.answer(
                    "âŒ <b>ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ Ğ½ĞµĞ´Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ğ¼Ñ‹Ğµ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñ‹</b>\n\n"
                    "ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ‚ĞµĞºÑÑ‚",
                    parse_mode="HTML",
                )
                return

        # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ ÑÑ‚Ğ°Ñ€Ğ¾Ğµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ğ´Ğ»Ñ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
        old_description = logistics_cards[user_id].get("description", "Ğ½Ğµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾")

        # ĞÑ‡Ğ¸Ñ‰Ğ°ĞµĞ¼ Ğ¾Ñ‚ Ğ»Ğ¸ÑˆĞ½Ğ¸Ñ… Ğ¿Ñ€Ğ¾Ğ±ĞµĞ»Ğ¾Ğ²
        description_cleaned = " ".join(description_text.split())

        # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ
        logistics_cards[user_id]["description"] = description_cleaned
        logistics_cards[user_id]["updated_at"] = datetime.now().strftime(
            "%d.%m.%Y %H:%M:%S"
        )

        # ĞĞ±Ñ€ĞµĞ·Ğ°ĞµĞ¼ Ğ´Ğ»Ğ¸Ğ½Ğ½Ñ‹Ğµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ Ğ´Ğ»Ñ Ğ¿Ñ€ĞµĞ²ÑŒÑ
        preview_old = (
            old_description[:80] + "..."
            if len(str(old_description)) > 80
            else old_description
        )
        preview_new = (
            description_cleaned[:80] + "..."
            if len(description_cleaned) > 80
            else description_cleaned
        )

        # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ½Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ
        text = (
            f"âœ… <b>ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾</b>\n\n"
            f"<b>ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°:</b>\n"
            f"ğŸ“ Ğ¡Ğ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²: <b>{len(description_cleaned)}</b>\n"
            f"ğŸ“„ Ğ¡Ğ»Ğ¾Ğ²: <b>{len(description_cleaned.split())}</b>\n\n"
            f"<b>ĞĞ¾Ğ²Ğ¾Ğµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ:</b>\n"
            f"<i>{preview_new}</i>\n\n"
            f"â° ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾: <i>{logistics_cards[user_id]['updated_at']}</i>"
        )

        keyboard = InlineKeyboardMarkup()
        keyboard.add(
            InlineKeyboardButton(
                "âœï¸ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ĞµÑ‰Ñ‘", callback_data="edit_logistic_card"
            ),
            InlineKeyboardButton("ğŸ“‹ Ğš ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞµ", callback_data="refresh_card"),
        )

        await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

        logging.info(
            f"Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ {user_id} Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ¸Ğ» Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ: " f"'{preview_old}' â†’ '{preview_new}'"
        )

        await state.finish()

    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğ¸ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ: {e}", exc_info=True)

        await message.answer(
            f"âŒ <b>ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğ¸</b>\n\n" f"ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·",
            parse_mode="HTML",
        )


# ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ Ğ¿Ğ¾ÑĞ»Ğµ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
# ============================================================================
# ğŸ« Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ¯ ĞĞ¢ĞĞ‘Ğ ĞĞ–Ğ•ĞĞ˜Ğ¯ ĞšĞĞ Ğ¢ĞĞ§ĞšĞ˜ Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢Ğ - Ğ§Ğ˜Ğ¡Ğ¢ĞĞ¯ Ğ’Ğ•Ğ Ğ¡Ğ˜Ğ¯
# ============================================================================


async def show_card_after_edit(message: types.Message, user_id: int):
    """
    ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° - ĞºÑ€Ğ°Ñ‚ĞºĞ°Ñ Ğ²ĞµÑ€ÑĞ¸Ñ Ğ±ĞµĞ· Ğ»Ğ¸ÑˆĞ½Ğ¸Ñ… ĞºĞ½Ğ¾Ğ¿Ğ¾Ğº

    Args:
        message: ĞĞ±ÑŠĞµĞºÑ‚ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ
        user_id: ID Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    """

    if user_id not in logistics_cards:
        keyboard = InlineKeyboardMarkup()
        keyboard.add(
            InlineKeyboardButton("â• Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ", callback_data="create_logistics_card")
        )

        await message.answer(
            "âŒ ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", reply_markup=keyboard, parse_mode="HTML"
        )
        return

    card = logistics_cards[user_id]

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
    vehicle_map = {
        "fura": ("ğŸš›", "Ğ¤ÑƒÑ€Ğ°"),
        "truck": ("ğŸšš", "Ğ“Ñ€ÑƒĞ·Ğ¾Ğ²Ğ¸Ğº"),
        "wagon": ("ğŸš‚", "Ğ–/Ğ´ Ğ²Ğ°Ğ³Ğ¾Ğ½"),
    }

    vehicle_type = card.get("vehicle_type", "fura")
    emoji, vehicle_name = vehicle_map.get(vehicle_type, ("â“", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"))

    capacity = card.get("capacity", 0)
    capacity_text = f"{capacity} Ñ‚" if capacity > 0 else "â“"

    regions = ", ".join(card.get("regions", [])) if card.get("regions") else "â“"

    price = card.get("price_per_km", 0)
    price_text = f"{price:.2f} â‚½/ĞºĞ¼" if price > 0 else "â“"

    description = card.get("description", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾")

    text = (
        f"ğŸ« <b>ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°</b>\n\n"
        f"{emoji} <b>{vehicle_name}</b>\n"
        f"ğŸ“¦ {capacity_text}\n"
        f"ğŸ“ {regions}\n"
        f"ğŸ’° {price_text}\n\n"
        f"{description}\n\n"
        f"ğŸ‘ ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ¾Ğ²: {card.get('views', 0)}\n"
        f"âœ… Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¾: {card.get('completed_deals', 0)}"
    )

    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("âœï¸ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ", callback_data="edit_logistic_card"),
        InlineKeyboardButton("ğŸ—‘ Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ", callback_data="delete_logistic_card"),
    )

    try:
        if hasattr(message, "edit_text"):
            await message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
        else:
            await message.answer(text, reply_markup=keyboard, parse_mode="HTML")
    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ°: {e}")
        await message.answer(text, reply_markup=keyboard, parse_mode="HTML")


# ============================================================================
# ğŸ”™ ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜Ğš Ğ’ĞĞ—Ğ’Ğ ĞĞ¢Ğ Ğš ĞšĞĞ Ğ¢ĞĞ§ĞšĞ•
# ============================================================================


@dp.callback_query_handler(lambda c: c.data == "back_to_card", state="*")
async def back_to_card(callback: types.CallbackQuery, state: FSMContext):
    """Ğ’ĞµÑ€Ğ½ÑƒÑ‚ÑŒÑÑ Ğº ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞµ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°"""
    user_id = callback.from_user.id

    try:
        # Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞ°ĞµĞ¼ Ğ»ÑĞ±Ğ¾Ğµ Ñ‚ĞµĞºÑƒÑ‰ĞµĞµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ
        await state.finish()

        # ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ
        await show_card_after_edit(callback.message, user_id)

        # ĞÑ‚Ğ²ĞµÑ‡Ğ°ĞµĞ¼ Ğ½Ğ° callback Ğ±ĞµĞ· ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ
        await callback.answer()

        logging.info(f"Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ {user_id} Ğ²ĞµÑ€Ğ½ÑƒĞ»ÑÑ Ğº ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞµ")

    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚Ğµ Ğº ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞµ: {e}", exc_info=True)

        try:
            await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        except:
            pass


# ========== ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜ĞšĞ˜ Ğ­ĞšĞ¡ĞŸĞ•Ğ”Ğ˜Ğ¢ĞĞ Ğ ==========
@dp.message_handler(lambda m: m.text == "ğŸ“‹ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ", state="*")
async def expeditor_create_offer_handler(message: types.Message, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ñ‚ÑŒ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°"""
    await state.finish()
    user_id = message.from_user.id

    if user_id not in users or users[user_id].get("role") != "expeditor":
        await message.answer("âŒ Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½.")
        return

    await ExpeditorOfferStates.service_type.set()
    await message.answer(
        "<b>ğŸ“‹ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ</b>\n\n<b>Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ‚Ğ¸Ğ¿ ÑƒÑĞ»ÑƒĞ³Ğ¸:</b>",
        reply_markup=expeditor_service_keyboard(),
        parse_mode="HTML",
    )


@dp.callback_query_handler(
    lambda c: c.data.startswith("service:"), state=ExpeditorOfferStates.service_type
)
async def set_service_type(callback: types.CallbackQuery, state: FSMContext):
    """Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ñ‚Ğ¸Ğ¿ ÑƒÑĞ»ÑƒĞ³Ğ¸"""
    service_type = callback.data.split(":")[1]
    service_names = {
        "docs": "ğŸ“„ ĞÑ„Ğ¾Ñ€Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²",
        "customs": "ğŸ¢ Ğ¢Ğ°Ğ¼Ğ¾Ğ¶ĞµĞ½Ğ½Ğ¾Ğµ Ğ¾Ñ„Ğ¾Ñ€Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ",
        "freight": "ğŸš¢ Ğ¤Ñ€Ğ°Ñ…Ñ‚Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ",
        "full": "ğŸ“¦ ĞŸĞ¾Ğ»Ğ½Ñ‹Ğ¹ ĞºĞ¾Ğ¼Ğ¿Ğ»ĞµĞºÑ ÑƒÑĞ»ÑƒĞ³",
    }

    await state.update_data(service_type=service_names.get(service_type, service_type))
    await ExpeditorOfferStates.ports.set()

    await callback.message.edit_text(
        f"<b>ğŸ¢ Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ñ€Ñ‚Ñ‹ Ğ¾Ğ±ÑĞ»ÑƒĞ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ñ:</b>\n\n"
        f"Ğ’Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ° ÑƒÑĞ»ÑƒĞ³Ğ°: {service_names.get(service_type, service_type)}\n\n"
        f"Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ñ€Ñ‚Ñ‹ Ñ‡ĞµÑ€ĞµĞ· Ğ·Ğ°Ğ¿ÑÑ‚ÑƒÑ:\n<code>ĞĞ¾Ğ²Ğ¾Ñ€Ğ¾ÑÑĞ¸Ğ¹ÑĞº, Ğ Ğ¾ÑÑ‚Ğ¾Ğ²-Ğ½Ğ°-Ğ”Ğ¾Ğ½Ñƒ</code>",
        parse_mode="HTML",
    )
    await callback.answer()


@dp.message_handler(state=ExpeditorOfferStates.ports)
async def set_expeditor_ports(message: types.Message, state: FSMContext):
    """Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ñ€Ñ‚Ñ‹ Ğ¾Ğ±ÑĞ»ÑƒĞ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ñ"""
    ports = message.text.strip()

    if len(ports) < 3:
        await message.answer("âŒ Ğ¡Ğ»Ğ¸ÑˆĞºĞ¾Ğ¼ ĞºĞ¾Ñ€Ğ¾Ñ‚ĞºĞ¾Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾Ñ€Ñ‚Ğ¾Ğ²")
        return

    await state.update_data(ports=ports)
    await ExpeditorOfferStates.price.set()
    await message.answer(
        "<b>ğŸ’° Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ ÑÑ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ ÑƒÑĞ»ÑƒĞ³ (â‚½):</b>\n\nĞ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ†ĞµĞ½Ñƒ: <code>50000</code>",
        parse_mode="HTML",
    )


@dp.message_handler(state=ExpeditorOfferStates.price)
async def set_expeditor_price(message: types.Message, state: FSMContext):
    """Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ñ†ĞµĞ½Ñƒ ÑƒÑĞ»ÑƒĞ³Ğ¸"""
    try:
        price = float(message.text.replace(",", ".").replace(" ", ""))
        if price <= 0:
            raise ValueError
    except ValueError:
        await message.answer(
            "âŒ ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾: <code>50000</code>", parse_mode="HTML"
        )
        return

    await state.update_data(price=price)
    await ExpeditorOfferStates.terms.set()
    await message.answer(
        "<b>ğŸ“ Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ñ:</b>\n\nĞĞ¿Ğ¸ÑˆĞ¸Ñ‚Ğµ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹, ÑÑ€Ğ¾ĞºĞ¸, Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ğ¸:\n<code>Ğ¡Ñ€Ğ¾Ğº: 3-5 Ğ´Ğ½ĞµĞ¹. Ğ“Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚Ğ°.</code>",
        parse_mode="HTML",
    )


@dp.message_handler(state=ExpeditorOfferStates.terms)
async def set_expeditor_terms(message: types.Message, state: FSMContext):
    """Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ñ"""
    terms = message.text.strip()

    if len(terms) < 10:
        await message.answer("âŒ Ğ¡Ğ»Ğ¸ÑˆĞºĞ¾Ğ¼ ĞºĞ¾Ñ€Ğ¾Ñ‚ĞºĞ¾Ğµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ğ¹.")
        return

    await state.update_data(terms=terms)
    await ExpeditorOfferStates.confirm.set()

    data = await state.get_data()
    text = f"<b>âœ… ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ:</b>\n\n"
    text += f"ğŸ“‹ {data['service_type']}\n"
    text += f"ğŸ¢ {data['ports']}\n"
    text += f"ğŸ’° {data['price']:,.0f} â‚½\n"
    text += f"ğŸ“ {data['terms']}\n\nĞ’ÑÑ‘ Ğ²ĞµÑ€Ğ½Ğ¾?"

    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("âœ… ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ğ¸Ñ‚ÑŒ", callback_data="confirm_expeditor_offer"),
        InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ", callback_data="cancel"),
    )
    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")


@dp.callback_query_handler(
    lambda c: c.data == "confirm_expeditor_offer", state=ExpeditorOfferStates.confirm
)
async def confirm_expeditor_offer(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ğ¸Ñ‚ÑŒ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°"""
    data = await state.get_data()
    user_id = callback.from_user.id

    offer_id = len(expeditor_offers) + 1
    offer = {
        "id": offer_id,
        "expeditor_id": user_id,
        "service_type": data["service_type"],
        "ports": data["ports"],
        "price": data["price"],
        "terms": data["terms"],
        "status": "active",
        "created_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
    }

    expeditor_offers[offer_id] = offer
    save_expeditor_offers()

    await callback.message.edit_text(
        f"<b>âœ… ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¾!</b>\n\nĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ #{offer_id}\n"
        f"ğŸ“‹ {data['service_type']}\n"
        f"ğŸ¢ {data['ports']}\n"
        f"ğŸ’° {data['price']:,.0f} â‚½\n\n"
        f"Ğ’Ğ°ÑˆĞµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ±ÑƒĞ´ĞµÑ‚ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶Ğ°Ñ‚ÑŒÑÑ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°Ğ¼.",
        parse_mode="HTML",
    )
    await state.finish()
    await callback.answer()


@dp.message_handler(
    lambda m: m.text == "ğŸ’¼ ĞœĞ¾Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ"
    and users.get(m.from_user.id, {}).get("role") == "expeditor",
    state="*",
)
async def expeditor_my_offers_handler(message: types.Message, state: FSMContext):
    """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°"""
    await state.finish()
    user_id = message.from_user.id

    my_offers = {
        oid: o
        for oid, o in expeditor_offers.items()
        if o.get("expeditor_id") == user_id
    }

    if not my_offers:
        await message.answer(
            "<b>ğŸ’¼ ĞœĞ¾Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ</b>\n\nĞ£ Ğ²Ğ°Ñ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹.\n\nĞ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ Ñ‡ĞµÑ€ĞµĞ· <b>ğŸ“‹ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ</b>",
            parse_mode="HTML",
        )
        return

    active = sum(1 for o in my_offers.values() if o.get("status") == "active")
    text = f"<b>ğŸ’¼ ĞœĞ¾Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ</b>\n\nĞ’ÑĞµĞ³Ğ¾: <b>{len(my_offers)}</b>\nĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ…: <b>{active}</b>\n\n"

    for idx, (offer_id, offer) in enumerate(list(my_offers.items())[:10], 1):
        text += f"{idx}. <b>ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ #{offer_id}</b>\n"
        text += f"   ğŸ“‹ {offer.get('service_type', '')}\n"
        text += f"   ğŸ¢ {offer.get('ports', '')}\n"
        text += f"   ğŸ’° {offer.get('price', 0):,.0f} â‚½\n"
        text += f"   Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: {offer.get('status', 'active')}\n\n"

    if len(my_offers) > 10:
        text += f"\n...Ğ¸ ĞµÑ‰Ñ‘ {len(my_offers) - 10}\n"

    await message.answer(text, parse_mode="HTML")


# ========== Ğ”ĞĞŸĞĞ›ĞĞ˜Ğ¢Ğ•Ğ›Ğ¬ĞĞ«Ğ• ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜ĞšĞ˜ ==========
# ============================================================================
# Ğ­ĞšĞ¡ĞŸĞĞ Ğ¢ĞĞ : ĞŸĞ ĞĞ¡ĞœĞĞ¢Ğ  ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ™ Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢ĞĞ’
# ============================================================================


@dp.callback_query_handler(
    lambda c: c.data.startswith("view_request_offers_"), state="*"
)
async def view_request_offers(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ² Ğ¿Ğ¾ Ğ·Ğ°ÑĞ²ĞºĞµ"""
    await state.finish()

    try:
        request_id = int(callback.data.split("_")[-1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ ID Ğ·Ğ°ÑĞ²ĞºĞ¸", show_alert=True)
        return

    if request_id not in shipping_requests:
        await callback.answer("âŒ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    request = shipping_requests[request_id]
    user_id = callback.from_user.id

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ñ€Ğ°Ğ²Ğ° Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°
    if request.get("exporter_id") != user_id:
        await callback.answer("âŒ Ğ­Ñ‚Ğ¾ Ğ½Ğµ Ğ²Ğ°ÑˆĞ° Ğ·Ğ°ÑĞ²ĞºĞ°", show_alert=True)
        return

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ²ÑĞµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾ Ğ·Ğ°ÑĞ²ĞºĞµ
    offers = [
        (offer_id, offer)
        for offer_id, offer in logistic_offers.items()
        if offer.get("request_id") == request_id
    ]

    if not offers:
        text = f"ğŸ“¦ <b>ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯ ĞŸĞ Ğ—ĞĞ¯Ğ’ĞšĞ• #{request_id}</b>\n\n"
        text += "âŒ ĞŸĞ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹ Ğ¾Ñ‚ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²\n\n"
        text += "<i>Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ğ»Ğ¸ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾ Ğ²Ğ°ÑˆĞµĞ¹ Ğ·Ğ°ÑĞ²ĞºĞµ.\n"
        text += "ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾ÑĞ²ÑÑ‚ÑÑ Ğ² Ğ±Ğ»Ğ¸Ğ¶Ğ°Ğ¹ÑˆĞµĞµ Ğ²Ñ€ĞµĞ¼Ñ.</i>"

        keyboard = InlineKeyboardMarkup()
        keyboard.add(
            InlineKeyboardButton("ğŸ”™ Ğš Ğ·Ğ°ÑĞ²ĞºĞ°Ğ¼", callback_data="my_shipping_requests")
        )
        keyboard.add(
            InlineKeyboardButton("ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main")
        )

        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
        await callback.answer()
        return

    # Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°Ğ¼
    by_status = {"pending": [], "accepted": [], "rejected": []}

    for offer_id, offer in offers:
        status = offer.get("status", "pending")
        if status in by_status:
            by_status[status].append((offer_id, offer))

    # Ğ¡Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾ Ñ†ĞµĞ½Ğµ (Ğ½Ğ¸Ğ·ĞºĞ¸Ğµ Ğ¿ĞµÑ€Ğ²Ñ‹Ğµ)
    for status in by_status:
        by_status[status].sort(key=lambda x: x[1].get("price", 999999))

    # Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ·Ğ°ÑĞ²ĞºĞµ
    pull_id = request.get("pull_id")
    pull_info = pulls.get(pull_id, {})

    text = f"ğŸ“¦ <b>ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯ ĞŸĞ Ğ—ĞĞ¯Ğ’ĞšĞ• #{request_id}</b>\n\n"
    text += f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {pull_info.get('culture', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}\n"
    text += f"ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: {request.get('volume', 0):.1f} Ñ‚\n"
    text += f"ğŸ“ ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚: {request.get('route_from', '')} â†’ {request.get('route_to', '')}\n\n"
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"

    # Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°
    total = len(offers)
    pending = len(by_status["pending"])
    accepted = len(by_status["accepted"])
    rejected = len(by_status["rejected"])

    text += f"ğŸ“Š <b>Ğ¡Ğ¢ĞĞ¢Ğ˜Ğ¡Ğ¢Ğ˜ĞšĞ:</b>\n"
    text += f"ğŸ“‹ Ğ’ÑĞµĞ³Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹: <b>{total}</b>\n"
    text += f"ğŸ• ĞĞ¶Ğ¸Ğ´Ğ°ÑÑ‚ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ: <b>{pending}</b>\n"
    text += f"âœ… ĞŸÑ€Ğ¸Ğ½ÑÑ‚Ğ¾: <b>{accepted}</b>\n"
    text += f"âŒ ĞÑ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¾: <b>{rejected}</b>\n\n"

    if pending > 0:
        # ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ»ÑƒÑ‡ÑˆĞµĞµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ
        best_offer_id, best_offer = by_status["pending"][0]
        text += f"ğŸ’° <b>Ğ›Ğ£Ğ§Ğ¨Ğ•Ğ• ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ•:</b>\n"
        text += f"ğŸ’µ Ğ¦ĞµĞ½Ğ°: <b>{best_offer.get('price', 0):,.0f} â‚½</b>\n"
        text += f"ğŸš› Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚: {best_offer.get('vehicle_type')}\n"
        text += f"ğŸ“… Ğ”Ğ°Ñ‚Ğ°: {best_offer.get('delivery_date')}\n\n"

    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    text += "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ°:"

    keyboard = InlineKeyboardMarkup(row_width=1)

    # ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¾Ğ¶Ğ¸Ğ´Ğ°ÑÑ‰Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
    for offer_id, offer in by_status["pending"][:5]:
        logist_id = offer.get("logist_id")
        logist_info = users.get(logist_id, {})
        logist_name = logist_info.get("company_name", f"Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ #{logist_id}")

        price = offer.get("price", 0)
        vehicle = offer.get("vehicle_type", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")

        button_text = f"ğŸ’° {price:,.0f} â‚½ | {vehicle[:15]} | {logist_name[:20]}"

        keyboard.add(
            InlineKeyboardButton(
                button_text, callback_data=f"view_offer_details_{offer_id}"
            )
        )

    if len(by_status["pending"]) > 5:
        keyboard.add(
            InlineKeyboardButton(
                f"â• ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ĞµÑ‰Ñ‘ {len(by_status['pending']) - 5}",
                callback_data=f"show_all_offers_{request_id}",
            )
        )

    # ĞšĞ½Ğ¾Ğ¿ĞºĞ° ÑÑ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ñ
    if pending >= 2:
        keyboard.add(
            InlineKeyboardButton(
                "âš–ï¸ Ğ¡Ñ€Ğ°Ğ²Ğ½Ğ¸Ñ‚ÑŒ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ", callback_data=f"compare_offers_{request_id}"
            )
        )

    keyboard.add(
        InlineKeyboardButton(
            "ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data=f"view_request_offers_{request_id}"
        )
    )
    keyboard.add(
        InlineKeyboardButton("ğŸ”™ Ğš Ğ·Ğ°ÑĞ²ĞºĞ°Ğ¼", callback_data="my_shipping_requests")
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("view_offer_details_"), state="*"
)
async def view_offer_details(callback: types.CallbackQuery, state: FSMContext):
    """Ğ”ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ"""
    await state.finish()

    try:
        offer_id = int(callback.data.split("_")[-1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ ID", show_alert=True)
        return

    if offer_id not in logistic_offers:
        await callback.answer("âŒ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾", show_alert=True)
        return

    offer = logistic_offers[offer_id]
    request_id = offer.get("request_id")
    request = shipping_requests.get(request_id, {})

    user_id = callback.from_user.id

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ñ€Ğ°Ğ²Ğ°
    if request.get("exporter_id") != user_id:
        await callback.answer("âŒ ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°", show_alert=True)
        return

    # Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğµ
    logist_id = offer.get("logist_id")
    logist_info = users.get(logist_id, {})
    logist_name = logist_info.get("company_name", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°")
    logist_phone = logist_info.get("phone", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")

    # Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°
    logist_offers = [
        o for o in logistic_offers.values() if o.get("logist_id") == logist_id
    ]
    logist_deliveries = [
        d for d in deliveries.values() if d.get("logist_id") == logist_id
    ]
    completed = len([d for d in logist_deliveries if d.get("status") == "completed"])
    total_offers = len(logist_offers)

    text = f"ğŸ“‹ <b>Ğ”Ğ•Ğ¢ĞĞ›Ğ˜ ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯ #{offer_id}</b>\n\n"

    # Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¸
    text += f"<b>ğŸ’° ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ•:</b>\n"
    text += f"ğŸ’µ Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ: <b>{offer.get('price', 0):,.0f} â‚½</b>\n"
    text += f"ğŸš› Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚: <b>{offer.get('vehicle_type', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</b>\n"
    text += f"ğŸ“… Ğ”Ğ°Ñ‚Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸: <b>{offer.get('delivery_date', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}</b>\n"

    if offer.get("additional_info"):
        text += f"\nâ„¹ï¸ Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾:\n<i>{offer.get('additional_info')}</i>\n"

    text += f"\nğŸ“… Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¾: {offer.get('created_at', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n\n"

    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"

    # Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğµ
    text += f"<b>ğŸšš Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢Ğ˜Ğ§Ğ•Ğ¡ĞšĞĞ¯ ĞšĞĞœĞŸĞĞĞ˜Ğ¯:</b>\n"
    text += f"ğŸ¢ ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ: <b>{logist_name}</b>\n"
    text += f"ğŸ“ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: {logist_phone}\n\n"

    # Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°
    text += f"<b>ğŸ“Š Ğ¡Ğ¢ĞĞ¢Ğ˜Ğ¡Ğ¢Ğ˜ĞšĞ:</b>\n"
    text += f"âœ… Ğ—Ğ°Ğ²ĞµÑ€ÑˆÑ‘Ğ½Ğ½Ñ‹Ñ… Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº: <b>{completed}</b>\n"
    text += f"ğŸ“‹ Ğ’ÑĞµĞ³Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹: <b>{total_offers}</b>\n"

    if completed > 0:
        # Ğ¡Ñ€ĞµĞ´Ğ½ÑÑ ÑÑ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ
        completed_deliveries = [
            logistic_offers.get(d.get("offer_id"), {}).get("price", 0)
            for d in logist_deliveries
            if d.get("status") == "completed"
        ]
        if completed_deliveries:
            avg_price = sum(completed_deliveries) / len(completed_deliveries)
            text += f"ğŸ’° Ğ¡Ñ€ĞµĞ´Ğ½ÑÑ ÑÑ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ: <b>{avg_price:,.0f} â‚½</b>\n"

    text += "\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"

    # Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
    status = offer.get("status", "pending")

    if status == "pending":
        text += "â³ <b>ĞĞ¶Ğ¸Ğ´Ğ°ĞµÑ‚ Ğ²Ğ°ÑˆĞµĞ³Ğ¾ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ</b>"
    elif status == "accepted":
        text += "âœ… <b>ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¾</b>"
    elif status == "rejected":
        text += "âŒ <b>ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¾</b>"
        if offer.get("rejection_reason"):
            text += f"\n<i>ĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ°: {offer.get('rejection_reason')}</i>"

    keyboard = InlineKeyboardMarkup(row_width=2)

    if status == "pending":
        keyboard.add(
            InlineKeyboardButton(
                "âœ… ĞŸÑ€Ğ¸Ğ½ÑÑ‚ÑŒ", callback_data=f"accept_offer_{offer_id}"
            ),
            InlineKeyboardButton(
                "âŒ ĞÑ‚ĞºĞ»Ğ¾Ğ½Ğ¸Ñ‚ÑŒ", callback_data=f"reject_offer_{offer_id}"
            ),
        )

    keyboard.add(
        InlineKeyboardButton(
            "ğŸ”™ Ğš Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸ÑĞ¼", callback_data=f"view_request_offers_{request_id}"
        )
    )
    keyboard.add(InlineKeyboardButton("ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main"))

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("compare_offers_"), state="*")
async def compare_offers(callback: types.CallbackQuery, state: FSMContext):
    """Ğ¡Ñ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹"""
    await state.finish()

    try:
        request_id = int(callback.data.split("_")[-1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    if request_id not in shipping_requests:
        await callback.answer("âŒ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    request = shipping_requests[request_id]
    user_id = callback.from_user.id

    if request.get("exporter_id") != user_id:
        await callback.answer("âŒ ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°", show_alert=True)
        return

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¾Ğ¶Ğ¸Ğ´Ğ°ÑÑ‰Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
    offers = [
        (offer_id, offer)
        for offer_id, offer in logistic_offers.items()
        if offer.get("request_id") == request_id and offer.get("status") == "pending"
    ]

    if len(offers) < 2:
        await callback.answer(
            "âŒ ĞĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹ Ğ´Ğ»Ñ ÑÑ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ñ", show_alert=True
        )
        return

    # Ğ¡Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾ Ñ†ĞµĞ½Ğµ
    offers.sort(key=lambda x: x[1].get("price", 999999))

    text = f"âš–ï¸ <b>Ğ¡Ğ ĞĞ’ĞĞ•ĞĞ˜Ğ• ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ™</b>\n\n"
    text += f"ğŸ“¦ Ğ—Ğ°ÑĞ²ĞºĞ° #{request_id}\n"
    text += f"ğŸ“Š Ğ¡Ñ€Ğ°Ğ²Ğ½Ğ¸Ğ²Ğ°ĞµĞ¼ {len(offers)} Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹\n\n"
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"

    # ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ‚Ğ¾Ğ¿-3
    for i, (offer_id, offer) in enumerate(offers[:3], 1):
        logist_id = offer.get("logist_id")
        logist_info = users.get(logist_id, {})
        logist_name = logist_info.get("company_name", f"Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ #{logist_id}")

        medal = "ğŸ¥‡" if i == 1 else "ğŸ¥ˆ" if i == 2 else "ğŸ¥‰"

        text += f"{medal} <b>#{i} - {logist_name}</b>\n"
        text += f"ğŸ’° Ğ¦ĞµĞ½Ğ°: <b>{offer.get('price', 0):,.0f} â‚½</b>\n"
        text += f"ğŸš› Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚: {offer.get('vehicle_type')}\n"
        text += f"ğŸ“… Ğ”Ğ°Ñ‚Ğ°: {offer.get('delivery_date')}\n"

        # Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°
        logist_deliveries = [
            d
            for d in deliveries.values()
            if d.get("logist_id") == logist_id and d.get("status") == "completed"
        ]
        completed = len(logist_deliveries)

        text += f"âœ… Ğ”Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº: {completed}\n"
        text += f"\n"

    if len(offers) > 3:
        text += f"<i>... Ğ¸ ĞµÑ‰Ñ‘ {len(offers) - 3} Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹</i>\n\n"

    # ĞĞ½Ğ°Ğ»Ğ¸Ğ·
    prices = [o[1].get("price", 0) for o in offers]
    min_price = min(prices)
    max_price = max(prices)
    avg_price = sum(prices) / len(prices)

    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    text += f"ğŸ“Š <b>ĞĞĞĞ›Ğ˜Ğ— Ğ¦Ğ•Ğ:</b>\n"
    text += f"ğŸ’µ ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ°Ñ: <b>{min_price:,.0f} â‚½</b>\n"
    text += f"ğŸ’° Ğ¡Ñ€ĞµĞ´Ğ½ÑÑ: <b>{avg_price:,.0f} â‚½</b>\n"
    text += f"ğŸ’¸ ĞœĞ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ°Ñ: <b>{max_price:,.0f} â‚½</b>\n"
    text += f"ğŸ“ˆ Ğ Ğ°Ğ·Ğ±Ñ€Ğ¾Ñ: <b>{max_price - min_price:,.0f} â‚½</b>\n\n"

    # Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ğ¸Ñ
    best_offer_id, best_offer = offers[0]
    text += f"ğŸ’¡ <b>Ğ Ğ•ĞšĞĞœĞ•ĞĞ”ĞĞ¦Ğ˜Ğ¯:</b>\n"
    text += f"Ğ¡Ğ°Ğ¼Ğ¾Ğµ Ğ²Ñ‹Ğ³Ğ¾Ğ´Ğ½Ğ¾Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ #{best_offer_id}\n"
    text += f"Ğ­ĞºĞ¾Ğ½Ğ¾Ğ¼Ğ¸Ñ: <b>{avg_price - min_price:,.0f} â‚½</b>"

    keyboard = InlineKeyboardMarkup(row_width=1)

    # ĞšĞ½Ğ¾Ğ¿ĞºĞ¸ Ğ´Ğ»Ñ Ñ‚Ğ¾Ğ¿-3
    for i, (offer_id, offer) in enumerate(offers[:3], 1):
        medal = "ğŸ¥‡" if i == 1 else "ğŸ¥ˆ" if i == 2 else "ğŸ¥‰"
        price = offer.get("price", 0)

        keyboard.add(
            InlineKeyboardButton(
                f"{medal} Ğ’Ñ‹Ğ±Ñ€Ğ°Ñ‚ÑŒ #{i} ({price:,.0f} â‚½)",
                callback_data=f"view_offer_details_{offer_id}",
            )
        )

    keyboard.add(
        InlineKeyboardButton(
            "ğŸ“‹ Ğ’ÑĞµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ", callback_data=f"view_request_offers_{request_id}"
        )
    )
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´", callback_data=f"view_request_offers_{request_id}"
        )
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


# ============================================================================
# Ğ­ĞšĞ¡ĞŸĞĞ Ğ¢ĞĞ : ĞŸĞ Ğ˜ĞĞ¯Ğ¢Ğ˜Ğ• Ğ˜ ĞĞ¢ĞšĞ›ĞĞĞ•ĞĞ˜Ğ• ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ™
# ============================================================================


class AcceptOfferStatesGroup(StatesGroup):
    """FSM Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¸Ñ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ"""

    offer_id = State()
    confirm = State()


class RejectOfferStatesGroup(StatesGroup):
    """FSM Ğ´Ğ»Ñ Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ñ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ"""

    offer_id = State()
    reason = State()


@dp.callback_query_handler(lambda c: c.data.startswith("accept_offer_"), state="*")
async def accept_offer_start(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ğ»Ğ¾ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¸Ñ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ"""
    await state.finish()

    try:
        offer_id = int(callback.data.split("_")[-1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ ID", show_alert=True)
        return

    if offer_id not in logistic_offers:
        await callback.answer("âŒ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾", show_alert=True)
        return

    offer = logistic_offers[offer_id]
    request_id = offer.get("request_id")
    request = shipping_requests.get(request_id, {})

    user_id = callback.from_user.id

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸
    if request.get("exporter_id") != user_id:
        await callback.answer("âŒ ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°", show_alert=True)
        return

    if offer.get("status") != "pending":
        await callback.answer("âŒ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ ÑƒĞ¶Ğµ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½Ğ¾", show_alert=True)
        return

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ğ½ĞµÑ‚ Ğ»Ğ¸ ÑƒĞ¶Ğµ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
    accepted_offers = [
        o
        for o in logistic_offers.values()
        if o.get("request_id") == request_id and o.get("status") == "accepted"
    ]

    if accepted_offers:
        await callback.answer(
            "âŒ ĞŸĞ¾ ÑÑ‚Ğ¾Ğ¹ Ğ·Ğ°ÑĞ²ĞºĞµ ÑƒĞ¶Ğµ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¾ Ğ´Ñ€ÑƒĞ³Ğ¾Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ", show_alert=True
        )
        return

    # Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¸
    logist_id = offer.get("logist_id")
    logist_info = users.get(logist_id, {})
    logist_name = logist_info.get("company_name", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°")

    pull_id = request.get("pull_id")
    pull_info = pulls.get(pull_id, {})

    text = f"âœ… <b>ĞŸĞ Ğ˜ĞĞ¯Ğ¢Ğ˜Ğ• ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯ #{offer_id}</b>\n\n"
    text += f"ğŸ“¦ <b>Ğ—ĞĞ¯Ğ’ĞšĞ #{request_id}</b>\n"
    text += f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: {pull_info.get('culture', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}\n"
    text += f"ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: {request.get('volume', 0):.1f} Ñ‚\n"
    text += f"ğŸ“ ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚: {request.get('route_from', '')} â†’ {request.get('route_to', '')}\n\n"

    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"

    text += f"<b>ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ•:</b>\n"
    text += f"ğŸšš Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚: <b>{logist_name}</b>\n"
    text += f"ğŸ’° Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ: <b>{offer.get('price', 0):,.0f} â‚½</b>\n"
    text += f"ğŸš› Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚: {offer.get('vehicle_type')}\n"
    text += f"ğŸ“… Ğ”Ğ°Ñ‚Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸: {offer.get('delivery_date')}\n\n"

    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"

    text += "âš ï¸ <b>Ğ’ĞĞ–ĞĞ:</b>\n"
    text += "â€¢ Ğ‘ÑƒĞ´ĞµÑ‚ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ°\n"
    text += "â€¢ ĞÑÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ±ÑƒĞ´ÑƒÑ‚ Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ñ‹\n"
    text += "â€¢ Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ\n"
    text += "â€¢ ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ±ÑƒĞ´ĞµÑ‚ Ğ½ĞµĞ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾\n\n"

    text += "âœ… ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ"

    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton(
            "âœ… ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´Ğ°Ñ", callback_data=f"confirm_accept_{offer_id}"
        ),
        InlineKeyboardButton(
            "âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data=f"view_offer_details_{offer_id}"
        ),
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("confirm_accept_"), state="*")
async def accept_offer_confirmed(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¸Ñ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ"""
    await state.finish()

    try:
        offer_id = int(callback.data.split("_")[-1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    if offer_id not in logistic_offers:
        await callback.answer("âŒ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾", show_alert=True)
        return

    offer = logistic_offers[offer_id]
    request_id = offer.get("request_id")
    request = shipping_requests.get(request_id, {})

    user_id = callback.from_user.id

    if request.get("exporter_id") != user_id:
        await callback.answer("âŒ ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°", show_alert=True)
        return

    # ĞŸÑ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°ĞµĞ¼ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ
    offer["status"] = "accepted"
    offer["accepted_at"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    offer["accepted_by"] = user_id

    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ·Ğ°ÑĞ²ĞºĞ¸
    request["status"] = "assigned"
    request["assigned_at"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    request["logist_id"] = offer.get("logist_id")

    # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ
    delivery_id = len(deliveries) + 1
    delivery = {
        "id": delivery_id,
        "request_id": request_id,
        "offer_id": offer_id,
        "exporter_id": user_id,
        "logist_id": offer.get("logist_id"),
        "pull_id": request.get("pull_id"),
        "route_from": request.get("route_from"),
        "route_to": request.get("route_to"),
        "volume": request.get("volume"),
        "price": offer.get("price"),
        "vehicle_type": offer.get("vehicle_type"),
        "delivery_date": offer.get("delivery_date"),
        "status": "pending",
        "created_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
    }

    deliveries[delivery_id] = delivery

    # ĞÑ‚ĞºĞ»Ğ¾Ğ½ÑĞµĞ¼ Ğ¾ÑÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
    rejected_count = 0
    for other_offer_id, other_offer in logistic_offers.items():
        if (
            other_offer.get("request_id") == request_id
            and other_offer_id != offer_id
            and other_offer.get("status") == "pending"
        ):

            other_offer["status"] = "rejected"
            other_offer["rejected_at"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            other_offer["rejection_reason"] = "ĞŸÑ€Ğ¸Ğ½ÑÑ‚Ğ¾ Ğ´Ñ€ÑƒĞ³Ğ¾Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ"
            rejected_count += 1

            # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²
            other_logist_id = other_offer.get("logist_id")
            if other_logist_id:
                asyncio.create_task(
                    notify_logistic_offer_rejected(
                        other_offer_id, user_id, "ĞŸÑ€Ğ¸Ğ½ÑÑ‚Ğ¾ Ğ´Ñ€ÑƒĞ³Ğ¾Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ"
                    )
                )

    # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
    save_shipping_requests()
    save_logistic_offers()
    save_deliveries()

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°
    logist_id = offer.get("logist_id")
    if logist_id:
        asyncio.create_task(notify_logistic_offer_accepted(offer_id, user_id))

    # Ğ¡Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    logist_info = users.get(logist_id, {})
    logist_name = logist_info.get("company_name", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°")

    text = f"ğŸ‰ <b>ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ• ĞŸĞ Ğ˜ĞĞ¯Ğ¢Ğ!</b>\n\n"
    text += f"âœ… ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ #{offer_id} ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¾\n"
    text += f"ğŸ“¦ Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° #{delivery_id} ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ°\n\n"
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    text += f"<b>Ğ”Ğ•Ğ¢ĞĞ›Ğ˜ Ğ”ĞĞ¡Ğ¢ĞĞ’ĞšĞ˜:</b>\n"
    text += f"ğŸšš Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚: {logist_name}\n"
    text += f"ğŸ’° Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ: {offer.get('price', 0):,.0f} â‚½\n"
    text += f"ğŸš› Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚: {offer.get('vehicle_type')}\n"
    text += f"ğŸ“… Ğ”Ğ°Ñ‚Ğ°: {offer.get('delivery_date')}\n\n"

    if rejected_count > 0:
        text += f"â„¹ï¸ ĞÑ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹: {rejected_count}\n\n"

    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    text += f"<b>Ğ¡Ğ›Ğ•Ğ”Ğ£Ğ®Ğ©Ğ˜Ğ• Ğ¨ĞĞ“Ğ˜:</b>\n"
    text += f"1. Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ\n"
    text += f"2. Ğ¡Ğ²ÑĞ¶Ğ¸Ñ‚ĞµÑÑŒ Ğ´Ğ»Ñ ÑƒÑ‚Ğ¾Ñ‡Ğ½ĞµĞ½Ğ¸Ñ Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹\n"
    text += f"3. ĞÑ‚ÑĞ»ĞµĞ¶Ğ¸Ğ²Ğ°Ğ¹Ñ‚Ğµ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ Ğ² Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ğµ 'ĞœĞ¾Ğ¸ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸'"

    keyboard = InlineKeyboardMarkup()
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ“¦ Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° #" + str(delivery_id),
            callback_data=f"view_delivery_{delivery_id}",
        )
    )
    keyboard.add(
        InlineKeyboardButton("ğŸ“‹ ĞœĞ¾Ğ¸ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸", callback_data="exporter_deliveries")
    )
    keyboard.add(InlineKeyboardButton("ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main"))

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer("âœ… ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¾!")

    logging.info(
        f"âœ… Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€ {user_id} Ğ¿Ñ€Ğ¸Ğ½ÑĞ» Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ #{offer_id}, ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° #{delivery_id}"
    )


@dp.callback_query_handler(lambda c: c.data.startswith("reject_offer_"), state="*")
async def reject_offer_start(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ğ»Ğ¾ Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ñ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ"""
    await state.finish()

    try:
        offer_id = int(callback.data.split("_")[-1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ ID", show_alert=True)
        return

    if offer_id not in logistic_offers:
        await callback.answer("âŒ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾", show_alert=True)
        return

    offer = logistic_offers[offer_id]
    request_id = offer.get("request_id")
    request = shipping_requests.get(request_id, {})

    user_id = callback.from_user.id

    if request.get("exporter_id") != user_id:
        await callback.answer("âŒ ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°", show_alert=True)
        return

    if offer.get("status") != "pending":
        await callback.answer("âŒ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ ÑƒĞ¶Ğµ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½Ğ¾", show_alert=True)
        return

    await state.update_data(offer_id=offer_id)

    logist_id = offer.get("logist_id")
    logist_info = users.get(logist_id, {})
    logist_name = logist_info.get("company_name", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°")

    text = f"âŒ <b>ĞĞ¢ĞšĞ›ĞĞĞ•ĞĞ˜Ğ• ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯ #{offer_id}</b>\n\n"
    text += f"ğŸšš Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚: {logist_name}\n"
    text += f"ğŸ’° Ğ¦ĞµĞ½Ğ°: {offer.get('price', 0):,.0f} â‚½\n\n"
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    text += "<b>Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ñƒ Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ñ</b>\n"
    text += "<i>(Ğ½ĞµĞ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾, Ğ½Ğ¾ Ñ€ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´ÑƒĞµÑ‚ÑÑ)</i>\n\n"
    text += "Ğ’Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ñ‹Ğµ Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ñ‹:\n"
    text += "â€¢ Ğ’Ñ‹ÑĞ¾ĞºĞ°Ñ Ñ†ĞµĞ½Ğ°\n"
    text += "â€¢ ĞĞµÑĞ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²Ğ¸Ğµ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°\n"
    text += "â€¢ ĞĞµĞ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´ÑÑ‰Ğ¸Ğµ ÑÑ€Ğ¾ĞºĞ¸\n"
    text += "â€¢ ĞŸÑ€Ğ¸Ğ½ÑÑ‚Ğ¾ Ğ´Ñ€ÑƒĞ³Ğ¾Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ\n\n"
    text += "Ğ˜Ğ»Ğ¸ Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ 'Ğ‘ĞµĞ· Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ñ‹'"

    keyboard = InlineKeyboardMarkup(row_width=1)

    reasons = [
        ("Ğ’Ñ‹ÑĞ¾ĞºĞ°Ñ Ñ†ĞµĞ½Ğ°", "reject_reason_Ğ’Ñ‹ÑĞ¾ĞºĞ°Ñ Ñ†ĞµĞ½Ğ°"),
        ("ĞĞµÑĞ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²Ğ¸Ğµ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°", "reject_reason_ĞĞµÑĞ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²Ğ¸Ğµ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°"),
        ("ĞĞµĞ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´ÑÑ‰Ğ¸Ğµ ÑÑ€Ğ¾ĞºĞ¸", "reject_reason_ĞĞµĞ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´ÑÑ‰Ğ¸Ğµ ÑÑ€Ğ¾ĞºĞ¸"),
        ("ĞŸÑ€Ğ¸Ğ½ÑÑ‚Ğ¾ Ğ´Ñ€ÑƒĞ³Ğ¾Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ", "reject_reason_ĞŸÑ€Ğ¸Ğ½ÑÑ‚Ğ¾ Ğ´Ñ€ÑƒĞ³Ğ¾Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ"),
    ]

    for reason_text, callback_data in reasons:
        keyboard.add(InlineKeyboardButton(reason_text, callback_data=callback_data))

    keyboard.add(
        InlineKeyboardButton(
            "âœï¸ Ğ£ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ÑĞ²Ğ¾Ñ Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ñƒ", callback_data="reject_reason_custom"
        )
    )
    keyboard.add(
        InlineKeyboardButton("â¡ï¸ Ğ‘ĞµĞ· Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ñ‹", callback_data="reject_reason_none")
    )
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ”™ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data=f"view_offer_details_{offer_id}"
        )
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await RejectOfferStatesGroup.reason.set()
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("reject_reason_"), state=RejectOfferStatesGroup.reason
)
async def reject_offer_reason_selected(
    callback: types.CallbackQuery, state: FSMContext
):
    """Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ñ‹ Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ñ"""
    reason_key = callback.data.replace("reject_reason_", "")

    data = await state.get_data()
    offer_id = data.get("offer_id")

    if reason_key == "custom":
        text = "âœï¸ <b>Ğ£ĞšĞĞ–Ğ˜Ğ¢Ğ• ĞŸĞ Ğ˜Ğ§Ğ˜ĞĞ£ ĞĞ¢ĞšĞ›ĞĞĞ•ĞĞ˜Ğ¯</b>\n\n"
        text += "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‚ĞµĞºÑÑ‚ Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ñ‹ (Ğ´Ğ¾ 200 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²):"

        keyboard = InlineKeyboardMarkup()
        keyboard.add(
            InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data=f"reject_offer_{offer_id}")
        )

        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
        await callback.answer()
        return

    if reason_key == "none":
        reason = None
    else:
        reason = reason_key

    # ĞÑ‚ĞºĞ»Ğ¾Ğ½ÑĞµĞ¼ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ
    await reject_offer_execute(callback, state, offer_id, reason)


@dp.message_handler(state=RejectOfferStatesGroup.reason)
async def reject_offer_custom_reason(message: types.Message, state: FSMContext):
    """Ğ’Ğ²Ğ¾Ğ´ ÑĞ²Ğ¾ĞµĞ¹ Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ñ‹ Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ñ"""
    reason = message.text.strip()

    if len(reason) > 200:
        await message.answer(
            "âŒ Ğ¡Ğ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ´Ğ»Ğ¸Ğ½Ğ½Ğ°Ñ Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ğ° (Ğ¼Ğ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ 200 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²)!\n\nĞ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ĞºĞ¾Ñ€Ğ¾Ñ‡Ğµ:"
        )
        return

    data = await state.get_data()
    offer_id = data.get("offer_id")

    # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ñ„ĞµĞ¹ĞºĞ¾Ğ²Ñ‹Ğ¹ callback Ğ´Ğ»Ñ Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
    class FakeCallback:
        def __init__(self, user_id, message):
            self.from_user = type("obj", (object,), {"id": user_id})
            self.message = message

        async def answer(self, text="", show_alert=False):
            pass

    fake_callback = FakeCallback(message.from_user.id, message)

    await reject_offer_execute(fake_callback, state, offer_id, reason)


async def reject_offer_execute(
    callback_or_fake, state: FSMContext, offer_id: int, reason: str = None
):
    """Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ñ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ"""

    if offer_id not in logistic_offers:
        if hasattr(callback_or_fake, "answer"):
            await callback_or_fake.answer("âŒ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾", show_alert=True)
        return

    offer = logistic_offers[offer_id]
    request_id = offer.get("request_id")

    user_id = callback_or_fake.from_user.id

    # ĞÑ‚ĞºĞ»Ğ¾Ğ½ÑĞµĞ¼ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ
    offer["status"] = "rejected"
    offer["rejected_at"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    offer["rejected_by"] = user_id
    if reason:
        offer["rejection_reason"] = reason

    save_logistic_offers()

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°
    logist_id = offer.get("logist_id")
    if logist_id:
        asyncio.create_task(notify_logistic_offer_rejected(offer_id, user_id, reason))

    # Ğ¡Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ
    text = f"âŒ <b>ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ• ĞĞ¢ĞšĞ›ĞĞĞ•ĞĞ</b>\n\n"
    text += f"âœ… ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ #{offer_id} Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¾\n"
    text += f"ğŸ“‹ Ğ—Ğ°ÑĞ²ĞºĞ° #{request_id}\n\n"

    if reason:
        text += f"ğŸ’¬ ĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ°: <i>{reason}</i>\n\n"

    text += "â„¹ï¸ Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ğ» ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ğ± Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ğ¸"

    keyboard = InlineKeyboardMarkup()
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ“‹ Ğ”Ñ€ÑƒĞ³Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ", callback_data=f"view_request_offers_{request_id}"
        )
    )
    keyboard.add(InlineKeyboardButton("ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main"))

    if hasattr(callback_or_fake.message, "edit_text"):
        await callback_or_fake.message.edit_text(
            text, reply_markup=keyboard, parse_mode="HTML"
        )
    else:
        await callback_or_fake.message.answer(
            text, reply_markup=keyboard, parse_mode="HTML"
        )

    await state.finish()

    logging.info(f"âŒ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€ {user_id} Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½Ğ¸Ğ» Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ #{offer_id}")


# ============================================================================
# Ğ­ĞšĞ¡ĞŸĞĞ Ğ¢ĞĞ : Ğ£ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ• Ğ—ĞĞ¯Ğ’ĞšĞĞœĞ˜ ĞĞ Ğ”ĞĞ¡Ğ¢ĞĞ’ĞšĞ£
# ============================================================================


@dp.callback_query_handler(lambda c: c.data == "my_shipping_requests", state="*")
async def show_my_shipping_requests(callback: types.CallbackQuery, state: FSMContext):
    """Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ·Ğ°ÑĞ²Ğ¾Ğº ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ° Ğ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ"""
    await state.finish()

    user_id = callback.from_user.id

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    my_requests = [
        (req_id, req)
        for req_id, req in shipping_requests.items()
        if req.get("exporter_id") == user_id
    ]

    if not my_requests:
        text = "ğŸ“¦ <b>ĞœĞĞ˜ Ğ—ĞĞ¯Ğ’ĞšĞ˜ ĞĞ Ğ”ĞĞ¡Ğ¢ĞĞ’ĞšĞ£</b>\n\n"
        text += "âŒ Ğ£ Ğ²Ğ°Ñ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ·Ğ°ÑĞ²Ğ¾Ğº Ğ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ\n\n"
        text += "<i>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ Ğ·Ğ°ÑĞ²ĞºÑƒ Ğ¸Ğ· Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ğ° 'ĞœĞ¾Ğ¸ Ğ¿ÑƒĞ»Ñ‹'</i>"

        keyboard = InlineKeyboardMarkup()
        keyboard.add(
            InlineKeyboardButton("â• Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¿ÑƒĞ»", callback_data="create_pull")
        )
        keyboard.add(
            InlineKeyboardButton("ğŸ”™ Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main")
        )

        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
        await callback.answer()
        return

    # Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°Ğ¼
    by_status = {
        "active": [],
        "assigned": [],
        "in_progress": [],
        "completed": [],
        "cancelled": [],
    }

    for req_id, req in my_requests:
        status = req.get("status", "active")
        if status in by_status:
            by_status[status].append((req_id, req))

    # Ğ¡Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾ Ğ´Ğ°Ñ‚Ğµ (Ğ½Ğ¾Ğ²Ñ‹Ğµ Ğ¿ĞµÑ€Ğ²Ñ‹Ğµ)
    for status in by_status:
        by_status[status].sort(key=lambda x: x[1].get("created_at", ""), reverse=True)

    text = f"ğŸ“¦ <b>ĞœĞĞ˜ Ğ—ĞĞ¯Ğ’ĞšĞ˜ ĞĞ Ğ”ĞĞ¡Ğ¢ĞĞ’ĞšĞ£</b>\n\n"
    text += f"Ğ’ÑĞµĞ³Ğ¾ Ğ·Ğ°ÑĞ²Ğ¾Ğº: <b>{len(my_requests)}</b>\n\n"

    # Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°
    active = len(by_status["active"])
    assigned = len(by_status["assigned"])
    in_progress = len(by_status["in_progress"])
    completed = len(by_status["completed"])

    text += f"ğŸ†• ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ: <b>{active}</b>\n"
    text += f"ğŸ‘¤ ĞĞ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ñ‹: <b>{assigned}</b>\n"
    text += f"ğŸšš Ğ’ Ğ¿ÑƒÑ‚Ğ¸: <b>{in_progress}</b>\n"
    text += f"âœ… Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ñ‹: <b>{completed}</b>\n\n"
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    text += "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ·Ğ°ÑĞ²ĞºÑƒ:"

    keyboard = InlineKeyboardMarkup(row_width=1)

    # ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ·Ğ°ÑĞ²ĞºĞ¸
    for status_key, status_name, emoji in [
        ("active", "ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ", "ğŸ†•"),
        ("assigned", "ĞĞ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ñ‹", "ğŸ‘¤"),
        ("in_progress", "Ğ’ Ğ¿ÑƒÑ‚Ğ¸", "ğŸšš"),
        ("completed", "Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ñ‹", "âœ…"),
    ]:
        requests = by_status[status_key]
        if requests:
            for req_id, req in requests[:5]:
                pull_id = req.get("pull_id")
                pull_info = pulls.get(pull_id, {})
                culture = pull_info.get("culture", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°")
                volume = req.get("volume", 0)

                # ĞŸĞ¾Ğ´ÑÑ‡Ñ‘Ñ‚ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹
                offers_count = len(
                    [
                        o
                        for o in logistic_offers.values()
                        if o.get("request_id") == req_id
                        and o.get("status") == "pending"
                    ]
                )

                button_text = f"{emoji} #{req_id} | {culture} {volume:.0f}Ñ‚"
                if offers_count > 0 and status_key == "active":
                    button_text += f" | ğŸ“¬ {offers_count}"

                keyboard.add(
                    InlineKeyboardButton(
                        button_text, callback_data=f"view_my_request_{req_id}"
                    )
                )

    keyboard.add(
        InlineKeyboardButton("ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="my_shipping_requests")
    )
    keyboard.add(InlineKeyboardButton("ğŸ”™ Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main"))

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("view_my_request_"), state="*")
async def view_my_request_details(callback: types.CallbackQuery, state: FSMContext):
    """Ğ”ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ ÑĞ²Ğ¾ĞµĞ¹ Ğ·Ğ°ÑĞ²ĞºĞ¸"""
    await state.finish()
    try:
        request_id = int(callback.data.split("_")[-1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ ID", show_alert=True)
        return

    if request_id not in shipping_requests:
        await callback.answer("âŒ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    request = shipping_requests[request_id]
    user_id = callback.from_user.id

    if request.get("exporter_id") != user_id:
        await callback.answer("âŒ Ğ­Ñ‚Ğ¾ Ğ½Ğµ Ğ²Ğ°ÑˆĞ° Ğ·Ğ°ÑĞ²ĞºĞ°", show_alert=True)
        return

    pull_id = request.get("pull_id")
    pull_info = pulls.get(pull_id, {})
    text = f"ğŸ“¦ <b>Ğ—ĞĞ¯Ğ’ĞšĞ #{request_id}</b>\n\n"
    text += f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: <b>{pull_info.get('culture', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}</b>\n"
    text += f"ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: <b>{request.get('volume', 0):.1f} Ñ‚</b>\n"
    text += f"ğŸ“ ĞÑ‚ĞºÑƒĞ´Ğ°: {request.get('route_from', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n"
    text += f"ğŸ“ ĞšÑƒĞ´Ğ°: {request.get('route_to', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n"
    if request.get("desired_date"):
        text += f"ğŸ“… Ğ–ĞµĞ»Ğ°ĞµĞ¼Ğ°Ñ Ğ´Ğ°Ñ‚Ğ°: {request.get('desired_date')}\n"
    if request.get("budget"):
        text += f"ğŸ’° Ğ‘ÑĞ´Ğ¶ĞµÑ‚: {request.get('budget'):,.0f} â‚½\n"
    if request.get("requirements"):
        text += f"\nğŸ“‹ Ğ¢Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ:\n{request.get('requirements')}\n"
    text += f"\nğŸ“… Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ°: {request.get('created_at', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n\n"
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"

    status = request.get("status", "active")
    status_icon = status_map.get(status, "âšª").split()[0]
    status_name = get_status_name(status)
    text += f"ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: <b>{status_icon} {status_name}</b>\n\n"

    all_offers = [
        o for o in logistic_offers.values() if o.get("request_id") == request_id
    ]
    pending_offers = [o for o in all_offers if o.get("status") == "pending"]
    accepted_offers = [o for o in all_offers if o.get("status") == "accepted"]

    text += f"ğŸ“¬ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹:\n"
    text += f"  â€¢ ĞĞ¶Ğ¸Ğ´Ğ°ÑÑ‚ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ: <b>{len(pending_offers)}</b>\n"
    text += f"  â€¢ ĞŸÑ€Ğ¸Ğ½ÑÑ‚Ğ¾: <b>{len(accepted_offers)}</b>\n"
    text += f"  â€¢ Ğ’ÑĞµĞ³Ğ¾: <b>{len(all_offers)}</b>\n\n"

    if request.get("logist_id"):
        logist_info = users.get(request.get("logist_id"), {})
        text += f"ğŸšš Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚: <b>{logist_info.get('company_name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}</b>\n"
        if logist_info.get("phone"):
            text += f"ğŸ“ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: {logist_info.get('phone')}\n"

    keyboard = InlineKeyboardMarkup(row_width=2)
    if status == "active":
        if len(pending_offers) > 0:
            keyboard.add(
                InlineKeyboardButton(
                    f"ğŸ“¬ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ ({len(pending_offers)})",
                    callback_data=f"view_request_offers_{request_id}",
                )
            )
        keyboard.add(
            InlineKeyboardButton(
                "âœï¸ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ", callback_data=f"edit_request_{request_id}"
            ),
            InlineKeyboardButton(
                "âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ", callback_data=f"cancel_request_{request_id}"
            ),
        )
    elif status == "assigned":
        keyboard.add(
            InlineKeyboardButton(
                "ğŸ“¦ Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ°", callback_data=f"view_delivery_by_request_{request_id}"
            )
        )
        keyboard.add(
            InlineKeyboardButton(
                "ğŸ“¬ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ", callback_data=f"view_request_offers_{request_id}"
            )
        )
    elif status in ["in_progress", "completed"]:
        keyboard.add(
            InlineKeyboardButton(
                "ğŸ“¦ Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ°", callback_data=f"view_delivery_by_request_{request_id}"
            )
        )

    keyboard.add(
        InlineKeyboardButton("ğŸ”™ Ğš Ğ·Ğ°ÑĞ²ĞºĞ°Ğ¼", callback_data="my_shipping_requests")
    )
    keyboard.add(InlineKeyboardButton("ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main"))

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("cancel_request_"), state="*")
async def cancel_request_confirm(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‹ Ğ·Ğ°ÑĞ²ĞºĞ¸"""
    await state.finish()

    try:
        request_id = int(callback.data.split("_")[-1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    if request_id not in shipping_requests:
        await callback.answer("âŒ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    request = shipping_requests[request_id]
    user_id = callback.from_user.id

    if request.get("exporter_id") != user_id:
        await callback.answer("âŒ ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°", show_alert=True)
        return

    if request.get("status") != "active":
        await callback.answer(
            "âŒ ĞœĞ¾Ğ¶Ğ½Ğ¾ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸", show_alert=True
        )
        return

    # ĞŸĞ¾Ğ´ÑÑ‡Ñ‘Ñ‚ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹
    pending_offers = [
        o
        for o in logistic_offers.values()
        if o.get("request_id") == request_id and o.get("status") == "pending"
    ]

    text = f"â“ <b>ĞĞ¢ĞœĞ•ĞĞ Ğ—ĞĞ¯Ğ’ĞšĞ˜ #{request_id}</b>\n\n"
    text += f"Ğ’Ñ‹ ÑƒĞ²ĞµÑ€ĞµĞ½Ñ‹, Ñ‡Ñ‚Ğ¾ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ·Ğ°ÑĞ²ĞºÑƒ?\n\n"

    if len(pending_offers) > 0:
        text += f"âš ï¸ Ğ£ Ğ²Ğ°Ñ ĞµÑÑ‚ÑŒ <b>{len(pending_offers)}</b> Ğ¾Ğ¶Ğ¸Ğ´Ğ°ÑÑ‰Ğ¸Ñ… Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹!\n"
        text += f"Ğ’ÑĞµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ±ÑƒĞ´ÑƒÑ‚ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ñ‹.\n\n"

    text += f"<i>Ğ­Ñ‚Ğ¾ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ½ĞµĞ»ÑŒĞ·Ñ Ğ±ÑƒĞ´ĞµÑ‚ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ</i>"

    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton(
            "âœ… Ğ”Ğ°, Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ", callback_data=f"confirm_cancel_request_{request_id}"
        ),
        InlineKeyboardButton("âŒ ĞĞµÑ‚", callback_data=f"view_my_request_{request_id}"),
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("confirm_cancel_request_"), state="*"
)
async def cancel_request_confirmed(callback: types.CallbackQuery, state: FSMContext):
    """ĞÑ‚Ğ¼ĞµĞ½Ğ° Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ°"""
    await state.finish()

    try:
        request_id = int(callback.data.split("_")[-1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    if request_id not in shipping_requests:
        await callback.answer("âŒ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    request = shipping_requests[request_id]
    user_id = callback.from_user.id

    if request.get("exporter_id") != user_id:
        await callback.answer("âŒ ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°", show_alert=True)
        return

    # ĞÑ‚Ğ¼ĞµĞ½ÑĞµĞ¼ Ğ·Ğ°ÑĞ²ĞºÑƒ
    request["status"] = "cancelled"
    request["cancelled_at"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # ĞÑ‚ĞºĞ»Ğ¾Ğ½ÑĞµĞ¼ Ğ²ÑĞµ Ğ¾Ğ¶Ğ¸Ğ´Ğ°ÑÑ‰Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
    cancelled_offers = 0
    for offer_id, offer in logistic_offers.items():
        if offer.get("request_id") == request_id and offer.get("status") == "pending":
            offer["status"] = "rejected"
            offer["rejected_at"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            offer["rejection_reason"] = "Ğ—Ğ°ÑĞ²ĞºĞ° Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ° Ğ·Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸ĞºĞ¾Ğ¼"
            cancelled_offers += 1

            # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°
            logist_id = offer.get("logist_id")
            if logist_id:
                asyncio.create_task(
                    notify_logistic_request_cancelled(
                        request_id, "Ğ—Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸Ğº Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ğ» Ğ·Ğ°ÑĞ²ĞºÑƒ"
                    )
                )

    save_shipping_requests()
    save_logistic_offers()

    text = f"âœ… <b>Ğ—ĞĞ¯Ğ’ĞšĞ #{request_id} ĞĞ¢ĞœĞ•ĞĞ•ĞĞ</b>\n\n"
    text += f"Ğ—Ğ°ÑĞ²ĞºĞ° ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ°.\n"

    if cancelled_offers > 0:
        text += f"\nğŸ“¬ ĞÑ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹: {cancelled_offers}\n"
        text += f"Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ğ»Ğ¸ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ.\n"

    keyboard = InlineKeyboardMarkup()
    keyboard.add(
        InlineKeyboardButton("ğŸ“¦ ĞœĞ¾Ğ¸ Ğ·Ğ°ÑĞ²ĞºĞ¸", callback_data="my_shipping_requests")
    )
    keyboard.add(InlineKeyboardButton("ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main"))

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer("âœ… Ğ—Ğ°ÑĞ²ĞºĞ° Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ°")

    logging.info(f"âŒ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€ {user_id} Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ğ» Ğ·Ğ°ÑĞ²ĞºÑƒ #{request_id}")


# ============================================================================
# Ğ­ĞšĞ¡ĞŸĞĞ Ğ¢ĞĞ : ĞŸĞ ĞĞ¡ĞœĞĞ¢Ğ  Ğ”ĞĞ¡Ğ¢ĞĞ’ĞĞš
# ============================================================================


@dp.callback_query_handler(lambda c: c.data == "exporter_deliveries", state="*")
async def show_exporter_deliveries(callback: types.CallbackQuery, state: FSMContext):
    """Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°"""
    await state.finish()

    user_id = callback.from_user.id

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    my_deliveries = [
        (deliv_id, deliv)
        for deliv_id, deliv in deliveries.items()
        if deliv.get("exporter_id") == user_id
    ]

    if not my_deliveries:
        text = "ğŸ“¦ <b>ĞœĞĞ˜ Ğ”ĞĞ¡Ğ¢ĞĞ’ĞšĞ˜</b>\n\n"
        text += "âŒ Ğ£ Ğ²Ğ°Ñ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº\n\n"
        text += "<i>Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸ Ğ¿Ğ¾ÑĞ²ÑÑ‚ÑÑ Ğ¿Ğ¾ÑĞ»Ğµ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¸Ñ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²</i>"

        keyboard = InlineKeyboardMarkup()
        keyboard.add(
            InlineKeyboardButton("ğŸ“‹ ĞœĞ¾Ğ¸ Ğ·Ğ°ÑĞ²ĞºĞ¸", callback_data="my_shipping_requests")
        )
        keyboard.add(
            InlineKeyboardButton("ğŸ”™ Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main")
        )

        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
        await callback.answer()
        return

    # Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°Ğ¼
    by_status = {"pending": [], "in_progress": [], "completed": [], "cancelled": []}

    for deliv_id, deliv in my_deliveries:
        status = deliv.get("status", "pending")
        if status in by_status:
            by_status[status].append((deliv_id, deliv))

    text = f"ğŸ“¦ <b>ĞœĞĞ˜ Ğ”ĞĞ¡Ğ¢ĞĞ’ĞšĞ˜</b>\n\n"
    text += f"Ğ’ÑĞµĞ³Ğ¾ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº: <b>{len(my_deliveries)}</b>\n\n"

    pending = len(by_status["pending"])
    in_progress = len(by_status["in_progress"])
    completed = len(by_status["completed"])

    text += f"ğŸ• ĞĞ¶Ğ¸Ğ´Ğ°ÑÑ‚ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ°: <b>{pending}</b>\n"
    text += f"ğŸšš Ğ’ Ğ¿ÑƒÑ‚Ğ¸: <b>{in_progress}</b>\n"
    text += f"âœ… Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ñ‹: <b>{completed}</b>\n\n"
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    text += "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ:"

    keyboard = InlineKeyboardMarkup(row_width=1)

    # ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸
    for status_key, status_name, emoji in [
        ("pending", "ĞĞ¶Ğ¸Ğ´Ğ°ÑÑ‚", "ğŸ•"),
        ("in_progress", "Ğ’ Ğ¿ÑƒÑ‚Ğ¸", "ğŸšš"),
        ("completed", "Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ñ‹", "âœ…"),
    ]:
        delivs = by_status[status_key]
        if delivs:
            for deliv_id, deliv in delivs[:5]:
                route = f"{deliv.get('route_from', '')} â†’ {deliv.get('route_to', '')}"
                volume = deliv.get("volume", 0)

                button_text = f"{emoji} #{deliv_id} | {route[:20]} | {volume:.0f}Ñ‚"

                keyboard.add(
                    InlineKeyboardButton(
                        button_text, callback_data=f"view_delivery_{deliv_id}"
                    )
                )

    keyboard.add(
        InlineKeyboardButton("ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="exporter_deliveries")
    )
    keyboard.add(InlineKeyboardButton("ğŸ”™ Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main"))

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("view_delivery_by_request_"), state="*"
)
async def view_delivery_by_request(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸ Ğ¿Ğ¾ ID Ğ·Ğ°ÑĞ²ĞºĞ¸"""
    await state.finish()

    try:
        request_id = int(callback.data.split("_")[-1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    # ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ Ğ¿Ğ¾ request_id
    delivery = None
    delivery_id = None
    for deliv_id, deliv in deliveries.items():
        if deliv.get("request_id") == request_id:
            delivery = deliv
            delivery_id = deliv_id
            break

    if not delivery:
        await callback.answer("âŒ Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    # ĞŸĞµÑ€ĞµĞ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ½Ğ° Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸
    await bot.answer_callback_query(callback.id)
    await bot.edit_message_text(
        chat_id=callback.message.chat.id,
        message_id=callback.message.message_id,
        text="ğŸ”„ Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ°...",
        parse_mode="HTML",
    )

    # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ callback Ğ´Ğ»Ñ view_delivery
    new_callback = types.CallbackQuery(
        id=callback.id,
        from_user=callback.from_user,
        message=callback.message,
        chat_instance=callback.chat_instance,
        data=f"view_delivery_{delivery_id}",
    )

    # Ğ’Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº (Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ±ÑƒĞ´ĞµÑ‚ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ view_delivery ĞµÑĞ»Ğ¸ ĞµĞ³Ğ¾ Ğ½ĞµÑ‚)
    # Ğ’Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ ID
    text = f"ğŸ“¦ Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° #{delivery_id}\n\nĞŸĞ¾Ğ´Ñ€Ğ¾Ğ±Ğ½Ğ°Ñ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ ÑĞºĞ¾Ñ€Ğ¾ Ğ±ÑƒĞ´ĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ°"
    keyboard = InlineKeyboardMarkup()
    keyboard.add(
        InlineKeyboardButton("ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´", callback_data=f"view_my_request_{request_id}")
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")


# ============================================================================
# Ğ­ĞšĞ¡ĞŸĞĞ Ğ¢ĞĞ : ĞĞ¦Ğ•ĞĞšĞ Ğ˜ ĞĞ¢Ğ—Ğ«Ğ’Ğ« Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢ĞĞ’
# ============================================================================

# Ğ“Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ğ°Ñ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ğ´Ğ»Ñ Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ñ€ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³Ğ¾Ğ²
logistic_ratings = {}  # {logist_id: {'total_rating': 0, 'count': 0, 'reviews': []}}


def save_logistic_ratings():
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ñ€ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³Ğ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²"""
    try:
        with open(os.path.join(DATA_DIR, "logistic_ratings.pkl"), "wb") as f:
            pickle.dump(logistic_ratings, f)
        logging.info("âœ… Logistic ratings saved")
    except Exception as e:
        logging.error(f"âŒ Error saving logistic ratings: {e}")


def load_logistic_ratings():
    """Ğ—Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ Ñ€ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³Ğ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²"""
    global logistic_ratings
    try:
        filepath = os.path.join(DATA_DIR, "logistic_ratings.pkl")
        if os.path.exists(filepath):
            with open(filepath, "rb") as f:
                logistic_ratings = pickle.load(f)
            logging.info(f"âœ… Loaded {len(logistic_ratings)} logistic ratings")
        else:
            logistic_ratings = {}
    except Exception as e:
        logging.error(f"âŒ Error loading logistic ratings: {e}")
        logistic_ratings = {}


class RateLogisticStatesGroup(StatesGroup):
    """FSM Ğ´Ğ»Ñ Ğ¾Ñ†ĞµĞ½ĞºĞ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°"""

    delivery_id = State()
    rating = State()
    review = State()


@dp.callback_query_handler(lambda c: c.data.startswith("rate_logistic_"), state="*")
async def rate_logistic_start(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ğ»Ğ¾ Ğ¾Ñ†ĞµĞ½ĞºĞ¸ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°"""
    await state.finish()

    try:
        delivery_id = int(callback.data.split("_")[-1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ ID", show_alert=True)
        return

    if delivery_id not in deliveries:
        await callback.answer("âŒ Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    delivery = deliveries[delivery_id]
    user_id = callback.from_user.id

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸
    if delivery.get("exporter_id") != user_id:
        await callback.answer("âŒ ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°", show_alert=True)
        return

    if delivery.get("status") != "completed":
        await callback.answer(
            "âŒ ĞœĞ¾Ğ¶Ğ½Ğ¾ Ğ¾Ñ†ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ·Ğ°Ğ²ĞµÑ€ÑˆÑ‘Ğ½Ğ½ÑƒÑ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ", show_alert=True
        )
        return

    if delivery.get("rated"):
        await callback.answer("âŒ Ğ’Ñ‹ ÑƒĞ¶Ğµ Ğ¾Ñ†ĞµĞ½Ğ¸Ğ»Ğ¸ ÑÑ‚Ñƒ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºÑƒ", show_alert=True)
        return

    await state.update_data(delivery_id=delivery_id)

    logist_id = delivery.get("logist_id")
    logist_info = users.get(logist_id, {})
    logist_name = logist_info.get("company_name", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°")

    text = f"â­ <b>ĞĞ¦Ğ•ĞĞšĞ Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢Ğ</b>\n\n"
    text += f"ğŸšš Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚: <b>{logist_name}</b>\n"
    text += f"ğŸ“¦ Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° #{delivery_id}\n\n"
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    text += "<b>ĞŸĞ¾ÑÑ‚Ğ°Ğ²ÑŒÑ‚Ğµ Ğ¾Ñ†ĞµĞ½ĞºÑƒ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğµ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°:</b>\n\n"
    text += "â­â­â­â­â­ â€” ĞÑ‚Ğ»Ğ¸Ñ‡Ğ½Ğ¾\n"
    text += "â­â­â­â­ â€” Ğ¥Ğ¾Ñ€Ğ¾ÑˆĞ¾\n"
    text += "â­â­â­ â€” ĞĞ¾Ñ€Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾\n"
    text += "â­â­ â€” ĞŸĞ»Ğ¾Ñ…Ğ¾\n"
    text += "â­ â€” ĞÑ‡ĞµĞ½ÑŒ Ğ¿Ğ»Ğ¾Ñ…Ğ¾"

    keyboard = InlineKeyboardMarkup(row_width=5)
    keyboard.add(
        InlineKeyboardButton("â­", callback_data="rate_1"),
        InlineKeyboardButton("â­â­", callback_data="rate_2"),
        InlineKeyboardButton("â­â­â­", callback_data="rate_3"),
        InlineKeyboardButton("â­â­â­â­", callback_data="rate_4"),
        InlineKeyboardButton("â­â­â­â­â­", callback_data="rate_5"),
    )
    keyboard.add(InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="exporter_deliveries"))

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await RateLogisticStatesGroup.rating.set()
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("rate_"), state=RateLogisticStatesGroup.rating
)
async def rate_logistic_rating_selected(
    callback: types.CallbackQuery, state: FSMContext
):
    """Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ¾Ñ†ĞµĞ½ĞºĞ¸"""

    try:
        rating = int(callback.data.split("_")[1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    if rating < 1 or rating > 5:
        await callback.answer("âŒ ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ°Ñ Ğ¾Ñ†ĞµĞ½ĞºĞ°", show_alert=True)
        return

    await state.update_data(rating=rating)

    data = await state.get_data()
    delivery_id = data.get("delivery_id")

    stars = "â­" * rating

    text = f"{stars} <b>ĞĞ¦Ğ•ĞĞšĞ: {rating}/5</b>\n\n"
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    text += "<b>ĞĞ°Ğ¿Ğ¸ÑˆĞ¸Ñ‚Ğµ Ğ¾Ñ‚Ğ·Ñ‹Ğ² Ğ¾ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğµ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°</b>\n"
    text += "<i>(Ğ½ĞµĞ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾, Ğ´Ğ¾ 500 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²)</i>\n\n"
    text += "ĞĞ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€:\n"
    text += "â€¢ Ğ‘Ñ‹ÑÑ‚Ñ€Ğ°Ñ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ°\n"
    text += "â€¢ ĞŸÑ€Ğ¾Ñ„ĞµÑÑĞ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´\n"
    text += "â€¢ Ğ“Ñ€ÑƒĞ· Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½ Ğ² Ñ†ĞµĞ»Ğ¾ÑÑ‚Ğ¸\n\n"
    text += "Ğ˜Ğ»Ğ¸ Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ 'ĞŸÑ€Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ'"

    keyboard = InlineKeyboardMarkup()
    keyboard.add(InlineKeyboardButton("â¡ï¸ ĞŸÑ€Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ", callback_data="skip_review"))
    keyboard.add(InlineKeyboardButton("âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="exporter_deliveries"))

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await RateLogisticStatesGroup.review.set()
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data == "skip_review", state=RateLogisticStatesGroup.review
)
async def rate_logistic_skip_review(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸÑ€Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ Ğ¾Ñ‚Ğ·Ñ‹Ğ²"""
    await rate_logistic_save(callback, state, None)


@dp.message_handler(state=RateLogisticStatesGroup.review)
async def rate_logistic_review_entered(message: types.Message, state: FSMContext):
    """Ğ’Ğ²Ğ¾Ğ´ Ğ¾Ñ‚Ğ·Ñ‹Ğ²Ğ°"""
    review = message.text.strip()

    if len(review) > 500:
        await message.answer(
            "âŒ Ğ¡Ğ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ´Ğ»Ğ¸Ğ½Ğ½Ñ‹Ğ¹ Ğ¾Ñ‚Ğ·Ñ‹Ğ² (Ğ¼Ğ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ 500 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²)!\n\nĞ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ĞºĞ¾Ñ€Ğ¾Ñ‡Ğµ:"
        )
        return

    # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ñ„ĞµĞ¹ĞºĞ¾Ğ²Ñ‹Ğ¹ callback
    class FakeCallback:
        def __init__(self, user_id, message):
            self.from_user = type("obj", (object,), {"id": user_id})
            self.message = message

        async def answer(self, text="", show_alert=False):
            pass

    fake_callback = FakeCallback(message.from_user.id, message)
    await rate_logistic_save(fake_callback, state, review)


async def rate_logistic_save(callback_or_fake, state: FSMContext, review: str = None):
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ¾Ñ†ĞµĞ½ĞºĞ¸ Ğ¸ Ğ¾Ñ‚Ğ·Ñ‹Ğ²Ğ°"""

    data = await state.get_data()
    delivery_id = data.get("delivery_id")
    rating = data.get("rating")

    user_id = callback_or_fake.from_user.id

    if delivery_id not in deliveries:
        if hasattr(callback_or_fake, "answer"):
            await callback_or_fake.answer("âŒ Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    delivery = deliveries[delivery_id]
    logist_id = delivery.get("logist_id")

    # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ¾Ñ†ĞµĞ½ĞºÑƒ Ğ² Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞµ
    delivery["rated"] = True
    delivery["rating"] = rating
    if review:
        delivery["review"] = review
    delivery["rated_at"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ñ€ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°
    if logist_id not in logistic_ratings:
        logistic_ratings[logist_id] = {"total_rating": 0, "count": 0, "reviews": []}

    logistic_ratings[logist_id]["total_rating"] += rating
    logistic_ratings[logist_id]["count"] += 1

    if review:
        logistic_ratings[logist_id]["reviews"].append(
            {
                "delivery_id": delivery_id,
                "exporter_id": user_id,
                "rating": rating,
                "review": review,
                "date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            }
        )

    # Ğ’Ñ‹Ñ‡Ğ¸ÑĞ»ÑĞµĞ¼ ÑÑ€ĞµĞ´Ğ½Ğ¸Ğ¹ Ñ€ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³
    avg_rating = (
        logistic_ratings[logist_id]["total_rating"]
        / logistic_ratings[logist_id]["count"]
    )

    save_deliveries()
    save_logistic_ratings()

    logist_info = users.get(logist_id, {})
    logist_name = logist_info.get("company_name", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°")

    stars = "â­" * rating

    text = f"âœ… <b>Ğ¡ĞŸĞĞ¡Ğ˜Ğ‘Ğ Ğ—Ğ ĞĞ¦Ğ•ĞĞšĞ£!</b>\n\n"
    text += f"{stars} <b>{rating}/5</b>\n\n"
    text += f"ğŸšš Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚: {logist_name}\n"
    text += f"ğŸ“¦ Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° #{delivery_id}\n\n"

    if review:
        text += f"ğŸ’¬ Ğ’Ğ°Ñˆ Ğ¾Ñ‚Ğ·Ñ‹Ğ²:\n<i>{review}</i>\n\n"

    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    text += f"ğŸ“Š Ğ¡Ñ€ĞµĞ´Ğ½Ğ¸Ğ¹ Ñ€ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°: <b>{avg_rating:.1f}/5</b>\n"
    text += f"ğŸ“‹ Ğ’ÑĞµĞ³Ğ¾ Ğ¾Ñ†ĞµĞ½Ğ¾Ğº: {logistic_ratings[logist_id]['count']}\n\n"
    text += "Ğ’Ğ°ÑˆĞ° Ğ¾Ñ†ĞµĞ½ĞºĞ° Ğ¿Ğ¾Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ´Ñ€ÑƒĞ³Ğ¸Ğ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼!"

    keyboard = InlineKeyboardMarkup()
    keyboard.add(
        InlineKeyboardButton("ğŸ“¦ ĞœĞ¾Ğ¸ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸", callback_data="exporter_deliveries")
    )
    keyboard.add(InlineKeyboardButton("ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main"))

    if hasattr(callback_or_fake.message, "edit_text"):
        try:
            await callback_or_fake.message.edit_text(
                text, reply_markup=keyboard, parse_mode="HTML"
            )
        except:
            await callback_or_fake.message.answer(
                text, reply_markup=keyboard, parse_mode="HTML"
            )
    else:
        await callback_or_fake.message.answer(
            text, reply_markup=keyboard, parse_mode="HTML"
        )

    await state.finish()

    logging.info(f"â­ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€ {user_id} Ğ¾Ñ†ĞµĞ½Ğ¸Ğ» Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ° {logist_id} Ğ½Ğ° {rating}/5")


@dp.callback_query_handler(
    lambda c: c.data.startswith("view_logistic_profile_"), state="*"
)
async def view_logistic_profile(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ Ğ¸ Ñ€ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³Ğ° Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ°"""
    await state.finish()

    try:
        logist_id = int(callback.data.split("_")[-1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    if logist_id not in users:
        await callback.answer("âŒ Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    logist_info = users[logist_id]

    text = f"ğŸšš <b>ĞŸĞ ĞĞ¤Ğ˜Ğ›Ğ¬ Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢Ğ</b>\n\n"
    text += f"ğŸ¢ ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ: <b>{logist_info.get('company_name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}</b>\n"
    text += f"ğŸ“ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: {logist_info.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"

    if logist_info.get("email"):
        text += f"ğŸ“§ Email: {logist_info.get('email')}\n"

    text += f"\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"

    # Ğ ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³
    if logist_id in logistic_ratings:
        rating_data = logistic_ratings[logist_id]
        avg_rating = rating_data["total_rating"] / rating_data["count"]
        stars = "â­" * int(round(avg_rating))

        text += f"<b>ğŸ“Š Ğ Ğ•Ğ™Ğ¢Ğ˜ĞĞ“:</b>\n"
        text += f"{stars} <b>{avg_rating:.1f}/5</b>\n"
        text += f"ğŸ“‹ ĞÑ†ĞµĞ½Ğ¾Ğº: {rating_data['count']}\n\n"
    else:
        text += f"<b>ğŸ“Š Ğ Ğ•Ğ™Ğ¢Ğ˜ĞĞ“:</b>\n"
        text += f"ĞŸĞ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ¾Ñ†ĞµĞ½Ğ¾Ğº\n\n"

    # Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº
    logist_deliveries = [
        d for d in deliveries.values() if d.get("logist_id") == logist_id
    ]

    completed = len([d for d in logist_deliveries if d.get("status") == "completed"])
    in_progress = len(
        [d for d in logist_deliveries if d.get("status") == "in_progress"]
    )

    text += f"<b>ğŸ“¦ Ğ¡Ğ¢ĞĞ¢Ğ˜Ğ¡Ğ¢Ğ˜ĞšĞ:</b>\n"
    text += f"âœ… Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¾ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº: {completed}\n"
    text += f"ğŸšš Ğ’ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑĞµ: {in_progress}\n"
    text += f"ğŸ“‹ Ğ’ÑĞµĞ³Ğ¾: {len(logist_deliveries)}\n\n"

    # ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ Ğ¾Ñ‚Ğ·Ñ‹Ğ²Ñ‹
    if logist_id in logistic_ratings and logistic_ratings[logist_id]["reviews"]:
        text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        text += f"<b>ğŸ’¬ ĞŸĞĞ¡Ğ›Ğ•Ğ”ĞĞ˜Ğ• ĞĞ¢Ğ—Ğ«Ğ’Ğ«:</b>\n\n"

        reviews = logistic_ratings[logist_id]["reviews"][-3:]  # ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ 3
        for r in reversed(reviews):
            stars = "â­" * r["rating"]
            text += f"{stars} {r['rating']}/5\n"
            text += f"<i>{r['review']}</i>\n"
            text += f"<code>{r['date']}</code>\n\n"

    keyboard = InlineKeyboardMarkup()
    keyboard.add(InlineKeyboardButton("ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back"))

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


# ============================================================================
# Ğ­ĞšĞ¡ĞŸĞ•Ğ”Ğ˜Ğ¢ĞĞ : Ğ£ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ• ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯ĞœĞ˜ Ğ˜ Ğ—ĞĞŸĞ ĞĞ¡ĞĞœĞ˜
# ============================================================================


@dp.callback_query_handler(lambda c: c.data == "expeditor_my_offers", state="*")
async def show_expeditor_my_offers(callback: types.CallbackQuery, state: FSMContext):
    """Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°"""
    await state.finish()

    user_id = callback.from_user.id

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    my_offers = [
        (offer_id, offer)
        for offer_id, offer in expeditor_offers.items()
        if offer.get("expeditor_id") == user_id
    ]

    if not my_offers:
        text = "ğŸ“‹ <b>ĞœĞĞ˜ ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯ Ğ£Ğ¡Ğ›Ğ£Ğ“</b>\n\n"
        text += "âŒ Ğ£ Ğ²Ğ°Ñ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹\n\n"
        text += "<i>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ² Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ğµ 'Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ'</i>"

        keyboard = InlineKeyboardMarkup()
        keyboard.add(
            InlineKeyboardButton(
                "â• Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ", callback_data="create_expeditor_offer"
            )
        )
        keyboard.add(
            InlineKeyboardButton("ğŸ”™ Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main")
        )

        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
        await callback.answer()
        return

    # Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°Ğ¼
    by_status = {"active": [], "selected": [], "cancelled": []}

    for offer_id, offer in my_offers:
        status = offer.get("status", "active")
        if status in by_status:
            by_status[status].append((offer_id, offer))

    text = f"ğŸ“‹ <b>ĞœĞĞ˜ ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯ Ğ£Ğ¡Ğ›Ğ£Ğ“</b>\n\n"
    text += f"Ğ’ÑĞµĞ³Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹: <b>{len(my_offers)}</b>\n\n"

    active = len(by_status["active"])
    selected = len(by_status["selected"])

    text += f"ğŸ†• ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ: <b>{active}</b>\n"
    text += f"âœ… Ğ’Ñ‹Ğ±Ñ€Ğ°Ğ½Ñ‹: <b>{selected}</b>\n\n"
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    text += "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ:"

    keyboard = InlineKeyboardMarkup(row_width=1)

    # ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
    for status_key, status_name, emoji in [
        ("active", "ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ", "ğŸ†•"),
        ("selected", "Ğ’Ñ‹Ğ±Ñ€Ğ°Ğ½Ñ‹", "âœ…"),
    ]:
        offers = by_status[status_key]
        if offers:
            for offer_id, offer in offers[:5]:
                service = offer.get("service_type", "Ğ£ÑĞ»ÑƒĞ³Ğ°")
                ports = offer.get("ports", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ñ‹")
                price = offer.get("price", 0)

                button_text = f"{emoji} #{offer_id} | {service[:20]} | {price:,.0f}â‚½"

                keyboard.add(
                    InlineKeyboardButton(
                        button_text, callback_data=f"view_expeditor_offer_{offer_id}"
                    )
                )

    keyboard.add(
        InlineKeyboardButton(
            "â• ĞĞ¾Ğ²Ğ¾Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ", callback_data="create_expeditor_offer"
        )
    )
    keyboard.add(
        InlineKeyboardButton("ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="expeditor_my_offers")
    )
    keyboard.add(InlineKeyboardButton("ğŸ”™ Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main"))

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("view_expeditor_offer_"), state="*"
)
async def view_expeditor_offer_details(
    callback: types.CallbackQuery, state: FSMContext
):
    """Ğ”ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°"""
    await state.finish()

    try:
        offer_id = int(callback.data.split("_")[-1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ ID", show_alert=True)
        return

    if offer_id not in expeditor_offers:
        await callback.answer("âŒ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾", show_alert=True)
        return

    offer = expeditor_offers[offer_id]
    user_id = callback.from_user.id

    if offer.get("expeditor_id") != user_id:
        await callback.answer("âŒ Ğ­Ñ‚Ğ¾ Ğ½Ğµ Ğ²Ğ°ÑˆĞµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ", show_alert=True)
        return

    text = f"ğŸ“‹ <b>ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ• #{offer_id}</b>\n\n"
    text += f"ğŸ“¦ Ğ£ÑĞ»ÑƒĞ³Ğ°: <b>{offer.get('service_type', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}</b>\n"
    text += f"ğŸš¢ ĞŸĞ¾Ñ€Ñ‚Ñ‹: {offer.get('ports', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ñ‹')}\n"
    text += f"ğŸ’° Ğ¦ĞµĞ½Ğ°: <b>{offer.get('price', 0):,.0f} â‚½</b>\n"
    text += f"ğŸ“… Ğ¡Ñ€Ğ¾ĞºĞ¸: {offer.get('terms', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ñ‹')}\n\n"

    if offer.get("description"):
        text += f"ğŸ“ ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ:\n<i>{offer.get('description')}</i>\n\n"

    text += f"ğŸ“… Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¾: {offer.get('created_at', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n\n"
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"

    # Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ
    status = offer.get("status", "active")

    if status == "active":
        text += "ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: <b>ğŸ†• ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾</b>\n"
        text += "Ğ’Ğ°ÑˆĞµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ²Ğ¸Ğ´Ğ½Ğ¾ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°Ğ¼"
    elif status == "selected":
        text += "ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: <b>âœ… Ğ’Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ¾ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ¼</b>\n"
        if offer.get("exporter_id"):
            exporter_info = users.get(offer.get("exporter_id"), {})
            text += (
                f"\nğŸ¢ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€: {exporter_info.get('company_name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}\n"
            )
            text += f"ğŸ“ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: {exporter_info.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}"
    elif status == "cancelled":
        text += "ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: <b>âŒ ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾</b>"

    keyboard = InlineKeyboardMarkup(row_width=2)

    if status == "active":
        keyboard.add(
            InlineKeyboardButton(
                "âœï¸ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ", callback_data=f"edit_expeditor_offer_{offer_id}"
            ),
            InlineKeyboardButton(
                "âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ", callback_data=f"cancel_expeditor_offer_{offer_id}"
            ),
        )

    keyboard.add(
        InlineKeyboardButton("ğŸ”™ Ğš Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸ÑĞ¼", callback_data="expeditor_my_offers")
    )
    keyboard.add(InlineKeyboardButton("ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main"))

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ Ğ•Ğ”ĞĞšĞ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ• ĞšĞĞ Ğ¢ĞĞ§ĞšĞ˜ Ğ­ĞšĞ¡ĞŸĞ•Ğ”Ğ˜Ğ¢ĞĞ Ğ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
@dp.callback_query_handler(lambda c: c.data == "edit_expeditor_card", state="*")
async def edit_expeditor_card_callback(
    callback: types.CallbackQuery, state: FSMContext
):
    """Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°"""
    await state.finish()

    user_id = callback.from_user.id

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ğ›ĞĞ“Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ• Ğ”Ğ›Ğ¯ Ğ”Ğ˜ĞĞ“ĞĞĞ¡Ğ¢Ğ˜ĞšĞ˜
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    logging.info(f"ğŸ”§ Ğ Ğ•Ğ”ĞĞšĞ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ• ĞšĞĞ Ğ¢ĞĞ§ĞšĞ˜")
    logging.info(f"   USER ID: {user_id}")
    logging.info(f"   expeditor_offers: {list(expeditor_offers.keys())}")
    logging.info(
        f"   expeditor_cards: {list(expeditor_cards.keys()) if 'expeditor_cards' in globals() else 'ĞĞ•Ğ¢'}"
    )

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ĞŸĞĞ˜Ğ¡Ğš Ğ’ expeditor_offers
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    offer_id = None
    offer = None

    for oid, off in expeditor_offers.items():
        logging.info(
            f"   ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ #{oid}: expeditor_id={off.get('expeditor_id')}"
        )
        if off.get("expeditor_id") == user_id:
            offer_id = oid
            offer = off
            logging.info(f"   âœ… ĞĞĞ™Ğ”Ğ•ĞĞ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° #{oid}")
            break

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ğ•Ğ¡Ğ›Ğ˜ ĞĞ• ĞĞĞ™Ğ”Ğ•ĞĞ Ğ’ expeditor_offers - Ğ˜Ğ©Ğ•Ğœ Ğ’ expeditor_cards
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if not offer_id and "expeditor_cards" in globals():
        logging.info("   âš ï¸ ĞĞµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ² expeditor_offers, Ğ¸Ñ‰ĞµĞ¼ Ğ² expeditor_cards")
        for cid, card in expeditor_cards.items():
            logging.info(f"   ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° card #{cid}: user_id={card.get('user_id')}")
            if card.get("user_id") == user_id:
                offer_id = cid
                offer = card
                logging.info(f"   âœ… ĞĞĞ™Ğ”Ğ•ĞĞ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ² expeditor_cards #{cid}")
                break

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ĞŸĞ ĞĞ’Ğ•Ğ ĞšĞ
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if not offer_id or not offer:
        logging.error(f"âŒ ĞšĞĞ Ğ¢ĞĞ§ĞšĞ ĞĞ• ĞĞĞ™Ğ”Ğ•ĞĞ Ğ´Ğ»Ñ user_id={user_id}")
        await callback.answer("âŒ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸", show_alert=True)
        return

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ĞŸĞ ĞĞ’Ğ•Ğ ĞšĞ Ğ¡Ğ¢ĞĞ¢Ğ£Ğ¡Ğ
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    status = offer.get("status", "active")
    logging.info(f"   Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸: {status}")

    if status != "active":
        await callback.answer(
            "âŒ ĞœĞ¾Ğ¶Ğ½Ğ¾ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸", show_alert=True
        )
        return

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ĞšĞ ĞĞ¡Ğ˜Ğ’ĞĞ• ĞœĞ•ĞĞ®
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    text = "âœï¸ <b>Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸</b>\n"
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ Ñ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ¾Ğ¹ Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
    service_type = offer.get("service_type", offer.get("transport_type", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"))
    price = offer.get("price", offer.get("price_per_km", 0))
    capacity = offer.get("capacity", offer.get("cargo_capacity", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°"))
    regions = offer.get("ports", offer.get("regions", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ñ‹"))
    description = offer.get("description", offer.get("notes", ""))

    # Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‚ĞµĞºÑÑ‚
    text += f"ğŸš› <b>Ğ¢Ğ¸Ğ¿ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚Ğ°</b>\n"
    text += f"   <code>{service_type}</code>\n\n"

    text += f"ğŸ’° <b>Ğ¦ĞµĞ½Ğ° Ğ·Ğ° ĞºĞ¼</b>\n"
    text += f"   <code>{price:,.2f} â‚½/ĞºĞ¼</code>\n\n"

    text += f"ğŸ“¦ <b>Ğ“Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ</b>\n"
    text += f"   <code>{capacity} Ñ‚</code>\n\n"

    text += f"ğŸ—º <b>Ğ ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹</b>\n"
    text += f"   <code>{regions}</code>\n\n"

    text += f"ğŸ“ <b>ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ</b>\n"
    if description:
        # ĞĞ±Ñ€ĞµĞ·Ğ°ĞµĞ¼ Ğ´Ğ»Ğ¸Ğ½Ğ½Ğ¾Ğµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ
        desc_preview = (
            description[:50] + "..." if len(description) > 50 else description
        )
        text += f"   <code>{desc_preview}</code>\n"
    else:
        text += f"   <i>ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾</i>\n"

    text += "\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
    text += "<i>ğŸ‘‡ Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€ Ğ´Ğ»Ñ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ</i>"

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ĞšĞ›ĞĞ’Ğ˜ĞĞ¢Ğ£Ğ Ğ
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton(
            "ğŸš› Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚", callback_data=f"edit_exp_field_service_type_{offer_id}"
        ),
        InlineKeyboardButton(
            "ğŸ’° Ğ¦ĞµĞ½Ğ°", callback_data=f"edit_exp_field_price_{offer_id}"
        ),
    )
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ“¦ Ğ“Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠÑ‘Ğ¼Ğ½Ğ¾ÑÑ‚ÑŒ", callback_data=f"edit_exp_field_capacity_{offer_id}"
        ),
        InlineKeyboardButton(
            "ğŸ—º Ğ ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹", callback_data=f"edit_exp_field_ports_{offer_id}"
        ),
    )
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ“ ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ", callback_data=f"edit_exp_field_description_{offer_id}"
        )
    )
    keyboard.add(
        InlineKeyboardButton("â—€ï¸ Ğš ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞµ", callback_data="expeditor_my_card")
    )

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ĞĞ¢ĞŸĞ ĞĞ’ĞšĞ
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()

    logging.info("âœ… ĞœĞ•ĞĞ® Ğ Ğ•Ğ”ĞĞšĞ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ¯ ĞĞ¢ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ¡ĞĞ¡Ğ¢ĞĞ¯ĞĞ˜Ğ¯ Ğ”Ğ›Ğ¯ Ğ Ğ•Ğ”ĞĞšĞ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ¯
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


class ExpeditatorEditStates(StatesGroup):
    waiting_value = State()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ĞĞ‘Ğ ĞĞ‘ĞĞ¢ĞšĞ ĞĞĞ’ĞĞ“Ğ Ğ—ĞĞĞ§Ğ•ĞĞ˜Ğ¯
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


@dp.message_handler(state=ExpeditatorEditStates.waiting_value)
async def process_expeditor_edit_value(message: types.Message, state: FSMContext):
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ"""
    data = await state.get_data()
    offer_id = data.get("edit_offer_id")
    field_name = data.get("edit_field")
    new_value = message.text.strip()

    # ĞÑ‚Ğ¼ĞµĞ½Ğ°
    if new_value == "/cancel":
        keyboard = InlineKeyboardMarkup()
        keyboard.add(
            InlineKeyboardButton(
                "â—€ï¸ Ğš ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞµ", callback_data=f"view_expeditor_offer_{offer_id}"
            )
        )
        await message.answer("âŒ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾", reply_markup=keyboard)
        await state.finish()
        return

    if offer_id not in expeditor_offers:
        await message.answer("âŒ ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°")
        await state.finish()
        return

    # Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ´Ğ»Ñ Ñ†ĞµĞ½Ñ‹
    if field_name == "price":
        try:
            new_value = float(new_value.replace(",", ".").replace(" ", ""))
            if new_value <= 0:
                raise ValueError
        except ValueError:
            await message.answer(
                "âŒ ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ñ†ĞµĞ½Ñ‹. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: 15000)"
            )
            return

    # ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞº Ğ´Ğ»Ñ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ
    if field_name == "description" and message.text == "/skip":
        new_value = ""

    # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ
    expeditor_offers[offer_id][field_name] = new_value
    save_expeditor_offers()

    field_names = {
        "service_type": "Ğ¢Ğ¸Ğ¿ ÑƒÑĞ»ÑƒĞ³Ğ¸",
        "price": "Ğ¦ĞµĞ½Ğ°",
        "terms": "Ğ¡Ñ€Ğ¾ĞºĞ¸",
        "ports": "ĞŸĞ¾Ñ€Ñ‚Ñ‹",
        "description": "ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ",
    }

    display_value = f"{new_value:,} â‚½" if field_name == "price" else new_value

    text = f"âœ… <b>{field_names.get(field_name, 'ĞŸĞ¾Ğ»Ğµ')} ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¾!</b>\n\n"
    text += f"ĞĞ¾Ğ²Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ:\n<code>{display_value}</code>"

    keyboard = InlineKeyboardMarkup()
    keyboard.add(
        InlineKeyboardButton(
            "ğŸ“‹ ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ", callback_data=f"view_expeditor_offer_{offer_id}"
        )
    )
    keyboard.add(
        InlineKeyboardButton(
            "âœï¸ Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ĞµÑ‰Ñ‘", callback_data=f"edit_expeditor_offer_{offer_id}"
        )
    )
    keyboard.add(
        InlineKeyboardButton("â—€ï¸ Ğš Ğ¼Ğ¾Ğ¸Ğ¼ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ°Ğ¼", callback_data="expeditor_my_offers")
    )

    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")
    await state.finish()

    logging.info(
        f"âœ… Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€ {message.from_user.id} Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ğ» {field_name} Ğ² ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞµ #{offer_id}"
    )


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ĞĞ¢ĞœĞ•ĞĞ ĞšĞĞ Ğ¢ĞĞ§ĞšĞ˜ Ğ­ĞšĞ¡ĞŸĞ•Ğ”Ğ˜Ğ¢ĞĞ Ğ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


@dp.callback_query_handler(
    lambda c: c.data.startswith("cancel_expeditor_offer_"), state="*"
)
async def cancel_expeditor_offer_callback(
    callback: types.CallbackQuery, state: FSMContext
):
    """ĞÑ‚Ğ¼ĞµĞ½Ğ°/ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°"""
    await state.finish()

    try:
        offer_id = int(callback.data.split("_")[-1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ ID", show_alert=True)
        return

    if offer_id not in expeditor_offers:
        await callback.answer("âŒ ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    offer = expeditor_offers[offer_id]
    user_id = callback.from_user.id

    if offer.get("expeditor_id") != user_id:
        await callback.answer("âŒ Ğ­Ñ‚Ğ¾ Ğ½Ğµ Ğ²Ğ°ÑˆĞ° ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ°", show_alert=True)
        return

    # ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ
    text = f"â“ <b>Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ #{offer_id}?</b>\n\n"
    text += f"Ğ£ÑĞ»ÑƒĞ³Ğ°: {offer.get('service_type', 'Ğ/Ğ”')}\n"
    text += f"Ğ¦ĞµĞ½Ğ°: {offer.get('price', 0):,} â‚½\n\n"
    text += "âš ï¸ Ğ­Ñ‚Ğ¾ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ½ĞµĞ»ÑŒĞ·Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ!"

    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton(
            "âœ… Ğ”Ğ°, ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ", callback_data=f"confirm_cancel_expeditor_{offer_id}"
        ),
        InlineKeyboardButton(
            "âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data=f"view_expeditor_offer_{offer_id}"
        ),
    )

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("confirm_cancel_expeditor_"), state="*"
)
async def confirm_cancel_expeditor_callback(
    callback: types.CallbackQuery, state: FSMContext
):
    """ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸"""
    await state.finish()

    try:
        offer_id = int(callback.data.split("_")[-1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    if offer_id not in expeditor_offers:
        await callback.answer("âŒ ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
        return

    # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ
    del expeditor_offers[offer_id]
    save_expeditor_offers()

    text = "âœ… <b>ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ°!</b>\n\n"
    text += f"ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° #{offer_id} Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ½Ğµ Ğ²Ğ¸Ğ´Ğ½Ğ° ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°Ğ¼."

    keyboard = InlineKeyboardMarkup()
    keyboard.add(
        InlineKeyboardButton("â—€ï¸ Ğš Ğ¼Ğ¾Ğ¸Ğ¼ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ°Ğ¼", callback_data="expeditor_my_offers")
    )
    keyboard.add(InlineKeyboardButton("ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main"))

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer("âœ… ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ°", show_alert=True)

    logging.info(f"âœ… Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€ {callback.from_user.id} ÑƒĞ´Ğ°Ğ»Ğ¸Ğ» ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ #{offer_id}")


@dp.callback_query_handler(
    lambda c: c.data.startswith("cancel_expeditor_offer_"), state="*"
)
async def cancel_expeditor_offer(callback: types.CallbackQuery, state: FSMContext):
    """ĞÑ‚Ğ¼ĞµĞ½Ğ° Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°"""
    await state.finish()

    try:
        offer_id = int(callback.data.split("_")[-1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    if offer_id not in expeditor_offers:
        await callback.answer("âŒ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾", show_alert=True)
        return

    offer = expeditor_offers[offer_id]
    user_id = callback.from_user.id

    if offer.get("expeditor_id") != user_id:
        await callback.answer("âŒ ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°", show_alert=True)
        return

    if offer.get("status") != "active":
        await callback.answer(
            "âŒ ĞœĞ¾Ğ¶Ğ½Ğ¾ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ", show_alert=True
        )
        return

    # ĞÑ‚Ğ¼ĞµĞ½ÑĞµĞ¼
    offer["status"] = "cancelled"
    offer["cancelled_at"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    save_expeditor_offers()

    text = f"âœ… <b>ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ• #{offer_id} ĞĞ¢ĞœĞ•ĞĞ•ĞĞ</b>\n\n"
    text += "ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ½Ğµ Ğ±ÑƒĞ´ĞµÑ‚ Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°Ñ‚ÑŒÑÑ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ°Ğ¼"

    keyboard = InlineKeyboardMarkup()
    keyboard.add(
        InlineKeyboardButton("ğŸ’¼ ĞœĞ¾Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ", callback_data="expeditor_my_offers")
    )
    keyboard.add(InlineKeyboardButton("ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main"))

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer("âœ… ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾")

    logging.info(f"âŒ Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€ {user_id} Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ğ» Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ #{offer_id}")


@dp.callback_query_handler(lambda c: c.data == "expeditor_available_pulls", state="*")
async def show_expeditor_available_pulls(
    callback: types.CallbackQuery, state: FSMContext
):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ¿ÑƒĞ»Ğ¾Ğ² Ğ´Ğ»Ñ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°"""
    await state.finish()

    user_id = callback.from_user.id

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ° Ğ´Ğ»Ñ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾Ñ€Ñ‚Ğ¾Ğ²
    my_offers = [
        offer
        for offer in expeditor_offers.values()
        if offer.get("expeditor_id") == user_id and offer.get("status") == "active"
    ]

    # Ğ¡Ğ¾Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ğ¿Ğ¾Ñ€Ñ‚Ñ‹ Ğ¸Ğ· Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹
    my_ports = set()
    for offer in my_offers:
        ports_str = offer.get("ports", "")
        if ports_str:
            ports_list = [p.strip() for p in ports_str.split(",")]
            my_ports.update([p.lower() for p in ports_list])

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: Ğ˜Ñ‰ĞµĞ¼ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´ÑÑ‰Ğ¸Ğµ Ğ¿ÑƒĞ»Ñ‹
    suitable_pulls = []
    all_pulls = pulls.get("pulls", {})  # âœ… Ğ”ĞĞ‘ĞĞ’Ğ›Ğ•ĞĞ

    for pull_id, pull in all_pulls.items():  # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ
        if not isinstance(pull, dict):  # âœ… Ğ”ĞĞ‘ĞĞ’Ğ›Ğ•ĞĞ
            continue

        if pull.get("status") != "filled":
            continue

        pull_port = pull.get("port", "").lower()

        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ñ€Ñ‚Ğ¾Ğ²
        if not my_ports or any(port in pull_port for port in my_ports):
            suitable_pulls.append((pull_id, pull))

    if not suitable_pulls:
        text = "ğŸš¢ <b>Ğ”ĞĞ¡Ğ¢Ğ£ĞŸĞĞ«Ğ• ĞŸĞ£Ğ›Ğ«</b>\n\n"

        if not my_offers:
            text += "âŒ Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° ÑĞ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ ÑƒÑĞ»ÑƒĞ³\n\n"
            text += "<i>Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ñ€Ñ‚Ñ‹, Ğ² ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ñ… Ğ²Ñ‹ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚Ğµ</i>"

            keyboard = InlineKeyboardMarkup()
            keyboard.add(
                InlineKeyboardButton(
                    "â• Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ", callback_data="create_expeditor_offer"
                )
            )
        else:
            text += "âŒ ĞĞµÑ‚ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´ÑÑ‰Ğ¸Ñ… Ğ¿ÑƒĞ»Ğ¾Ğ² Ğ¿Ğ¾ Ğ²Ğ°ÑˆĞ¸Ğ¼ Ğ¿Ğ¾Ñ€Ñ‚Ğ°Ğ¼\n\n"
            text += f"Ğ’Ğ°ÑˆĞ¸ Ğ¿Ğ¾Ñ€Ñ‚Ñ‹: <i>{', '.join(my_ports)}</i>"

            keyboard = InlineKeyboardMarkup()
            keyboard.add(
                InlineKeyboardButton(
                    "ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="expeditor_available_pulls"
                )
            )

        keyboard.add(
            InlineKeyboardButton("ğŸ”™ Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main")
        )

        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
        await callback.answer()
        return

    # Ğ¡Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾ Ğ´Ğ°Ñ‚Ğµ (Ğ½Ğ¾Ğ²Ñ‹Ğµ Ğ¿ĞµÑ€Ğ²Ñ‹Ğµ)
    suitable_pulls.sort(key=lambda x: x[1].get("created_at", ""), reverse=True)

    text = f"ğŸš¢ <b>Ğ”ĞĞ¡Ğ¢Ğ£ĞŸĞĞ«Ğ• ĞŸĞ£Ğ›Ğ«</b>\n\n"
    text += f"ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ¿ÑƒĞ»Ğ¾Ğ²: <b>{len(suitable_pulls)}</b>\n"

    if my_ports:
        text += f"Ğ’Ğ°ÑˆĞ¸ Ğ¿Ğ¾Ñ€Ñ‚Ñ‹: <i>{', '.join(my_ports)}</i>\n"

    text += "\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    text += "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿ÑƒĞ»:"

    keyboard = InlineKeyboardMarkup(row_width=1)

    for pull_id, pull in suitable_pulls[:10]:
        culture = pull.get("culture", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°")
        volume = pull.get("current_volume", 0)
        port = pull.get("port", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½")

        button_text = f"ğŸ“¦ #{pull_id} | {culture} {volume:.0f}Ñ‚ | {port}"

        keyboard.add(
            InlineKeyboardButton(
                button_text, callback_data=f"view_pull_for_expeditor_{pull_id}"
            )
        )

    if len(suitable_pulls) > 10:
        keyboard.add(
            InlineKeyboardButton(
                f"â• ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ĞµÑ‰Ñ‘ {len(suitable_pulls) - 10}",
                callback_data="show_more_pulls_expeditor",
            )
        )

    keyboard.add(
        InlineKeyboardButton("ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="expeditor_available_pulls")
    )
    keyboard.add(InlineKeyboardButton("ğŸ”™ Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main"))

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(
    lambda c: c.data.startswith("view_pull_for_expeditor_"), state="*"
)
async def view_pull_for_expeditor(callback: types.CallbackQuery, state: FSMContext):
    """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ¿ÑƒĞ»Ğ° Ğ´Ğ»Ñ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°"""
    await state.finish()

    try:
        pull_id = int(callback.data.split("_")[-1])
    except (IndexError, ValueError):
        await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ ID", show_alert=True)
        return

    # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿ÑƒĞ»Ñ‹ Ğ¸Ğ· Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑÑ‚Ğ°
    all_pulls = pulls.get("pulls", {})

    if pull_id not in all_pulls:
        await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    pull = all_pulls.get(pull_id) or all_pulls.get(str(pull_id))

    if not pull:
        await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    text = f"ğŸ“¦ <b>ĞŸĞ£Ğ› #{pull_id}</b>\n\n"
    text += f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: <b>{pull.get('culture', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}</b>\n"
    text += f"ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: <b>{pull.get('current_volume', 0):.1f} Ñ‚</b>\n"
    text += f"ğŸš¢ ĞŸĞ¾Ñ€Ñ‚ Ğ¾Ñ‚Ğ³Ñ€ÑƒĞ·ĞºĞ¸: {pull.get('port', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
    text += f"ğŸ“… Ğ”Ğ°Ñ‚Ğ° Ğ¾Ñ‚Ğ³Ñ€ÑƒĞ·ĞºĞ¸: {pull.get('shipment_date', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}\n\n"

    # Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ± ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğµ
    exporter_id = pull.get("exporter_id")
    if exporter_id:
        exporter_info = users.get(exporter_id, {})
        text += f"<b>ğŸ¢ Ğ­ĞšĞ¡ĞŸĞĞ Ğ¢ĞĞ :</b>\n"
        text += f"ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ: {exporter_info.get('company_name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}\n"
        text += f"Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: {exporter_info.get('phone', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}\n"
        if exporter_info.get("email"):
            text += f"Email: {exporter_info.get('email')}\n"
        text += "\n"

    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    text += "ğŸ’¡ <b>Ğ”Ğ»Ñ ÑĞ¾Ñ‚Ñ€ÑƒĞ´Ğ½Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ°:</b>\n"
    text += "Ğ¡Ğ²ÑĞ¶Ğ¸Ñ‚ĞµÑÑŒ Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€Ğ¾Ğ¼ Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ÑƒÑ\n"
    text += "Ğ¸Ğ»Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ ÑƒÑĞ»ÑƒĞ³"

    keyboard = InlineKeyboardMarkup()
    keyboard.add(
        InlineKeyboardButton("ğŸ’¼ ĞœĞ¾Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ", callback_data="expeditor_my_offers")
    )
    keyboard.add(
        InlineKeyboardButton("ğŸ”™ Ğš Ğ¿ÑƒĞ»Ğ°Ğ¼", callback_data="expeditor_available_pulls")
    )
    keyboard.add(InlineKeyboardButton("ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main"))

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


@dp.callback_query_handler(lambda c: c.data == "expeditor_statistics", state="*")
async def show_expeditor_statistics(callback: types.CallbackQuery, state: FSMContext):
    """Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ°"""
    await state.finish()

    user_id = callback.from_user.id

    # Ğ¡Ğ¾Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºÑƒ
    my_offers = [
        offer
        for offer in expeditor_offers.values()
        if offer.get("expeditor_id") == user_id
    ]

    total_offers = len(my_offers)
    active_offers = len([o for o in my_offers if o.get("status") == "active"])
    selected_offers = len([o for o in my_offers if o.get("status") == "selected"])

    # ĞŸĞ¾Ğ´ÑÑ‡Ñ‘Ñ‚ Ğ¿ÑƒĞ»Ğ¾Ğ² Ğ¿Ğ¾ Ğ¿Ğ¾Ñ€Ñ‚Ğ°Ğ¼
    ports_dict = {}
    for offer in my_offers:
        ports_str = offer.get("ports", "")
        if ports_str:
            for port in ports_str.split(","):
                port = port.strip()
                ports_dict[port] = ports_dict.get(port, 0) + 1

    text = f"ğŸ“Š <b>ĞœĞĞ¯ Ğ¡Ğ¢ĞĞ¢Ğ˜Ğ¡Ğ¢Ğ˜ĞšĞ</b>\n\n"
    text += f"<b>ĞŸĞ Ğ•Ğ”Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯:</b>\n"
    text += f"ğŸ“‹ Ğ’ÑĞµĞ³Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹: <b>{total_offers}</b>\n"
    text += f"ğŸ†• ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ…: <b>{active_offers}</b>\n"
    text += f"âœ… Ğ’Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ¾: <b>{selected_offers}</b>\n\n"

    if selected_offers > 0 and total_offers > 0:
        success_rate = (selected_offers / total_offers) * 100
        text += f"ğŸ“ˆ ĞŸÑ€Ğ¾Ñ†ĞµĞ½Ñ‚ ÑƒÑĞ¿ĞµÑ…Ğ°: <b>{success_rate:.1f}%</b>\n\n"

    if ports_dict:
        text += f"<b>ĞŸĞĞ Ğ¢Ğ«:</b>\n"
        for port, count in sorted(ports_dict.items(), key=lambda x: x[1], reverse=True)[
            :5
        ]:
            text += f"ğŸš¢ {port}: {count} Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹\n"
        text += "\n"

    # Ğ¡Ñ€ĞµĞ´Ğ½ÑÑ Ñ†ĞµĞ½Ğ° ÑƒÑĞ»ÑƒĞ³
    prices = [o.get("price", 0) for o in my_offers if o.get("price")]
    if prices:
        avg_price = sum(prices) / len(prices)
        text += f"<b>Ğ¦Ğ•ĞĞĞĞ‘Ğ ĞĞ—ĞĞ’ĞĞĞ˜Ğ•:</b>\n"
        text += f"ğŸ’° Ğ¡Ñ€ĞµĞ´Ğ½ÑÑ Ñ†ĞµĞ½Ğ°: <b>{avg_price:,.0f} â‚½</b>\n"
        text += f"ğŸ’µ ĞœĞ¸Ğ½. Ñ†ĞµĞ½Ğ°: {min(prices):,.0f} â‚½\n"
        text += f"ğŸ’¸ ĞœĞ°ĞºÑ. Ñ†ĞµĞ½Ğ°: {max(prices):,.0f} â‚½\n"

    keyboard = InlineKeyboardMarkup()
    keyboard.add(
        InlineKeyboardButton("ğŸ’¼ ĞœĞ¾Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ", callback_data="expeditor_my_offers")
    )
    keyboard.add(
        InlineKeyboardButton("ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="expeditor_statistics")
    )
    keyboard.add(InlineKeyboardButton("ğŸ”™ Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main"))

    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()


# ============= Ğ˜ĞĞ¢Ğ•Ğ ĞĞšĞ¢Ğ˜Ğ’ĞĞ«Ğ™ ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜Ğš: ĞœĞĞ˜ Ğ¡Ğ”Ğ•Ğ›ĞšĞ˜ Ğ¡ Ğ¤Ğ˜Ğ›Ğ¬Ğ¢Ğ ĞĞ¦Ğ˜Ğ•Ğ™ Ğ˜ Ğ”Ğ•Ğ¢ĞĞ›Ğ¯ĞœĞ˜ =============


# FSM ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ° ÑĞ´ĞµĞ»Ğ¾Ğº
class DealView(StatesGroup):
    viewing_deals = State()
    viewing_detail = State()


deals_cache = {}


# ==========================@==================================================
@dp.message_handler(lambda msg: msg.text in ["ğŸ“‹ ĞœĞ¾Ğ¸ ÑĞ´ĞµĞ»ĞºĞ¸"])
async def show_user_deals(message: types.Message, state: FSMContext):
    """âœ… Ğ“Ğ›ĞĞ’ĞĞ«Ğ™ ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜Ğš - Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ Ğ’Ğ¡Ğ• ÑÑ‚Ğ°Ñ‚ÑƒÑÑ‹, ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ Ğ¢ĞĞ›Ğ¬ĞšĞ ĞµÑĞ»Ğ¸ > 0"""
    await state.finish()

    user_id = message.from_user.id
    user_data = users.get(user_id, {})
    user_role = user_data.get("role", "unknown")
    user_name = user_data.get("name", "ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ")

    logging.critical(f"ğŸ“‹ ĞœĞĞ˜ Ğ¡Ğ”Ğ•Ğ›ĞšĞ˜/ĞŸĞĞ Ğ¢Ğ˜Ğ˜: user_id={user_id}, role={user_role}")

    try:
        keyboard = InlineKeyboardMarkup(row_width=1)
        text = ""

        # ============================================================================
        # ğŸ‘¨â€ğŸŒ¾ Ğ¤Ğ•Ğ ĞœĞ•Ğ 
        # ============================================================================
        if user_role == "farmer":
            user_batches = batches.get(user_id, [])

            # ĞĞ¾Ñ€Ğ¼Ğ°Ğ»Ğ¸Ğ·ÑƒĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑÑ‹ - Ğ¿Ñ€Ğ¸Ğ²Ğ¾Ğ´Ğ¸Ğ¼ Ğº Ğ½Ğ¸Ğ¶Ğ½ĞµĞ¼Ñƒ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ñƒ
            active = len(
                [
                    d
                    for d in user_batches
                    if (d.get("status") or "").lower()
                    in ["active", "pending", "Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ°", "", "none"]
                ]
            )
            reserved = len(
                [
                    d
                    for d in user_batches
                    if (d.get("status") or "").lower()
                    in ["reserved", "Ğ·Ğ°Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ°"]
                    or d.get("reserved_volume", 0) > 0
                ]
            )
            sold = len(
                [
                    d
                    for d in user_batches
                    if (d.get("status") or "").lower()
                    in ["sold", "Ğ¿Ñ€Ğ¾Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ", "Ğ¿Ñ€Ğ¾Ğ´Ğ°Ğ½Ğ¾"]
                    or d.get("sold")
                ]
            )
            canceled = len(
                [
                    d
                    for d in user_batches
                    if (d.get("status") or "").lower()
                    in ["canceled", "Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾", "cancelled"]
                ]
            )
            matches = len([d for d in user_batches if len(d.get("matches", [])) > 0])

            total = active + reserved + sold + canceled
            total_volume = sum([b.get("volume", 0) for b in user_batches])
            total_price = sum(
                [b.get("volume", 0) * b.get("price", 0) for b in user_batches]
            )

            text = (
                f"<b>ğŸ‘¨â€ğŸŒ¾ ĞœĞĞ˜ ĞŸĞĞ Ğ¢Ğ˜Ğ˜</b>\n\n"
                f"<b>ğŸ‘¨â€ğŸŒ¾ Ğ¤ĞµÑ€Ğ¼ĞµÑ€</b>\n"
                f"ğŸ‘¤ {user_name}\n"
                f"ğŸ“Š Ğ’ÑĞµĞ³Ğ¾: <b>{total}</b>\n"
                f"ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: {total_volume:,.0f}Ñ‚\n"
                f"ğŸ’° Ğ¡ÑƒĞ¼Ğ¼Ğ°: {total_price:,.0f}â‚½\n\n"
                f"âœ… ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ: {active}\n"
                f"ğŸ”’ Ğ—Ğ°Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ: {reserved}\n"
                f"ğŸ’° ĞŸÑ€Ğ¾Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ: {sold}\n"
                f"âŒ Ğ¡Ğ½ÑÑ‚Ñ‹Ğµ Ñ Ğ¿Ñ€Ğ¾Ğ´Ğ°Ğ¶Ğ¸: {canceled}\n"
                f"ğŸ¯ Ğ¡ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸ÑĞ¼Ğ¸: {matches}\n\n"
                f"<b>Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ÑÑ‚Ğ°Ñ‚ÑƒÑ:</b>"
            )

            # Ğ¢ĞĞ›Ğ¬ĞšĞ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ ĞµÑĞ»Ğ¸ COUNT > 0
            if active > 0:
                keyboard.add(
                    InlineKeyboardButton(
                        f"âœ… ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ ({active})",
                        callback_data="deals_status:farmer:active",
                    )
                )
            if reserved > 0:
                keyboard.add(
                    InlineKeyboardButton(
                        f"ğŸ”’ Ğ—Ğ°Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ ({reserved})",
                        callback_data="deals_status:farmer:reserved",
                    )
                )
            if sold > 0:
                keyboard.add(
                    InlineKeyboardButton(
                        f"ğŸ’° ĞŸÑ€Ğ¾Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ ({sold})",
                        callback_data="deals_status:farmer:sold",
                    )
                )
            if canceled > 0:
                keyboard.add(
                    InlineKeyboardButton(
                        f"âŒ Ğ¡Ğ½ÑÑ‚Ñ‹Ğµ Ñ Ğ¿Ñ€Ğ¾Ğ´Ğ°Ğ¶Ğ¸ ({canceled})",
                        callback_data="deals_status:farmer:canceled",
                    )
                )
            if matches > 0:
                keyboard.add(
                    InlineKeyboardButton(
                        f"ğŸ¯ Ğ¡ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸ÑĞ¼Ğ¸ ({matches})",
                        callback_data="deals_status:farmer:matches",
                    )
                )

            if total == 0:
                text = (
                    f"ğŸ‘¨â€ğŸŒ¾ <b>ĞœĞĞ˜ ĞŸĞĞ Ğ¢Ğ˜Ğ˜</b>\n\n"
                    f"ğŸ‘¤ {user_name}\n"
                    "ğŸ“­ <b>ĞŸĞ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾</b>\n\n"
                    "ğŸ’¡ <b>ĞŸĞ¾Ğ´ÑĞºĞ°Ğ·ĞºĞ°:</b> Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ Ğ½Ğ¾Ğ²ÑƒÑ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ñ‡ĞµÑ€ĞµĞ· 'â• Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ'"
                )

        # ============================================================================
        # ğŸ“¤ Ğ­ĞšĞ¡ĞŸĞĞ Ğ¢Ğ•Ğ 
        # ============================================================================
        elif user_role == "exporter":
            # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿ÑƒĞ»Ñ‹ Ğ¸Ğ· Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑÑ‚Ğ°
            all_pulls_dict = pulls.get("pulls", {})
            all_pulls = {
                k: v
                for k, v in all_pulls_dict.items()
                if isinstance(v, dict) and v.get("exporter_id") == user_id
            }

            active = len(
                [
                    d
                    for d in all_pulls.values()
                    if (d.get("status") or "").lower() in ["active", "none", ""]
                ]
            )
            filled = len(
                [
                    d
                    for d in all_pulls.values()
                    if (d.get("status") or "").lower() == "filled"
                ]
            )
            closed = len(
                [
                    d
                    for d in all_pulls.values()
                    if (d.get("status") or "").lower() == "closed"
                ]
            )
            completed = len(
                [
                    d
                    for d in all_pulls.values()
                    if (d.get("status") or "").lower() == "completed"
                ]
            )
            cancelled = len(
                [
                    d
                    for d in all_pulls.values()
                    if (d.get("status") or "").lower() in ["cancelled", "canceled"]
                ]
            )

            total_volume = sum([p.get("target_volume", 0) for p in all_pulls.values()])
            total_price = sum(
                [
                    p.get("target_volume", 0) * p.get("price", 0)
                    for p in all_pulls.values()
                ]
            )

            text = (
                f"ğŸ“¤ <b>ĞœĞĞ˜ ĞŸĞ£Ğ›Ğ«</b>\n\n"
                f"ğŸ‘¤ {user_name}\n"
                f"ğŸ“Š Ğ’ÑĞµĞ³Ğ¾: <b>{len(all_pulls)}</b>\n"
                f"ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: {total_volume:,.0f}Ñ‚\n"
                f"ğŸ’° Ğ¡ÑƒĞ¼Ğ¼Ğ°: {total_price:,.0f}â‚½\n\n"
                f"âœ… ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ: {active}\n"
                f"ğŸ”’ Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ½Ñ‹Ğµ: {filled}\n"
                f"ğŸ’° Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ: {closed}\n"
                f"âŒ ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½Ğ½Ñ‹Ğµ: {cancelled}\n"
                f"ğŸ¯ Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ½Ñ‹Ğµ: {completed}\n\n"
                f"<b>Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ÑÑ‚Ğ°Ñ‚ÑƒÑ:</b>"
            )

            # Ğ¢ĞĞ›Ğ¬ĞšĞ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ ĞµÑĞ»Ğ¸ COUNT > 0
            if active > 0:
                keyboard.add(
                    InlineKeyboardButton(
                        f"âœ… ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ ({active})",
                        callback_data="deals_status:exporter:active",
                    )
                )
            if filled > 0:
                keyboard.add(
                    InlineKeyboardButton(
                        f"ğŸ”’ Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ½Ñ‹Ğµ ({filled})",
                        callback_data="deals_status:exporter:filled",
                    )
                )
            if closed > 0:
                keyboard.add(
                    InlineKeyboardButton(
                        f"ğŸ’° Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ ({closed})",
                        callback_data="deals_status:exporter:closed",
                    )
                )
            if cancelled > 0:
                keyboard.add(
                    InlineKeyboardButton(
                        f"âŒ ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½Ğ½Ñ‹Ğµ ({cancelled})",
                        callback_data="deals_status:exporter:cancelled",
                    )
                )
            if completed > 0:
                keyboard.add(
                    InlineKeyboardButton(
                        f"ğŸ¯ Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ½Ñ‹Ğµ ({completed})",
                        callback_data="deals_status:exporter:completed",
                    )
                )

            if len(all_pulls) == 0:
                text = (
                    f"ğŸ“¤ <b>ĞœĞĞ˜ ĞŸĞ£Ğ›Ğ«</b>\n\n"
                    f"ğŸ‘¤ {user_name}\n"
                    "ğŸ“­ <b>ĞŸÑƒĞ»Ğ¾Ğ² Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾</b>\n\n"
                    "ğŸ’¡ <b>ĞŸĞ¾Ğ´ÑĞºĞ°Ğ·ĞºĞ°:</b> Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ¿ÑƒĞ» Ñ‡ĞµÑ€ĞµĞ· 'â• Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¿ÑƒĞ»'"
                )

        # ============================================================================
        # ğŸšš Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢
        # ============================================================================
        elif user_role == "logist":
            all_orders = {
                k: v
                for k, v in shipping_requests.items()
                if v.get("logist_id") == user_id
            }

            pending = len(
                [
                    d
                    for d in all_orders.values()
                    if (d.get("status") or "").lower() in ["pending", "new", "none", ""]
                ]
            )
            in_progress = len(
                [
                    d
                    for d in all_orders.values()
                    if (d.get("status") or "").lower() == "in_progress"
                ]
            )
            completed = len(
                [
                    d
                    for d in all_orders.values()
                    if (d.get("status") or "").lower() == "completed"
                ]
            )

            total_volume = sum([o.get("volume", 0) for o in all_orders.values()])
            total_price = sum([o.get("price", 0) for o in all_orders.values()])

            text = (
                f"ğŸšš <b>ĞœĞĞ˜ Ğ”ĞĞ¡Ğ¢ĞĞ’ĞšĞ˜</b>\n\n"
                f"ğŸ‘¤ {user_name}\n"
                f"ğŸ“Š Ğ’ÑĞµĞ³Ğ¾: <b>{len(all_orders)}</b>\n"
                f"ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: {total_volume:,.0f}Ñ‚\n"
                f"ğŸ’° Ğ¡ÑƒĞ¼Ğ¼Ğ°: {total_price:,.0f}â‚½\n\n"
                f"â³ ĞĞ¶Ğ¸Ğ´Ğ°ÑÑ‰Ğ¸Ğµ: {pending}\n"
                f"ğŸš— Ğ’ Ğ¿ÑƒÑ‚Ğ¸: {in_progress}\n"
                f"âœ… Ğ”Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ğ¾: {completed}\n\n"
                f"<b>Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ÑÑ‚Ğ°Ñ‚ÑƒÑ:</b>"
            )

            # Ğ¢ĞĞ›Ğ¬ĞšĞ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ ĞµÑĞ»Ğ¸ COUNT > 0
            if pending > 0:
                keyboard.add(
                    InlineKeyboardButton(
                        f"â³ ĞĞ¶Ğ¸Ğ´Ğ°ÑÑ‰Ğ¸Ğµ ({pending})",
                        callback_data="deals_status:logist:pending",
                    )
                )
            if in_progress > 0:
                keyboard.add(
                    InlineKeyboardButton(
                        f"ğŸš— Ğ’ Ğ¿ÑƒÑ‚Ğ¸ ({in_progress})",
                        callback_data="deals_status:logist:in_progress",
                    )
                )
            if completed > 0:
                keyboard.add(
                    InlineKeyboardButton(
                        f"âœ… Ğ”Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ ({completed})",
                        callback_data="deals_status:logist:completed",
                    )
                )

            if len(all_orders) == 0:
                text = (
                    f"ğŸšš <b>ĞœĞĞ˜ Ğ”ĞĞ¡Ğ¢ĞĞ’ĞšĞ˜</b>\n\n"
                    f"ğŸ‘¤ {user_name}\n"
                    "ğŸ“­ <b>Ğ”Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾</b>"
                )

        # ============================================================================
        # âœˆï¸ Ğ­ĞšĞ¡ĞŸĞ•Ğ”Ğ˜Ğ¢ĞĞ 
        # ============================================================================
        elif user_role == "expeditor":
            all_offers = {
                k: v
                for k, v in expeditor_offers.items()
                if v.get("expeditor_id") == user_id
            }

            active = len(
                [
                    d
                    for d in all_offers.values()
                    if (d.get("status") or "").lower() in ["active", "open", "none", ""]
                ]
            )
            in_progress = len(
                [
                    d
                    for d in all_offers.values()
                    if (d.get("status") or "").lower() == "in_progress"
                ]
            )
            delivered = len(
                [
                    d
                    for d in all_offers.values()
                    if (d.get("status") or "").lower() == "delivered"
                ]
            )

            total_volume = sum([o.get("volume", 0) for o in all_offers.values()])
            total_price = sum([o.get("price", 0) for o in all_offers.values()])

            text = (
                f"âœˆï¸ <b>ĞœĞĞ˜ ĞœĞĞ Ğ¨Ğ Ğ£Ğ¢Ğ«</b>\n\n"
                f"ğŸ‘¤ {user_name}\n"
                f"ğŸ“Š Ğ’ÑĞµĞ³Ğ¾: <b>{len(all_offers)}</b>\n"
                f"ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: {total_volume:,.0f}Ñ‚\n"
                f"ğŸ’° Ğ¡ÑƒĞ¼Ğ¼Ğ°: {total_price:,.0f}â‚½\n\n"
                f"ğŸŸ¢ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ: {active}\n"
                f"â³ Ğ’ Ğ¿ÑƒÑ‚Ğ¸: {in_progress}\n"
                f"âœ… Ğ”Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ğ¾: {delivered}\n\n"
                f"<b>Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ÑÑ‚Ğ°Ñ‚ÑƒÑ:</b>"
            )

            # Ğ¢ĞĞ›Ğ¬ĞšĞ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ ĞµÑĞ»Ğ¸ COUNT > 0
            if active > 0:
                keyboard.add(
                    InlineKeyboardButton(
                        f"ğŸŸ¢ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ ({active})",
                        callback_data="deals_status:expeditor:active",
                    )
                )
            if in_progress > 0:
                keyboard.add(
                    InlineKeyboardButton(
                        f"â³ Ğ’ Ğ¿ÑƒÑ‚Ğ¸ ({in_progress})",
                        callback_data="deals_status:expeditor:in_progress",
                    )
                )
            if delivered > 0:
                keyboard.add(
                    InlineKeyboardButton(
                        f"âœ… Ğ”Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ ({delivered})",
                        callback_data="deals_status:expeditor:delivered",
                    )
                )

            if len(all_offers) == 0:
                text = (
                    f"âœˆï¸ <b>ĞœĞĞ˜ ĞœĞĞ Ğ¨Ğ Ğ£Ğ¢Ğ«</b>\n\n"
                    f"ğŸ‘¤ {user_name}\n"
                    "ğŸ“­ <b>ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚Ğ¾Ğ² Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾</b>"
                )

        else:
            text = f"â“ ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ°Ñ Ñ€Ğ¾Ğ»ÑŒ: {user_role}"

        await message.answer(text, reply_markup=keyboard, parse_mode="HTML")
        logging.info(f"âœ… Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾: {user_role}")

    except Exception as e:
        logging.error(f"âŒ ĞĞ¨Ğ˜Ğ‘ĞšĞ: {e}", exc_info=True)
        await message.answer(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)}")


@dp.callback_query_handler(
    lambda q: q.data in ("back_to_main", "back_to_menu", "main_menu")
)
async def back_to_main_handler(callback: types.CallbackQuery, state: FSMContext = None):
    """âœ… Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğ² Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ Ğ´Ğ»Ñ Ğ’Ğ¡Ğ•Ğ¥ ĞºĞ½Ğ¾Ğ¿Ğ¾Ğº Ğ½Ğ°Ğ·Ğ°Ğ´"""
    user_id = callback.from_user.id
    current_time = time.time()
    last_click = last_back_click.get(user_id, 0)

    # âœ… ANTISPAM: Ğ¸Ğ³Ğ½Ğ¾Ñ€Ğ¸Ñ€ÑƒĞµĞ¼ ĞºĞ»Ğ¸ĞºĞ¸ Ğ±Ñ‹ÑÑ‚Ñ€ĞµĞµ 0.5 ÑĞµĞºÑƒĞ½Ğ´Ñ‹
    if current_time - last_click < 0.5:
        logging.info(f"â±ï¸ Ğ—Ğ°Ñ‰Ğ¸Ñ‚Ğ° Ğ¾Ñ‚ ÑĞ¿Ğ°Ğ¼Ğ°: {user_id} Ğ½Ğ°Ğ¶Ğ¸Ğ¼Ğ°ĞµÑ‚ ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ±Ñ‹ÑÑ‚Ñ€Ğ¾")
        await callback.answer("â±ï¸ ĞŸĞ¾Ğ´Ğ¾Ğ¶Ğ´Ğ¸Ñ‚Ğµ Ğ½ĞµĞ¼Ğ½Ğ¾Ğ³Ğ¾...", show_alert=False)
        return

    last_back_click[user_id] = current_time
    await callback.answer()

    try:
        if state:
            try:
                await state.finish()
            except:
                pass

        user_data = users.get(user_id, {})
        role = user_data.get("role", "unknown").lower()

        logging.info(f"â¬…ï¸ Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğ² Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ: role={role}, user_id={user_id}")

        # âœ… Ğ’Ğ¡Ğ•Ğ“Ğ”Ğ Ğ˜ĞĞ˜Ğ¦Ğ˜ĞĞ›Ğ˜Ğ—Ğ˜Ğ Ğ£Ğ•Ğœ VARIABLES Ğ’ ĞĞĞ§ĞĞ›Ğ•!
        text = f"<b>ğŸ“Š Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ</b>\n\n"
        text += f"ğŸ‘¤ Ğ Ğ¾Ğ»ÑŒ: <b>{role}</b>\n"
        text += f"ğŸ‘¤ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ: {user_data.get('name', 'Unknown')}\n\n"
        text += f"Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ:"

        keyboard = InlineKeyboardMarkup(row_width=1)
        keyboard.add(InlineKeyboardButton("ğŸ“‹ ĞœĞ¾Ğ¸ ÑĞ´ĞµĞ»ĞºĞ¸", callback_data="my_deals"))
        keyboard.add(InlineKeyboardButton("ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°", callback_data="stats"))
        keyboard.add(InlineKeyboardButton("âš™ï¸ ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸", callback_data="settings"))

        # âœ… TRY EDIT
        try:
            await callback.message.edit_text(
                text, reply_markup=keyboard, parse_mode="HTML"
            )
            logging.info(f"âœ… Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ Ğ¾Ñ‚Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾")
        except Exception as e:
            error_str = str(e).lower()
            if "not modified" in error_str:
                logging.info(f"âš ï¸ Ğ¡Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ ÑƒĞ¶Ğµ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ Ñ‚Ğ¾ Ğ¶Ğµ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ğ¼Ğ¾Ğµ")
            else:
                logging.warning(f"âš ï¸ edit_text Ğ¾ÑˆĞ¸Ğ±ĞºĞ°: {error_str}")
                try:
                    await callback.message.answer(
                        text, reply_markup=keyboard, parse_mode="HTML"
                    )
                    logging.info(f"âœ… ĞĞ¾Ğ²Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾")
                except Exception as e2:
                    logging.error(f"âŒ answer Ğ¾ÑˆĞ¸Ğ±ĞºĞ°: {e2}")

    except Exception as e:
        logging.error(f"âŒ ĞšĞ Ğ˜Ğ¢Ğ˜Ğ§Ğ•Ğ¡ĞšĞĞ¯ ĞĞ¨Ğ˜Ğ‘ĞšĞ: {e}", exc_info=True)
        try:
            recovery_kb = InlineKeyboardMarkup()
            recovery_kb.add(
                InlineKeyboardButton("ğŸ  ĞŸĞ¾Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ñ‚ÑŒ", callback_data="back_to_main")
            )
            await callback.message.edit_text(
                f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)[:100]}",
                reply_markup=recovery_kb,
                parse_mode="HTML",
            )
        except:
            pass


# ============================================================================
# Ğ¤Ğ˜Ğ›Ğ¬Ğ¢Ğ  ĞŸĞ Ğ¡Ğ¢ĞĞ¢Ğ£Ğ¡Ğ£
# ============================================================================
@dp.callback_query_handler(lambda q: q.data.startswith("deals_status:"))
async def filter_deals_by_status(callback: types.CallbackQuery):
    """âœ… Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ÑƒĞµÑ‚ ÑĞ´ĞµĞ»ĞºĞ¸ Ğ¿Ğ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°Ğ¼ - Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ"""
    await callback.answer()

    try:
        parts = callback.data.split(":")
        role = parts[1]
        status = parts[2]
        user_id = callback.from_user.id

        logging.info(f"ğŸ“Š Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€: role={role}, status={status}, user_id={user_id}")

        filtered_items = []
        search_status = status.lower()
        logging.info(f"   ğŸ” Ğ˜Ñ‰Ñƒ ÑÑ‚Ğ°Ñ‚ÑƒÑ: '{search_status}'")
        if search_status == "all":
            search_status = "active"

        # âœ… Ğ­ĞœĞĞ”Ğ—Ğ˜ ĞšĞ£Ğ›Ğ¬Ğ¢Ğ£Ğ 
        culture_emoji = {
            "Ğ¿ÑˆĞµĞ½Ğ¸Ñ†Ğ°": "ğŸŒ¾",
            "ÑÑ‡Ğ¼ĞµĞ½ÑŒ": "ğŸŒ¾",
            "ĞºÑƒĞºÑƒÑ€ÑƒĞ·Ğ°": "ğŸŒ½",
            "Ğ¿Ğ¾Ğ´ÑĞ¾Ğ»Ğ½ĞµÑ‡Ğ½Ğ¸Ğº": "ğŸŒ»",
            "ÑĞ¾Ñ": "ğŸ«˜",
            "Ñ€Ğ°Ğ¿Ñ": "ğŸŒ¿",
        }

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ‘¨â€ğŸŒ¾ Ğ¤Ğ•Ğ ĞœĞ•Ğ  - Ğ‘ĞĞ¢Ğ§Ğ˜
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if role == "farmer":
            # âœ… Ğ˜Ğ¡ĞŸĞĞ›Ğ¬Ğ—Ğ£Ğ•Ğœ status_map Ğ”Ğ›Ğ¯ ĞŸĞ Ğ•ĞĞ‘Ğ ĞĞ—ĞĞ’ĞĞĞ˜Ğ¯
            status_map = {
                "active": "âœ… ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ°",
                "in_progress": "ğŸ”„ Ğ’ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğµ",
                "completed": "âœ… Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¾",
                "canceled": "âŒ ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾",
                "reserved": "ğŸ”’ Ğ—Ğ°Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ°",
                "sold": "ğŸ’° ĞŸÑ€Ğ¾Ğ´Ğ°Ğ½Ğ°",
                "filled": "ğŸ“¥ Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½",
                "closed": "ğŸ”’ Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚",
                "cancelled": "âŒ ĞÑ‚Ğ¼ĞµĞ½Ñ‘Ğ½",
                "open": "ğŸ“‚ ĞÑ‚ĞºÑ€Ñ‹Ñ‚",
                "pending": "â³ ĞĞ¶Ğ¸Ğ´Ğ°Ğ½Ğ¸Ğµ",
                "delivered": "ğŸšš Ğ”Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½",
            }

            # âœ… Ğ˜Ğ—Ğ’Ğ›Ğ•ĞšĞĞ•Ğœ Ğ§Ğ˜Ğ¡Ğ¢Ğ«Ğ™ Ğ¡Ğ¢ĞĞ¢Ğ£Ğ¡ (Ğ±ĞµĞ· ÑĞ¼Ğ¾Ğ´Ğ·Ğ¸)
            status_with_emoji = status_map.get(search_status, search_status)
            # Ğ£Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ ÑĞ¼Ğ¾Ğ´Ğ·Ğ¸: 'ğŸ”’ Ğ—Ğ°Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ°' â†’ 'Ğ—Ğ°Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ°'
            clean_status = (
                status_with_emoji.split()[-1]
                if " " in status_with_emoji
                else status_with_emoji
            )

            user_batches = batches.get(user_id, [])
            logging.info(f"   ğŸ“¦ Ğ‘Ğ°Ñ‚Ñ‡ĞµĞ¹ Ñƒ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ°: {len(user_batches)}")
            logging.info(f"   ğŸ” Ğ˜Ñ‰Ñƒ ÑÑ‚Ğ°Ñ‚ÑƒÑ: '{search_status}' â†’ '{clean_status}'")

            for idx, batch in enumerate(user_batches):
                batch_status = batch.get("status", "ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ°")
                logging.info(
                    f"      Ğ‘Ğ°Ñ‚Ñ‡ #{idx}: '{batch.get('culture', 'N/A')}' â†’ ÑÑ‚Ğ°Ñ‚ÑƒÑ='{batch_status}'"
                )

                # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: Ğ¡Ñ€Ğ°Ğ²Ğ½Ğ¸Ğ²Ğ°ĞµĞ¼ Ñ Ñ‡Ğ¸ÑÑ‚Ñ‹Ğ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ¾Ğ¼
                if (
                    batch_status == clean_status
                    or batch_status.lower() == search_status
                ):
                    filtered_items.append(
                        {
                            "index": idx,
                            "culture": batch.get("culture", "N/A"),
                            "volume": batch.get("volume", 0),
                            "price": batch.get("price", 0),
                            "status": batch_status,
                            "id": batch.get("id", f"batch_{idx}"),
                        }
                    )
                    logging.info(f"         âœ… Ğ”ĞĞ‘ĞĞ’Ğ›Ğ•ĞĞ Ğ² Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹!")

            logging.info(
                f"   âœ… Ğ’ÑĞµĞ³Ğ¾ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ±Ğ°Ñ‚Ñ‡ĞµĞ¹: {len(filtered_items)} Ğ¸Ğ· {len(user_batches)}"
            )

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ“¤ Ğ­ĞšĞ¡ĞŸĞĞ Ğ¢Ğ•Ğ  - ĞŸĞ£Ğ›Ğ«
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        elif role == "exporter":
            pull_count = 0
            all_pulls = pulls.get("pulls", {})

            for pull_id, pull in all_pulls.items():
                if not isinstance(pull, dict):
                    continue

                if (
                    pull.get("creator_id") == user_id
                    or pull.get("exporter_id") == user_id
                ):
                    pull_count += 1
                    pull_status = pull.get("status", "ĞÑ‚ĞºÑ€Ñ‹Ñ‚")

                    logging.info(
                        f"      ĞŸÑƒĞ» #{pull.get('id')}: '{pull.get('culture', 'N/A')}' â†’ ÑÑ‚Ğ°Ñ‚ÑƒÑ='{pull_status}'"
                    )

                    if search_status == "all" or pull_status.lower() == search_status:
                        filtered_items.append(
                            {
                                "index": pull.get("id"),
                                "culture": pull.get("culture", "N/A"),
                                "volume": pull.get("current_volume", 0),
                                "target": pull.get("target_volume", 0),
                                "price": pull.get("price_per_ton", 0),
                                "status": pull_status,
                                "id": pull.get("id"),
                            }
                        )
                        logging.info(f"         âœ… Ğ”ĞĞ‘ĞĞ’Ğ›Ğ•Ğ Ğ² Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹!")

            logging.info(
                f"   âœ… Ğ’ÑĞµĞ³Ğ¾ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ¿ÑƒĞ»Ğ¾Ğ²: {len(filtered_items)} Ğ¸Ğ· {pull_count}"
            )

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸšš Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢ - Ğ”ĞĞ¡Ğ¢ĞĞ’ĞšĞ˜
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        elif role == "logist":
            ship_count = 0
            for shipping_id, shipping in shipping_requests.items():
                if shipping.get("logist_id") == user_id:
                    ship_count += 1
                    ship_status = shipping.get("status", "ĞÑ‚ĞºÑ€Ñ‹Ñ‚")

                    logging.info(
                        f"      Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° #{shipping.get('id')}: {shipping.get('from')}â†’{shipping.get('to')} â†’ ÑÑ‚Ğ°Ñ‚ÑƒÑ='{ship_status}'"
                    )

                    if ship_status.lower() == search_status:
                        filtered_items.append(
                            {
                                "index": shipping.get("id"),
                                "from": shipping.get("from", "N/A"),
                                "to": shipping.get("to", "N/A"),
                                "volume": shipping.get("volume", 0),
                                "price": shipping.get("price", 0),
                                "status": ship_status,
                                "id": shipping.get("id"),
                            }
                        )
                        logging.info(f"         âœ… Ğ”ĞĞ‘ĞĞ’Ğ›Ğ•ĞĞ Ğ² Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹!")

            logging.info(
                f"   âœ… Ğ’ÑĞµĞ³Ğ¾ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº: {len(filtered_items)} Ğ¸Ğ· {ship_count}"
            )

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # âœˆï¸ Ğ­ĞšĞ¡ĞŸĞ•Ğ”Ğ˜Ğ¢ĞĞ  - ĞœĞĞ Ğ¨Ğ Ğ£Ğ¢Ğ«
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        elif role == "expeditor":
            offer_count = 0
            for offer_id, offer in expeditor_offers.items():
                if offer.get("expeditor_id") == user_id:
                    offer_count += 1
                    offer_status = offer.get("status", "ĞÑ‚ĞºÑ€Ñ‹Ñ‚")

                    logging.info(
                        f"      ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚ #{offer.get('id')}: {offer.get('from_port')}â†’{offer.get('to_port')} â†’ ÑÑ‚Ğ°Ñ‚ÑƒÑ='{offer_status}'"
                    )

                    if offer_status.lower() == search_status:
                        filtered_items.append(
                            {
                                "index": offer.get("id"),
                                "from": offer.get("from_port", "N/A"),
                                "to": offer.get("to_port", "N/A"),
                                "volume": offer.get("max_volume", 0),
                                "price": offer.get("price", 0),
                                "status": offer_status,
                                "id": offer.get("id"),
                            }
                        )
                        logging.info(f"         âœ… Ğ”ĞĞ‘ĞĞ’Ğ›Ğ•Ğ Ğ² Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹!")

            logging.info(
                f"   âœ… Ğ’ÑĞµĞ³Ğ¾ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ¼Ğ°Ñ€ÑˆÑ€ÑƒÑ‚Ğ¾Ğ²: {len(filtered_items)} Ğ¸Ğ· {offer_count}"
            )

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # âœ… ĞšĞĞœĞŸĞĞšĞ¢ĞĞ«Ğ™ Ğ¢Ğ•ĞšĞ¡Ğ¢
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        status_titles = {
            "active": "ĞĞšĞ¢Ğ˜Ğ’ĞĞ«Ğ•",
            "filled": "Ğ—ĞĞŸĞĞ›ĞĞ•ĞĞĞ«Ğ•",
            "closed": "Ğ—ĞĞšĞ Ğ«Ğ¢Ğ«Ğ•",
            "cancelled": "ĞĞ¢ĞœĞ•ĞĞ•ĞĞĞ«Ğ•",
            "canceled": "ĞĞ¢ĞœĞ•ĞĞ•ĞĞĞ«Ğ•",
            "completed": "Ğ—ĞĞ’Ğ•Ğ Ğ¨Ğ•ĞĞĞ«Ğ•",
        }

        title = status_titles.get(search_status, search_status.upper())

        if filtered_items:
            text = f"<b>âœ… {title}</b> ({len(filtered_items)} ÑˆÑ‚.)\n\n"
            text += "<i>Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ° Ğ´ĞµÑ‚Ğ°Ğ»ĞµĞ¹:</i>"
        else:
            text = f"ğŸ“­ <b>ĞĞµÑ‚ {title.lower()} ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²</b>"
            logging.warning(f"   âš ï¸ ĞĞ• ĞĞĞ™Ğ”Ğ•ĞĞ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ² ÑĞ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ¾Ğ¼ '{search_status}'")

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # âœ… ĞšĞĞĞŸĞšĞ˜ Ğ¡ Ğ­ĞœĞĞ”Ğ—Ğ˜ ĞšĞ£Ğ›Ğ¬Ğ¢Ğ£Ğ 
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        keyboard = InlineKeyboardMarkup(row_width=1)

        if filtered_items:
            for item in filtered_items:
                callback_data = f"deal_detail:{role}:{item['id']}"

                if role == "farmer":
                    culture = item.get("culture", "").lower()
                    emoji = culture_emoji.get(culture, "ğŸŒ¾")
                    button_text = f"{emoji} {item['culture']}"

                elif role == "exporter":
                    culture = item.get("culture", "").lower()
                    emoji = culture_emoji.get(culture, "ğŸŒ¾")
                    progress = 0
                    if item["target"] > 0:
                        progress = (item["volume"] / item["target"]) * 100
                    button_text = f"{emoji} {item['culture']} ({progress:.0f}%)"

                elif role in ["logist", "expeditor"]:
                    button_text = f"ğŸšš {item['from']} â†’ {item['to']}"

                keyboard.add(
                    InlineKeyboardButton(button_text, callback_data=callback_data)
                )

        keyboard.add(InlineKeyboardButton("â—€ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_main"))

        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
        logging.info(f"   âœ… ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¾ {len(filtered_items)} ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ² Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ")

    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ² Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğµ: {e}", exc_info=True)
        await callback.answer(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)[:50]}", show_alert=True)


@dp.callback_query_handler(lambda q: q.data.startswith("deals_status:"))
async def back_to_deals_status_handler(callback: types.CallbackQuery):
    try:
        user_id = callback.from_user.id
        parts = callback.data.split(":")
        role = parts[1]
        status = parts[2]

        logging.info(f"ğŸ“Š Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€: role={role}, status={status}, user_id={user_id}")

        text = ""
        keyboard = InlineKeyboardMarkup()

        # Ğ¤Ğ•Ğ ĞœĞ•Ğ  - ĞœĞĞ˜ ĞŸĞĞ Ğ¢Ğ˜Ğ˜
        if role == "farmer":
            user_batches = batches.get(user_id, [])

            if status == "all":
                deals = user_batches
            else:
                deals = [b for b in user_batches if b.get("status") == status]

            logging.info(f"   âœ… ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹: {len(deals)}")

            if not deals:
                text = f"ğŸ“­ <b>ĞĞµÑ‚ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹</b>\n\n"
                text += "ğŸ“ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ Ğ½Ğ¾Ğ²ÑƒÑ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ!"
                keyboard.add(
                    InlineKeyboardButton(
                        "â• Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ", callback_data="create_batch"
                    )
                )
            else:
                title = (
                    f"<b>ğŸŒ¾ ĞœĞ¾Ğ¸ ĞŸĞ°Ñ€Ñ‚Ğ¸Ğ¸ ({len(deals)})</b>"
                    if status == "all"
                    else f"<b>ğŸŒ¾ ĞŸĞ°Ñ€Ñ‚Ğ¸Ğ¸ - {status.upper()} ({len(deals)})</b>"
                )
                text = title + "\n\n"
                for idx, batch in enumerate(deals):
                    culture = batch.get("culture", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°")
                    volume = batch.get("volume", 0)
                    batch_status = batch.get("status", "Ğ½ĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")
                    text += (
                        f"{idx + 1}. <b>{culture}</b>\n"
                        f"   ğŸ“¦ {volume} Ñ‚ | ğŸ”µ {batch_status}\n\n"
                    )

                for idx, batch in enumerate(deals):
                    keyboard.add(
                        InlineKeyboardButton(
                            f"ğŸ“¦ {batch.get('culture', 'ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ')} - {batch.get('volume', 0)}Ñ‚",
                            callback_data=f"deal_detail:farmer:{idx}:{status}",
                        )
                    )

        # Ğ­ĞšĞ¡ĞŸĞĞ Ğ¢Ğ•Ğ  - ĞœĞĞ˜ ĞŸĞ£Ğ›Ğ«
        elif role == "exporter":
            pulls_dict = pulls.get("pulls", {})
            user_pulls = [
                p for p in pulls_dict.values() if p.get("creator_id") == user_id
            ]

            if status == "all":
                deals = user_pulls
            else:
                deals = [p for p in user_pulls if p.get("status") == status]

            logging.info(f"   âœ… ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ¿ÑƒĞ»Ğ¾Ğ²: {len(deals)}")

            if not deals:
                text = f"ğŸ“­ <b>ĞĞµÑ‚ Ğ¿ÑƒĞ»Ğ¾Ğ²</b>\n\n"
                text += "ğŸ“ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ¿ÑƒĞ»Ğ»!"
                keyboard.add(
                    InlineKeyboardButton("â• Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¿ÑƒĞ»Ğ»", callback_data="create_pull")
                )
            else:
                title = (
                    f"<b>ğŸ“¤ ĞœĞ¾Ğ¸ ĞŸÑƒĞ»Ñ‹ ({len(deals)})</b>"
                    if status == "all"
                    else f"<b>ğŸ“¤ ĞŸÑƒĞ»Ñ‹ - {status.upper()} ({len(deals)})</b>"
                )
                text = title + "\n\n"
                for pull in deals:
                    culture = pull.get("culture", "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°")
                    current_vol = pull.get("current_volume", 0)
                    target_vol = pull.get("target_volume", 0)
                    pull_status = pull.get("status", "Ğ½ĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")
                    farmer_count = len(pull.get("farmer_ids", []))

                    text += (
                        f"<b>ğŸŒ¾ {culture}</b>\n"
                        f"ğŸ“¦ {current_vol}/{target_vol} Ñ‚ | ğŸ‘¥ {farmer_count} Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ²\n"
                        f"ğŸ”µ {pull_status}\n\n"
                    )

                for pull in deals:
                    pull_id = pull.get("id")
                    keyboard.add(
                        InlineKeyboardButton(
                            f"ğŸ“¤ {pull.get('culture', 'ĞŸÑƒĞ»')} - {pull.get('current_volume', 0)}/{pull.get('target_volume', 0)}Ñ‚",
                            callback_data=f"deal_detail:exporter:{pull_id}:{status}",
                        )
                    )

        # Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢ - ĞœĞĞ˜ Ğ”ĞĞ¡Ğ¢ĞĞ’ĞšĞ˜
        elif role == "logist":
            user_shippings = [
                s for s in shipping_requests.values() if s.get("logist_id") == user_id
            ]

            if status == "all":
                deals = user_shippings
            else:
                deals = [s for s in user_shippings if s.get("status") == status]

            logging.info(f"   âœ… ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº: {len(deals)}")

            if not deals:
                text = f"ğŸ“­ <b>ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº</b>\n\n"
                text += "ğŸ“ ĞĞ¶Ğ¸Ğ´Ğ°Ğ¹Ñ‚Ğµ Ğ½Ğ¾Ğ²Ñ‹Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸!"
                keyboard.add(
                    InlineKeyboardButton(
                        "ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="view_shipping_requests"
                    )
                )
            else:
                title = (
                    f"<b>ğŸšš ĞœĞ¾Ğ¸ Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸ ({len(deals)})</b>"
                    if status == "all"
                    else f"<b>ğŸšš Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸ - {status.upper()} ({len(deals)})</b>"
                )
                text = title + "\n\n"
                for shipping in deals:
                    from_city = shipping.get("from", "â€”")
                    to_city = shipping.get("to", "â€”")
                    volume = shipping.get("volume", 0)
                    ship_status = shipping.get("status", "Ğ½ĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")

                    text += (
                        f"<b>ğŸ“¤ {from_city} â†’ ğŸ“¥ {to_city}</b>\n"
                        f"ğŸ“¦ {volume} Ñ‚ | ğŸ”µ {ship_status}\n\n"
                    )

                for shipping in deals:
                    shipping_id = shipping.get("id")
                    keyboard.add(
                        InlineKeyboardButton(
                            f"ğŸšš {shipping.get('from', 'ĞÑ‚')} â†’ {shipping.get('to', 'Ğ’')}",
                            callback_data=f"deal_detail:logist:{shipping_id}:{status}",
                        )
                    )

        # Ğ­ĞšĞ¡ĞŸĞ•Ğ”Ğ˜Ğ¢ĞĞ  - ĞœĞĞ˜ ĞœĞĞ Ğ¨Ğ Ğ£Ğ¢Ğ«
        elif role == "expeditor":
            user_offers = [
                o for o in expeditor_offers.values() if o.get("expeditor_id") == user_id
            ]

            if status == "all":
                deals = user_offers
            else:
                deals = [o for o in user_offers if o.get("status") == status]

            logging.info(f"   âœ… ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ¼Ğ°Ñ€ÑˆÑ€ÑƒÑ‚Ğ¾Ğ²: {len(deals)}")

            if not deals:
                text = f"ğŸ“­ <b>ĞĞµÑ‚ Ğ¼Ğ°Ñ€ÑˆÑ€ÑƒÑ‚Ğ¾Ğ²</b>\n\n"
                text += "ğŸ“ ĞĞ¶Ğ¸Ğ´Ğ°Ğ¹Ñ‚Ğµ Ğ½Ğ¾Ğ²Ñ‹Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ!"
                keyboard.add(
                    InlineKeyboardButton(
                        "ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="view_expeditor_offers"
                    )
                )
            else:
                title = (
                    f"<b>âœˆï¸ ĞœĞ¾Ğ¸ ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚Ñ‹ ({len(deals)})</b>"
                    if status == "all"
                    else f"<b>âœˆï¸ ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚Ñ‹ - {status.upper()} ({len(deals)})</b>"
                )
                text = title + "\n\n"
                for offer in deals:
                    from_port = offer.get("from_port", "â€”")
                    to_port = offer.get("to_port", "â€”")
                    max_vol = offer.get("max_volume", 0)
                    offer_status = offer.get("status", "Ğ½ĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")

                    text += (
                        f"<b>â›´ï¸ {from_port} â†’ ğŸï¸ {to_port}</b>\n"
                        f"ğŸ“¦ {max_vol} Ñ‚ | ğŸ”µ {offer_status}\n\n"
                    )

                for offer in deals:
                    offer_id = offer.get("id")
                    keyboard.add(
                        InlineKeyboardButton(
                            f"âœˆï¸ {offer.get('from_port', 'ĞÑ‚')} â†’ {offer.get('to_port', 'Ğ’')}",
                            callback_data=f"deal_detail:expeditor:{offer_id}:{status}",
                        )
                    )

        else:
            text = "âŒ <b>ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ°Ñ Ñ€Ğ¾Ğ»ÑŒ!</b>"

        # ĞšĞ½Ğ¾Ğ¿ĞºĞ° "Ğ’ Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ"
        keyboard.add(
            InlineKeyboardButton("ğŸ“Š Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main")
        )

        try:
            await callback.message.edit_text(
                text, reply_markup=keyboard, parse_mode="HTML"
            )
            logging.info(f"   âœ… Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº ÑĞ´ĞµĞ»Ğ¾Ğº Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½ Ğ´Ğ»Ñ {role}")
        except Exception as edit_error:
            logging.error(f"   âŒ ĞÑˆĞ¸Ğ±ĞºĞ° edit_text: {edit_error}")
            try:
                await callback.message.answer(
                    text, reply_markup=keyboard, parse_mode="HTML"
                )
            except Exception as answer_error:
                logging.error(f"   âŒ ĞÑˆĞ¸Ğ±ĞºĞ° answer: {answer_error}")
                await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞµ ÑĞ¿Ğ¸ÑĞºĞ°", show_alert=True)

    except Exception as e:
        logging.error(f"âŒ ĞĞ¨Ğ˜Ğ‘ĞšĞ Ğ² back_to_deals_status: {e}", exc_info=True)
        try:
            keyboard = InlineKeyboardMarkup()
            keyboard.add(
                InlineKeyboardButton("ğŸ“Š Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="main_menu")
            )
            await callback.message.edit_text(
                f"âŒ <b>ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞµ ÑĞ¿Ğ¸ÑĞºĞ°:</b>\n<code>{str(e)[:100]}</code>",
                reply_markup=keyboard,
                parse_mode="HTML",
            )
        except:
            await callback.answer(
                f"âŒ ĞšÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¾ÑˆĞ¸Ğ±ĞºĞ°: {str(e)[:50]}", show_alert=True
            )


# ============================================================================
# ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜Ğš Ğ”Ğ•Ğ¢ĞĞ›Ğ•Ğ™ Ğ¡Ğ”Ğ•Ğ›ĞšĞ˜ - ĞŸĞĞ›ĞĞĞ¯ Ğ˜ĞĞ¤ĞĞ ĞœĞĞ¦Ğ˜Ğ¯ ĞĞ‘Ğ Ğ’Ğ¡Ğ•Ğ™ Ğ¦Ğ•ĞŸĞĞ§ĞšĞ•
# ============================================================================
# ============================================================================
# ğŸ  Ğ“Ğ›ĞĞ’ĞĞĞ• ĞœĞ•ĞĞ® - Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº
# ============================================================================
@dp.callback_query_handler(lambda q: q.data in ("main_menu", "back_to_main"))
async def go_main_menu(callback: types.CallbackQuery):
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğ² Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ"""
    await callback.answer()

    user_id = callback.from_user.id

    if user_id not in users:
        await callback.answer("âŒ Ğ’Ñ‹ Ğ½Ğµ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹", show_alert=True)
        return

    user_role = users[user_id].get("role", "unknown").lower()

    text = f"<b>ğŸ“Š Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ</b>\n\n"
    text += f"ğŸ‘¤ Ğ Ğ¾Ğ»ÑŒ: <b>{user_role}</b>\n"
    text += f"ğŸ‘¤ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ: {users[user_id].get('name', 'Unknown')}\n\n"
    text += f"Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ¸Ğ· ĞºĞ½Ğ¾Ğ¿Ğ¾Ğº Ğ½Ğ¸Ğ¶Ğµ:"
    try:
        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    except:
        await callback.message.answer(text, reply_markup=keyboard, parse_mode="HTML")

    logging.info(f"âœ… Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¾ Ğ´Ğ»Ñ {user_role}")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ’Ğ¡ĞŸĞĞœĞĞ“ĞĞ¢Ğ•Ğ›Ğ¬ĞĞ«Ğ• Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ˜
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ“Ğ›ĞĞ‘ĞĞ›Ğ¬ĞĞ«Ğ• Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ˜
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


def get_safe_float(value, default=0):
    """Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ Ğ¿Ñ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·ÑƒĞµÑ‚ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ² float"""
    if value is None:
        return default
    try:
        return float(value)
    except (ValueError, TypeError):
        return default


def get_pull_by_batch_v3(batch_id):
    """âœ… ĞĞšĞĞĞ§ĞĞ¢Ğ•Ğ›Ğ¬ĞĞĞ¯ Ğ’Ğ•Ğ Ğ¡Ğ˜Ğ¯: ĞŸĞ¾Ğ¸ÑĞº Ğ¿ÑƒĞ»Ğ° Ğ¿Ğ¾ batch_id"""
    try:
        global pulls

        # ĞĞ¾Ñ€Ğ¼Ğ°Ğ»Ğ¸Ğ·ÑƒĞµĞ¼ batch_id Ğº int
        try:
            search_batch_id = int(batch_id)
        except (ValueError, TypeError):
            logging.error(f"âŒ ĞĞµĞ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¿Ñ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ batch_id={batch_id} Ğ² int")
            return None, None

        logging.info(
            f"ğŸ” Ğ˜Ñ‰Ñƒ Ğ¿ÑƒĞ» Ğ´Ğ»Ñ batch_id={search_batch_id} (type={type(search_batch_id).__name__})"
        )

        # âœ… Ğ“Ğ›ĞĞ’ĞĞ«Ğ™ Ğ˜Ğ¡Ğ¢ĞĞ§ĞĞ˜Ğš: pullparticipants
        pullparticipants = pulls.get("pullparticipants", {})
        logging.info(f"ğŸ“‹ pullparticipants.keys() = {list(pullparticipants.keys())}")

        if not pullparticipants:
            logging.warning(f"âš ï¸ pullparticipants Ğ¿ÑƒÑÑ‚Ğ°!")
            return None, None

        # Ğ˜Ñ‰ĞµĞ¼ Ñ‡ĞµÑ€ĞµĞ· Ğ’Ğ¡Ğ• Ğ¿ÑƒĞ»Ñ‹
        for pull_id, participants_list in pullparticipants.items():
            logging.info(
                f"   ğŸ” ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑÑ pull_id={pull_id} (type={type(pull_id).__name__})"
            )

            # participants_list Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ±Ñ‹Ñ‚ÑŒ ÑĞ¿Ğ¸ÑĞ¾Ğº
            if not isinstance(participants_list, list):
                logging.warning(
                    f"      âš ï¸ participants Ğ´Ğ»Ñ pull_id={pull_id} ĞĞ• ÑĞ¿Ğ¸ÑĞ¾Ğº! type={type(participants_list)}"
                )
                continue

            logging.info(
                f"      ğŸ“ Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² Ğ² pull_id={pull_id}: {len(participants_list)}"
            )

            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ°
            for idx, participant in enumerate(participants_list):
                if not isinstance(participant, dict):
                    logging.warning(f"         âš ï¸ Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸Ğº {idx} ĞĞ• dict!")
                    continue

                participant_batch_id = participant.get("batch_id")
                logging.info(
                    f"         ğŸ‘¤ Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸Ğº {idx}: batch_id={participant_batch_id} (type={type(participant_batch_id).__name__})"
                )

                # âœ… ĞšĞ›Ğ®Ğ§Ğ•Ğ’ĞĞ• Ğ¡Ğ ĞĞ’ĞĞ•ĞĞ˜Ğ•
                if participant_batch_id == search_batch_id:
                    logging.info(
                        f"         ğŸ¯ ĞœĞĞ¢Ğ§! {participant_batch_id} == {search_batch_id}"
                    )

                    # Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ¸Ñ‰ĞµĞ¼ ÑĞ°Ğ¼ Ğ¿ÑƒĞ» Ğ² pulls['pulls']
                    pulls_dict = pulls.get("pulls", {})
                    logging.info(
                        f"         ğŸ“¦ pulls['pulls'].keys() = {list(pulls_dict.keys())}"
                    )

                    # ĞŸÑƒĞ» Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ Ñ ĞºĞ»ÑÑ‡Ğ¾Ğ¼ str Ğ¸Ğ»Ğ¸ int
                    pull = (
                        pulls_dict.get(pull_id)
                        or pulls_dict.get(
                            int(pull_id) if str(pull_id).isdigit() else none
                        )
                        or pulls_dict.get(
                            int(pull_id)
                            if isinstance(pull_id, str) and pull_id.isdigit()
                            else None
                        )
                    )

                    if pull:
                        logging.info(
                            f"         âœ…âœ…âœ… Ğ£Ğ¡ĞŸĞ•Ğ¥! ĞĞ°Ğ¹Ğ´ĞµĞ½ Ğ¿ÑƒĞ» pull_id={pull_id}"
                        )
                        logging.info(
                            f"              ĞŸÑƒĞ» Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ: culture={pull.get('culture')}, volume={pull.get('current_volume')}/{pull.get('target_volume')}"
                        )
                        return pull, str(pull_id)
                    else:
                        logging.warning(
                            f"         âš ï¸ ĞŸÑƒĞ» pull_id={pull_id} ĞĞ• Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ Ğ² pulls['pulls']!"
                        )

        logging.warning(f"âŒ batch_id={search_batch_id} Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ° Ğ½Ğ¸ Ğ² Ğ¾Ğ´Ğ½Ğ¾Ğ¼ Ğ¿ÑƒĞ»Ğµ")
        return None, None

    except Exception as e:
        logging.error(f"âŒ ĞĞ¨Ğ˜Ğ‘ĞšĞ Ğ² get_pull_by_batch_v3: {e}", exc_info=True)
        return None, None


def get_batches_by_pull(pull_id):
    """ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ²ÑĞµ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ¿ÑƒĞ»Ğ°"""
    try:
        pulls_dict = pulls.get("pulls", {})
        if isinstance(pulls_dict.get(pull_id), dict):
            return pulls_dict[pull_id].get("batch_ids", []) or pulls_dict[pull_id].get(
                "batches", []
            )
    except:
        pass
    return []


def get_farmers_by_pull(pull_id):
    """ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ²ÑĞµÑ… Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ² Ğ¿ÑƒĞ»Ğ°"""
    try:
        pulls_dict = pulls.get("pulls", {})
        if isinstance(pulls_dict.get(pull_id), dict):
            return pulls_dict[pull_id].get("farmer_ids", []) or pulls_dict[pull_id].get(
                "participants", []
            )
    except:
        pass
    return []


def get_logistics_for_pull(pull_id):
    """ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ Ğ´Ğ»Ñ Ğ¿ÑƒĞ»Ğ°"""
    try:
        for logistic_id, logistic in logistics_requests.items():
            if logistic.get("pull_id") == pull_id:
                return logistic, logistic_id
    except:
        pass
    return None, None


def get_expeditors_data(logistics_id=None):
    """ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²"""
    expeditors_list = []
    try:
        for exp_id, expeditor in expeditor_cards.items():
            if logistics_id is None or expeditor.get("logistics_id") == logistics_id:
                expeditors_list.append((expeditor, exp_id))
    except:
        pass
    return expeditors_list


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ“Ğ›ĞĞ’ĞĞĞ¯ Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ¯ - Ğ”Ğ›Ğ¯ Ğ’Ğ¡Ğ•Ğ¥ Ğ ĞĞ›Ğ•Ğ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


@dp.callback_query_handler(lambda q: q.data.startswith("deal_detail:"))
async def show_deal_detail(callback: types.CallbackQuery):
    """âœ… Ğ¤Ğ˜ĞĞĞ›Ğ¬ĞĞ«Ğ™ ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜Ğš: ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ/Ğ¿ÑƒĞ»/Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ ÑĞ¾ Ğ’Ğ¡Ğ•ĞœĞ˜ Ğ£Ğ§ĞĞ¡Ğ¢ĞĞ˜ĞšĞĞœĞ˜"""
    await callback.answer()

    try:
        global batches, pulls, users, logistics_requests, expeditor_cards

        parts = callback.data.split(":")
        role = parts[1]
        item_id = parts[2]
        user_id = callback.from_user.id

        logging.info(f"ğŸ” Ğ¡Ğ´ĞµĞ»ĞºĞ°: role={role}, item_id={item_id}, user_id={user_id}")

        text = ""
        keyboard = InlineKeyboardMarkup()

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Ğ’Ğ›ĞĞ–Ğ•ĞĞĞ«Ğ• Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ˜
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        def get_safe_float(val, default=0):
            """Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ ĞºĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ² float"""
            try:
                if val is None or val == "â€”":
                    return default
                return float(val)
            except:
                return default

        def get_pull_by_batch_v3(batch_id):
            """âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞĞĞ¯: ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ Ğ¿ÑƒĞ» Ğ¿Ğ¾ batch_id Ğ¸Ğ· pullparticipants"""
            try:
                search_batch_id = int(batch_id)
            except (ValueError, TypeError):
                logging.error(f"âŒ ĞĞµĞ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¿Ñ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ batch_id={batch_id}")
                return None, None

            try:
                # âœ… Ğ“Ğ›ĞĞ’ĞĞ«Ğ™ Ğ˜Ğ¡Ğ¢ĞĞ§ĞĞ˜Ğš: pullparticipants
                pullparticipants = pulls.get("pullparticipants", {})
                logging.info(
                    f"ğŸ” pullparticipants.keys() = {list(pullparticipants.keys())}"
                )

                # Ğ˜Ñ‰ĞµĞ¼ Ğ² pullparticipants
                for pull_id_str, participants_list in pullparticipants.items():
                    if not isinstance(participants_list, list):
                        logging.warning(
                            f"âš ï¸ pull_id={pull_id_str} participants ĞĞ• ÑĞ¿Ğ¸ÑĞ¾Ğº!"
                        )
                        continue

                    for participant in participants_list:
                        if not isinstance(participant, dict):
                            continue

                        participant_batch_id = participant.get("batch_id")
                        logging.info(
                            f"   ğŸ‘¤ ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑÑ batch_id={participant_batch_id} == {search_batch_id}"
                        )

                        if participant_batch_id == search_batch_id:
                            logging.info(f"   âœ… ĞœĞĞ¢Ğ§ ĞĞĞ™Ğ”Ğ•Ğ Ğ² pull_id={pull_id_str}")

                            # Ğ”Ğ¾ÑÑ‚Ğ°Ñ‘Ğ¼ ÑĞ°Ğ¼ Ğ¿ÑƒĞ»
                            pulls_dict = pulls.get("pulls", {})
                            pull = pulls_dict.get(pull_id_str) or pulls_dict.get(
                                int(pull_id_str)
                                if isinstance(pull_id_str, str)
                                and pull_id_str.isdigit()
                                else None
                            )

                            if pull:
                                logging.info(
                                    f"   âœ…âœ… ĞŸĞ£Ğ›Ğ ĞĞĞ™Ğ”Ğ•Ğ! pull_id={pull_id_str}"
                                )
                                return pull, str(pull_id_str)
                            else:
                                logging.warning(f"   âš ï¸ ĞŸÑƒĞ» ĞĞ• Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ Ğ² pulls['pulls']!")

                logging.warning(
                    f"âŒ batch_id={search_batch_id} Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ° ĞĞ˜ Ğ’ ĞĞ”ĞĞĞœ Ğ¿ÑƒĞ»Ğµ"
                )
                return None, None

            except Exception as e:
                logging.error(f"âŒ get_pull_by_batch_v3 Ğ¾ÑˆĞ¸Ğ±ĞºĞ°: {e}", exc_info=True)
                return None, None

        def get_batch_participants_in_pull(pull_id):
            """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ Ğ²ÑĞµÑ… Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ² Ğ¸ Ğ¸Ñ… Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸ Ğ² Ğ¿ÑƒĞ»Ğµ"""
            try:
                pullparticipants = pulls.get("pullparticipants", {})
                participants = pullparticipants.get(str(pull_id), [])

                if isinstance(participants, list):
                    return participants

                return []
            except Exception as e:
                logging.error(f"âŒ get_batch_participants_in_pull: {e}")
                return []

        def get_logistics_by_pull(pull_id):
            """ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºÑƒ Ğ¿Ğ¾ ID Ğ¿ÑƒĞ»Ğ°"""
            try:
                for logistic_id, logistic in logistics_requests.items():
                    pull_ref = logistic.get("pull_id")
                    if pull_ref == pull_id or str(pull_ref) == str(pull_id):
                        return logistic, logistic_id
            except:
                pass
            return None, None

        def get_expeditors_by_logistics(logistics_id):
            """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ ÑĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ² Ğ´Ğ»Ñ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¸ĞºĞ¸"""
            expeditors_list = []
            try:
                for exp_id, expeditor in expeditor_cards.items():
                    if str(expeditor.get("logistics_id")) == str(logistics_id):
                        expeditors_list.append((expeditor, exp_id))
            except:
                pass
            return expeditors_list

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ‘¨â€ğŸŒ¾ Ğ¤Ğ•Ğ ĞœĞ•Ğ  - ĞŸĞĞ Ğ¢Ğ˜Ğ¯ + ĞŸĞ£Ğ› + Ğ£Ğ§ĞĞ¡Ğ¢ĞĞ˜ĞšĞ˜
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if role == "farmer":
            user_batches = batches.get(user_id, [])
            try:
                batch_id = int(item_id)  # âœ… item_id Ñ‚ĞµĞ¿ĞµÑ€ÑŒ ÑÑ‚Ğ¾ ID Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸

                # âœ… Ğ˜Ñ‰ĞµĞ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ Ğ¿Ğ¾ ID, Ğ° Ğ½Ğµ Ğ¿Ğ¾ Ğ¸Ğ½Ğ´ĞµĞºÑÑƒ
                batch = None
                batch_idx = None
                for idx, b in enumerate(user_batches):
                    if b.get("id") == batch_id:
                        batch = b
                        batch_idx = idx
                        break

                if not batch:
                    text = "âŒ <b>ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°</b>"
                else:
                    logging.info(f"ğŸ“Š Ğ¤ĞµÑ€Ğ¼ĞµÑ€ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ°Ñ‚Ñ€Ğ¸Ğ²Ğ°ĞµÑ‚: batch_id={batch_id}")

                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    # ĞŸĞĞ Ğ¢Ğ˜Ğ¯
                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    volume = get_safe_float(batch.get("volume"), 0)
                    price_per_ton = get_safe_float(
                        batch.get("price"), 0
                    ) or get_safe_float(batch.get("price_per_ton"), 0)
                    total_price = volume * price_per_ton

                    humidity = batch.get("humidity", "â€”")
                    if humidity and humidity != "â€”":
                        humidity = f"{get_safe_float(humidity):.1f}%"

                    impurity = batch.get("impurity", "â€”")
                    if impurity and impurity != "â€”":
                        impurity = f"{get_safe_float(impurity):.1f}%"

                    text = f"<b>ğŸ“‹ ĞŸĞĞ Ğ¢Ğ˜Ğ¯ Ğ˜ Ğ’Ğ¡Ğ• Ğ£Ğ§ĞĞ¡Ğ¢ĞĞ˜ĞšĞ˜</b>\n\n"
                    text += f"<b>ğŸŒ¾ ĞŸĞĞ Ğ¢Ğ˜Ğ¯</b>\n"
                    text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                    text += (
                        f"ğŸŒ± ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: <b>{batch.get('culture', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}</b>\n"
                    )
                    text += f"ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: <b>{volume:,.1f} Ñ‚</b>\n"
                    text += f"ğŸ’° Ğ¦ĞµĞ½Ğ°/Ñ‚Ğ¾Ğ½Ğ½Ğ°: <b>{price_per_ton:,.1f} â‚½</b>\n"
                    text += f"ğŸ’µ Ğ¡ÑƒĞ¼Ğ¼Ğ°: <b>{total_price:,.0f} â‚½</b>\n"
                    text += f"ğŸ’§ Ğ’Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ: <b>{humidity}</b>\n"
                    text += f"ğŸ—‘ï¸ ĞŸÑ€Ğ¸Ğ¼ĞµÑĞ¸: <b>{impurity}</b>\n"
                    text += f"â­ ĞšĞ»Ğ°ÑÑ: <b>{batch.get('quality_class', 'â€”')}</b>\n"
                    text += f"ğŸ“… Ğ”Ğ°Ñ‚Ğ°: <b>{batch.get('created_at', 'N/A')}</b>\n"

                    # Ğ¤ĞĞ™Ğ›Ğ«
                    files = batch.get("files", [])
                    if files:
                        text += f"\n<b>ğŸ“„ Ğ¤ĞĞ™Ğ›Ğ« ({len(files)})</b>\n"
                        text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                        for f_item in files:
                            size_kb = f_item.get("size", 0) / 1024
                            text += (
                                f"ğŸ“ {f_item.get('name', 'Ğ¤Ğ°Ğ¹Ğ»')} ({size_kb:.1f} KB)\n"
                            )
                    else:
                        text += f"\n<b>ğŸ“„ Ğ¤ĞĞ™Ğ›Ğ«</b>\n"
                        text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                        text += f"âŒ ĞĞµÑ‚ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²\n"

                    # Ğ ĞĞ¡Ğ§ĞĞ¢ Ğ¡Ğ¢ĞĞ˜ĞœĞĞ¡Ğ¢Ğ˜
                    base_cost = volume * price_per_ton
                    quality_multiplier = 1.0
                    quality_class = batch.get("quality_class", "")
                    if "1" in quality_class or "2" in quality_class:
                        quality_multiplier = 1.1
                    elif "4" in quality_class or "5" in quality_class:
                        quality_multiplier = 0.9

                    humidity_val = get_safe_float(batch.get("humidity"), 13)
                    humidity_cost = 0
                    if humidity_val < 10 or humidity_val > 15:
                        humidity_cost = base_cost * 0.05

                    impurity_val = get_safe_float(batch.get("impurity"), 1)
                    impurity_cost = 0
                    if impurity_val > 2:
                        impurity_cost = base_cost * 0.1

                    storage_cost = base_cost * 0.02
                    total_cost = (
                        (base_cost * quality_multiplier)
                        - humidity_cost
                        - impurity_cost
                        + storage_cost
                    )

                    text += f"\n<b>ğŸ’° Ğ ĞĞ¡Ğ§ĞĞ¢ Ğ¡Ğ¢ĞĞ˜ĞœĞĞ¡Ğ¢Ğ˜</b>\n"
                    text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                    text += f"Ğ‘Ğ°Ğ·Ğ¾Ğ²Ğ°Ñ: <b>{base_cost:,.0f} â‚½</b>\n"
                    text += f"Ã—{quality_multiplier} (ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ¾): <b>{base_cost * quality_multiplier:,.0f} â‚½</b>\n"
                    text += f"â€“{humidity_cost:,.0f} (Ğ²Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ)\n"
                    text += f"â€“{impurity_cost:,.0f} (Ğ¿Ñ€Ğ¸Ğ¼ĞµÑĞ¸)\n"
                    text += f"+{storage_cost:,.0f} (Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ)\n"
                    text += f"<b>Ğ˜Ğ¢ĞĞ“Ğ: {total_cost:,.0f} â‚½</b>\n"

                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    # Ğ¤Ğ•Ğ ĞœĞ•Ğ 
                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    text += f"\n<b>ğŸ‘¨â€ğŸŒ¾ Ğ’Ğ« (Ğ¤Ğ•Ğ ĞœĞ•Ğ )</b>\n"
                    text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                    farmer = users.get(user_id, {})
                    text += f"ğŸ‘¤ Ğ˜Ğ¼Ñ: <b>{farmer.get('name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}</b>\n"
                    text += f"â˜ï¸ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <b>{farmer.get('phone', 'â€”')}</b>\n"
                    text += f"ğŸ“ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½: <b>{farmer.get('region', 'â€”')}</b>\n"

                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    # âœ… ĞŸĞĞ˜Ğ¡Ğš ĞŸĞ£Ğ› ĞŸĞ ĞŸĞĞ Ğ¢Ğ˜Ğ˜
                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    pull, pull_id = get_pull_by_batch_v3(batch_id)
                    if pull and pull_id:
                        logging.info(f"âœ… ĞŸÑƒĞ» Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ Ğ´Ğ»Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸!")

                        # ĞŸĞ£Ğ›
                        text += f"\n<b>ğŸ“¤ ĞŸĞ£Ğ› (#{pull_id})</b>\n"
                        text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                        text += f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: <b>{pull.get('culture', 'â€”')}</b>\n"
                        text += f"ğŸ“¦ ĞĞ±ÑŠÑ‘Ğ¼: <b>{pull.get('current_volume', 0):,.1f}/{pull.get('target_volume', 0):,.1f} Ñ‚</b>\n"
                        text += f"ğŸ—ï¸ ĞŸĞ¾Ñ€Ñ‚: <b>{pull.get('port', 'â€”')}</b>\n"
                        text += (
                            f"ğŸ’° Ğ¦ĞµĞ½Ğ°/Ñ‚: <b>{pull.get('price_per_ton', 0):,.1f} â‚½</b>\n"
                        )

                        # Ğ­ĞšĞ¡ĞŸĞĞ Ğ¢Ğ•Ğ 
                        exporter_id = pull.get("exporter_id") or pull.get("creator_id")
                        if exporter_id and exporter_id in users:
                            exporter = users[exporter_id]
                            text += f"\n<b>ğŸ“¤ Ğ­ĞšĞ¡ĞŸĞĞ Ğ¢Ğ•Ğ </b>\n"
                            text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                            text += (
                                f"ğŸ‘¤ Ğ˜Ğ¼Ñ: <b>{exporter.get('name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}</b>\n"
                            )
                            text += f"â˜ï¸ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <b>{exporter.get('phone', 'â€”')}</b>\n"
                            text += f"ğŸ“ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½: <b>{exporter.get('region', 'â€”')}</b>\n"

                        # Ğ’Ğ¡Ğ• Ğ¤Ğ•Ğ ĞœĞ•Ğ Ğ« Ğ’ ĞŸĞ£Ğ›Ğ•
                        participants = get_batch_participants_in_pull(pull_id)
                        if participants:
                            text += (
                                f"\n<b>ğŸ‘¨â€ğŸŒ¾ Ğ¤Ğ•Ğ ĞœĞ•Ğ Ğ« Ğ’ ĞŸĞ£Ğ›Ğ• ({len(participants)})</b>\n"
                            )
                            text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                            for idx_p, p in enumerate(participants, 1):
                                text += f"{idx_p}. <b>{p.get('farmer_name', 'Unknown')}</b>\n"
                                text += f"   ğŸ“¦ {p.get('volume', 0):,.1f} Ñ‚\n"

                        # Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢
                        logistics, logistics_id = get_logistics_by_pull(pull_id)
                        if logistics and logistics.get("logist_id") in users:
                            logist = users[logistics["logist_id"]]
                            text += f"\n<b>ğŸšš Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢</b>\n"
                            text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                            text += (
                                f"ğŸ‘¤ Ğ˜Ğ¼Ñ: <b>{logist.get('name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}</b>\n"
                            )
                            text += f"â˜ï¸ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <b>{logist.get('phone', 'â€”')}</b>\n"
                            text += (
                                f"ğŸ“¤ ĞÑ‚: <b>{logistics.get('route_from', 'â€”')}</b>\n"
                            )
                            text += (
                                f"ğŸ“¥ ĞšÑƒĞ´Ğ°: <b>{logistics.get('route_to', 'â€”')}</b>\n"
                            )

                            # Ğ­ĞšĞ¡ĞŸĞ•Ğ”Ğ˜Ğ¢ĞĞ Ğ«
                            expeditors_list = get_expeditors_by_logistics(logistics_id)
                            if expeditors_list:
                                text += (
                                    f"\n<b>âœˆï¸ Ğ­ĞšĞ¡ĞŸĞ•Ğ”Ğ˜Ğ¢ĞĞ Ğ« ({len(expeditors_list)})</b>\n"
                                )
                                text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                                for idx_exp, (expeditor, exp_id) in enumerate(
                                    expeditors_list, 1
                                ):
                                    exp_user_id = expeditor.get("user_id")
                                    if exp_user_id and exp_user_id in users:
                                        expeditor_user = users[exp_user_id]
                                        text += f"{idx_exp}. <b>{expeditor_user.get('name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}</b>\n"
                                        text += (
                                            f"   â˜ï¸ {expeditor_user.get('phone', 'â€”')}\n"
                                        )
                                        text += f"   ğŸš¢ {expeditor.get('vehicle_type', 'â€”')}\n"
                    else:
                        text += f"\n<b>âŒ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ½Ğµ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ° Ğ² Ğ¿ÑƒĞ»</b>\n"

            except (ValueError, IndexError) as e:
                logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ñ„ĞµÑ€Ğ¼ĞµÑ€: {e}")
                text = "âŒ <b>ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ½ĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ ID Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸</b>"

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ“¤ Ğ­ĞšĞ¡ĞŸĞĞ Ğ¢Ğ•Ğ 
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        elif role == "exporter":
            try:
                pull_id = str(item_id)
                pulls_dict = pulls.get("pulls", {})
                pull = pulls_dict.get(pull_id) or pulls_dict.get(
                    int(pull_id) if str(pull_id).isdigit() else None
                )

                if not pull:
                    text = "âŒ <b>ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½</b>"
                else:
                    target_volume = get_safe_float(pull.get("target_volume"), 0)
                    current_volume = get_safe_float(pull.get("current_volume"), 0)
                    price_per_ton = get_safe_float(
                        pull.get("price_per_ton"), 0
                    ) or get_safe_float(pull.get("price"), 0)
                    progress = (
                        (current_volume / target_volume * 100)
                        if target_volume > 0
                        else 0
                    )
                    total_price = current_volume * price_per_ton

                    # ĞŸĞ£Ğ›
                    text = f"<b>ğŸ“‹ ĞŸĞ£Ğ› Ğ˜ Ğ’Ğ¡Ğ• Ğ£Ğ§ĞĞ¡Ğ¢ĞĞ˜ĞšĞ˜</b>\n\n"
                    text += f"<b>ğŸ“¤ ĞŸĞ£Ğ› (#{pull_id})</b>\n"
                    text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                    text += f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: <b>{pull.get('culture', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}</b>\n"
                    text += f"ğŸ¯ ĞĞ±ÑŠÑ‘Ğ¼: <b>{current_volume:,.1f}/{target_volume:,.1f} Ñ‚ ({progress:.0f}%)</b>\n"
                    text += f"ğŸ’° Ğ¦ĞµĞ½Ğ°/Ñ‚: <b>{price_per_ton:,.1f} â‚½</b>\n"
                    text += f"ğŸ’µ Ğ¡ÑƒĞ¼Ğ¼Ğ°: <b>{total_price:,.0f} â‚½</b>\n"
                    text += f"ğŸ—ï¸ ĞŸĞ¾Ñ€Ñ‚: <b>{pull.get('port', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}</b>\n"

                    # Ğ­ĞšĞ¡ĞŸĞĞ Ğ¢Ğ•Ğ 
                    exporter_id = pull.get("exporter_id") or pull.get("creator_id")
                    exporter = users.get(exporter_id, {})

                    text += f"\n<b>ğŸ“¤ Ğ’Ğ« (Ğ­ĞšĞ¡ĞŸĞĞ Ğ¢Ğ•Ğ )</b>\n"
                    text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                    text += f"ğŸ‘¤ Ğ˜Ğ¼Ñ: <b>{exporter.get('name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}</b>\n"
                    text += f"â˜ï¸ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <b>{exporter.get('phone', 'â€”')}</b>\n"
                    text += f"ğŸ“ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½: <b>{exporter.get('region', 'â€”')}</b>\n"

                    # Ğ’Ğ¡Ğ• Ğ¤Ğ•Ğ ĞœĞ•Ğ Ğ« Ğ˜ Ğ˜Ğ¥ ĞŸĞĞ Ğ¢Ğ˜Ğ˜
                    participants = get_batch_participants_in_pull(pull_id)
                    if participants:
                        text += (
                            f"\n<b>ğŸ‘¨â€ğŸŒ¾ Ğ¤Ğ•Ğ ĞœĞ•Ğ Ğ« Ğ˜ Ğ˜Ğ¥ ĞŸĞĞ Ğ¢Ğ˜Ğ˜ ({len(participants)})</b>\n"
                        )
                        text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                        for idx_p, p in enumerate(participants, 1):
                            farmer_id = p.get("farmer_id")
                            farmer_name = p.get("farmer_name", "Unknown")
                            volume = p.get("volume", 0)

                            text += f"{idx_p}. <b>{farmer_name}</b>\n"
                            text += f"   ğŸ“¦ ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ: {volume:,.1f} Ñ‚\n"
                            text += f"   â­ ĞšĞ»Ğ°ÑÑ: {p.get('quality_class', 'â€”')}\n"

                            if farmer_id and farmer_id in users:
                                farmer = users[farmer_id]
                                text += f"   â˜ï¸ {farmer.get('phone', 'â€”')}\n"
                    else:
                        text += f"\n<b>ğŸ‘¨â€ğŸŒ¾ Ğ¤Ğ•Ğ ĞœĞ•Ğ Ğ«</b>\n"
                        text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                        text += f"âŒ Ğ¤ĞµÑ€Ğ¼ĞµÑ€Ñ‹ Ğ½Ğµ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ñ‹\n"

                    # Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢
                    logistics, logistics_id = get_logistics_by_pull(pull_id)
                    if logistics and logistics.get("logist_id") in users:
                        logist = users[logistics["logist_id"]]
                        text += f"\n<b>ğŸšš Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢</b>\n"
                        text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                        text += f"ğŸ‘¤ Ğ˜Ğ¼Ñ: <b>{logist.get('name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}</b>\n"
                        text += f"â˜ï¸ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: <b>{logist.get('phone', 'â€”')}</b>\n"
                        text += f"ğŸ“¤ ĞÑ‚: <b>{logistics.get('route_from', 'â€”')}</b>\n"
                        text += f"ğŸ“¥ ĞšÑƒĞ´Ğ°: <b>{logistics.get('route_to', 'â€”')}</b>\n"

                        # Ğ­ĞšĞ¡ĞŸĞ•Ğ”Ğ˜Ğ¢ĞĞ Ğ«
                        expeditors_list = get_expeditors_by_logistics(logistics_id)
                        if expeditors_list:
                            text += f"\n<b>âœˆï¸ Ğ­ĞšĞ¡ĞŸĞ•Ğ”Ğ˜Ğ¢ĞĞ Ğ« ({len(expeditors_list)})</b>\n"
                            text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                            for idx_e, (expeditor, exp_id) in enumerate(
                                expeditors_list, 1
                            ):
                                exp_user_id = expeditor.get("user_id")
                                if exp_user_id and exp_user_id in users:
                                    exp_user = users[exp_user_id]
                                    text += f"{idx_e}. <b>{exp_user.get('name', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}</b>\n"
                                    text += f"   â˜ï¸ {exp_user.get('phone', 'â€”')}\n"
                                    text += (
                                        f"   ğŸš¢ {expeditor.get('vehicle_type', 'â€”')}\n"
                                    )
                    else:
                        text += f"\n<b>ğŸšš Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢</b>\n"
                        text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                        text += f"âŒ Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ Ğ½Ğµ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½\n"

            except (ValueError, KeyError) as e:
                logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° exporter: {e}")
                text = "âŒ <b>ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ½ĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ ID Ğ¿ÑƒĞ»Ğ°</b>"

        else:
            text = "âŒ <b>ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ°Ñ Ñ€Ğ¾Ğ»ÑŒ!</b>"

        # âœ… ĞšĞĞĞŸĞšĞ ĞĞĞ—ĞĞ”
        keyboard.add(
            InlineKeyboardButton("â¬…ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data=f"deals_status:{role}:all")
        )
        try:
            await callback.message.edit_text(
                text, reply_markup=keyboard, parse_mode="HTML"
            )
            logging.info(f"   âœ… Ğ”ĞµÑ‚Ğ°Ğ»Ğ¸ Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ñ‹ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾")
        except MessageNotModified:
            pass
        except:
            try:
                await callback.message.answer(
                    text, reply_markup=keyboard, parse_mode="HTML"
                )
            except:
                await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞµ", show_alert=True)

    except Exception as e:
        logging.error(f"âŒ ĞĞ¨Ğ˜Ğ‘ĞšĞ show_deal_detail: {e}", exc_info=True)
        keyboard = InlineKeyboardMarkup()
        keyboard.add(InlineKeyboardButton("ğŸ“Š ĞœĞµĞ½Ñ", callback_data="back_to_main"))
        try:
            await callback.message.edit_text(
                f"âŒ <b>ĞÑˆĞ¸Ğ±ĞºĞ°:</b>\n<code>{str(e)[:100]}</code>",
                reply_markup=keyboard,
                parse_mode="HTML",
            )
        except:
            await callback.answer(f"âŒ {str(e)[:50]}", show_alert=True)


# ============================================================================
# Ğ¡ĞœĞ•ĞĞ Ğ¡Ğ¢ĞĞ¢Ğ£Ğ¡ĞĞ’: Ğ¤Ğ•Ğ ĞœĞ•Ğ 
# ============================================================================


@dp.callback_query_handler(lambda q: q.data.startswith("change_farmer_status:"))
async def change_farmer_batch_status(callback: types.CallbackQuery):
    """âœ… Ğ¤ĞµÑ€Ğ¼ĞµÑ€ Ğ¼ĞµĞ½ÑĞµÑ‚ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¸"""
    await callback.answer()
    try:
        parts = callback.data.split(":")
        deal_id = parts[1]
        new_status = parts[2]
        user_id = callback.from_user.id

        user_batches = batches.get(user_id, [])

        try:
            batch_idx = int(deal_id)
            if batch_idx >= len(user_batches):
                await callback.answer("âŒ Ğ‘Ğ°Ñ‚Ñ‡ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
                return

            batch = user_batches[batch_idx]
        except (ValueError, IndexError):
            await callback.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ID Ğ±Ğ°Ñ‚Ñ‡Ğ°", show_alert=True)
            return

        old_status = batch.get("status", "active")

        valid = {
            "active": ["in_progress", "canceled"],
            "in_progress": ["completed", "active"],
            "completed": [],
            "canceled": ["active"],
            None: ["in_progress"],
        }

        if new_status not in valid.get(old_status, []):
            await callback.answer(
                f"âŒ ĞŸĞµÑ€ĞµÑ…Ğ¾Ğ´ {old_status} â†’ {new_status} Ğ½Ğµ Ğ´Ğ¾Ğ¿ÑƒÑ‰ĞµĞ½", show_alert=True
            )
            return

        batch["status"] = new_status
        batch["status_changed_at"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        batch["status_changed_by"] = user_id

        save_batches_to_pickle()

        logging.info(
            f"âœ… Ğ¤ĞµÑ€Ğ¼ĞµÑ€ {user_id}: Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ñ {batch_idx} {old_status} â†’ {new_status}"
        )

        await callback.message.edit_text(
            f"âœ… <b>ĞŸĞĞ Ğ¢Ğ˜Ğ¯ ĞĞ‘ĞĞĞ’Ğ›Ğ•ĞĞ</b>\n\n"
            f"ğŸŒ¾ {batch.get('crop', '?')}\n"
            f"ğŸ“¦ {batch.get('volume', 0)}Ñ‚\n"
            f"â±ï¸ {old_status} â†’ <b>{new_status}</b>",
            parse_mode="HTML",
        )
    except Exception as e:
        logging.error(f"âŒ ĞĞ¨Ğ˜Ğ‘ĞšĞ: {e}", exc_info=True)
        await callback.answer(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)}", show_alert=True)


# ============================================================================
# Ğ¡ĞœĞ•ĞĞ Ğ¡Ğ¢ĞĞ¢Ğ£Ğ¡ĞĞ’: Ğ­ĞšĞ¡ĞŸĞĞ Ğ¢Ğ•Ğ 
# ============================================================================


@dp.callback_query_handler(lambda q: q.data.startswith("change_exporter_status:"))
async def change_exporter_pool_status(callback: types.CallbackQuery):
    """âœ… Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€ Ğ¼ĞµĞ½ÑĞµÑ‚ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ¿ÑƒĞ»Ğ°"""
    await callback.answer()
    try:
        parts = callback.data.split(":")
        pool_id = parts[1]
        new_status = parts[2]
        user_id = callback.from_user.id

        # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿ÑƒĞ»Ñ‹ Ğ¸Ğ· Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑÑ‚Ğ°
        all_pulls = pulls.get("pulls", {})
        pool = (
            all_pulls.get(pool_id)
            or all_pulls.get(str(pool_id))
            or all_pulls.get(int(pool_id) if str(pool_id).isdigit() else None)
        )

        if not pool or pool.get("exporter_id") != user_id:
            await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
            return

        old_status = pool.get("status", "open")

        valid = {
            "open": ["collecting"],
            "collecting": ["filled", "open"],
            "filled": ["shipped", "collecting"],
            "shipped": ["completed"],
            "active": ["collecting"],
            None: ["collecting"],
        }

        if new_status not in valid.get(old_status, []):
            await callback.answer(
                f"âŒ ĞŸĞµÑ€ĞµÑ…Ğ¾Ğ´ {old_status} â†’ {new_status} Ğ½Ğµ Ğ´Ğ¾Ğ¿ÑƒÑ‰ĞµĞ½", show_alert=True
            )
            return

        pool["status"] = new_status
        pool["status_changed_at"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        pool["status_changed_by"] = user_id

        save_pulls_to_pickle()

        logging.info(
            f"âœ… Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ĞµÑ€ {user_id}: Ğ¿ÑƒĞ» {pool_id} {old_status} â†’ {new_status}"
        )

        await callback.message.edit_text(
            f"âœ… <b>ĞŸĞ£Ğ› ĞĞ‘ĞĞĞ’Ğ›Ğ•Ğ</b>\n\n"
            f"ğŸ“¤ {pool.get('culture', '?')}\n"
            f"ğŸ“¦ {pool.get('current_volume', 0)}/{pool.get('target_volume', 0)}Ñ‚\n"
            f"â±ï¸ {old_status} â†’ <b>{new_status}</b>",
            parse_mode="HTML",
        )
    except Exception as e:
        logging.error(f"âŒ ĞĞ¨Ğ˜Ğ‘ĞšĞ: {e}", exc_info=True)
        await callback.answer(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)}", show_alert=True)


# ============================================================================
# Ğ¡ĞœĞ•ĞĞ Ğ¡Ğ¢ĞĞ¢Ğ£Ğ¡ĞĞ’: Ğ›ĞĞ“Ğ˜Ğ¡Ğ¢
# ============================================================================


@dp.callback_query_handler(lambda q: q.data.startswith("change_logist_status:"))
async def change_logist_delivery_status(callback: types.CallbackQuery):
    """âœ… Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ Ğ¼ĞµĞ½ÑĞµÑ‚ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸"""
    await callback.answer()
    try:
        parts = callback.data.split(":")
        delivery_id = parts[1]
        new_status = parts[2]
        user_id = callback.from_user.id

        delivery = shipping_requests.get(delivery_id)
        if not delivery or delivery.get("logist_id") != user_id:
            await callback.answer("âŒ Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°", show_alert=True)
            return

        old_status = delivery.get("status", "pending")

        valid = {
            "pending": ["in_progress"],
            "in_progress": ["completed", "pending"],
            "completed": [],
            "new": ["in_progress"],
            None: ["in_progress"],
        }

        if new_status not in valid.get(old_status, []):
            await callback.answer(
                f"âŒ ĞŸĞµÑ€ĞµÑ…Ğ¾Ğ´ {old_status} â†’ {new_status} Ğ½Ğµ Ğ´Ğ¾Ğ¿ÑƒÑ‰ĞµĞ½", show_alert=True
            )
            return

        delivery["status"] = new_status
        delivery["status_changed_at"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        delivery["status_changed_by"] = user_id

        save_shipping_requests_to_pickle()

        logging.info(
            f"âœ… Ğ›Ğ¾Ğ³Ğ¸ÑÑ‚ {user_id}: Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° {delivery_id} {old_status} â†’ {new_status}"
        )

        await callback.message.edit_text(
            f"âœ… <b>Ğ”ĞĞ¡Ğ¢ĞĞ’ĞšĞ ĞĞ‘ĞĞĞ’Ğ›Ğ•ĞĞ</b>\n\n"
            f"ğŸ“ {delivery.get('from', '?')} â†’ {delivery.get('to', '?')}\n"
            f"ğŸ“¦ {delivery.get('weight', 0)}Ñ‚\n"
            f"â±ï¸ {old_status} â†’ <b>{new_status}</b>",
            parse_mode="HTML",
        )
    except Exception as e:
        logging.error(f"âŒ ĞĞ¨Ğ˜Ğ‘ĞšĞ: {e}", exc_info=True)
        await callback.answer(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)}", show_alert=True)


# ============================================================================
# Ğ¡ĞœĞ•ĞĞ Ğ¡Ğ¢ĞĞ¢Ğ£Ğ¡ĞĞ’: Ğ­ĞšĞ¡ĞŸĞ•Ğ”Ğ˜Ğ¢ĞĞ 
# ============================================================================


@dp.callback_query_handler(lambda q: q.data.startswith("change_expeditor_status:"))
async def change_expeditor_freight_status(callback: types.CallbackQuery):
    """âœ… Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€ Ğ¼ĞµĞ½ÑĞµÑ‚ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ¼Ğ°Ñ€ÑˆÑ€ÑƒÑ‚Ğ° + Ğ—ĞĞšĞ Ğ«Ğ’ĞĞ•Ğ¢ Ğ¡Ğ”Ğ•Ğ›ĞšĞ˜"""
    await callback.answer()
    try:
        parts = callback.data.split(":")
        freight_id = parts[1]
        new_status = parts[2]
        user_id = callback.from_user.id

        freight = expeditor_offers.get(freight_id)
        if not freight or freight.get("expeditor_id") != user_id:
            await callback.answer("âŒ ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
            return

        old_status = freight.get("status", "active")

        valid = {
            "active": ["in_progress"],
            "in_progress": ["delivered"],
            "delivered": [],
            None: ["in_progress"],
        }

        if new_status not in valid.get(old_status, []):
            await callback.answer(
                f"âŒ ĞŸĞµÑ€ĞµÑ…Ğ¾Ğ´ {old_status} â†’ {new_status} Ğ½Ğµ Ğ´Ğ¾Ğ¿ÑƒÑ‰ĞµĞ½", show_alert=True
            )
            return

        freight["status"] = new_status
        freight["status_changed_at"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        freight["status_changed_by"] = user_id

        # âœ… Ğ•Ğ¡Ğ›Ğ˜ Ğ¡Ğ¢ĞĞ¢Ğ£Ğ¡ "delivered" - Ğ—ĞĞšĞ Ğ«Ğ¢Ğ¬ Ğ’Ğ¡Ğ• Ğ¡Ğ”Ğ•Ğ›ĞšĞ˜
        if new_status == "delivered":
            logging.info(
                f"ğŸ‰ Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€ {user_id}: Ğ¼Ğ°Ñ€ÑˆÑ€ÑƒÑ‚ {freight_id} Ğ”ĞĞ¡Ğ¢ĞĞ’Ğ›Ğ•Ğ - Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ Ğ²ÑĞµÑ… ÑĞ´ĞµĞ»Ğ¾Ğº..."
            )

            # âœ… Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ²ÑĞµ Ğ¿ÑƒĞ»Ñ‹ ÑĞ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ¾Ğ¼ shipped
            all_pulls = pulls.get("pulls", {})

            for pull_id, pull in all_pulls.items():
                if not isinstance(pull, dict):
                    continue

                if pull.get("status") == "shipped":
                    pull["status"] = "completed"
                    pull["completed_at"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    logging.info(f"   âœ… ĞŸÑƒĞ» {pull_id} Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½")

            # Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ²ÑĞµ Ğ±Ğ°Ñ‚Ñ‡Ğ¸ Ñ‡ĞµÑ€ĞµĞ· participants
            for farmer_id, farmer_batches in batches.items():
                for batch in farmer_batches:
                    if batch.get("status") == "in_progress":
                        batch["status"] = "completed"
                        batch["completed_at"] = datetime.now().strftime(
                            "%Y-%m-%d %H:%M:%S"
                        )
                        logging.info(f"   âœ… Ğ‘Ğ°Ñ‚Ñ‡ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ° {farmer_id} Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½")

            # Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ²ÑĞµ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸ ÑĞ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ¾Ğ¼ in_progress
            for delivery_id, delivery in shipping_requests.items():
                if delivery.get("status") == "in_progress":
                    delivery["status"] = "completed"
                    delivery["completed_at"] = datetime.now().strftime(
                        "%Y-%m-%d %H:%M:%S"
                    )
                    logging.info(f"   âœ… Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° {delivery_id} Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°")

            # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ
            save_expeditor_offers_to_pickle()
            save_pulls_to_pickle()
            save_batches_to_pickle()
            save_shipping_requests_to_pickle()

            logging.info(f"ğŸ‰ Ğ’Ğ¡Ğ• Ğ¡Ğ”Ğ•Ğ›ĞšĞ˜ Ğ—ĞĞšĞ Ğ«Ğ¢Ğ« Ğ˜ Ğ¡ĞĞ¥Ğ ĞĞĞ•ĞĞ«!")

            await callback.message.edit_text(
                f"âœ… <b>ĞœĞĞ Ğ¨Ğ Ğ£Ğ¢ ĞĞ‘ĞĞĞ’Ğ›Ğ•Ğ</b>\n\n"
                f"âœˆï¸ {freight.get('from_port', '?')} â†’ {freight.get('to_port', '?')}\n"
                f"â±ï¸ {old_status} â†’ <b>{new_status}</b>\n\n"
                f"ğŸ‰ <b>Ğ’Ğ¡Ğ• Ğ¡Ğ”Ğ•Ğ›ĞšĞ˜ Ğ—ĞĞ’Ğ•Ğ Ğ¨Ğ•ĞĞ«!</b>",
                parse_mode="HTML",
            )
        else:
            save_expeditor_offers_to_pickle()

            await callback.message.edit_text(
                f"âœ… <b>ĞœĞĞ Ğ¨Ğ Ğ£Ğ¢ ĞĞ‘ĞĞĞ’Ğ›Ğ•Ğ</b>\n\n"
                f"âœˆï¸ {freight.get('from_port', '?')} â†’ {freight.get('to_port', '?')}\n"
                f"â±ï¸ {old_status} â†’ <b>{new_status}</b>",
                parse_mode="HTML",
            )

        logging.info(
            f"âœ… Ğ­ĞºÑĞ¿ĞµĞ´Ğ¸Ñ‚Ğ¾Ñ€ {user_id}: Ğ¼Ğ°Ñ€ÑˆÑ€ÑƒÑ‚ {freight_id} {old_status} â†’ {new_status}"
        )

    except Exception as e:
        logging.error(f"âŒ ĞĞ¨Ğ˜Ğ‘ĞšĞ: {e}", exc_info=True)
        await callback.answer(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)}", show_alert=True)


@dp.callback_query_handler(lambda q: q.data.startswith("change_pull_status:"))
async def change_pull_status(callback: types.CallbackQuery):
    """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¼ĞµĞ½Ñ ÑĞ¼ĞµĞ½Ñ‹ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ° Ğ¿ÑƒĞ»Ğ°"""
    await callback.answer()

    try:
        parts = callback.data.split(":")
        pull_id = int(parts[1])
        user_id = callback.from_user.id

        all_pulls = pulls.get("pulls", {})
        pull = all_pulls.get(pull_id) or all_pulls.get(str(pull_id))

        if not pull:
            await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
            return

        creator_id = pull.get("creator_id") or pull.get("exporter_id")
        if creator_id != user_id:
            await callback.answer(
                "âŒ Ğ’Ñ‹ Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¼ĞµĞ½ÑÑ‚ÑŒ ÑÑ‚Ğ°Ñ‚ÑƒÑ ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ¿ÑƒĞ»Ğ°", show_alert=True
            )
            return

        current_status = str(pull.get("status", "active")).lower()
        text = (
            f"<b>ğŸ”„ Ğ¡Ğ¼ĞµĞ½Ğ° ÑÑ‚Ğ°Ñ‚ÑƒÑĞ° Ğ¿ÑƒĞ»Ğ°</b>\n\n"
            f"<b>ĞŸÑƒĞ»:</b> #{pull_id}\n"
            f"ğŸŒ¾ <b>ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°:</b> {pull.get('culture', '?')}\n"
            f"<b>Ğ¢ĞµĞºÑƒÑ‰Ğ¸Ğ¹ ÑÑ‚Ğ°Ñ‚ÑƒÑ:</b> {status_map.get(current_status, current_status)}\n\n"
            f"<b>Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ ÑÑ‚Ğ°Ñ‚ÑƒÑ:</b>"
        )

        keyboard = InlineKeyboardMarkup(row_width=1)
        for status, label in status_map.items():
            if status != current_status:
                keyboard.add(
                    InlineKeyboardButton(
                        label, callback_data=f"confirm_pull_status:{pull_id}:{status}"
                    )
                )

        keyboard.add(
            InlineKeyboardButton("ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´", callback_data=f"view_pull:{pull_id}")
        )

        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
        logging.info(f"âœ… ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ğ½Ñ‹ Ğ¾Ğ¿Ñ†Ğ¸Ğ¸ ÑĞ¼ĞµĞ½Ñ‹ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ° Ğ´Ğ»Ñ Ğ¿ÑƒĞ»Ğ° {pull_id}")

    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ² change_pull_status: {e}", exc_info=True)
        await callback.answer(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)[:50]}", show_alert=True)


@dp.callback_query_handler(lambda q: q.data.startswith("confirm_pull_status:"))
async def confirm_pull_status(callback: types.CallbackQuery):
    """ĞŸÑ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğº Ğ¿ÑƒĞ»Ñƒ, ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ Ğ’Ğ¡Ğ•Ğ¥ Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½Ğ¸Ğ²ÑˆĞ¸Ñ…ÑÑ Ñ„ĞµÑ€Ğ¼ĞµÑ€Ğ¾Ğ² Ğ¸ Ğ’Ğ¡Ğ•Ğ¥ Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ğ¾Ğ²"""
    await callback.answer()

    try:
        parts = callback.data.split(":")
        pull_id = int(parts[1])
        new_status = parts[2].lower()
        user_id = callback.from_user.id

        all_pulls = pulls.get("pulls", {})
        pull = all_pulls.get(pull_id) or all_pulls.get(str(pull_id))

        if not pull:
            await callback.answer("âŒ ĞŸÑƒĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
            return

        creator_id = pull.get("creator_id") or pull.get("exporter_id")
        if creator_id != user_id:
            await callback.answer(
                "âŒ Ğ’Ñ‹ Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¼ĞµĞ½ÑÑ‚ÑŒ ÑÑ‚Ğ°Ñ‚ÑƒÑ ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ¿ÑƒĞ»Ğ°", show_alert=True
            )
            return

        old_status = str(pull.get("status", "active")).lower()

        # Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ¾Ğ²
        if new_status == "active":
            if pull.get("current_volume", 0) > 0:
                await callback.answer(
                    "âš ï¸ ĞĞµĞ»ÑŒĞ·Ñ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ¿ÑƒĞ» Ñ Ğ¿Ğ°Ñ€Ñ‚Ğ¸ÑĞ¼Ğ¸!", show_alert=True
                )
                return

        elif new_status == "filled":
            current = pull.get("current_volume", 0)
            target = pull.get("target_volume", 0)
            if current < target:
                await callback.answer(
                    f"âš ï¸ ĞŸÑƒĞ» Ğ½Ğµ Ğ¿Ğ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½!\n{current:.0f}/{target:.0f}Ñ‚",
                    show_alert=True,
                )
                return

        pull["status"] = new_status
        pull["updated_at"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        save_pulls_to_pickle()

        # Ğ’Ğ¡Ğ• Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ñ‹ Ğ¿Ğ¾ Ñ€Ğ¾Ğ»ÑĞ¼
        logist_ids = [uid for uid, u in users.items() if u.get("role") == "logistic"]
        # Ğ’Ğ¡Ğ• Ñ„ĞµÑ€Ğ¼ĞµÑ€Ñ‹-ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¸ Ñ‡ĞµÑ€ĞµĞ· pullparticipants
        farmer_ids = [
            p.get("farmer_id")
            for p in pullparticipants.get(pull_id, [])
            if p.get("farmer_id")
        ]
        all_notify_ids = set(farmer_ids) | set(logist_ids)
        logging.info(
            f"[CONFIRM_PULL_STATUS] pull_id={pull_id} logist_ids={logist_ids} farmer_ids={farmer_ids} all_notify_ids={list(all_notify_ids)}"
        )

        notification_text = (
            f"<b>âœ… Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ Ğ¿ÑƒĞ»Ğ° Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ğ»ÑÑ!</b>\n\n"
            f"ğŸ“¤ ĞŸÑƒĞ»: <b>#{pull_id}</b>\n"
            f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: <b>{pull.get('culture', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}</b>\n"
            f"ğŸ“Š ĞĞ±ÑŠÑ‘Ğ¼: <b>{pull.get('current_volume', 0):,.1f} Ñ‚</b>\n"
            f"ğŸ”„ Ğ‘Ñ‹Ğ»Ğ¾: {status_map.get(old_status, old_status)}\n"
            f"â¡ï¸ Ğ¡Ñ‚Ğ°Ğ»Ğ¾: <b>{status_map.get(new_status, new_status)}</b>\n"
            f"ğŸ“… Ğ’Ñ€ĞµĞ¼Ñ: {pull['updated_at']}"
        )

        keyboard_notification = InlineKeyboardMarkup()
        keyboard_notification.add(
            InlineKeyboardButton(
                "ğŸ“Š ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ğ¿ÑƒĞ»", callback_data=f"view_pull:{pull_id}"
            )
        )

        sent_count = 0
        failed_ids = []
        for notify_id in all_notify_ids:
            try:
                await bot.send_message(
                    notify_id,
                    notification_text,
                    parse_mode="HTML",
                    reply_markup=keyboard_notification,
                )
                logging.info(f"[NOTIFY] Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ {notify_id}")
                sent_count += 1
            except Exception as e:
                logging.warning(
                    f"[NOTIFY] ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ {notify_id}: {e}"
                )
                failed_ids.append(notify_id)

        keyboard = InlineKeyboardMarkup(row_width=1)
        keyboard.add(
            InlineKeyboardButton(
                "ğŸ“Š ĞĞ°Ğ·Ğ°Ğ´ Ğº Ğ¿ÑƒĞ»Ñƒ", callback_data=f"view_pull:{pull_id}"
            )
        )
        keyboard.add(
            InlineKeyboardButton("ğŸ  Ğ’ Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main")
        )

        confirmation_text = (
            f"<b>âœ… Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ Ğ¿ÑƒĞ»Ğ° Ğ¸Ğ·Ğ¼ĞµĞ½Ñ‘Ğ½!</b>\n\n"
            f"ğŸ“¤ ĞŸÑƒĞ»: <b>#{pull_id}</b>\n"
            f"ğŸŒ¾ ĞšÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ°: <b>{pull.get('culture', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}</b>\n"
            f"ğŸ”„ Ğ‘Ñ‹Ğ»Ğ¾: <b>{status_map.get(old_status, old_status)}</b>\n"
            f"â¡ï¸ Ğ¡Ñ‚Ğ°Ğ»Ğ¾: <b>{status_map.get(new_status, new_status)}</b>\n"
            f"ğŸ“… Ğ’Ñ€ĞµĞ¼Ñ: {pull['updated_at']}\n\n"
            f"ğŸ”” ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹: {sent_count} (Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚Ñ‹: {len(logist_ids)}, Ñ„ĞµÑ€Ğ¼ĞµÑ€Ñ‹: {len(farmer_ids)})"
        )

        await callback.message.edit_text(
            confirmation_text, reply_markup=keyboard, parse_mode="HTML"
        )

        logging.info(
            f"âœ… Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ Ğ¿ÑƒĞ»Ğ° {pull_id}: "
            f"{status_map.get(old_status, old_status)} â†’ "
            f"{status_map.get(new_status, new_status)}"
        )

    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ² confirm_pull_status: {e}", exc_info=True)
        await callback.answer(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)[:50]}", show_alert=True)


# ============================================================================
# Ğ—ĞĞŸĞ£Ğ¡Ğš Ğ‘ĞĞ¢Ğ
# ============================================================================
if __name__ == "__main__":
    logging.info("ğŸš€ Ğ—Ğ°Ğ¿ÑƒÑĞº Ğ±Ğ¾Ñ‚Ğ°...")
    try:
        os.makedirs("data", exist_ok=True)
        os.makedirs("logs", exist_ok=True)
    except Exception as e:
        logging.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ğ¹: {e}")

    # âœ… executor Ğ¢ĞĞ›Ğ¬ĞšĞ Ğ—Ğ”Ğ•Ğ¡Ğ¬! ĞĞ”Ğ˜Ğ Ğ ĞĞ—!
    from aiogram import executor

    executor.start_polling(
        dp, skip_updates=True, on_startup=on_startup, on_shutdown=on_shutdown
    )
